// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_DEVOPS20210625_H_
#define ALIBABACLOUD_DEVOPS20210625_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Devops20210625 {
class AddGroupMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<long> accessLevel{};
  shared_ptr<string> aliyunPks{};
  shared_ptr<string> organizationId{};

  AddGroupMemberRequest() {}

  explicit AddGroupMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (accessLevel) {
      res["accessLevel"] = boost::any(*accessLevel);
    }
    if (aliyunPks) {
      res["aliyunPks"] = boost::any(*aliyunPks);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("accessLevel") != m.end() && !m["accessLevel"].empty()) {
      accessLevel = make_shared<long>(boost::any_cast<long>(m["accessLevel"]));
    }
    if (m.find("aliyunPks") != m.end() && !m["aliyunPks"].empty()) {
      aliyunPks = make_shared<string>(boost::any_cast<string>(m["aliyunPks"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~AddGroupMemberRequest() = default;
};
class AddGroupMemberResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> accessLevel{};
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> sourceId{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};

  AddGroupMemberResponseBodyResult() {}

  explicit AddGroupMemberResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessLevel) {
      res["accessLevel"] = boost::any(*accessLevel);
    }
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sourceId) {
      res["sourceId"] = boost::any(*sourceId);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessLevel") != m.end() && !m["accessLevel"].empty()) {
      accessLevel = make_shared<long>(boost::any_cast<long>(m["accessLevel"]));
    }
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sourceId") != m.end() && !m["sourceId"].empty()) {
      sourceId = make_shared<long>(boost::any_cast<long>(m["sourceId"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~AddGroupMemberResponseBodyResult() = default;
};
class AddGroupMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<AddGroupMemberResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  AddGroupMemberResponseBody() {}

  explicit AddGroupMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<AddGroupMemberResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddGroupMemberResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<AddGroupMemberResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~AddGroupMemberResponseBody() = default;
};
class AddGroupMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddGroupMemberResponseBody> body{};

  AddGroupMemberResponse() {}

  explicit AddGroupMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddGroupMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddGroupMemberResponseBody>(model1);
      }
    }
  }


  virtual ~AddGroupMemberResponse() = default;
};
class AddPipelineRelationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> relObjectIds{};
  shared_ptr<string> relObjectType{};

  AddPipelineRelationsRequest() {}

  explicit AddPipelineRelationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (relObjectIds) {
      res["relObjectIds"] = boost::any(*relObjectIds);
    }
    if (relObjectType) {
      res["relObjectType"] = boost::any(*relObjectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("relObjectIds") != m.end() && !m["relObjectIds"].empty()) {
      relObjectIds = make_shared<string>(boost::any_cast<string>(m["relObjectIds"]));
    }
    if (m.find("relObjectType") != m.end() && !m["relObjectType"].empty()) {
      relObjectType = make_shared<string>(boost::any_cast<string>(m["relObjectType"]));
    }
  }


  virtual ~AddPipelineRelationsRequest() = default;
};
class AddPipelineRelationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddPipelineRelationsResponseBody() {}

  explicit AddPipelineRelationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~AddPipelineRelationsResponseBody() = default;
};
class AddPipelineRelationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddPipelineRelationsResponseBody> body{};

  AddPipelineRelationsResponse() {}

  explicit AddPipelineRelationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddPipelineRelationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddPipelineRelationsResponseBody>(model1);
      }
    }
  }


  virtual ~AddPipelineRelationsResponse() = default;
};
class AddRepositoryMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<long> accessLevel{};
  shared_ptr<string> aliyunPks{};
  shared_ptr<string> organizationId{};

  AddRepositoryMemberRequest() {}

  explicit AddRepositoryMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (accessLevel) {
      res["accessLevel"] = boost::any(*accessLevel);
    }
    if (aliyunPks) {
      res["aliyunPks"] = boost::any(*aliyunPks);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("accessLevel") != m.end() && !m["accessLevel"].empty()) {
      accessLevel = make_shared<long>(boost::any_cast<long>(m["accessLevel"]));
    }
    if (m.find("aliyunPks") != m.end() && !m["aliyunPks"].empty()) {
      aliyunPks = make_shared<string>(boost::any_cast<string>(m["aliyunPks"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~AddRepositoryMemberRequest() = default;
};
class AddRepositoryMemberResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> accessLevel{};
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> state{};

  AddRepositoryMemberResponseBodyResult() {}

  explicit AddRepositoryMemberResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessLevel) {
      res["accessLevel"] = boost::any(*accessLevel);
    }
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessLevel") != m.end() && !m["accessLevel"].empty()) {
      accessLevel = make_shared<long>(boost::any_cast<long>(m["accessLevel"]));
    }
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
  }


  virtual ~AddRepositoryMemberResponseBodyResult() = default;
};
class AddRepositoryMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<AddRepositoryMemberResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  AddRepositoryMemberResponseBody() {}

  explicit AddRepositoryMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<AddRepositoryMemberResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddRepositoryMemberResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<AddRepositoryMemberResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~AddRepositoryMemberResponseBody() = default;
};
class AddRepositoryMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddRepositoryMemberResponseBody> body{};

  AddRepositoryMemberResponse() {}

  explicit AddRepositoryMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddRepositoryMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddRepositoryMemberResponseBody>(model1);
      }
    }
  }


  virtual ~AddRepositoryMemberResponse() = default;
};
class AddWebhookRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> description{};
  shared_ptr<bool> enableSslVerification{};
  shared_ptr<bool> mergeRequestsEvents{};
  shared_ptr<bool> noteEvents{};
  shared_ptr<bool> pushEvents{};
  shared_ptr<string> secretToken{};
  shared_ptr<bool> tagPushEvents{};
  shared_ptr<string> url{};
  shared_ptr<string> organizationId{};

  AddWebhookRequest() {}

  explicit AddWebhookRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (enableSslVerification) {
      res["enableSslVerification"] = boost::any(*enableSslVerification);
    }
    if (mergeRequestsEvents) {
      res["mergeRequestsEvents"] = boost::any(*mergeRequestsEvents);
    }
    if (noteEvents) {
      res["noteEvents"] = boost::any(*noteEvents);
    }
    if (pushEvents) {
      res["pushEvents"] = boost::any(*pushEvents);
    }
    if (secretToken) {
      res["secretToken"] = boost::any(*secretToken);
    }
    if (tagPushEvents) {
      res["tagPushEvents"] = boost::any(*tagPushEvents);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("enableSslVerification") != m.end() && !m["enableSslVerification"].empty()) {
      enableSslVerification = make_shared<bool>(boost::any_cast<bool>(m["enableSslVerification"]));
    }
    if (m.find("mergeRequestsEvents") != m.end() && !m["mergeRequestsEvents"].empty()) {
      mergeRequestsEvents = make_shared<bool>(boost::any_cast<bool>(m["mergeRequestsEvents"]));
    }
    if (m.find("noteEvents") != m.end() && !m["noteEvents"].empty()) {
      noteEvents = make_shared<bool>(boost::any_cast<bool>(m["noteEvents"]));
    }
    if (m.find("pushEvents") != m.end() && !m["pushEvents"].empty()) {
      pushEvents = make_shared<bool>(boost::any_cast<bool>(m["pushEvents"]));
    }
    if (m.find("secretToken") != m.end() && !m["secretToken"].empty()) {
      secretToken = make_shared<string>(boost::any_cast<string>(m["secretToken"]));
    }
    if (m.find("tagPushEvents") != m.end() && !m["tagPushEvents"].empty()) {
      tagPushEvents = make_shared<bool>(boost::any_cast<bool>(m["tagPushEvents"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~AddWebhookRequest() = default;
};
class AddWebhookResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> createdAt{};
  shared_ptr<string> description{};
  shared_ptr<bool> enableSslVerification{};
  shared_ptr<long> id{};
  shared_ptr<string> lastTestResult{};
  shared_ptr<bool> mergeRequestsEvents{};
  shared_ptr<bool> noteEvents{};
  shared_ptr<bool> pushEvents{};
  shared_ptr<long> repositoryId{};
  shared_ptr<string> secretToken{};
  shared_ptr<bool> tagPushEvents{};
  shared_ptr<string> url{};

  AddWebhookResponseBodyResult() {}

  explicit AddWebhookResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (enableSslVerification) {
      res["enableSslVerification"] = boost::any(*enableSslVerification);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (lastTestResult) {
      res["lastTestResult"] = boost::any(*lastTestResult);
    }
    if (mergeRequestsEvents) {
      res["mergeRequestsEvents"] = boost::any(*mergeRequestsEvents);
    }
    if (noteEvents) {
      res["noteEvents"] = boost::any(*noteEvents);
    }
    if (pushEvents) {
      res["pushEvents"] = boost::any(*pushEvents);
    }
    if (repositoryId) {
      res["repositoryId"] = boost::any(*repositoryId);
    }
    if (secretToken) {
      res["secretToken"] = boost::any(*secretToken);
    }
    if (tagPushEvents) {
      res["tagPushEvents"] = boost::any(*tagPushEvents);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("enableSslVerification") != m.end() && !m["enableSslVerification"].empty()) {
      enableSslVerification = make_shared<bool>(boost::any_cast<bool>(m["enableSslVerification"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("lastTestResult") != m.end() && !m["lastTestResult"].empty()) {
      lastTestResult = make_shared<string>(boost::any_cast<string>(m["lastTestResult"]));
    }
    if (m.find("mergeRequestsEvents") != m.end() && !m["mergeRequestsEvents"].empty()) {
      mergeRequestsEvents = make_shared<bool>(boost::any_cast<bool>(m["mergeRequestsEvents"]));
    }
    if (m.find("noteEvents") != m.end() && !m["noteEvents"].empty()) {
      noteEvents = make_shared<bool>(boost::any_cast<bool>(m["noteEvents"]));
    }
    if (m.find("pushEvents") != m.end() && !m["pushEvents"].empty()) {
      pushEvents = make_shared<bool>(boost::any_cast<bool>(m["pushEvents"]));
    }
    if (m.find("repositoryId") != m.end() && !m["repositoryId"].empty()) {
      repositoryId = make_shared<long>(boost::any_cast<long>(m["repositoryId"]));
    }
    if (m.find("secretToken") != m.end() && !m["secretToken"].empty()) {
      secretToken = make_shared<string>(boost::any_cast<string>(m["secretToken"]));
    }
    if (m.find("tagPushEvents") != m.end() && !m["tagPushEvents"].empty()) {
      tagPushEvents = make_shared<bool>(boost::any_cast<bool>(m["tagPushEvents"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~AddWebhookResponseBodyResult() = default;
};
class AddWebhookResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<AddWebhookResponseBodyResult> result{};
  shared_ptr<bool> success{};

  AddWebhookResponseBody() {}

  explicit AddWebhookResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        AddWebhookResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<AddWebhookResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~AddWebhookResponseBody() = default;
};
class AddWebhookResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddWebhookResponseBody> body{};

  AddWebhookResponse() {}

  explicit AddWebhookResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddWebhookResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddWebhookResponseBody>(model1);
      }
    }
  }


  virtual ~AddWebhookResponse() = default;
};
class CancelExecutionReleaseStageRequest : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};

  CancelExecutionReleaseStageRequest() {}

  explicit CancelExecutionReleaseStageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~CancelExecutionReleaseStageRequest() = default;
};
class CancelExecutionReleaseStageResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> success{};

  CancelExecutionReleaseStageResponseBody() {}

  explicit CancelExecutionReleaseStageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CancelExecutionReleaseStageResponseBody() = default;
};
class CancelExecutionReleaseStageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelExecutionReleaseStageResponseBody> body{};

  CancelExecutionReleaseStageResponse() {}

  explicit CancelExecutionReleaseStageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelExecutionReleaseStageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelExecutionReleaseStageResponseBody>(model1);
      }
    }
  }


  virtual ~CancelExecutionReleaseStageResponse() = default;
};
class CloseMergeRequestRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> organizationId{};

  CloseMergeRequestRequest() {}

  explicit CloseMergeRequestRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~CloseMergeRequestRequest() = default;
};
class CloseMergeRequestResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> result{};

  CloseMergeRequestResponseBodyResult() {}

  explicit CloseMergeRequestResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~CloseMergeRequestResponseBodyResult() = default;
};
class CloseMergeRequestResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<CloseMergeRequestResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CloseMergeRequestResponseBody() {}

  explicit CloseMergeRequestResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        CloseMergeRequestResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<CloseMergeRequestResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CloseMergeRequestResponseBody() = default;
};
class CloseMergeRequestResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CloseMergeRequestResponseBody> body{};

  CloseMergeRequestResponse() {}

  explicit CloseMergeRequestResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CloseMergeRequestResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CloseMergeRequestResponseBody>(model1);
      }
    }
  }


  virtual ~CloseMergeRequestResponse() = default;
};
class CreateAppMembersRequestPlayerList : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> type{};

  CreateAppMembersRequestPlayerList() {}

  explicit CreateAppMembersRequestPlayerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~CreateAppMembersRequestPlayerList() = default;
};
class CreateAppMembersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateAppMembersRequestPlayerList>> playerList{};
  shared_ptr<vector<string>> roleNames{};
  shared_ptr<string> organizationId{};

  CreateAppMembersRequest() {}

  explicit CreateAppMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (playerList) {
      vector<boost::any> temp1;
      for(auto item1:*playerList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["playerList"] = boost::any(temp1);
    }
    if (roleNames) {
      res["roleNames"] = boost::any(*roleNames);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("playerList") != m.end() && !m["playerList"].empty()) {
      if (typeid(vector<boost::any>) == m["playerList"].type()) {
        vector<CreateAppMembersRequestPlayerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["playerList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAppMembersRequestPlayerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        playerList = make_shared<vector<CreateAppMembersRequestPlayerList>>(expect1);
      }
    }
    if (m.find("roleNames") != m.end() && !m["roleNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["roleNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["roleNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      roleNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~CreateAppMembersRequest() = default;
};
class CreateAppMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<string> body{};

  CreateAppMembersResponse() {}

  explicit CreateAppMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~CreateAppMembersResponse() = default;
};
class CreateBranchRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> branchName{};
  shared_ptr<string> ref{};
  shared_ptr<string> organizationId{};

  CreateBranchRequest() {}

  explicit CreateBranchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (branchName) {
      res["branchName"] = boost::any(*branchName);
    }
    if (ref) {
      res["ref"] = boost::any(*ref);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("branchName") != m.end() && !m["branchName"].empty()) {
      branchName = make_shared<string>(boost::any_cast<string>(m["branchName"]));
    }
    if (m.find("ref") != m.end() && !m["ref"].empty()) {
      ref = make_shared<string>(boost::any_cast<string>(m["ref"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~CreateBranchRequest() = default;
};
class CreateBranchResponseBodyResultCommit : public Darabonba::Model {
public:
  shared_ptr<string> authorEmail{};
  shared_ptr<string> authorName{};
  shared_ptr<string> authoredDate{};
  shared_ptr<string> committedDate{};
  shared_ptr<string> committerEmail{};
  shared_ptr<string> committerName{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> id{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> parentIds{};
  shared_ptr<string> shortId{};
  shared_ptr<string> title{};

  CreateBranchResponseBodyResultCommit() {}

  explicit CreateBranchResponseBodyResultCommit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorEmail) {
      res["authorEmail"] = boost::any(*authorEmail);
    }
    if (authorName) {
      res["authorName"] = boost::any(*authorName);
    }
    if (authoredDate) {
      res["authoredDate"] = boost::any(*authoredDate);
    }
    if (committedDate) {
      res["committedDate"] = boost::any(*committedDate);
    }
    if (committerEmail) {
      res["committerEmail"] = boost::any(*committerEmail);
    }
    if (committerName) {
      res["committerName"] = boost::any(*committerName);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (parentIds) {
      res["parentIds"] = boost::any(*parentIds);
    }
    if (shortId) {
      res["shortId"] = boost::any(*shortId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("authorEmail") != m.end() && !m["authorEmail"].empty()) {
      authorEmail = make_shared<string>(boost::any_cast<string>(m["authorEmail"]));
    }
    if (m.find("authorName") != m.end() && !m["authorName"].empty()) {
      authorName = make_shared<string>(boost::any_cast<string>(m["authorName"]));
    }
    if (m.find("authoredDate") != m.end() && !m["authoredDate"].empty()) {
      authoredDate = make_shared<string>(boost::any_cast<string>(m["authoredDate"]));
    }
    if (m.find("committedDate") != m.end() && !m["committedDate"].empty()) {
      committedDate = make_shared<string>(boost::any_cast<string>(m["committedDate"]));
    }
    if (m.find("committerEmail") != m.end() && !m["committerEmail"].empty()) {
      committerEmail = make_shared<string>(boost::any_cast<string>(m["committerEmail"]));
    }
    if (m.find("committerName") != m.end() && !m["committerName"].empty()) {
      committerName = make_shared<string>(boost::any_cast<string>(m["committerName"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("parentIds") != m.end() && !m["parentIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["parentIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["parentIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      parentIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("shortId") != m.end() && !m["shortId"].empty()) {
      shortId = make_shared<string>(boost::any_cast<string>(m["shortId"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~CreateBranchResponseBodyResultCommit() = default;
};
class CreateBranchResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<CreateBranchResponseBodyResultCommit> commit{};
  shared_ptr<string> name{};
  shared_ptr<bool> protected_{};

  CreateBranchResponseBodyResult() {}

  explicit CreateBranchResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commit) {
      res["commit"] = commit ? boost::any(commit->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (protected_) {
      res["protected"] = boost::any(*protected_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commit") != m.end() && !m["commit"].empty()) {
      if (typeid(map<string, boost::any>) == m["commit"].type()) {
        CreateBranchResponseBodyResultCommit model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["commit"]));
        commit = make_shared<CreateBranchResponseBodyResultCommit>(model1);
      }
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("protected") != m.end() && !m["protected"].empty()) {
      protected_ = make_shared<bool>(boost::any_cast<bool>(m["protected"]));
    }
  }


  virtual ~CreateBranchResponseBodyResult() = default;
};
class CreateBranchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateBranchResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateBranchResponseBody() {}

  explicit CreateBranchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        CreateBranchResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<CreateBranchResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreateBranchResponseBody() = default;
};
class CreateBranchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBranchResponseBody> body{};

  CreateBranchResponse() {}

  explicit CreateBranchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBranchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBranchResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBranchResponse() = default;
};
class CreateChangeRequestRequest : public Darabonba::Model {
public:
  shared_ptr<string> appCodeRepoSn{};
  shared_ptr<bool> autoDeleteBranchWhenEnd{};
  shared_ptr<string> branchName{};
  shared_ptr<bool> createBranch{};
  shared_ptr<string> ownerAccountId{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> title{};
  shared_ptr<string> organizationId{};

  CreateChangeRequestRequest() {}

  explicit CreateChangeRequestRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCodeRepoSn) {
      res["appCodeRepoSn"] = boost::any(*appCodeRepoSn);
    }
    if (autoDeleteBranchWhenEnd) {
      res["autoDeleteBranchWhenEnd"] = boost::any(*autoDeleteBranchWhenEnd);
    }
    if (branchName) {
      res["branchName"] = boost::any(*branchName);
    }
    if (createBranch) {
      res["createBranch"] = boost::any(*createBranch);
    }
    if (ownerAccountId) {
      res["ownerAccountId"] = boost::any(*ownerAccountId);
    }
    if (ownerId) {
      res["ownerId"] = boost::any(*ownerId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("appCodeRepoSn") != m.end() && !m["appCodeRepoSn"].empty()) {
      appCodeRepoSn = make_shared<string>(boost::any_cast<string>(m["appCodeRepoSn"]));
    }
    if (m.find("autoDeleteBranchWhenEnd") != m.end() && !m["autoDeleteBranchWhenEnd"].empty()) {
      autoDeleteBranchWhenEnd = make_shared<bool>(boost::any_cast<bool>(m["autoDeleteBranchWhenEnd"]));
    }
    if (m.find("branchName") != m.end() && !m["branchName"].empty()) {
      branchName = make_shared<string>(boost::any_cast<string>(m["branchName"]));
    }
    if (m.find("createBranch") != m.end() && !m["createBranch"].empty()) {
      createBranch = make_shared<bool>(boost::any_cast<bool>(m["createBranch"]));
    }
    if (m.find("ownerAccountId") != m.end() && !m["ownerAccountId"].empty()) {
      ownerAccountId = make_shared<string>(boost::any_cast<string>(m["ownerAccountId"]));
    }
    if (m.find("ownerId") != m.end() && !m["ownerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["ownerId"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~CreateChangeRequestRequest() = default;
};
class CreateChangeRequestResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> appCodeRepoSn{};
  shared_ptr<string> appName{};
  shared_ptr<bool> autoDeleteBranchWhenEnd{};
  shared_ptr<string> branch{};
  shared_ptr<string> creatorAccountId{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> name{};
  shared_ptr<string> originBranch{};
  shared_ptr<string> originBranchRevisionSha{};
  shared_ptr<string> ownerAccountId{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> sn{};
  shared_ptr<string> state{};
  shared_ptr<string> type{};

  CreateChangeRequestResponseBody() {}

  explicit CreateChangeRequestResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCodeRepoSn) {
      res["appCodeRepoSn"] = boost::any(*appCodeRepoSn);
    }
    if (appName) {
      res["appName"] = boost::any(*appName);
    }
    if (autoDeleteBranchWhenEnd) {
      res["autoDeleteBranchWhenEnd"] = boost::any(*autoDeleteBranchWhenEnd);
    }
    if (branch) {
      res["branch"] = boost::any(*branch);
    }
    if (creatorAccountId) {
      res["creatorAccountId"] = boost::any(*creatorAccountId);
    }
    if (creatorId) {
      res["creatorId"] = boost::any(*creatorId);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (originBranch) {
      res["originBranch"] = boost::any(*originBranch);
    }
    if (originBranchRevisionSha) {
      res["originBranchRevisionSha"] = boost::any(*originBranchRevisionSha);
    }
    if (ownerAccountId) {
      res["ownerAccountId"] = boost::any(*ownerAccountId);
    }
    if (ownerId) {
      res["ownerId"] = boost::any(*ownerId);
    }
    if (sn) {
      res["sn"] = boost::any(*sn);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("appCodeRepoSn") != m.end() && !m["appCodeRepoSn"].empty()) {
      appCodeRepoSn = make_shared<string>(boost::any_cast<string>(m["appCodeRepoSn"]));
    }
    if (m.find("appName") != m.end() && !m["appName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["appName"]));
    }
    if (m.find("autoDeleteBranchWhenEnd") != m.end() && !m["autoDeleteBranchWhenEnd"].empty()) {
      autoDeleteBranchWhenEnd = make_shared<bool>(boost::any_cast<bool>(m["autoDeleteBranchWhenEnd"]));
    }
    if (m.find("branch") != m.end() && !m["branch"].empty()) {
      branch = make_shared<string>(boost::any_cast<string>(m["branch"]));
    }
    if (m.find("creatorAccountId") != m.end() && !m["creatorAccountId"].empty()) {
      creatorAccountId = make_shared<string>(boost::any_cast<string>(m["creatorAccountId"]));
    }
    if (m.find("creatorId") != m.end() && !m["creatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["creatorId"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmtModified"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("originBranch") != m.end() && !m["originBranch"].empty()) {
      originBranch = make_shared<string>(boost::any_cast<string>(m["originBranch"]));
    }
    if (m.find("originBranchRevisionSha") != m.end() && !m["originBranchRevisionSha"].empty()) {
      originBranchRevisionSha = make_shared<string>(boost::any_cast<string>(m["originBranchRevisionSha"]));
    }
    if (m.find("ownerAccountId") != m.end() && !m["ownerAccountId"].empty()) {
      ownerAccountId = make_shared<string>(boost::any_cast<string>(m["ownerAccountId"]));
    }
    if (m.find("ownerId") != m.end() && !m["ownerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["ownerId"]));
    }
    if (m.find("sn") != m.end() && !m["sn"].empty()) {
      sn = make_shared<string>(boost::any_cast<string>(m["sn"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~CreateChangeRequestResponseBody() = default;
};
class CreateChangeRequestResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateChangeRequestResponseBody> body{};

  CreateChangeRequestResponse() {}

  explicit CreateChangeRequestResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateChangeRequestResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateChangeRequestResponseBody>(model1);
      }
    }
  }


  virtual ~CreateChangeRequestResponse() = default;
};
class CreateCheckRunRequestAnnotations : public Darabonba::Model {
public:
  shared_ptr<string> annotationLevel{};
  shared_ptr<long> endColumn{};
  shared_ptr<long> endLine{};
  shared_ptr<string> message{};
  shared_ptr<string> path{};
  shared_ptr<string> rawDetails{};
  shared_ptr<long> startColumn{};
  shared_ptr<long> startLine{};
  shared_ptr<string> title{};

  CreateCheckRunRequestAnnotations() {}

  explicit CreateCheckRunRequestAnnotations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationLevel) {
      res["annotationLevel"] = boost::any(*annotationLevel);
    }
    if (endColumn) {
      res["endColumn"] = boost::any(*endColumn);
    }
    if (endLine) {
      res["endLine"] = boost::any(*endLine);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (rawDetails) {
      res["rawDetails"] = boost::any(*rawDetails);
    }
    if (startColumn) {
      res["startColumn"] = boost::any(*startColumn);
    }
    if (startLine) {
      res["startLine"] = boost::any(*startLine);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("annotationLevel") != m.end() && !m["annotationLevel"].empty()) {
      annotationLevel = make_shared<string>(boost::any_cast<string>(m["annotationLevel"]));
    }
    if (m.find("endColumn") != m.end() && !m["endColumn"].empty()) {
      endColumn = make_shared<long>(boost::any_cast<long>(m["endColumn"]));
    }
    if (m.find("endLine") != m.end() && !m["endLine"].empty()) {
      endLine = make_shared<long>(boost::any_cast<long>(m["endLine"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("rawDetails") != m.end() && !m["rawDetails"].empty()) {
      rawDetails = make_shared<string>(boost::any_cast<string>(m["rawDetails"]));
    }
    if (m.find("startColumn") != m.end() && !m["startColumn"].empty()) {
      startColumn = make_shared<long>(boost::any_cast<long>(m["startColumn"]));
    }
    if (m.find("startLine") != m.end() && !m["startLine"].empty()) {
      startLine = make_shared<long>(boost::any_cast<long>(m["startLine"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~CreateCheckRunRequestAnnotations() = default;
};
class CreateCheckRunRequestOutputImages : public Darabonba::Model {
public:
  shared_ptr<string> alt{};
  shared_ptr<string> caption{};
  shared_ptr<string> imageUrl{};

  CreateCheckRunRequestOutputImages() {}

  explicit CreateCheckRunRequestOutputImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alt) {
      res["alt"] = boost::any(*alt);
    }
    if (caption) {
      res["caption"] = boost::any(*caption);
    }
    if (imageUrl) {
      res["imageUrl"] = boost::any(*imageUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alt") != m.end() && !m["alt"].empty()) {
      alt = make_shared<string>(boost::any_cast<string>(m["alt"]));
    }
    if (m.find("caption") != m.end() && !m["caption"].empty()) {
      caption = make_shared<string>(boost::any_cast<string>(m["caption"]));
    }
    if (m.find("imageUrl") != m.end() && !m["imageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["imageUrl"]));
    }
  }


  virtual ~CreateCheckRunRequestOutputImages() = default;
};
class CreateCheckRunRequestOutput : public Darabonba::Model {
public:
  shared_ptr<vector<CreateCheckRunRequestOutputImages>> images{};
  shared_ptr<string> summary{};
  shared_ptr<string> text{};
  shared_ptr<string> title{};

  CreateCheckRunRequestOutput() {}

  explicit CreateCheckRunRequestOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (images) {
      vector<boost::any> temp1;
      for(auto item1:*images){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["images"] = boost::any(temp1);
    }
    if (summary) {
      res["summary"] = boost::any(*summary);
    }
    if (text) {
      res["text"] = boost::any(*text);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("images") != m.end() && !m["images"].empty()) {
      if (typeid(vector<boost::any>) == m["images"].type()) {
        vector<CreateCheckRunRequestOutputImages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["images"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCheckRunRequestOutputImages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        images = make_shared<vector<CreateCheckRunRequestOutputImages>>(expect1);
      }
    }
    if (m.find("summary") != m.end() && !m["summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["summary"]));
    }
    if (m.find("text") != m.end() && !m["text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["text"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~CreateCheckRunRequestOutput() = default;
};
class CreateCheckRunRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<vector<CreateCheckRunRequestAnnotations>> annotations{};
  shared_ptr<string> completedAt{};
  shared_ptr<string> conclusion{};
  shared_ptr<string> detailsUrl{};
  shared_ptr<string> externalId{};
  shared_ptr<string> headSha{};
  shared_ptr<string> name{};
  shared_ptr<CreateCheckRunRequestOutput> output{};
  shared_ptr<string> startedAt{};
  shared_ptr<string> status{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> repositoryIdentity{};

  CreateCheckRunRequest() {}

  explicit CreateCheckRunRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (annotations) {
      vector<boost::any> temp1;
      for(auto item1:*annotations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["annotations"] = boost::any(temp1);
    }
    if (completedAt) {
      res["completedAt"] = boost::any(*completedAt);
    }
    if (conclusion) {
      res["conclusion"] = boost::any(*conclusion);
    }
    if (detailsUrl) {
      res["detailsUrl"] = boost::any(*detailsUrl);
    }
    if (externalId) {
      res["externalId"] = boost::any(*externalId);
    }
    if (headSha) {
      res["headSha"] = boost::any(*headSha);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (output) {
      res["output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startedAt) {
      res["startedAt"] = boost::any(*startedAt);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (repositoryIdentity) {
      res["repositoryIdentity"] = boost::any(*repositoryIdentity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("annotations") != m.end() && !m["annotations"].empty()) {
      if (typeid(vector<boost::any>) == m["annotations"].type()) {
        vector<CreateCheckRunRequestAnnotations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["annotations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCheckRunRequestAnnotations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotations = make_shared<vector<CreateCheckRunRequestAnnotations>>(expect1);
      }
    }
    if (m.find("completedAt") != m.end() && !m["completedAt"].empty()) {
      completedAt = make_shared<string>(boost::any_cast<string>(m["completedAt"]));
    }
    if (m.find("conclusion") != m.end() && !m["conclusion"].empty()) {
      conclusion = make_shared<string>(boost::any_cast<string>(m["conclusion"]));
    }
    if (m.find("detailsUrl") != m.end() && !m["detailsUrl"].empty()) {
      detailsUrl = make_shared<string>(boost::any_cast<string>(m["detailsUrl"]));
    }
    if (m.find("externalId") != m.end() && !m["externalId"].empty()) {
      externalId = make_shared<string>(boost::any_cast<string>(m["externalId"]));
    }
    if (m.find("headSha") != m.end() && !m["headSha"].empty()) {
      headSha = make_shared<string>(boost::any_cast<string>(m["headSha"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("output") != m.end() && !m["output"].empty()) {
      if (typeid(map<string, boost::any>) == m["output"].type()) {
        CreateCheckRunRequestOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["output"]));
        output = make_shared<CreateCheckRunRequestOutput>(model1);
      }
    }
    if (m.find("startedAt") != m.end() && !m["startedAt"].empty()) {
      startedAt = make_shared<string>(boost::any_cast<string>(m["startedAt"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("repositoryIdentity") != m.end() && !m["repositoryIdentity"].empty()) {
      repositoryIdentity = make_shared<string>(boost::any_cast<string>(m["repositoryIdentity"]));
    }
  }


  virtual ~CreateCheckRunRequest() = default;
};
class CreateCheckRunResponseBodyResultAnnotations : public Darabonba::Model {
public:
  shared_ptr<string> annotationLevel{};
  shared_ptr<long> endColumn{};
  shared_ptr<long> endLine{};
  shared_ptr<long> id{};
  shared_ptr<string> message{};
  shared_ptr<string> path{};
  shared_ptr<string> rawDetails{};
  shared_ptr<long> startColumn{};
  shared_ptr<long> startLine{};
  shared_ptr<string> title{};

  CreateCheckRunResponseBodyResultAnnotations() {}

  explicit CreateCheckRunResponseBodyResultAnnotations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationLevel) {
      res["annotationLevel"] = boost::any(*annotationLevel);
    }
    if (endColumn) {
      res["endColumn"] = boost::any(*endColumn);
    }
    if (endLine) {
      res["endLine"] = boost::any(*endLine);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (rawDetails) {
      res["rawDetails"] = boost::any(*rawDetails);
    }
    if (startColumn) {
      res["startColumn"] = boost::any(*startColumn);
    }
    if (startLine) {
      res["startLine"] = boost::any(*startLine);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("annotationLevel") != m.end() && !m["annotationLevel"].empty()) {
      annotationLevel = make_shared<string>(boost::any_cast<string>(m["annotationLevel"]));
    }
    if (m.find("endColumn") != m.end() && !m["endColumn"].empty()) {
      endColumn = make_shared<long>(boost::any_cast<long>(m["endColumn"]));
    }
    if (m.find("endLine") != m.end() && !m["endLine"].empty()) {
      endLine = make_shared<long>(boost::any_cast<long>(m["endLine"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("rawDetails") != m.end() && !m["rawDetails"].empty()) {
      rawDetails = make_shared<string>(boost::any_cast<string>(m["rawDetails"]));
    }
    if (m.find("startColumn") != m.end() && !m["startColumn"].empty()) {
      startColumn = make_shared<long>(boost::any_cast<long>(m["startColumn"]));
    }
    if (m.find("startLine") != m.end() && !m["startLine"].empty()) {
      startLine = make_shared<long>(boost::any_cast<long>(m["startLine"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~CreateCheckRunResponseBodyResultAnnotations() = default;
};
class CreateCheckRunResponseBodyResultCheckSuite : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  CreateCheckRunResponseBodyResultCheckSuite() {}

  explicit CreateCheckRunResponseBodyResultCheckSuite(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
  }


  virtual ~CreateCheckRunResponseBodyResultCheckSuite() = default;
};
class CreateCheckRunResponseBodyResultOutputImages : public Darabonba::Model {
public:
  shared_ptr<string> alt{};
  shared_ptr<string> caption{};
  shared_ptr<string> imageUrl{};

  CreateCheckRunResponseBodyResultOutputImages() {}

  explicit CreateCheckRunResponseBodyResultOutputImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alt) {
      res["alt"] = boost::any(*alt);
    }
    if (caption) {
      res["caption"] = boost::any(*caption);
    }
    if (imageUrl) {
      res["imageUrl"] = boost::any(*imageUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alt") != m.end() && !m["alt"].empty()) {
      alt = make_shared<string>(boost::any_cast<string>(m["alt"]));
    }
    if (m.find("caption") != m.end() && !m["caption"].empty()) {
      caption = make_shared<string>(boost::any_cast<string>(m["caption"]));
    }
    if (m.find("imageUrl") != m.end() && !m["imageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["imageUrl"]));
    }
  }


  virtual ~CreateCheckRunResponseBodyResultOutputImages() = default;
};
class CreateCheckRunResponseBodyResultOutput : public Darabonba::Model {
public:
  shared_ptr<vector<CreateCheckRunResponseBodyResultOutputImages>> images{};
  shared_ptr<string> summary{};
  shared_ptr<string> text{};
  shared_ptr<string> title{};

  CreateCheckRunResponseBodyResultOutput() {}

  explicit CreateCheckRunResponseBodyResultOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (images) {
      vector<boost::any> temp1;
      for(auto item1:*images){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["images"] = boost::any(temp1);
    }
    if (summary) {
      res["summary"] = boost::any(*summary);
    }
    if (text) {
      res["text"] = boost::any(*text);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("images") != m.end() && !m["images"].empty()) {
      if (typeid(vector<boost::any>) == m["images"].type()) {
        vector<CreateCheckRunResponseBodyResultOutputImages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["images"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCheckRunResponseBodyResultOutputImages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        images = make_shared<vector<CreateCheckRunResponseBodyResultOutputImages>>(expect1);
      }
    }
    if (m.find("summary") != m.end() && !m["summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["summary"]));
    }
    if (m.find("text") != m.end() && !m["text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["text"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~CreateCheckRunResponseBodyResultOutput() = default;
};
class CreateCheckRunResponseBodyResultWriter : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> logoUrl{};
  shared_ptr<string> name{};
  shared_ptr<string> slug{};
  shared_ptr<string> type{};

  CreateCheckRunResponseBodyResultWriter() {}

  explicit CreateCheckRunResponseBodyResultWriter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (logoUrl) {
      res["logoUrl"] = boost::any(*logoUrl);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (slug) {
      res["slug"] = boost::any(*slug);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("logoUrl") != m.end() && !m["logoUrl"].empty()) {
      logoUrl = make_shared<string>(boost::any_cast<string>(m["logoUrl"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("slug") != m.end() && !m["slug"].empty()) {
      slug = make_shared<string>(boost::any_cast<string>(m["slug"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~CreateCheckRunResponseBodyResultWriter() = default;
};
class CreateCheckRunResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<CreateCheckRunResponseBodyResultAnnotations>> annotations{};
  shared_ptr<CreateCheckRunResponseBodyResultCheckSuite> checkSuite{};
  shared_ptr<string> completedAt{};
  shared_ptr<string> conclusion{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> detailsUrl{};
  shared_ptr<string> externalId{};
  shared_ptr<string> headSha{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<CreateCheckRunResponseBodyResultOutput> output{};
  shared_ptr<string> startedAt{};
  shared_ptr<string> status{};
  shared_ptr<string> updatedAt{};
  shared_ptr<CreateCheckRunResponseBodyResultWriter> writer{};

  CreateCheckRunResponseBodyResult() {}

  explicit CreateCheckRunResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotations) {
      vector<boost::any> temp1;
      for(auto item1:*annotations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["annotations"] = boost::any(temp1);
    }
    if (checkSuite) {
      res["checkSuite"] = checkSuite ? boost::any(checkSuite->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (completedAt) {
      res["completedAt"] = boost::any(*completedAt);
    }
    if (conclusion) {
      res["conclusion"] = boost::any(*conclusion);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (detailsUrl) {
      res["detailsUrl"] = boost::any(*detailsUrl);
    }
    if (externalId) {
      res["externalId"] = boost::any(*externalId);
    }
    if (headSha) {
      res["headSha"] = boost::any(*headSha);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (output) {
      res["output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startedAt) {
      res["startedAt"] = boost::any(*startedAt);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (updatedAt) {
      res["updatedAt"] = boost::any(*updatedAt);
    }
    if (writer) {
      res["writer"] = writer ? boost::any(writer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("annotations") != m.end() && !m["annotations"].empty()) {
      if (typeid(vector<boost::any>) == m["annotations"].type()) {
        vector<CreateCheckRunResponseBodyResultAnnotations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["annotations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCheckRunResponseBodyResultAnnotations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotations = make_shared<vector<CreateCheckRunResponseBodyResultAnnotations>>(expect1);
      }
    }
    if (m.find("checkSuite") != m.end() && !m["checkSuite"].empty()) {
      if (typeid(map<string, boost::any>) == m["checkSuite"].type()) {
        CreateCheckRunResponseBodyResultCheckSuite model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["checkSuite"]));
        checkSuite = make_shared<CreateCheckRunResponseBodyResultCheckSuite>(model1);
      }
    }
    if (m.find("completedAt") != m.end() && !m["completedAt"].empty()) {
      completedAt = make_shared<string>(boost::any_cast<string>(m["completedAt"]));
    }
    if (m.find("conclusion") != m.end() && !m["conclusion"].empty()) {
      conclusion = make_shared<string>(boost::any_cast<string>(m["conclusion"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("detailsUrl") != m.end() && !m["detailsUrl"].empty()) {
      detailsUrl = make_shared<string>(boost::any_cast<string>(m["detailsUrl"]));
    }
    if (m.find("externalId") != m.end() && !m["externalId"].empty()) {
      externalId = make_shared<string>(boost::any_cast<string>(m["externalId"]));
    }
    if (m.find("headSha") != m.end() && !m["headSha"].empty()) {
      headSha = make_shared<string>(boost::any_cast<string>(m["headSha"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("output") != m.end() && !m["output"].empty()) {
      if (typeid(map<string, boost::any>) == m["output"].type()) {
        CreateCheckRunResponseBodyResultOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["output"]));
        output = make_shared<CreateCheckRunResponseBodyResultOutput>(model1);
      }
    }
    if (m.find("startedAt") != m.end() && !m["startedAt"].empty()) {
      startedAt = make_shared<string>(boost::any_cast<string>(m["startedAt"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("updatedAt") != m.end() && !m["updatedAt"].empty()) {
      updatedAt = make_shared<string>(boost::any_cast<string>(m["updatedAt"]));
    }
    if (m.find("writer") != m.end() && !m["writer"].empty()) {
      if (typeid(map<string, boost::any>) == m["writer"].type()) {
        CreateCheckRunResponseBodyResultWriter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["writer"]));
        writer = make_shared<CreateCheckRunResponseBodyResultWriter>(model1);
      }
    }
  }


  virtual ~CreateCheckRunResponseBodyResult() = default;
};
class CreateCheckRunResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateCheckRunResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateCheckRunResponseBody() {}

  explicit CreateCheckRunResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        CreateCheckRunResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<CreateCheckRunResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreateCheckRunResponseBody() = default;
};
class CreateCheckRunResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCheckRunResponseBody> body{};

  CreateCheckRunResponse() {}

  explicit CreateCheckRunResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCheckRunResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCheckRunResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCheckRunResponse() = default;
};
class CreateCommentRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> commentType{};
  shared_ptr<string> content{};
  shared_ptr<bool> draft{};
  shared_ptr<string> filePath{};
  shared_ptr<long> lineNumber{};
  shared_ptr<string> parentCommentBizId{};
  shared_ptr<string> patchSetBizId{};
  shared_ptr<bool> resolved{};
  shared_ptr<long> localId{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> repositoryIdentity{};

  CreateCommentRequest() {}

  explicit CreateCommentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (commentType) {
      res["commentType"] = boost::any(*commentType);
    }
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (draft) {
      res["draft"] = boost::any(*draft);
    }
    if (filePath) {
      res["filePath"] = boost::any(*filePath);
    }
    if (lineNumber) {
      res["lineNumber"] = boost::any(*lineNumber);
    }
    if (parentCommentBizId) {
      res["parentCommentBizId"] = boost::any(*parentCommentBizId);
    }
    if (patchSetBizId) {
      res["patchSetBizId"] = boost::any(*patchSetBizId);
    }
    if (resolved) {
      res["resolved"] = boost::any(*resolved);
    }
    if (localId) {
      res["localId"] = boost::any(*localId);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (repositoryIdentity) {
      res["repositoryIdentity"] = boost::any(*repositoryIdentity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("commentType") != m.end() && !m["commentType"].empty()) {
      commentType = make_shared<string>(boost::any_cast<string>(m["commentType"]));
    }
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("draft") != m.end() && !m["draft"].empty()) {
      draft = make_shared<bool>(boost::any_cast<bool>(m["draft"]));
    }
    if (m.find("filePath") != m.end() && !m["filePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["filePath"]));
    }
    if (m.find("lineNumber") != m.end() && !m["lineNumber"].empty()) {
      lineNumber = make_shared<long>(boost::any_cast<long>(m["lineNumber"]));
    }
    if (m.find("parentCommentBizId") != m.end() && !m["parentCommentBizId"].empty()) {
      parentCommentBizId = make_shared<string>(boost::any_cast<string>(m["parentCommentBizId"]));
    }
    if (m.find("patchSetBizId") != m.end() && !m["patchSetBizId"].empty()) {
      patchSetBizId = make_shared<string>(boost::any_cast<string>(m["patchSetBizId"]));
    }
    if (m.find("resolved") != m.end() && !m["resolved"].empty()) {
      resolved = make_shared<bool>(boost::any_cast<bool>(m["resolved"]));
    }
    if (m.find("localId") != m.end() && !m["localId"].empty()) {
      localId = make_shared<long>(boost::any_cast<long>(m["localId"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("repositoryIdentity") != m.end() && !m["repositoryIdentity"].empty()) {
      repositoryIdentity = make_shared<string>(boost::any_cast<string>(m["repositoryIdentity"]));
    }
  }


  virtual ~CreateCommentRequest() = default;
};
class CreateCommentResponseBodyResultAuthor : public Darabonba::Model {
public:
  shared_ptr<string> aliyunPk{};
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};

  CreateCommentResponseBodyResultAuthor() {}

  explicit CreateCommentResponseBodyResultAuthor(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunPk) {
      res["aliyunPk"] = boost::any(*aliyunPk);
    }
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aliyunPk") != m.end() && !m["aliyunPk"].empty()) {
      aliyunPk = make_shared<string>(boost::any_cast<string>(m["aliyunPk"]));
    }
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~CreateCommentResponseBodyResultAuthor() = default;
};
class CreateCommentResponseBodyResultRelatedPatchSet : public Darabonba::Model {
public:
  shared_ptr<string> commitId{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> patchSetBizId{};
  shared_ptr<string> patchSetName{};
  shared_ptr<string> patchSetNo{};
  shared_ptr<string> relatedMergeItemType{};
  shared_ptr<string> shortId{};

  CreateCommentResponseBodyResultRelatedPatchSet() {}

  explicit CreateCommentResponseBodyResultRelatedPatchSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commitId) {
      res["commitId"] = boost::any(*commitId);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (patchSetBizId) {
      res["patchSetBizId"] = boost::any(*patchSetBizId);
    }
    if (patchSetName) {
      res["patchSetName"] = boost::any(*patchSetName);
    }
    if (patchSetNo) {
      res["patchSetNo"] = boost::any(*patchSetNo);
    }
    if (relatedMergeItemType) {
      res["relatedMergeItemType"] = boost::any(*relatedMergeItemType);
    }
    if (shortId) {
      res["shortId"] = boost::any(*shortId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commitId") != m.end() && !m["commitId"].empty()) {
      commitId = make_shared<string>(boost::any_cast<string>(m["commitId"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("patchSetBizId") != m.end() && !m["patchSetBizId"].empty()) {
      patchSetBizId = make_shared<string>(boost::any_cast<string>(m["patchSetBizId"]));
    }
    if (m.find("patchSetName") != m.end() && !m["patchSetName"].empty()) {
      patchSetName = make_shared<string>(boost::any_cast<string>(m["patchSetName"]));
    }
    if (m.find("patchSetNo") != m.end() && !m["patchSetNo"].empty()) {
      patchSetNo = make_shared<string>(boost::any_cast<string>(m["patchSetNo"]));
    }
    if (m.find("relatedMergeItemType") != m.end() && !m["relatedMergeItemType"].empty()) {
      relatedMergeItemType = make_shared<string>(boost::any_cast<string>(m["relatedMergeItemType"]));
    }
    if (m.find("shortId") != m.end() && !m["shortId"].empty()) {
      shortId = make_shared<string>(boost::any_cast<string>(m["shortId"]));
    }
  }


  virtual ~CreateCommentResponseBodyResultRelatedPatchSet() = default;
};
class CreateCommentResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<CreateCommentResponseBodyResultAuthor> author{};
  shared_ptr<string> commentBizId{};
  shared_ptr<string> commentTime{};
  shared_ptr<string> commentType{};
  shared_ptr<string> content{};
  shared_ptr<bool> deleted{};
  shared_ptr<string> filePath{};
  shared_ptr<string> lastEditTime{};
  shared_ptr<string> lineNumber{};
  shared_ptr<string> parentCommentBizId{};
  shared_ptr<CreateCommentResponseBodyResultRelatedPatchSet> relatedPatchSet{};
  shared_ptr<bool> resolved{};
  shared_ptr<string> rootCommentBizId{};
  shared_ptr<string> state{};

  CreateCommentResponseBodyResult() {}

  explicit CreateCommentResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (author) {
      res["author"] = author ? boost::any(author->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (commentBizId) {
      res["commentBizId"] = boost::any(*commentBizId);
    }
    if (commentTime) {
      res["commentTime"] = boost::any(*commentTime);
    }
    if (commentType) {
      res["commentType"] = boost::any(*commentType);
    }
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (deleted) {
      res["deleted"] = boost::any(*deleted);
    }
    if (filePath) {
      res["filePath"] = boost::any(*filePath);
    }
    if (lastEditTime) {
      res["lastEditTime"] = boost::any(*lastEditTime);
    }
    if (lineNumber) {
      res["lineNumber"] = boost::any(*lineNumber);
    }
    if (parentCommentBizId) {
      res["parentCommentBizId"] = boost::any(*parentCommentBizId);
    }
    if (relatedPatchSet) {
      res["relatedPatchSet"] = relatedPatchSet ? boost::any(relatedPatchSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resolved) {
      res["resolved"] = boost::any(*resolved);
    }
    if (rootCommentBizId) {
      res["rootCommentBizId"] = boost::any(*rootCommentBizId);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("author") != m.end() && !m["author"].empty()) {
      if (typeid(map<string, boost::any>) == m["author"].type()) {
        CreateCommentResponseBodyResultAuthor model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["author"]));
        author = make_shared<CreateCommentResponseBodyResultAuthor>(model1);
      }
    }
    if (m.find("commentBizId") != m.end() && !m["commentBizId"].empty()) {
      commentBizId = make_shared<string>(boost::any_cast<string>(m["commentBizId"]));
    }
    if (m.find("commentTime") != m.end() && !m["commentTime"].empty()) {
      commentTime = make_shared<string>(boost::any_cast<string>(m["commentTime"]));
    }
    if (m.find("commentType") != m.end() && !m["commentType"].empty()) {
      commentType = make_shared<string>(boost::any_cast<string>(m["commentType"]));
    }
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("deleted") != m.end() && !m["deleted"].empty()) {
      deleted = make_shared<bool>(boost::any_cast<bool>(m["deleted"]));
    }
    if (m.find("filePath") != m.end() && !m["filePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["filePath"]));
    }
    if (m.find("lastEditTime") != m.end() && !m["lastEditTime"].empty()) {
      lastEditTime = make_shared<string>(boost::any_cast<string>(m["lastEditTime"]));
    }
    if (m.find("lineNumber") != m.end() && !m["lineNumber"].empty()) {
      lineNumber = make_shared<string>(boost::any_cast<string>(m["lineNumber"]));
    }
    if (m.find("parentCommentBizId") != m.end() && !m["parentCommentBizId"].empty()) {
      parentCommentBizId = make_shared<string>(boost::any_cast<string>(m["parentCommentBizId"]));
    }
    if (m.find("relatedPatchSet") != m.end() && !m["relatedPatchSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["relatedPatchSet"].type()) {
        CreateCommentResponseBodyResultRelatedPatchSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["relatedPatchSet"]));
        relatedPatchSet = make_shared<CreateCommentResponseBodyResultRelatedPatchSet>(model1);
      }
    }
    if (m.find("resolved") != m.end() && !m["resolved"].empty()) {
      resolved = make_shared<bool>(boost::any_cast<bool>(m["resolved"]));
    }
    if (m.find("rootCommentBizId") != m.end() && !m["rootCommentBizId"].empty()) {
      rootCommentBizId = make_shared<string>(boost::any_cast<string>(m["rootCommentBizId"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
  }


  virtual ~CreateCommentResponseBodyResult() = default;
};
class CreateCommentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateCommentResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateCommentResponseBody() {}

  explicit CreateCommentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        CreateCommentResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<CreateCommentResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreateCommentResponseBody() = default;
};
class CreateCommentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCommentResponseBody> body{};

  CreateCommentResponse() {}

  explicit CreateCommentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCommentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCommentResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCommentResponse() = default;
};
class CreateCommitStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> context{};
  shared_ptr<string> description{};
  shared_ptr<string> state{};
  shared_ptr<string> targetUrl{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> repositoryIdentity{};
  shared_ptr<string> sha{};

  CreateCommitStatusRequest() {}

  explicit CreateCommitStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (context) {
      res["context"] = boost::any(*context);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (targetUrl) {
      res["targetUrl"] = boost::any(*targetUrl);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (repositoryIdentity) {
      res["repositoryIdentity"] = boost::any(*repositoryIdentity);
    }
    if (sha) {
      res["sha"] = boost::any(*sha);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("context") != m.end() && !m["context"].empty()) {
      context = make_shared<string>(boost::any_cast<string>(m["context"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("targetUrl") != m.end() && !m["targetUrl"].empty()) {
      targetUrl = make_shared<string>(boost::any_cast<string>(m["targetUrl"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("repositoryIdentity") != m.end() && !m["repositoryIdentity"].empty()) {
      repositoryIdentity = make_shared<string>(boost::any_cast<string>(m["repositoryIdentity"]));
    }
    if (m.find("sha") != m.end() && !m["sha"].empty()) {
      sha = make_shared<string>(boost::any_cast<string>(m["sha"]));
    }
  }


  virtual ~CreateCommitStatusRequest() = default;
};
class CreateCommitStatusResponseBodyResultCreator : public Darabonba::Model {
public:
  shared_ptr<long> aliyunPk{};
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> login{};
  shared_ptr<string> type{};

  CreateCommitStatusResponseBodyResultCreator() {}

  explicit CreateCommitStatusResponseBodyResultCreator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunPk) {
      res["aliyunPk"] = boost::any(*aliyunPk);
    }
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (login) {
      res["login"] = boost::any(*login);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aliyunPk") != m.end() && !m["aliyunPk"].empty()) {
      aliyunPk = make_shared<long>(boost::any_cast<long>(m["aliyunPk"]));
    }
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("login") != m.end() && !m["login"].empty()) {
      login = make_shared<string>(boost::any_cast<string>(m["login"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~CreateCommitStatusResponseBodyResultCreator() = default;
};
class CreateCommitStatusResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> context{};
  shared_ptr<CreateCommitStatusResponseBodyResultCreator> creator{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> sha{};
  shared_ptr<string> state{};
  shared_ptr<string> targetUrl{};

  CreateCommitStatusResponseBodyResult() {}

  explicit CreateCommitStatusResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (context) {
      res["context"] = boost::any(*context);
    }
    if (creator) {
      res["creator"] = creator ? boost::any(creator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (sha) {
      res["sha"] = boost::any(*sha);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (targetUrl) {
      res["targetUrl"] = boost::any(*targetUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("context") != m.end() && !m["context"].empty()) {
      context = make_shared<string>(boost::any_cast<string>(m["context"]));
    }
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      if (typeid(map<string, boost::any>) == m["creator"].type()) {
        CreateCommitStatusResponseBodyResultCreator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["creator"]));
        creator = make_shared<CreateCommitStatusResponseBodyResultCreator>(model1);
      }
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("sha") != m.end() && !m["sha"].empty()) {
      sha = make_shared<string>(boost::any_cast<string>(m["sha"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("targetUrl") != m.end() && !m["targetUrl"].empty()) {
      targetUrl = make_shared<string>(boost::any_cast<string>(m["targetUrl"]));
    }
  }


  virtual ~CreateCommitStatusResponseBodyResult() = default;
};
class CreateCommitStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateCommitStatusResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateCommitStatusResponseBody() {}

  explicit CreateCommitStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        CreateCommitStatusResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<CreateCommitStatusResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreateCommitStatusResponseBody() = default;
};
class CreateCommitStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCommitStatusResponseBody> body{};

  CreateCommitStatusResponse() {}

  explicit CreateCommitStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCommitStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCommitStatusResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCommitStatusResponse() = default;
};
class CreateCommitWithMultipleFilesRequestActions : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> content{};
  shared_ptr<string> filePath{};
  shared_ptr<string> previousPath{};

  CreateCommitWithMultipleFilesRequestActions() {}

  explicit CreateCommitWithMultipleFilesRequestActions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["action"] = boost::any(*action);
    }
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (filePath) {
      res["filePath"] = boost::any(*filePath);
    }
    if (previousPath) {
      res["previousPath"] = boost::any(*previousPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("action") != m.end() && !m["action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["action"]));
    }
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("filePath") != m.end() && !m["filePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["filePath"]));
    }
    if (m.find("previousPath") != m.end() && !m["previousPath"].empty()) {
      previousPath = make_shared<string>(boost::any_cast<string>(m["previousPath"]));
    }
  }


  virtual ~CreateCommitWithMultipleFilesRequestActions() = default;
};
class CreateCommitWithMultipleFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<vector<CreateCommitWithMultipleFilesRequestActions>> actions{};
  shared_ptr<string> branch{};
  shared_ptr<string> commitMessage{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> repositoryIdentity{};

  CreateCommitWithMultipleFilesRequest() {}

  explicit CreateCommitWithMultipleFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (actions) {
      vector<boost::any> temp1;
      for(auto item1:*actions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["actions"] = boost::any(temp1);
    }
    if (branch) {
      res["branch"] = boost::any(*branch);
    }
    if (commitMessage) {
      res["commitMessage"] = boost::any(*commitMessage);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (repositoryIdentity) {
      res["repositoryIdentity"] = boost::any(*repositoryIdentity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("actions") != m.end() && !m["actions"].empty()) {
      if (typeid(vector<boost::any>) == m["actions"].type()) {
        vector<CreateCommitWithMultipleFilesRequestActions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["actions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCommitWithMultipleFilesRequestActions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        actions = make_shared<vector<CreateCommitWithMultipleFilesRequestActions>>(expect1);
      }
    }
    if (m.find("branch") != m.end() && !m["branch"].empty()) {
      branch = make_shared<string>(boost::any_cast<string>(m["branch"]));
    }
    if (m.find("commitMessage") != m.end() && !m["commitMessage"].empty()) {
      commitMessage = make_shared<string>(boost::any_cast<string>(m["commitMessage"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("repositoryIdentity") != m.end() && !m["repositoryIdentity"].empty()) {
      repositoryIdentity = make_shared<string>(boost::any_cast<string>(m["repositoryIdentity"]));
    }
  }


  virtual ~CreateCommitWithMultipleFilesRequest() = default;
};
class CreateCommitWithMultipleFilesResponseBodyResultAuthor : public Darabonba::Model {
public:
  shared_ptr<string> aliyunPk{};
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};
  shared_ptr<string> websiteUrl{};

  CreateCommitWithMultipleFilesResponseBodyResultAuthor() {}

  explicit CreateCommitWithMultipleFilesResponseBodyResultAuthor(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunPk) {
      res["aliyunPk"] = boost::any(*aliyunPk);
    }
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    if (websiteUrl) {
      res["websiteUrl"] = boost::any(*websiteUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aliyunPk") != m.end() && !m["aliyunPk"].empty()) {
      aliyunPk = make_shared<string>(boost::any_cast<string>(m["aliyunPk"]));
    }
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
    if (m.find("websiteUrl") != m.end() && !m["websiteUrl"].empty()) {
      websiteUrl = make_shared<string>(boost::any_cast<string>(m["websiteUrl"]));
    }
  }


  virtual ~CreateCommitWithMultipleFilesResponseBodyResultAuthor() = default;
};
class CreateCommitWithMultipleFilesResponseBodyResultCommitter : public Darabonba::Model {
public:
  shared_ptr<string> aliyunPk{};
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};
  shared_ptr<string> websiteUrl{};

  CreateCommitWithMultipleFilesResponseBodyResultCommitter() {}

  explicit CreateCommitWithMultipleFilesResponseBodyResultCommitter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunPk) {
      res["aliyunPk"] = boost::any(*aliyunPk);
    }
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    if (websiteUrl) {
      res["websiteUrl"] = boost::any(*websiteUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aliyunPk") != m.end() && !m["aliyunPk"].empty()) {
      aliyunPk = make_shared<string>(boost::any_cast<string>(m["aliyunPk"]));
    }
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
    if (m.find("websiteUrl") != m.end() && !m["websiteUrl"].empty()) {
      websiteUrl = make_shared<string>(boost::any_cast<string>(m["websiteUrl"]));
    }
  }


  virtual ~CreateCommitWithMultipleFilesResponseBodyResultCommitter() = default;
};
class CreateCommitWithMultipleFilesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<CreateCommitWithMultipleFilesResponseBodyResultAuthor> author{};
  shared_ptr<string> authorEmail{};
  shared_ptr<string> authorName{};
  shared_ptr<string> authoredDate{};
  shared_ptr<string> committedDate{};
  shared_ptr<CreateCommitWithMultipleFilesResponseBodyResultCommitter> committer{};
  shared_ptr<string> committerEmail{};
  shared_ptr<string> committerName{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> id{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> parentIds{};
  shared_ptr<string> shortId{};
  shared_ptr<string> title{};

  CreateCommitWithMultipleFilesResponseBodyResult() {}

  explicit CreateCommitWithMultipleFilesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (author) {
      res["author"] = author ? boost::any(author->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (authorEmail) {
      res["authorEmail"] = boost::any(*authorEmail);
    }
    if (authorName) {
      res["authorName"] = boost::any(*authorName);
    }
    if (authoredDate) {
      res["authoredDate"] = boost::any(*authoredDate);
    }
    if (committedDate) {
      res["committedDate"] = boost::any(*committedDate);
    }
    if (committer) {
      res["committer"] = committer ? boost::any(committer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (committerEmail) {
      res["committerEmail"] = boost::any(*committerEmail);
    }
    if (committerName) {
      res["committerName"] = boost::any(*committerName);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (parentIds) {
      res["parentIds"] = boost::any(*parentIds);
    }
    if (shortId) {
      res["shortId"] = boost::any(*shortId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("author") != m.end() && !m["author"].empty()) {
      if (typeid(map<string, boost::any>) == m["author"].type()) {
        CreateCommitWithMultipleFilesResponseBodyResultAuthor model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["author"]));
        author = make_shared<CreateCommitWithMultipleFilesResponseBodyResultAuthor>(model1);
      }
    }
    if (m.find("authorEmail") != m.end() && !m["authorEmail"].empty()) {
      authorEmail = make_shared<string>(boost::any_cast<string>(m["authorEmail"]));
    }
    if (m.find("authorName") != m.end() && !m["authorName"].empty()) {
      authorName = make_shared<string>(boost::any_cast<string>(m["authorName"]));
    }
    if (m.find("authoredDate") != m.end() && !m["authoredDate"].empty()) {
      authoredDate = make_shared<string>(boost::any_cast<string>(m["authoredDate"]));
    }
    if (m.find("committedDate") != m.end() && !m["committedDate"].empty()) {
      committedDate = make_shared<string>(boost::any_cast<string>(m["committedDate"]));
    }
    if (m.find("committer") != m.end() && !m["committer"].empty()) {
      if (typeid(map<string, boost::any>) == m["committer"].type()) {
        CreateCommitWithMultipleFilesResponseBodyResultCommitter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["committer"]));
        committer = make_shared<CreateCommitWithMultipleFilesResponseBodyResultCommitter>(model1);
      }
    }
    if (m.find("committerEmail") != m.end() && !m["committerEmail"].empty()) {
      committerEmail = make_shared<string>(boost::any_cast<string>(m["committerEmail"]));
    }
    if (m.find("committerName") != m.end() && !m["committerName"].empty()) {
      committerName = make_shared<string>(boost::any_cast<string>(m["committerName"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("parentIds") != m.end() && !m["parentIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["parentIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["parentIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      parentIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("shortId") != m.end() && !m["shortId"].empty()) {
      shortId = make_shared<string>(boost::any_cast<string>(m["shortId"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~CreateCommitWithMultipleFilesResponseBodyResult() = default;
};
class CreateCommitWithMultipleFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateCommitWithMultipleFilesResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateCommitWithMultipleFilesResponseBody() {}

  explicit CreateCommitWithMultipleFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        CreateCommitWithMultipleFilesResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<CreateCommitWithMultipleFilesResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreateCommitWithMultipleFilesResponseBody() = default;
};
class CreateCommitWithMultipleFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCommitWithMultipleFilesResponseBody> body{};

  CreateCommitWithMultipleFilesResponse() {}

  explicit CreateCommitWithMultipleFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCommitWithMultipleFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCommitWithMultipleFilesResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCommitWithMultipleFilesResponse() = default;
};
class CreateDeployKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> key{};
  shared_ptr<string> title{};
  shared_ptr<string> organizationId{};

  CreateDeployKeyRequest() {}

  explicit CreateDeployKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~CreateDeployKeyRequest() = default;
};
class CreateDeployKeyResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> createdAt{};
  shared_ptr<string> fingerprint{};
  shared_ptr<long> id{};
  shared_ptr<string> key{};
  shared_ptr<string> title{};

  CreateDeployKeyResponseBodyResult() {}

  explicit CreateDeployKeyResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (fingerprint) {
      res["fingerprint"] = boost::any(*fingerprint);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("fingerprint") != m.end() && !m["fingerprint"].empty()) {
      fingerprint = make_shared<string>(boost::any_cast<string>(m["fingerprint"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~CreateDeployKeyResponseBodyResult() = default;
};
class CreateDeployKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateDeployKeyResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateDeployKeyResponseBody() {}

  explicit CreateDeployKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        CreateDeployKeyResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<CreateDeployKeyResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreateDeployKeyResponseBody() = default;
};
class CreateDeployKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDeployKeyResponseBody> body{};

  CreateDeployKeyResponse() {}

  explicit CreateDeployKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDeployKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDeployKeyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDeployKeyResponse() = default;
};
class CreateFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> branchName{};
  shared_ptr<string> commitMessage{};
  shared_ptr<string> content{};
  shared_ptr<string> encoding{};
  shared_ptr<string> filePath{};
  shared_ptr<string> organizationId{};

  CreateFileRequest() {}

  explicit CreateFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (branchName) {
      res["branchName"] = boost::any(*branchName);
    }
    if (commitMessage) {
      res["commitMessage"] = boost::any(*commitMessage);
    }
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (encoding) {
      res["encoding"] = boost::any(*encoding);
    }
    if (filePath) {
      res["filePath"] = boost::any(*filePath);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("branchName") != m.end() && !m["branchName"].empty()) {
      branchName = make_shared<string>(boost::any_cast<string>(m["branchName"]));
    }
    if (m.find("commitMessage") != m.end() && !m["commitMessage"].empty()) {
      commitMessage = make_shared<string>(boost::any_cast<string>(m["commitMessage"]));
    }
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("encoding") != m.end() && !m["encoding"].empty()) {
      encoding = make_shared<string>(boost::any_cast<string>(m["encoding"]));
    }
    if (m.find("filePath") != m.end() && !m["filePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["filePath"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~CreateFileRequest() = default;
};
class CreateFileResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> branchName{};
  shared_ptr<string> filePath{};

  CreateFileResponseBodyResult() {}

  explicit CreateFileResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (branchName) {
      res["branchName"] = boost::any(*branchName);
    }
    if (filePath) {
      res["filePath"] = boost::any(*filePath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("branchName") != m.end() && !m["branchName"].empty()) {
      branchName = make_shared<string>(boost::any_cast<string>(m["branchName"]));
    }
    if (m.find("filePath") != m.end() && !m["filePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["filePath"]));
    }
  }


  virtual ~CreateFileResponseBodyResult() = default;
};
class CreateFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateFileResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateFileResponseBody() {}

  explicit CreateFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        CreateFileResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<CreateFileResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreateFileResponseBody() = default;
};
class CreateFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFileResponseBody> body{};

  CreateFileResponse() {}

  explicit CreateFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFileResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFileResponse() = default;
};
class CreateFlowTagRequest : public Darabonba::Model {
public:
  shared_ptr<string> color{};
  shared_ptr<long> flowTagGroupId{};
  shared_ptr<string> name{};

  CreateFlowTagRequest() {}

  explicit CreateFlowTagRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (color) {
      res["color"] = boost::any(*color);
    }
    if (flowTagGroupId) {
      res["flowTagGroupId"] = boost::any(*flowTagGroupId);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("color") != m.end() && !m["color"].empty()) {
      color = make_shared<string>(boost::any_cast<string>(m["color"]));
    }
    if (m.find("flowTagGroupId") != m.end() && !m["flowTagGroupId"].empty()) {
      flowTagGroupId = make_shared<long>(boost::any_cast<long>(m["flowTagGroupId"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~CreateFlowTagRequest() = default;
};
class CreateFlowTagResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateFlowTagResponseBody() {}

  explicit CreateFlowTagResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreateFlowTagResponseBody() = default;
};
class CreateFlowTagResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFlowTagResponseBody> body{};

  CreateFlowTagResponse() {}

  explicit CreateFlowTagResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFlowTagResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFlowTagResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFlowTagResponse() = default;
};
class CreateFlowTagGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  CreateFlowTagGroupRequest() {}

  explicit CreateFlowTagGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~CreateFlowTagGroupRequest() = default;
};
class CreateFlowTagGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateFlowTagGroupResponseBody() {}

  explicit CreateFlowTagGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreateFlowTagGroupResponseBody() = default;
};
class CreateFlowTagGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFlowTagGroupResponseBody> body{};

  CreateFlowTagGroupResponse() {}

  explicit CreateFlowTagGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFlowTagGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFlowTagGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFlowTagGroupResponse() = default;
};
class CreateHostGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunRegion{};
  shared_ptr<string> ecsLabelKey{};
  shared_ptr<string> ecsLabelValue{};
  shared_ptr<string> ecsType{};
  shared_ptr<string> envId{};
  shared_ptr<string> machineInfos{};
  shared_ptr<string> name{};
  shared_ptr<long> serviceConnectionId{};
  shared_ptr<string> tagIds{};
  shared_ptr<string> type{};

  CreateHostGroupRequest() {}

  explicit CreateHostGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunRegion) {
      res["aliyunRegion"] = boost::any(*aliyunRegion);
    }
    if (ecsLabelKey) {
      res["ecsLabelKey"] = boost::any(*ecsLabelKey);
    }
    if (ecsLabelValue) {
      res["ecsLabelValue"] = boost::any(*ecsLabelValue);
    }
    if (ecsType) {
      res["ecsType"] = boost::any(*ecsType);
    }
    if (envId) {
      res["envId"] = boost::any(*envId);
    }
    if (machineInfos) {
      res["machineInfos"] = boost::any(*machineInfos);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (serviceConnectionId) {
      res["serviceConnectionId"] = boost::any(*serviceConnectionId);
    }
    if (tagIds) {
      res["tagIds"] = boost::any(*tagIds);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aliyunRegion") != m.end() && !m["aliyunRegion"].empty()) {
      aliyunRegion = make_shared<string>(boost::any_cast<string>(m["aliyunRegion"]));
    }
    if (m.find("ecsLabelKey") != m.end() && !m["ecsLabelKey"].empty()) {
      ecsLabelKey = make_shared<string>(boost::any_cast<string>(m["ecsLabelKey"]));
    }
    if (m.find("ecsLabelValue") != m.end() && !m["ecsLabelValue"].empty()) {
      ecsLabelValue = make_shared<string>(boost::any_cast<string>(m["ecsLabelValue"]));
    }
    if (m.find("ecsType") != m.end() && !m["ecsType"].empty()) {
      ecsType = make_shared<string>(boost::any_cast<string>(m["ecsType"]));
    }
    if (m.find("envId") != m.end() && !m["envId"].empty()) {
      envId = make_shared<string>(boost::any_cast<string>(m["envId"]));
    }
    if (m.find("machineInfos") != m.end() && !m["machineInfos"].empty()) {
      machineInfos = make_shared<string>(boost::any_cast<string>(m["machineInfos"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("serviceConnectionId") != m.end() && !m["serviceConnectionId"].empty()) {
      serviceConnectionId = make_shared<long>(boost::any_cast<long>(m["serviceConnectionId"]));
    }
    if (m.find("tagIds") != m.end() && !m["tagIds"].empty()) {
      tagIds = make_shared<string>(boost::any_cast<string>(m["tagIds"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~CreateHostGroupRequest() = default;
};
class CreateHostGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> hostGroupId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateHostGroupResponseBody() {}

  explicit CreateHostGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (hostGroupId) {
      res["hostGroupId"] = boost::any(*hostGroupId);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("hostGroupId") != m.end() && !m["hostGroupId"].empty()) {
      hostGroupId = make_shared<long>(boost::any_cast<long>(m["hostGroupId"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreateHostGroupResponseBody() = default;
};
class CreateHostGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateHostGroupResponseBody> body{};

  CreateHostGroupResponse() {}

  explicit CreateHostGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateHostGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateHostGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateHostGroupResponse() = default;
};
class CreateMergeRequestRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> createFrom{};
  shared_ptr<string> description{};
  shared_ptr<vector<string>> reviewerIds{};
  shared_ptr<string> sourceBranch{};
  shared_ptr<long> sourceProjectId{};
  shared_ptr<string> targetBranch{};
  shared_ptr<long> targetProjectId{};
  shared_ptr<string> title{};
  shared_ptr<string> workItemIds{};
  shared_ptr<string> organizationId{};

  CreateMergeRequestRequest() {}

  explicit CreateMergeRequestRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (createFrom) {
      res["createFrom"] = boost::any(*createFrom);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (reviewerIds) {
      res["reviewerIds"] = boost::any(*reviewerIds);
    }
    if (sourceBranch) {
      res["sourceBranch"] = boost::any(*sourceBranch);
    }
    if (sourceProjectId) {
      res["sourceProjectId"] = boost::any(*sourceProjectId);
    }
    if (targetBranch) {
      res["targetBranch"] = boost::any(*targetBranch);
    }
    if (targetProjectId) {
      res["targetProjectId"] = boost::any(*targetProjectId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (workItemIds) {
      res["workItemIds"] = boost::any(*workItemIds);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("createFrom") != m.end() && !m["createFrom"].empty()) {
      createFrom = make_shared<string>(boost::any_cast<string>(m["createFrom"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("reviewerIds") != m.end() && !m["reviewerIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["reviewerIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["reviewerIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      reviewerIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("sourceBranch") != m.end() && !m["sourceBranch"].empty()) {
      sourceBranch = make_shared<string>(boost::any_cast<string>(m["sourceBranch"]));
    }
    if (m.find("sourceProjectId") != m.end() && !m["sourceProjectId"].empty()) {
      sourceProjectId = make_shared<long>(boost::any_cast<long>(m["sourceProjectId"]));
    }
    if (m.find("targetBranch") != m.end() && !m["targetBranch"].empty()) {
      targetBranch = make_shared<string>(boost::any_cast<string>(m["targetBranch"]));
    }
    if (m.find("targetProjectId") != m.end() && !m["targetProjectId"].empty()) {
      targetProjectId = make_shared<long>(boost::any_cast<long>(m["targetProjectId"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("workItemIds") != m.end() && !m["workItemIds"].empty()) {
      workItemIds = make_shared<string>(boost::any_cast<string>(m["workItemIds"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~CreateMergeRequestRequest() = default;
};
class CreateMergeRequestResponseBodyResultAuthor : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};

  CreateMergeRequestResponseBodyResultAuthor() {}

  explicit CreateMergeRequestResponseBodyResultAuthor(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~CreateMergeRequestResponseBodyResultAuthor() = default;
};
class CreateMergeRequestResponseBodyResultReviewers : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<bool> hasReviewed{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> reviewOpinionStatus{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};

  CreateMergeRequestResponseBodyResultReviewers() {}

  explicit CreateMergeRequestResponseBodyResultReviewers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (hasReviewed) {
      res["hasReviewed"] = boost::any(*hasReviewed);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (reviewOpinionStatus) {
      res["reviewOpinionStatus"] = boost::any(*reviewOpinionStatus);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("hasReviewed") != m.end() && !m["hasReviewed"].empty()) {
      hasReviewed = make_shared<bool>(boost::any_cast<bool>(m["hasReviewed"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("reviewOpinionStatus") != m.end() && !m["reviewOpinionStatus"].empty()) {
      reviewOpinionStatus = make_shared<string>(boost::any_cast<string>(m["reviewOpinionStatus"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~CreateMergeRequestResponseBodyResultReviewers() = default;
};
class CreateMergeRequestResponseBodyResultSubscribers : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};

  CreateMergeRequestResponseBodyResultSubscribers() {}

  explicit CreateMergeRequestResponseBodyResultSubscribers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~CreateMergeRequestResponseBodyResultSubscribers() = default;
};
class CreateMergeRequestResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> ahead{};
  shared_ptr<bool> allRequirementsPass{};
  shared_ptr<CreateMergeRequestResponseBodyResultAuthor> author{};
  shared_ptr<long> behind{};
  shared_ptr<string> createFrom{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> detailUrl{};
  shared_ptr<long> localId{};
  shared_ptr<string> mrBizId{};
  shared_ptr<string> mrType{};
  shared_ptr<long> projectId{};
  shared_ptr<vector<CreateMergeRequestResponseBodyResultReviewers>> reviewers{};
  shared_ptr<string> sourceBranch{};
  shared_ptr<long> sourceProjectId{};
  shared_ptr<string> status{};
  shared_ptr<vector<CreateMergeRequestResponseBodyResultSubscribers>> subscribers{};
  shared_ptr<bool> supportMergeFastForwardOnly{};
  shared_ptr<string> targetBranch{};
  shared_ptr<long> targetProjectId{};
  shared_ptr<string> title{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> webUrl{};

  CreateMergeRequestResponseBodyResult() {}

  explicit CreateMergeRequestResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ahead) {
      res["ahead"] = boost::any(*ahead);
    }
    if (allRequirementsPass) {
      res["allRequirementsPass"] = boost::any(*allRequirementsPass);
    }
    if (author) {
      res["author"] = author ? boost::any(author->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (behind) {
      res["behind"] = boost::any(*behind);
    }
    if (createFrom) {
      res["createFrom"] = boost::any(*createFrom);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (detailUrl) {
      res["detailUrl"] = boost::any(*detailUrl);
    }
    if (localId) {
      res["localId"] = boost::any(*localId);
    }
    if (mrBizId) {
      res["mrBizId"] = boost::any(*mrBizId);
    }
    if (mrType) {
      res["mrType"] = boost::any(*mrType);
    }
    if (projectId) {
      res["projectId"] = boost::any(*projectId);
    }
    if (reviewers) {
      vector<boost::any> temp1;
      for(auto item1:*reviewers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["reviewers"] = boost::any(temp1);
    }
    if (sourceBranch) {
      res["sourceBranch"] = boost::any(*sourceBranch);
    }
    if (sourceProjectId) {
      res["sourceProjectId"] = boost::any(*sourceProjectId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (subscribers) {
      vector<boost::any> temp1;
      for(auto item1:*subscribers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["subscribers"] = boost::any(temp1);
    }
    if (supportMergeFastForwardOnly) {
      res["supportMergeFastForwardOnly"] = boost::any(*supportMergeFastForwardOnly);
    }
    if (targetBranch) {
      res["targetBranch"] = boost::any(*targetBranch);
    }
    if (targetProjectId) {
      res["targetProjectId"] = boost::any(*targetProjectId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    if (webUrl) {
      res["webUrl"] = boost::any(*webUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ahead") != m.end() && !m["ahead"].empty()) {
      ahead = make_shared<long>(boost::any_cast<long>(m["ahead"]));
    }
    if (m.find("allRequirementsPass") != m.end() && !m["allRequirementsPass"].empty()) {
      allRequirementsPass = make_shared<bool>(boost::any_cast<bool>(m["allRequirementsPass"]));
    }
    if (m.find("author") != m.end() && !m["author"].empty()) {
      if (typeid(map<string, boost::any>) == m["author"].type()) {
        CreateMergeRequestResponseBodyResultAuthor model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["author"]));
        author = make_shared<CreateMergeRequestResponseBodyResultAuthor>(model1);
      }
    }
    if (m.find("behind") != m.end() && !m["behind"].empty()) {
      behind = make_shared<long>(boost::any_cast<long>(m["behind"]));
    }
    if (m.find("createFrom") != m.end() && !m["createFrom"].empty()) {
      createFrom = make_shared<string>(boost::any_cast<string>(m["createFrom"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("detailUrl") != m.end() && !m["detailUrl"].empty()) {
      detailUrl = make_shared<string>(boost::any_cast<string>(m["detailUrl"]));
    }
    if (m.find("localId") != m.end() && !m["localId"].empty()) {
      localId = make_shared<long>(boost::any_cast<long>(m["localId"]));
    }
    if (m.find("mrBizId") != m.end() && !m["mrBizId"].empty()) {
      mrBizId = make_shared<string>(boost::any_cast<string>(m["mrBizId"]));
    }
    if (m.find("mrType") != m.end() && !m["mrType"].empty()) {
      mrType = make_shared<string>(boost::any_cast<string>(m["mrType"]));
    }
    if (m.find("projectId") != m.end() && !m["projectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["projectId"]));
    }
    if (m.find("reviewers") != m.end() && !m["reviewers"].empty()) {
      if (typeid(vector<boost::any>) == m["reviewers"].type()) {
        vector<CreateMergeRequestResponseBodyResultReviewers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["reviewers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMergeRequestResponseBodyResultReviewers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reviewers = make_shared<vector<CreateMergeRequestResponseBodyResultReviewers>>(expect1);
      }
    }
    if (m.find("sourceBranch") != m.end() && !m["sourceBranch"].empty()) {
      sourceBranch = make_shared<string>(boost::any_cast<string>(m["sourceBranch"]));
    }
    if (m.find("sourceProjectId") != m.end() && !m["sourceProjectId"].empty()) {
      sourceProjectId = make_shared<long>(boost::any_cast<long>(m["sourceProjectId"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("subscribers") != m.end() && !m["subscribers"].empty()) {
      if (typeid(vector<boost::any>) == m["subscribers"].type()) {
        vector<CreateMergeRequestResponseBodyResultSubscribers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["subscribers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMergeRequestResponseBodyResultSubscribers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subscribers = make_shared<vector<CreateMergeRequestResponseBodyResultSubscribers>>(expect1);
      }
    }
    if (m.find("supportMergeFastForwardOnly") != m.end() && !m["supportMergeFastForwardOnly"].empty()) {
      supportMergeFastForwardOnly = make_shared<bool>(boost::any_cast<bool>(m["supportMergeFastForwardOnly"]));
    }
    if (m.find("targetBranch") != m.end() && !m["targetBranch"].empty()) {
      targetBranch = make_shared<string>(boost::any_cast<string>(m["targetBranch"]));
    }
    if (m.find("targetProjectId") != m.end() && !m["targetProjectId"].empty()) {
      targetProjectId = make_shared<long>(boost::any_cast<long>(m["targetProjectId"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["updateTime"]));
    }
    if (m.find("webUrl") != m.end() && !m["webUrl"].empty()) {
      webUrl = make_shared<string>(boost::any_cast<string>(m["webUrl"]));
    }
  }


  virtual ~CreateMergeRequestResponseBodyResult() = default;
};
class CreateMergeRequestResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateMergeRequestResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateMergeRequestResponseBody() {}

  explicit CreateMergeRequestResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        CreateMergeRequestResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<CreateMergeRequestResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreateMergeRequestResponseBody() = default;
};
class CreateMergeRequestResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMergeRequestResponseBody> body{};

  CreateMergeRequestResponse() {}

  explicit CreateMergeRequestResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMergeRequestResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMergeRequestResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMergeRequestResponse() = default;
};
class CreateOAuthTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientId{};
  shared_ptr<string> clientSecret{};
  shared_ptr<string> code{};
  shared_ptr<string> grantType{};
  shared_ptr<string> login{};
  shared_ptr<string> scope{};

  CreateOAuthTokenRequest() {}

  explicit CreateOAuthTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientId) {
      res["clientId"] = boost::any(*clientId);
    }
    if (clientSecret) {
      res["clientSecret"] = boost::any(*clientSecret);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (grantType) {
      res["grantType"] = boost::any(*grantType);
    }
    if (login) {
      res["login"] = boost::any(*login);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientId") != m.end() && !m["clientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["clientId"]));
    }
    if (m.find("clientSecret") != m.end() && !m["clientSecret"].empty()) {
      clientSecret = make_shared<string>(boost::any_cast<string>(m["clientSecret"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("grantType") != m.end() && !m["grantType"].empty()) {
      grantType = make_shared<string>(boost::any_cast<string>(m["grantType"]));
    }
    if (m.find("login") != m.end() && !m["login"].empty()) {
      login = make_shared<string>(boost::any_cast<string>(m["login"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["scope"]));
    }
  }


  virtual ~CreateOAuthTokenRequest() = default;
};
class CreateOAuthTokenResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> id{};
  shared_ptr<string> scope{};
  shared_ptr<string> tokenType{};

  CreateOAuthTokenResponseBodyResult() {}

  explicit CreateOAuthTokenResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (tokenType) {
      res["tokenType"] = boost::any(*tokenType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["scope"]));
    }
    if (m.find("tokenType") != m.end() && !m["tokenType"].empty()) {
      tokenType = make_shared<string>(boost::any_cast<string>(m["tokenType"]));
    }
  }


  virtual ~CreateOAuthTokenResponseBodyResult() = default;
};
class CreateOAuthTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateOAuthTokenResponseBodyResult> result{};
  shared_ptr<string> success{};

  CreateOAuthTokenResponseBody() {}

  explicit CreateOAuthTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        CreateOAuthTokenResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<CreateOAuthTokenResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["success"]));
    }
  }


  virtual ~CreateOAuthTokenResponseBody() = default;
};
class CreateOAuthTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOAuthTokenResponseBody> body{};

  CreateOAuthTokenResponse() {}

  explicit CreateOAuthTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOAuthTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOAuthTokenResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOAuthTokenResponse() = default;
};
class CreatePipelineRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> name{};

  CreatePipelineRequest() {}

  explicit CreatePipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~CreatePipelineRequest() = default;
};
class CreatePipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> pipelinId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreatePipelineResponseBody() {}

  explicit CreatePipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (pipelinId) {
      res["pipelinId"] = boost::any(*pipelinId);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("pipelinId") != m.end() && !m["pipelinId"].empty()) {
      pipelinId = make_shared<long>(boost::any_cast<long>(m["pipelinId"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreatePipelineResponseBody() = default;
};
class CreatePipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePipelineResponseBody> body{};

  CreatePipelineResponse() {}

  explicit CreatePipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePipelineResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePipelineResponse() = default;
};
class CreatePipelineGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  CreatePipelineGroupRequest() {}

  explicit CreatePipelineGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~CreatePipelineGroupRequest() = default;
};
class CreatePipelineGroupResponseBodyPipelineGroup : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  CreatePipelineGroupResponseBodyPipelineGroup() {}

  explicit CreatePipelineGroupResponseBodyPipelineGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~CreatePipelineGroupResponseBodyPipelineGroup() = default;
};
class CreatePipelineGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<CreatePipelineGroupResponseBodyPipelineGroup> pipelineGroup{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreatePipelineGroupResponseBody() {}

  explicit CreatePipelineGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (pipelineGroup) {
      res["pipelineGroup"] = pipelineGroup ? boost::any(pipelineGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("pipelineGroup") != m.end() && !m["pipelineGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["pipelineGroup"].type()) {
        CreatePipelineGroupResponseBodyPipelineGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["pipelineGroup"]));
        pipelineGroup = make_shared<CreatePipelineGroupResponseBodyPipelineGroup>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreatePipelineGroupResponseBody() = default;
};
class CreatePipelineGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePipelineGroupResponseBody> body{};

  CreatePipelineGroupResponse() {}

  explicit CreatePipelineGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePipelineGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePipelineGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePipelineGroupResponse() = default;
};
class CreateProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> customCode{};
  shared_ptr<string> name{};
  shared_ptr<string> scope{};
  shared_ptr<string> templateIdentifier{};

  CreateProjectRequest() {}

  explicit CreateProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customCode) {
      res["customCode"] = boost::any(*customCode);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (templateIdentifier) {
      res["templateIdentifier"] = boost::any(*templateIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("customCode") != m.end() && !m["customCode"].empty()) {
      customCode = make_shared<string>(boost::any_cast<string>(m["customCode"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["scope"]));
    }
    if (m.find("templateIdentifier") != m.end() && !m["templateIdentifier"].empty()) {
      templateIdentifier = make_shared<string>(boost::any_cast<string>(m["templateIdentifier"]));
    }
  }


  virtual ~CreateProjectRequest() = default;
};
class CreateProjectResponseBodyProject : public Darabonba::Model {
public:
  shared_ptr<string> categoryIdentifier{};
  shared_ptr<string> creator{};
  shared_ptr<string> customCode{};
  shared_ptr<string> description{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> icon{};
  shared_ptr<string> identifier{};
  shared_ptr<string> logicalStatus{};
  shared_ptr<string> modifier{};
  shared_ptr<string> name{};
  shared_ptr<string> organizationIdentifier{};
  shared_ptr<string> scope{};
  shared_ptr<string> statusIdentifier{};
  shared_ptr<string> statusStageIdentifier{};
  shared_ptr<string> typeIdentifier{};

  CreateProjectResponseBodyProject() {}

  explicit CreateProjectResponseBodyProject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryIdentifier) {
      res["categoryIdentifier"] = boost::any(*categoryIdentifier);
    }
    if (creator) {
      res["creator"] = boost::any(*creator);
    }
    if (customCode) {
      res["customCode"] = boost::any(*customCode);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (icon) {
      res["icon"] = boost::any(*icon);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (logicalStatus) {
      res["logicalStatus"] = boost::any(*logicalStatus);
    }
    if (modifier) {
      res["modifier"] = boost::any(*modifier);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (organizationIdentifier) {
      res["organizationIdentifier"] = boost::any(*organizationIdentifier);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (statusIdentifier) {
      res["statusIdentifier"] = boost::any(*statusIdentifier);
    }
    if (statusStageIdentifier) {
      res["statusStageIdentifier"] = boost::any(*statusStageIdentifier);
    }
    if (typeIdentifier) {
      res["typeIdentifier"] = boost::any(*typeIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("categoryIdentifier") != m.end() && !m["categoryIdentifier"].empty()) {
      categoryIdentifier = make_shared<string>(boost::any_cast<string>(m["categoryIdentifier"]));
    }
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["creator"]));
    }
    if (m.find("customCode") != m.end() && !m["customCode"].empty()) {
      customCode = make_shared<string>(boost::any_cast<string>(m["customCode"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("icon") != m.end() && !m["icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["icon"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("logicalStatus") != m.end() && !m["logicalStatus"].empty()) {
      logicalStatus = make_shared<string>(boost::any_cast<string>(m["logicalStatus"]));
    }
    if (m.find("modifier") != m.end() && !m["modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["modifier"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("organizationIdentifier") != m.end() && !m["organizationIdentifier"].empty()) {
      organizationIdentifier = make_shared<string>(boost::any_cast<string>(m["organizationIdentifier"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["scope"]));
    }
    if (m.find("statusIdentifier") != m.end() && !m["statusIdentifier"].empty()) {
      statusIdentifier = make_shared<string>(boost::any_cast<string>(m["statusIdentifier"]));
    }
    if (m.find("statusStageIdentifier") != m.end() && !m["statusStageIdentifier"].empty()) {
      statusStageIdentifier = make_shared<string>(boost::any_cast<string>(m["statusStageIdentifier"]));
    }
    if (m.find("typeIdentifier") != m.end() && !m["typeIdentifier"].empty()) {
      typeIdentifier = make_shared<string>(boost::any_cast<string>(m["typeIdentifier"]));
    }
  }


  virtual ~CreateProjectResponseBodyProject() = default;
};
class CreateProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<CreateProjectResponseBodyProject> project{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateProjectResponseBody() {}

  explicit CreateProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (project) {
      res["project"] = project ? boost::any(project->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("project") != m.end() && !m["project"].empty()) {
      if (typeid(map<string, boost::any>) == m["project"].type()) {
        CreateProjectResponseBodyProject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["project"]));
        project = make_shared<CreateProjectResponseBodyProject>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreateProjectResponseBody() = default;
};
class CreateProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateProjectResponseBody> body{};

  CreateProjectResponse() {}

  explicit CreateProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProjectResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProjectResponse() = default;
};
class CreateProjectLabelRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> color{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> repositoryIdentity{};

  CreateProjectLabelRequest() {}

  explicit CreateProjectLabelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (color) {
      res["color"] = boost::any(*color);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (repositoryIdentity) {
      res["repositoryIdentity"] = boost::any(*repositoryIdentity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("color") != m.end() && !m["color"].empty()) {
      color = make_shared<string>(boost::any_cast<string>(m["color"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("repositoryIdentity") != m.end() && !m["repositoryIdentity"].empty()) {
      repositoryIdentity = make_shared<string>(boost::any_cast<string>(m["repositoryIdentity"]));
    }
  }


  virtual ~CreateProjectLabelRequest() = default;
};
class CreateProjectLabelResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> color{};
  shared_ptr<string> description{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  CreateProjectLabelResponseBodyResult() {}

  explicit CreateProjectLabelResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (color) {
      res["color"] = boost::any(*color);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("color") != m.end() && !m["color"].empty()) {
      color = make_shared<string>(boost::any_cast<string>(m["color"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~CreateProjectLabelResponseBodyResult() = default;
};
class CreateProjectLabelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateProjectLabelResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateProjectLabelResponseBody() {}

  explicit CreateProjectLabelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        CreateProjectLabelResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<CreateProjectLabelResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreateProjectLabelResponseBody() = default;
};
class CreateProjectLabelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateProjectLabelResponseBody> body{};

  CreateProjectLabelResponse() {}

  explicit CreateProjectLabelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProjectLabelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProjectLabelResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProjectLabelResponse() = default;
};
class CreateProtectdBranchRequestMergeRequestSetting : public Darabonba::Model {
public:
  shared_ptr<vector<long>> allowMergeRequestRoles{};
  shared_ptr<vector<string>> defaultAssignees{};
  shared_ptr<bool> isAllowSelfApproval{};
  shared_ptr<bool> isRequireDiscussionProcessed{};
  shared_ptr<bool> isRequired{};
  shared_ptr<bool> isResetApprovalWhenNewPush{};
  shared_ptr<long> minimumApproval{};
  shared_ptr<string> mrMode{};
  shared_ptr<string> whiteList{};

  CreateProtectdBranchRequestMergeRequestSetting() {}

  explicit CreateProtectdBranchRequestMergeRequestSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowMergeRequestRoles) {
      res["allowMergeRequestRoles"] = boost::any(*allowMergeRequestRoles);
    }
    if (defaultAssignees) {
      res["defaultAssignees"] = boost::any(*defaultAssignees);
    }
    if (isAllowSelfApproval) {
      res["isAllowSelfApproval"] = boost::any(*isAllowSelfApproval);
    }
    if (isRequireDiscussionProcessed) {
      res["isRequireDiscussionProcessed"] = boost::any(*isRequireDiscussionProcessed);
    }
    if (isRequired) {
      res["isRequired"] = boost::any(*isRequired);
    }
    if (isResetApprovalWhenNewPush) {
      res["isResetApprovalWhenNewPush"] = boost::any(*isResetApprovalWhenNewPush);
    }
    if (minimumApproval) {
      res["minimumApproval"] = boost::any(*minimumApproval);
    }
    if (mrMode) {
      res["mrMode"] = boost::any(*mrMode);
    }
    if (whiteList) {
      res["whiteList"] = boost::any(*whiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("allowMergeRequestRoles") != m.end() && !m["allowMergeRequestRoles"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["allowMergeRequestRoles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["allowMergeRequestRoles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      allowMergeRequestRoles = make_shared<vector<long>>(toVec1);
    }
    if (m.find("defaultAssignees") != m.end() && !m["defaultAssignees"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["defaultAssignees"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["defaultAssignees"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      defaultAssignees = make_shared<vector<string>>(toVec1);
    }
    if (m.find("isAllowSelfApproval") != m.end() && !m["isAllowSelfApproval"].empty()) {
      isAllowSelfApproval = make_shared<bool>(boost::any_cast<bool>(m["isAllowSelfApproval"]));
    }
    if (m.find("isRequireDiscussionProcessed") != m.end() && !m["isRequireDiscussionProcessed"].empty()) {
      isRequireDiscussionProcessed = make_shared<bool>(boost::any_cast<bool>(m["isRequireDiscussionProcessed"]));
    }
    if (m.find("isRequired") != m.end() && !m["isRequired"].empty()) {
      isRequired = make_shared<bool>(boost::any_cast<bool>(m["isRequired"]));
    }
    if (m.find("isResetApprovalWhenNewPush") != m.end() && !m["isResetApprovalWhenNewPush"].empty()) {
      isResetApprovalWhenNewPush = make_shared<bool>(boost::any_cast<bool>(m["isResetApprovalWhenNewPush"]));
    }
    if (m.find("minimumApproval") != m.end() && !m["minimumApproval"].empty()) {
      minimumApproval = make_shared<long>(boost::any_cast<long>(m["minimumApproval"]));
    }
    if (m.find("mrMode") != m.end() && !m["mrMode"].empty()) {
      mrMode = make_shared<string>(boost::any_cast<string>(m["mrMode"]));
    }
    if (m.find("whiteList") != m.end() && !m["whiteList"].empty()) {
      whiteList = make_shared<string>(boost::any_cast<string>(m["whiteList"]));
    }
  }


  virtual ~CreateProtectdBranchRequestMergeRequestSetting() = default;
};
class CreateProtectdBranchRequestTestSettingDTOCheckConfigCheckItems : public Darabonba::Model {
public:
  shared_ptr<bool> isRequired{};
  shared_ptr<string> name{};

  CreateProtectdBranchRequestTestSettingDTOCheckConfigCheckItems() {}

  explicit CreateProtectdBranchRequestTestSettingDTOCheckConfigCheckItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isRequired) {
      res["isRequired"] = boost::any(*isRequired);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("isRequired") != m.end() && !m["isRequired"].empty()) {
      isRequired = make_shared<bool>(boost::any_cast<bool>(m["isRequired"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~CreateProtectdBranchRequestTestSettingDTOCheckConfigCheckItems() = default;
};
class CreateProtectdBranchRequestTestSettingDTOCheckConfig : public Darabonba::Model {
public:
  shared_ptr<vector<CreateProtectdBranchRequestTestSettingDTOCheckConfigCheckItems>> checkItems{};

  CreateProtectdBranchRequestTestSettingDTOCheckConfig() {}

  explicit CreateProtectdBranchRequestTestSettingDTOCheckConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkItems) {
      vector<boost::any> temp1;
      for(auto item1:*checkItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["checkItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("checkItems") != m.end() && !m["checkItems"].empty()) {
      if (typeid(vector<boost::any>) == m["checkItems"].type()) {
        vector<CreateProtectdBranchRequestTestSettingDTOCheckConfigCheckItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["checkItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateProtectdBranchRequestTestSettingDTOCheckConfigCheckItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        checkItems = make_shared<vector<CreateProtectdBranchRequestTestSettingDTOCheckConfigCheckItems>>(expect1);
      }
    }
  }


  virtual ~CreateProtectdBranchRequestTestSettingDTOCheckConfig() = default;
};
class CreateProtectdBranchRequestTestSettingDTOCheckTaskQualityConfig : public Darabonba::Model {
public:
  shared_ptr<string> bizNo{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> message{};
  shared_ptr<string> taskName{};

  CreateProtectdBranchRequestTestSettingDTOCheckTaskQualityConfig() {}

  explicit CreateProtectdBranchRequestTestSettingDTOCheckTaskQualityConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizNo) {
      res["bizNo"] = boost::any(*bizNo);
    }
    if (enabled) {
      res["enabled"] = boost::any(*enabled);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (taskName) {
      res["taskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bizNo") != m.end() && !m["bizNo"].empty()) {
      bizNo = make_shared<string>(boost::any_cast<string>(m["bizNo"]));
    }
    if (m.find("enabled") != m.end() && !m["enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["enabled"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("taskName") != m.end() && !m["taskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["taskName"]));
    }
  }


  virtual ~CreateProtectdBranchRequestTestSettingDTOCheckTaskQualityConfig() = default;
};
class CreateProtectdBranchRequestTestSettingDTOCodeGuidelinesDetection : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<string> message{};

  CreateProtectdBranchRequestTestSettingDTOCodeGuidelinesDetection() {}

  explicit CreateProtectdBranchRequestTestSettingDTOCodeGuidelinesDetection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["enabled"] = boost::any(*enabled);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enabled") != m.end() && !m["enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["enabled"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
  }


  virtual ~CreateProtectdBranchRequestTestSettingDTOCodeGuidelinesDetection() = default;
};
class CreateProtectdBranchRequestTestSettingDTOSensitiveInfoDetection : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<string> message{};

  CreateProtectdBranchRequestTestSettingDTOSensitiveInfoDetection() {}

  explicit CreateProtectdBranchRequestTestSettingDTOSensitiveInfoDetection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["enabled"] = boost::any(*enabled);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enabled") != m.end() && !m["enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["enabled"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
  }


  virtual ~CreateProtectdBranchRequestTestSettingDTOSensitiveInfoDetection() = default;
};
class CreateProtectdBranchRequestTestSettingDTO : public Darabonba::Model {
public:
  shared_ptr<CreateProtectdBranchRequestTestSettingDTOCheckConfig> checkConfig{};
  shared_ptr<CreateProtectdBranchRequestTestSettingDTOCheckTaskQualityConfig> checkTaskQualityConfig{};
  shared_ptr<CreateProtectdBranchRequestTestSettingDTOCodeGuidelinesDetection> codeGuidelinesDetection{};
  shared_ptr<bool> isRequired{};
  shared_ptr<CreateProtectdBranchRequestTestSettingDTOSensitiveInfoDetection> sensitiveInfoDetection{};

  CreateProtectdBranchRequestTestSettingDTO() {}

  explicit CreateProtectdBranchRequestTestSettingDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkConfig) {
      res["checkConfig"] = checkConfig ? boost::any(checkConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (checkTaskQualityConfig) {
      res["checkTaskQualityConfig"] = checkTaskQualityConfig ? boost::any(checkTaskQualityConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (codeGuidelinesDetection) {
      res["codeGuidelinesDetection"] = codeGuidelinesDetection ? boost::any(codeGuidelinesDetection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isRequired) {
      res["isRequired"] = boost::any(*isRequired);
    }
    if (sensitiveInfoDetection) {
      res["sensitiveInfoDetection"] = sensitiveInfoDetection ? boost::any(sensitiveInfoDetection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("checkConfig") != m.end() && !m["checkConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["checkConfig"].type()) {
        CreateProtectdBranchRequestTestSettingDTOCheckConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["checkConfig"]));
        checkConfig = make_shared<CreateProtectdBranchRequestTestSettingDTOCheckConfig>(model1);
      }
    }
    if (m.find("checkTaskQualityConfig") != m.end() && !m["checkTaskQualityConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["checkTaskQualityConfig"].type()) {
        CreateProtectdBranchRequestTestSettingDTOCheckTaskQualityConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["checkTaskQualityConfig"]));
        checkTaskQualityConfig = make_shared<CreateProtectdBranchRequestTestSettingDTOCheckTaskQualityConfig>(model1);
      }
    }
    if (m.find("codeGuidelinesDetection") != m.end() && !m["codeGuidelinesDetection"].empty()) {
      if (typeid(map<string, boost::any>) == m["codeGuidelinesDetection"].type()) {
        CreateProtectdBranchRequestTestSettingDTOCodeGuidelinesDetection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["codeGuidelinesDetection"]));
        codeGuidelinesDetection = make_shared<CreateProtectdBranchRequestTestSettingDTOCodeGuidelinesDetection>(model1);
      }
    }
    if (m.find("isRequired") != m.end() && !m["isRequired"].empty()) {
      isRequired = make_shared<bool>(boost::any_cast<bool>(m["isRequired"]));
    }
    if (m.find("sensitiveInfoDetection") != m.end() && !m["sensitiveInfoDetection"].empty()) {
      if (typeid(map<string, boost::any>) == m["sensitiveInfoDetection"].type()) {
        CreateProtectdBranchRequestTestSettingDTOSensitiveInfoDetection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["sensitiveInfoDetection"]));
        sensitiveInfoDetection = make_shared<CreateProtectdBranchRequestTestSettingDTOSensitiveInfoDetection>(model1);
      }
    }
  }


  virtual ~CreateProtectdBranchRequestTestSettingDTO() = default;
};
class CreateProtectdBranchRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<vector<long>> allowMergeRoles{};
  shared_ptr<vector<string>> allowMergeUserIds{};
  shared_ptr<vector<long>> allowPushRoles{};
  shared_ptr<vector<string>> allowPushUserIds{};
  shared_ptr<string> branch{};
  shared_ptr<long> id{};
  shared_ptr<CreateProtectdBranchRequestMergeRequestSetting> mergeRequestSetting{};
  shared_ptr<CreateProtectdBranchRequestTestSettingDTO> testSettingDTO{};
  shared_ptr<string> organizationId{};

  CreateProtectdBranchRequest() {}

  explicit CreateProtectdBranchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (allowMergeRoles) {
      res["allowMergeRoles"] = boost::any(*allowMergeRoles);
    }
    if (allowMergeUserIds) {
      res["allowMergeUserIds"] = boost::any(*allowMergeUserIds);
    }
    if (allowPushRoles) {
      res["allowPushRoles"] = boost::any(*allowPushRoles);
    }
    if (allowPushUserIds) {
      res["allowPushUserIds"] = boost::any(*allowPushUserIds);
    }
    if (branch) {
      res["branch"] = boost::any(*branch);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (mergeRequestSetting) {
      res["mergeRequestSetting"] = mergeRequestSetting ? boost::any(mergeRequestSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (testSettingDTO) {
      res["testSettingDTO"] = testSettingDTO ? boost::any(testSettingDTO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("allowMergeRoles") != m.end() && !m["allowMergeRoles"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["allowMergeRoles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["allowMergeRoles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      allowMergeRoles = make_shared<vector<long>>(toVec1);
    }
    if (m.find("allowMergeUserIds") != m.end() && !m["allowMergeUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["allowMergeUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["allowMergeUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      allowMergeUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("allowPushRoles") != m.end() && !m["allowPushRoles"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["allowPushRoles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["allowPushRoles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      allowPushRoles = make_shared<vector<long>>(toVec1);
    }
    if (m.find("allowPushUserIds") != m.end() && !m["allowPushUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["allowPushUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["allowPushUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      allowPushUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("branch") != m.end() && !m["branch"].empty()) {
      branch = make_shared<string>(boost::any_cast<string>(m["branch"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("mergeRequestSetting") != m.end() && !m["mergeRequestSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["mergeRequestSetting"].type()) {
        CreateProtectdBranchRequestMergeRequestSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["mergeRequestSetting"]));
        mergeRequestSetting = make_shared<CreateProtectdBranchRequestMergeRequestSetting>(model1);
      }
    }
    if (m.find("testSettingDTO") != m.end() && !m["testSettingDTO"].empty()) {
      if (typeid(map<string, boost::any>) == m["testSettingDTO"].type()) {
        CreateProtectdBranchRequestTestSettingDTO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["testSettingDTO"]));
        testSettingDTO = make_shared<CreateProtectdBranchRequestTestSettingDTO>(model1);
      }
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~CreateProtectdBranchRequest() = default;
};
class CreateProtectdBranchResponseBodyResultMergeRequestSetting : public Darabonba::Model {
public:
  shared_ptr<vector<long>> allowMergeRequestRoles{};
  shared_ptr<vector<string>> defaultAssignees{};
  shared_ptr<bool> isAllowSelfApproval{};
  shared_ptr<bool> isRequireDiscussionProcessed{};
  shared_ptr<bool> isRequired{};
  shared_ptr<bool> isResetApprovalWhenNewPush{};
  shared_ptr<long> minimumApproval{};
  shared_ptr<string> mrMode{};
  shared_ptr<string> whiteList{};

  CreateProtectdBranchResponseBodyResultMergeRequestSetting() {}

  explicit CreateProtectdBranchResponseBodyResultMergeRequestSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowMergeRequestRoles) {
      res["allowMergeRequestRoles"] = boost::any(*allowMergeRequestRoles);
    }
    if (defaultAssignees) {
      res["defaultAssignees"] = boost::any(*defaultAssignees);
    }
    if (isAllowSelfApproval) {
      res["isAllowSelfApproval"] = boost::any(*isAllowSelfApproval);
    }
    if (isRequireDiscussionProcessed) {
      res["isRequireDiscussionProcessed"] = boost::any(*isRequireDiscussionProcessed);
    }
    if (isRequired) {
      res["isRequired"] = boost::any(*isRequired);
    }
    if (isResetApprovalWhenNewPush) {
      res["isResetApprovalWhenNewPush"] = boost::any(*isResetApprovalWhenNewPush);
    }
    if (minimumApproval) {
      res["minimumApproval"] = boost::any(*minimumApproval);
    }
    if (mrMode) {
      res["mrMode"] = boost::any(*mrMode);
    }
    if (whiteList) {
      res["whiteList"] = boost::any(*whiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("allowMergeRequestRoles") != m.end() && !m["allowMergeRequestRoles"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["allowMergeRequestRoles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["allowMergeRequestRoles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      allowMergeRequestRoles = make_shared<vector<long>>(toVec1);
    }
    if (m.find("defaultAssignees") != m.end() && !m["defaultAssignees"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["defaultAssignees"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["defaultAssignees"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      defaultAssignees = make_shared<vector<string>>(toVec1);
    }
    if (m.find("isAllowSelfApproval") != m.end() && !m["isAllowSelfApproval"].empty()) {
      isAllowSelfApproval = make_shared<bool>(boost::any_cast<bool>(m["isAllowSelfApproval"]));
    }
    if (m.find("isRequireDiscussionProcessed") != m.end() && !m["isRequireDiscussionProcessed"].empty()) {
      isRequireDiscussionProcessed = make_shared<bool>(boost::any_cast<bool>(m["isRequireDiscussionProcessed"]));
    }
    if (m.find("isRequired") != m.end() && !m["isRequired"].empty()) {
      isRequired = make_shared<bool>(boost::any_cast<bool>(m["isRequired"]));
    }
    if (m.find("isResetApprovalWhenNewPush") != m.end() && !m["isResetApprovalWhenNewPush"].empty()) {
      isResetApprovalWhenNewPush = make_shared<bool>(boost::any_cast<bool>(m["isResetApprovalWhenNewPush"]));
    }
    if (m.find("minimumApproval") != m.end() && !m["minimumApproval"].empty()) {
      minimumApproval = make_shared<long>(boost::any_cast<long>(m["minimumApproval"]));
    }
    if (m.find("mrMode") != m.end() && !m["mrMode"].empty()) {
      mrMode = make_shared<string>(boost::any_cast<string>(m["mrMode"]));
    }
    if (m.find("whiteList") != m.end() && !m["whiteList"].empty()) {
      whiteList = make_shared<string>(boost::any_cast<string>(m["whiteList"]));
    }
  }


  virtual ~CreateProtectdBranchResponseBodyResultMergeRequestSetting() = default;
};
class CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfigCheckItems : public Darabonba::Model {
public:
  shared_ptr<bool> isRequired{};
  shared_ptr<string> name{};

  CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfigCheckItems() {}

  explicit CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfigCheckItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isRequired) {
      res["isRequired"] = boost::any(*isRequired);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("isRequired") != m.end() && !m["isRequired"].empty()) {
      isRequired = make_shared<bool>(boost::any_cast<bool>(m["isRequired"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfigCheckItems() = default;
};
class CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfig : public Darabonba::Model {
public:
  shared_ptr<vector<CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfigCheckItems>> checkItems{};

  CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfig() {}

  explicit CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkItems) {
      vector<boost::any> temp1;
      for(auto item1:*checkItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["checkItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("checkItems") != m.end() && !m["checkItems"].empty()) {
      if (typeid(vector<boost::any>) == m["checkItems"].type()) {
        vector<CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfigCheckItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["checkItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfigCheckItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        checkItems = make_shared<vector<CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfigCheckItems>>(expect1);
      }
    }
  }


  virtual ~CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfig() = default;
};
class CreateProtectdBranchResponseBodyResultTestSettingDTOCheckTaskQualityConfig : public Darabonba::Model {
public:
  shared_ptr<string> bizNo{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> message{};
  shared_ptr<string> taskName{};

  CreateProtectdBranchResponseBodyResultTestSettingDTOCheckTaskQualityConfig() {}

  explicit CreateProtectdBranchResponseBodyResultTestSettingDTOCheckTaskQualityConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizNo) {
      res["bizNo"] = boost::any(*bizNo);
    }
    if (enabled) {
      res["enabled"] = boost::any(*enabled);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (taskName) {
      res["taskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bizNo") != m.end() && !m["bizNo"].empty()) {
      bizNo = make_shared<string>(boost::any_cast<string>(m["bizNo"]));
    }
    if (m.find("enabled") != m.end() && !m["enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["enabled"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("taskName") != m.end() && !m["taskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["taskName"]));
    }
  }


  virtual ~CreateProtectdBranchResponseBodyResultTestSettingDTOCheckTaskQualityConfig() = default;
};
class CreateProtectdBranchResponseBodyResultTestSettingDTOCodeGuidelinesDetection : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<string> message{};

  CreateProtectdBranchResponseBodyResultTestSettingDTOCodeGuidelinesDetection() {}

  explicit CreateProtectdBranchResponseBodyResultTestSettingDTOCodeGuidelinesDetection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["enabled"] = boost::any(*enabled);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enabled") != m.end() && !m["enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["enabled"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
  }


  virtual ~CreateProtectdBranchResponseBodyResultTestSettingDTOCodeGuidelinesDetection() = default;
};
class CreateProtectdBranchResponseBodyResultTestSettingDTOSensitiveInfoDetection : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<string> message{};

  CreateProtectdBranchResponseBodyResultTestSettingDTOSensitiveInfoDetection() {}

  explicit CreateProtectdBranchResponseBodyResultTestSettingDTOSensitiveInfoDetection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["enabled"] = boost::any(*enabled);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enabled") != m.end() && !m["enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["enabled"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
  }


  virtual ~CreateProtectdBranchResponseBodyResultTestSettingDTOSensitiveInfoDetection() = default;
};
class CreateProtectdBranchResponseBodyResultTestSettingDTO : public Darabonba::Model {
public:
  shared_ptr<CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfig> checkConfig{};
  shared_ptr<CreateProtectdBranchResponseBodyResultTestSettingDTOCheckTaskQualityConfig> checkTaskQualityConfig{};
  shared_ptr<CreateProtectdBranchResponseBodyResultTestSettingDTOCodeGuidelinesDetection> codeGuidelinesDetection{};
  shared_ptr<bool> isRequired{};
  shared_ptr<CreateProtectdBranchResponseBodyResultTestSettingDTOSensitiveInfoDetection> sensitiveInfoDetection{};

  CreateProtectdBranchResponseBodyResultTestSettingDTO() {}

  explicit CreateProtectdBranchResponseBodyResultTestSettingDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkConfig) {
      res["checkConfig"] = checkConfig ? boost::any(checkConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (checkTaskQualityConfig) {
      res["checkTaskQualityConfig"] = checkTaskQualityConfig ? boost::any(checkTaskQualityConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (codeGuidelinesDetection) {
      res["codeGuidelinesDetection"] = codeGuidelinesDetection ? boost::any(codeGuidelinesDetection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isRequired) {
      res["isRequired"] = boost::any(*isRequired);
    }
    if (sensitiveInfoDetection) {
      res["sensitiveInfoDetection"] = sensitiveInfoDetection ? boost::any(sensitiveInfoDetection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("checkConfig") != m.end() && !m["checkConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["checkConfig"].type()) {
        CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["checkConfig"]));
        checkConfig = make_shared<CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfig>(model1);
      }
    }
    if (m.find("checkTaskQualityConfig") != m.end() && !m["checkTaskQualityConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["checkTaskQualityConfig"].type()) {
        CreateProtectdBranchResponseBodyResultTestSettingDTOCheckTaskQualityConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["checkTaskQualityConfig"]));
        checkTaskQualityConfig = make_shared<CreateProtectdBranchResponseBodyResultTestSettingDTOCheckTaskQualityConfig>(model1);
      }
    }
    if (m.find("codeGuidelinesDetection") != m.end() && !m["codeGuidelinesDetection"].empty()) {
      if (typeid(map<string, boost::any>) == m["codeGuidelinesDetection"].type()) {
        CreateProtectdBranchResponseBodyResultTestSettingDTOCodeGuidelinesDetection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["codeGuidelinesDetection"]));
        codeGuidelinesDetection = make_shared<CreateProtectdBranchResponseBodyResultTestSettingDTOCodeGuidelinesDetection>(model1);
      }
    }
    if (m.find("isRequired") != m.end() && !m["isRequired"].empty()) {
      isRequired = make_shared<bool>(boost::any_cast<bool>(m["isRequired"]));
    }
    if (m.find("sensitiveInfoDetection") != m.end() && !m["sensitiveInfoDetection"].empty()) {
      if (typeid(map<string, boost::any>) == m["sensitiveInfoDetection"].type()) {
        CreateProtectdBranchResponseBodyResultTestSettingDTOSensitiveInfoDetection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["sensitiveInfoDetection"]));
        sensitiveInfoDetection = make_shared<CreateProtectdBranchResponseBodyResultTestSettingDTOSensitiveInfoDetection>(model1);
      }
    }
  }


  virtual ~CreateProtectdBranchResponseBodyResultTestSettingDTO() = default;
};
class CreateProtectdBranchResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<long>> allowMergeRoles{};
  shared_ptr<vector<long>> allowMergeUserIds{};
  shared_ptr<vector<long>> allowPushRoles{};
  shared_ptr<vector<long>> allowPushUserIds{};
  shared_ptr<string> branch{};
  shared_ptr<long> id{};
  shared_ptr<CreateProtectdBranchResponseBodyResultMergeRequestSetting> mergeRequestSetting{};
  shared_ptr<CreateProtectdBranchResponseBodyResultTestSettingDTO> testSettingDTO{};

  CreateProtectdBranchResponseBodyResult() {}

  explicit CreateProtectdBranchResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowMergeRoles) {
      res["allowMergeRoles"] = boost::any(*allowMergeRoles);
    }
    if (allowMergeUserIds) {
      res["allowMergeUserIds"] = boost::any(*allowMergeUserIds);
    }
    if (allowPushRoles) {
      res["allowPushRoles"] = boost::any(*allowPushRoles);
    }
    if (allowPushUserIds) {
      res["allowPushUserIds"] = boost::any(*allowPushUserIds);
    }
    if (branch) {
      res["branch"] = boost::any(*branch);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (mergeRequestSetting) {
      res["mergeRequestSetting"] = mergeRequestSetting ? boost::any(mergeRequestSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (testSettingDTO) {
      res["testSettingDTO"] = testSettingDTO ? boost::any(testSettingDTO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("allowMergeRoles") != m.end() && !m["allowMergeRoles"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["allowMergeRoles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["allowMergeRoles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      allowMergeRoles = make_shared<vector<long>>(toVec1);
    }
    if (m.find("allowMergeUserIds") != m.end() && !m["allowMergeUserIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["allowMergeUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["allowMergeUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      allowMergeUserIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("allowPushRoles") != m.end() && !m["allowPushRoles"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["allowPushRoles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["allowPushRoles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      allowPushRoles = make_shared<vector<long>>(toVec1);
    }
    if (m.find("allowPushUserIds") != m.end() && !m["allowPushUserIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["allowPushUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["allowPushUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      allowPushUserIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("branch") != m.end() && !m["branch"].empty()) {
      branch = make_shared<string>(boost::any_cast<string>(m["branch"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("mergeRequestSetting") != m.end() && !m["mergeRequestSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["mergeRequestSetting"].type()) {
        CreateProtectdBranchResponseBodyResultMergeRequestSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["mergeRequestSetting"]));
        mergeRequestSetting = make_shared<CreateProtectdBranchResponseBodyResultMergeRequestSetting>(model1);
      }
    }
    if (m.find("testSettingDTO") != m.end() && !m["testSettingDTO"].empty()) {
      if (typeid(map<string, boost::any>) == m["testSettingDTO"].type()) {
        CreateProtectdBranchResponseBodyResultTestSettingDTO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["testSettingDTO"]));
        testSettingDTO = make_shared<CreateProtectdBranchResponseBodyResultTestSettingDTO>(model1);
      }
    }
  }


  virtual ~CreateProtectdBranchResponseBodyResult() = default;
};
class CreateProtectdBranchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateProtectdBranchResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateProtectdBranchResponseBody() {}

  explicit CreateProtectdBranchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        CreateProtectdBranchResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<CreateProtectdBranchResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreateProtectdBranchResponseBody() = default;
};
class CreateProtectdBranchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateProtectdBranchResponseBody> body{};

  CreateProtectdBranchResponse() {}

  explicit CreateProtectdBranchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProtectdBranchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProtectdBranchResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProtectdBranchResponse() = default;
};
class CreatePushRuleRequestRuleInfos : public Darabonba::Model {
public:
  shared_ptr<string> checkerName{};
  shared_ptr<string> checkerType{};
  shared_ptr<string> extraMessage{};
  shared_ptr<vector<string>> fileRuleRegexes{};

  CreatePushRuleRequestRuleInfos() {}

  explicit CreatePushRuleRequestRuleInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkerName) {
      res["checkerName"] = boost::any(*checkerName);
    }
    if (checkerType) {
      res["checkerType"] = boost::any(*checkerType);
    }
    if (extraMessage) {
      res["extraMessage"] = boost::any(*extraMessage);
    }
    if (fileRuleRegexes) {
      res["fileRuleRegexes"] = boost::any(*fileRuleRegexes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("checkerName") != m.end() && !m["checkerName"].empty()) {
      checkerName = make_shared<string>(boost::any_cast<string>(m["checkerName"]));
    }
    if (m.find("checkerType") != m.end() && !m["checkerType"].empty()) {
      checkerType = make_shared<string>(boost::any_cast<string>(m["checkerType"]));
    }
    if (m.find("extraMessage") != m.end() && !m["extraMessage"].empty()) {
      extraMessage = make_shared<string>(boost::any_cast<string>(m["extraMessage"]));
    }
    if (m.find("fileRuleRegexes") != m.end() && !m["fileRuleRegexes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["fileRuleRegexes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["fileRuleRegexes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fileRuleRegexes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreatePushRuleRequestRuleInfos() = default;
};
class CreatePushRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<vector<CreatePushRuleRequestRuleInfos>> ruleInfos{};
  shared_ptr<string> organizationId{};

  CreatePushRuleRequest() {}

  explicit CreatePushRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (ruleInfos) {
      vector<boost::any> temp1;
      for(auto item1:*ruleInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ruleInfos"] = boost::any(temp1);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("ruleInfos") != m.end() && !m["ruleInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["ruleInfos"].type()) {
        vector<CreatePushRuleRequestRuleInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ruleInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreatePushRuleRequestRuleInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleInfos = make_shared<vector<CreatePushRuleRequestRuleInfos>>(expect1);
      }
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~CreatePushRuleRequest() = default;
};
class CreatePushRuleResponseBodyResultRuleInfos : public Darabonba::Model {
public:
  shared_ptr<string> checkerName{};
  shared_ptr<string> checkerType{};
  shared_ptr<string> extraMessage{};
  shared_ptr<vector<string>> fileRuleRegexes{};

  CreatePushRuleResponseBodyResultRuleInfos() {}

  explicit CreatePushRuleResponseBodyResultRuleInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkerName) {
      res["checkerName"] = boost::any(*checkerName);
    }
    if (checkerType) {
      res["checkerType"] = boost::any(*checkerType);
    }
    if (extraMessage) {
      res["extraMessage"] = boost::any(*extraMessage);
    }
    if (fileRuleRegexes) {
      res["fileRuleRegexes"] = boost::any(*fileRuleRegexes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("checkerName") != m.end() && !m["checkerName"].empty()) {
      checkerName = make_shared<string>(boost::any_cast<string>(m["checkerName"]));
    }
    if (m.find("checkerType") != m.end() && !m["checkerType"].empty()) {
      checkerType = make_shared<string>(boost::any_cast<string>(m["checkerType"]));
    }
    if (m.find("extraMessage") != m.end() && !m["extraMessage"].empty()) {
      extraMessage = make_shared<string>(boost::any_cast<string>(m["extraMessage"]));
    }
    if (m.find("fileRuleRegexes") != m.end() && !m["fileRuleRegexes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["fileRuleRegexes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["fileRuleRegexes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fileRuleRegexes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreatePushRuleResponseBodyResultRuleInfos() = default;
};
class CreatePushRuleResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<vector<CreatePushRuleResponseBodyResultRuleInfos>> ruleInfos{};

  CreatePushRuleResponseBodyResult() {}

  explicit CreatePushRuleResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (ruleInfos) {
      vector<boost::any> temp1;
      for(auto item1:*ruleInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ruleInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("ruleInfos") != m.end() && !m["ruleInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["ruleInfos"].type()) {
        vector<CreatePushRuleResponseBodyResultRuleInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ruleInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreatePushRuleResponseBodyResultRuleInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleInfos = make_shared<vector<CreatePushRuleResponseBodyResultRuleInfos>>(expect1);
      }
    }
  }


  virtual ~CreatePushRuleResponseBodyResult() = default;
};
class CreatePushRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<CreatePushRuleResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreatePushRuleResponseBody() {}

  explicit CreatePushRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        CreatePushRuleResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<CreatePushRuleResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreatePushRuleResponseBody() = default;
};
class CreatePushRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePushRuleResponseBody> body{};

  CreatePushRuleResponse() {}

  explicit CreatePushRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePushRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePushRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePushRuleResponse() = default;
};
class CreateRepositoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> description{};
  shared_ptr<string> gitignoreType{};
  shared_ptr<string> importAccount{};
  shared_ptr<bool> importDemoProject{};
  shared_ptr<string> importRepoType{};
  shared_ptr<string> importToken{};
  shared_ptr<string> importTokenEncrypted{};
  shared_ptr<string> importUrl{};
  shared_ptr<bool> initStandardService{};
  shared_ptr<bool> isCryptoEnabled{};
  shared_ptr<string> localImportUrl{};
  shared_ptr<string> name{};
  shared_ptr<long> namespaceId{};
  shared_ptr<string> path{};
  shared_ptr<string> readmeType{};
  shared_ptr<long> visibilityLevel{};
  shared_ptr<bool> createParentPath{};
  shared_ptr<string> organizationId{};
  shared_ptr<bool> sync{};

  CreateRepositoryRequest() {}

  explicit CreateRepositoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (gitignoreType) {
      res["gitignoreType"] = boost::any(*gitignoreType);
    }
    if (importAccount) {
      res["importAccount"] = boost::any(*importAccount);
    }
    if (importDemoProject) {
      res["importDemoProject"] = boost::any(*importDemoProject);
    }
    if (importRepoType) {
      res["importRepoType"] = boost::any(*importRepoType);
    }
    if (importToken) {
      res["importToken"] = boost::any(*importToken);
    }
    if (importTokenEncrypted) {
      res["importTokenEncrypted"] = boost::any(*importTokenEncrypted);
    }
    if (importUrl) {
      res["importUrl"] = boost::any(*importUrl);
    }
    if (initStandardService) {
      res["initStandardService"] = boost::any(*initStandardService);
    }
    if (isCryptoEnabled) {
      res["isCryptoEnabled"] = boost::any(*isCryptoEnabled);
    }
    if (localImportUrl) {
      res["localImportUrl"] = boost::any(*localImportUrl);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (namespaceId) {
      res["namespaceId"] = boost::any(*namespaceId);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (readmeType) {
      res["readmeType"] = boost::any(*readmeType);
    }
    if (visibilityLevel) {
      res["visibilityLevel"] = boost::any(*visibilityLevel);
    }
    if (createParentPath) {
      res["createParentPath"] = boost::any(*createParentPath);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (sync) {
      res["sync"] = boost::any(*sync);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("gitignoreType") != m.end() && !m["gitignoreType"].empty()) {
      gitignoreType = make_shared<string>(boost::any_cast<string>(m["gitignoreType"]));
    }
    if (m.find("importAccount") != m.end() && !m["importAccount"].empty()) {
      importAccount = make_shared<string>(boost::any_cast<string>(m["importAccount"]));
    }
    if (m.find("importDemoProject") != m.end() && !m["importDemoProject"].empty()) {
      importDemoProject = make_shared<bool>(boost::any_cast<bool>(m["importDemoProject"]));
    }
    if (m.find("importRepoType") != m.end() && !m["importRepoType"].empty()) {
      importRepoType = make_shared<string>(boost::any_cast<string>(m["importRepoType"]));
    }
    if (m.find("importToken") != m.end() && !m["importToken"].empty()) {
      importToken = make_shared<string>(boost::any_cast<string>(m["importToken"]));
    }
    if (m.find("importTokenEncrypted") != m.end() && !m["importTokenEncrypted"].empty()) {
      importTokenEncrypted = make_shared<string>(boost::any_cast<string>(m["importTokenEncrypted"]));
    }
    if (m.find("importUrl") != m.end() && !m["importUrl"].empty()) {
      importUrl = make_shared<string>(boost::any_cast<string>(m["importUrl"]));
    }
    if (m.find("initStandardService") != m.end() && !m["initStandardService"].empty()) {
      initStandardService = make_shared<bool>(boost::any_cast<bool>(m["initStandardService"]));
    }
    if (m.find("isCryptoEnabled") != m.end() && !m["isCryptoEnabled"].empty()) {
      isCryptoEnabled = make_shared<bool>(boost::any_cast<bool>(m["isCryptoEnabled"]));
    }
    if (m.find("localImportUrl") != m.end() && !m["localImportUrl"].empty()) {
      localImportUrl = make_shared<string>(boost::any_cast<string>(m["localImportUrl"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("namespaceId") != m.end() && !m["namespaceId"].empty()) {
      namespaceId = make_shared<long>(boost::any_cast<long>(m["namespaceId"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("readmeType") != m.end() && !m["readmeType"].empty()) {
      readmeType = make_shared<string>(boost::any_cast<string>(m["readmeType"]));
    }
    if (m.find("visibilityLevel") != m.end() && !m["visibilityLevel"].empty()) {
      visibilityLevel = make_shared<long>(boost::any_cast<long>(m["visibilityLevel"]));
    }
    if (m.find("createParentPath") != m.end() && !m["createParentPath"].empty()) {
      createParentPath = make_shared<bool>(boost::any_cast<bool>(m["createParentPath"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("sync") != m.end() && !m["sync"].empty()) {
      sync = make_shared<bool>(boost::any_cast<bool>(m["sync"]));
    }
  }


  virtual ~CreateRepositoryRequest() = default;
};
class CreateRepositoryResponseBodyResultNamespace : public Darabonba::Model {
public:
  shared_ptr<string> avatar{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> path{};
  shared_ptr<bool> public_{};
  shared_ptr<string> updatedAt{};
  shared_ptr<string> visibilityLevel{};

  CreateRepositoryResponseBodyResultNamespace() {}

  explicit CreateRepositoryResponseBodyResultNamespace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatar) {
      res["avatar"] = boost::any(*avatar);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (ownerId) {
      res["ownerId"] = boost::any(*ownerId);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (public_) {
      res["public"] = boost::any(*public_);
    }
    if (updatedAt) {
      res["updatedAt"] = boost::any(*updatedAt);
    }
    if (visibilityLevel) {
      res["visibilityLevel"] = boost::any(*visibilityLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatar") != m.end() && !m["avatar"].empty()) {
      avatar = make_shared<string>(boost::any_cast<string>(m["avatar"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("ownerId") != m.end() && !m["ownerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["ownerId"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("public") != m.end() && !m["public"].empty()) {
      public_ = make_shared<bool>(boost::any_cast<bool>(m["public"]));
    }
    if (m.find("updatedAt") != m.end() && !m["updatedAt"].empty()) {
      updatedAt = make_shared<string>(boost::any_cast<string>(m["updatedAt"]));
    }
    if (m.find("visibilityLevel") != m.end() && !m["visibilityLevel"].empty()) {
      visibilityLevel = make_shared<string>(boost::any_cast<string>(m["visibilityLevel"]));
    }
  }


  virtual ~CreateRepositoryResponseBodyResultNamespace() = default;
};
class CreateRepositoryResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> importFromSvn{};
  shared_ptr<bool> archived{};
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> createdAt{};
  shared_ptr<long> creatorId{};
  shared_ptr<string> defaultBranch{};
  shared_ptr<bool> demoProject{};
  shared_ptr<string> description{};
  shared_ptr<string> httpUrlToRepo{};
  shared_ptr<long> id{};
  shared_ptr<string> lastActivityAt{};
  shared_ptr<string> name{};
  shared_ptr<string> nameWithNamespace{};
  shared_ptr<CreateRepositoryResponseBodyResultNamespace> namespace_{};
  shared_ptr<string> path{};
  shared_ptr<string> pathWithNamespace{};
  shared_ptr<string> sshUrlToRepo{};
  shared_ptr<string> visibilityLevel{};
  shared_ptr<string> webUrl{};

  CreateRepositoryResponseBodyResult() {}

  explicit CreateRepositoryResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (importFromSvn) {
      res["Import_from_svn"] = boost::any(*importFromSvn);
    }
    if (archived) {
      res["archived"] = boost::any(*archived);
    }
    if (avatarUrl) {
      res["avatar_url"] = boost::any(*avatarUrl);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (creatorId) {
      res["creatorId"] = boost::any(*creatorId);
    }
    if (defaultBranch) {
      res["defaultBranch"] = boost::any(*defaultBranch);
    }
    if (demoProject) {
      res["demoProject"] = boost::any(*demoProject);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (httpUrlToRepo) {
      res["httpUrlToRepo"] = boost::any(*httpUrlToRepo);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (lastActivityAt) {
      res["lastActivityAt"] = boost::any(*lastActivityAt);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nameWithNamespace) {
      res["nameWithNamespace"] = boost::any(*nameWithNamespace);
    }
    if (namespace_) {
      res["namespace"] = namespace_ ? boost::any(namespace_->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (pathWithNamespace) {
      res["pathWithNamespace"] = boost::any(*pathWithNamespace);
    }
    if (sshUrlToRepo) {
      res["sshUrlToRepo"] = boost::any(*sshUrlToRepo);
    }
    if (visibilityLevel) {
      res["visibilityLevel"] = boost::any(*visibilityLevel);
    }
    if (webUrl) {
      res["webUrl"] = boost::any(*webUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Import_from_svn") != m.end() && !m["Import_from_svn"].empty()) {
      importFromSvn = make_shared<bool>(boost::any_cast<bool>(m["Import_from_svn"]));
    }
    if (m.find("archived") != m.end() && !m["archived"].empty()) {
      archived = make_shared<bool>(boost::any_cast<bool>(m["archived"]));
    }
    if (m.find("avatar_url") != m.end() && !m["avatar_url"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatar_url"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("creatorId") != m.end() && !m["creatorId"].empty()) {
      creatorId = make_shared<long>(boost::any_cast<long>(m["creatorId"]));
    }
    if (m.find("defaultBranch") != m.end() && !m["defaultBranch"].empty()) {
      defaultBranch = make_shared<string>(boost::any_cast<string>(m["defaultBranch"]));
    }
    if (m.find("demoProject") != m.end() && !m["demoProject"].empty()) {
      demoProject = make_shared<bool>(boost::any_cast<bool>(m["demoProject"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("httpUrlToRepo") != m.end() && !m["httpUrlToRepo"].empty()) {
      httpUrlToRepo = make_shared<string>(boost::any_cast<string>(m["httpUrlToRepo"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("lastActivityAt") != m.end() && !m["lastActivityAt"].empty()) {
      lastActivityAt = make_shared<string>(boost::any_cast<string>(m["lastActivityAt"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nameWithNamespace") != m.end() && !m["nameWithNamespace"].empty()) {
      nameWithNamespace = make_shared<string>(boost::any_cast<string>(m["nameWithNamespace"]));
    }
    if (m.find("namespace") != m.end() && !m["namespace"].empty()) {
      if (typeid(map<string, boost::any>) == m["namespace"].type()) {
        CreateRepositoryResponseBodyResultNamespace model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["namespace"]));
        namespace_ = make_shared<CreateRepositoryResponseBodyResultNamespace>(model1);
      }
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("pathWithNamespace") != m.end() && !m["pathWithNamespace"].empty()) {
      pathWithNamespace = make_shared<string>(boost::any_cast<string>(m["pathWithNamespace"]));
    }
    if (m.find("sshUrlToRepo") != m.end() && !m["sshUrlToRepo"].empty()) {
      sshUrlToRepo = make_shared<string>(boost::any_cast<string>(m["sshUrlToRepo"]));
    }
    if (m.find("visibilityLevel") != m.end() && !m["visibilityLevel"].empty()) {
      visibilityLevel = make_shared<string>(boost::any_cast<string>(m["visibilityLevel"]));
    }
    if (m.find("webUrl") != m.end() && !m["webUrl"].empty()) {
      webUrl = make_shared<string>(boost::any_cast<string>(m["webUrl"]));
    }
  }


  virtual ~CreateRepositoryResponseBodyResult() = default;
};
class CreateRepositoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateRepositoryResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateRepositoryResponseBody() {}

  explicit CreateRepositoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        CreateRepositoryResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<CreateRepositoryResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreateRepositoryResponseBody() = default;
};
class CreateRepositoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRepositoryResponseBody> body{};

  CreateRepositoryResponse() {}

  explicit CreateRepositoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRepositoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRepositoryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRepositoryResponse() = default;
};
class CreateRepositoryGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<long> parentId{};
  shared_ptr<string> path{};
  shared_ptr<long> visibilityLevel{};
  shared_ptr<string> organizationId{};

  CreateRepositoryGroupRequest() {}

  explicit CreateRepositoryGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (parentId) {
      res["parentId"] = boost::any(*parentId);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (visibilityLevel) {
      res["visibilityLevel"] = boost::any(*visibilityLevel);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("parentId") != m.end() && !m["parentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["parentId"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("visibilityLevel") != m.end() && !m["visibilityLevel"].empty()) {
      visibilityLevel = make_shared<long>(boost::any_cast<long>(m["visibilityLevel"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~CreateRepositoryGroupRequest() = default;
};
class CreateRepositoryGroupResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> nameWithNamespace{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> parentId{};
  shared_ptr<string> path{};
  shared_ptr<string> pathWithNamespace{};
  shared_ptr<string> type{};
  shared_ptr<long> visibilityLevel{};
  shared_ptr<string> webUrl{};

  CreateRepositoryGroupResponseBodyResult() {}

  explicit CreateRepositoryGroupResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nameWithNamespace) {
      res["nameWithNamespace"] = boost::any(*nameWithNamespace);
    }
    if (ownerId) {
      res["ownerId"] = boost::any(*ownerId);
    }
    if (parentId) {
      res["parentId"] = boost::any(*parentId);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (pathWithNamespace) {
      res["pathWithNamespace"] = boost::any(*pathWithNamespace);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (visibilityLevel) {
      res["visibilityLevel"] = boost::any(*visibilityLevel);
    }
    if (webUrl) {
      res["webUrl"] = boost::any(*webUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nameWithNamespace") != m.end() && !m["nameWithNamespace"].empty()) {
      nameWithNamespace = make_shared<string>(boost::any_cast<string>(m["nameWithNamespace"]));
    }
    if (m.find("ownerId") != m.end() && !m["ownerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["ownerId"]));
    }
    if (m.find("parentId") != m.end() && !m["parentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["parentId"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("pathWithNamespace") != m.end() && !m["pathWithNamespace"].empty()) {
      pathWithNamespace = make_shared<string>(boost::any_cast<string>(m["pathWithNamespace"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("visibilityLevel") != m.end() && !m["visibilityLevel"].empty()) {
      visibilityLevel = make_shared<long>(boost::any_cast<long>(m["visibilityLevel"]));
    }
    if (m.find("webUrl") != m.end() && !m["webUrl"].empty()) {
      webUrl = make_shared<string>(boost::any_cast<string>(m["webUrl"]));
    }
  }


  virtual ~CreateRepositoryGroupResponseBodyResult() = default;
};
class CreateRepositoryGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateRepositoryGroupResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateRepositoryGroupResponseBody() {}

  explicit CreateRepositoryGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        CreateRepositoryGroupResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<CreateRepositoryGroupResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreateRepositoryGroupResponseBody() = default;
};
class CreateRepositoryGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRepositoryGroupResponseBody> body{};

  CreateRepositoryGroupResponse() {}

  explicit CreateRepositoryGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRepositoryGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRepositoryGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRepositoryGroupResponse() = default;
};
class CreateResourceMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> roleName{};

  CreateResourceMemberRequest() {}

  explicit CreateResourceMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    if (roleName) {
      res["roleName"] = boost::any(*roleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
    if (m.find("roleName") != m.end() && !m["roleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["roleName"]));
    }
  }


  virtual ~CreateResourceMemberRequest() = default;
};
class CreateResourceMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateResourceMemberResponseBody() {}

  explicit CreateResourceMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreateResourceMemberResponseBody() = default;
};
class CreateResourceMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateResourceMemberResponseBody> body{};

  CreateResourceMemberResponse() {}

  explicit CreateResourceMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateResourceMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateResourceMemberResponseBody>(model1);
      }
    }
  }


  virtual ~CreateResourceMemberResponse() = default;
};
class CreateServiceAuthRequest : public Darabonba::Model {
public:
  shared_ptr<string> serviceAuthType{};

  CreateServiceAuthRequest() {}

  explicit CreateServiceAuthRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceAuthType) {
      res["serviceAuthType"] = boost::any(*serviceAuthType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("serviceAuthType") != m.end() && !m["serviceAuthType"].empty()) {
      serviceAuthType = make_shared<string>(boost::any_cast<string>(m["serviceAuthType"]));
    }
  }


  virtual ~CreateServiceAuthRequest() = default;
};
class CreateServiceAuthResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateServiceAuthResponseBody() {}

  explicit CreateServiceAuthResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreateServiceAuthResponseBody() = default;
};
class CreateServiceAuthResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateServiceAuthResponseBody> body{};

  CreateServiceAuthResponse() {}

  explicit CreateServiceAuthResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateServiceAuthResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateServiceAuthResponseBody>(model1);
      }
    }
  }


  virtual ~CreateServiceAuthResponse() = default;
};
class CreateServiceConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> authType{};
  shared_ptr<string> connectionName{};
  shared_ptr<string> connectionType{};
  shared_ptr<string> scope{};
  shared_ptr<long> serviceAuthId{};

  CreateServiceConnectionRequest() {}

  explicit CreateServiceConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authType) {
      res["authType"] = boost::any(*authType);
    }
    if (connectionName) {
      res["connectionName"] = boost::any(*connectionName);
    }
    if (connectionType) {
      res["connectionType"] = boost::any(*connectionType);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (serviceAuthId) {
      res["serviceAuthId"] = boost::any(*serviceAuthId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("authType") != m.end() && !m["authType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["authType"]));
    }
    if (m.find("connectionName") != m.end() && !m["connectionName"].empty()) {
      connectionName = make_shared<string>(boost::any_cast<string>(m["connectionName"]));
    }
    if (m.find("connectionType") != m.end() && !m["connectionType"].empty()) {
      connectionType = make_shared<string>(boost::any_cast<string>(m["connectionType"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["scope"]));
    }
    if (m.find("serviceAuthId") != m.end() && !m["serviceAuthId"].empty()) {
      serviceAuthId = make_shared<long>(boost::any_cast<long>(m["serviceAuthId"]));
    }
  }


  virtual ~CreateServiceConnectionRequest() = default;
};
class CreateServiceConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateServiceConnectionResponseBody() {}

  explicit CreateServiceConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreateServiceConnectionResponseBody() = default;
};
class CreateServiceConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateServiceConnectionResponseBody> body{};

  CreateServiceConnectionResponse() {}

  explicit CreateServiceConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateServiceConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateServiceConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateServiceConnectionResponse() = default;
};
class CreateServiceCredentialRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> password{};
  shared_ptr<string> scope{};
  shared_ptr<string> type{};
  shared_ptr<string> username{};

  CreateServiceCredentialRequest() {}

  explicit CreateServiceCredentialRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (password) {
      res["password"] = boost::any(*password);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("password") != m.end() && !m["password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["password"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["scope"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~CreateServiceCredentialRequest() = default;
};
class CreateServiceCredentialResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateServiceCredentialResponseBody() {}

  explicit CreateServiceCredentialResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreateServiceCredentialResponseBody() = default;
};
class CreateServiceCredentialResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateServiceCredentialResponseBody> body{};

  CreateServiceCredentialResponse() {}

  explicit CreateServiceCredentialResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateServiceCredentialResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateServiceCredentialResponseBody>(model1);
      }
    }
  }


  virtual ~CreateServiceCredentialResponse() = default;
};
class CreateSprintRequest : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<string> name{};
  shared_ptr<string> spaceIdentifier{};
  shared_ptr<vector<string>> staffIds{};
  shared_ptr<string> startDate{};

  CreateSprintRequest() {}

  explicit CreateSprintRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["endDate"] = boost::any(*endDate);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (spaceIdentifier) {
      res["spaceIdentifier"] = boost::any(*spaceIdentifier);
    }
    if (staffIds) {
      res["staffIds"] = boost::any(*staffIds);
    }
    if (startDate) {
      res["startDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endDate") != m.end() && !m["endDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["endDate"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("spaceIdentifier") != m.end() && !m["spaceIdentifier"].empty()) {
      spaceIdentifier = make_shared<string>(boost::any_cast<string>(m["spaceIdentifier"]));
    }
    if (m.find("staffIds") != m.end() && !m["staffIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["staffIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["staffIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      staffIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("startDate") != m.end() && !m["startDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["startDate"]));
    }
  }


  virtual ~CreateSprintRequest() = default;
};
class CreateSprintResponseBodySprint : public Darabonba::Model {
public:
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<long> endDate{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> identifier{};
  shared_ptr<string> modifier{};
  shared_ptr<string> name{};
  shared_ptr<string> scope{};
  shared_ptr<string> spaceIdentifier{};
  shared_ptr<long> startDate{};
  shared_ptr<string> status{};

  CreateSprintResponseBodySprint() {}

  explicit CreateSprintResponseBodySprint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creator) {
      res["creator"] = boost::any(*creator);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (endDate) {
      res["endDate"] = boost::any(*endDate);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (modifier) {
      res["modifier"] = boost::any(*modifier);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (spaceIdentifier) {
      res["spaceIdentifier"] = boost::any(*spaceIdentifier);
    }
    if (startDate) {
      res["startDate"] = boost::any(*startDate);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["creator"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("endDate") != m.end() && !m["endDate"].empty()) {
      endDate = make_shared<long>(boost::any_cast<long>(m["endDate"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("modifier") != m.end() && !m["modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["modifier"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["scope"]));
    }
    if (m.find("spaceIdentifier") != m.end() && !m["spaceIdentifier"].empty()) {
      spaceIdentifier = make_shared<string>(boost::any_cast<string>(m["spaceIdentifier"]));
    }
    if (m.find("startDate") != m.end() && !m["startDate"].empty()) {
      startDate = make_shared<long>(boost::any_cast<long>(m["startDate"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~CreateSprintResponseBodySprint() = default;
};
class CreateSprintResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateSprintResponseBodySprint> sprint{};
  shared_ptr<bool> success{};

  CreateSprintResponseBody() {}

  explicit CreateSprintResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (sprint) {
      res["sprint"] = sprint ? boost::any(sprint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("sprint") != m.end() && !m["sprint"].empty()) {
      if (typeid(map<string, boost::any>) == m["sprint"].type()) {
        CreateSprintResponseBodySprint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["sprint"]));
        sprint = make_shared<CreateSprintResponseBodySprint>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreateSprintResponseBody() = default;
};
class CreateSprintResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSprintResponseBody> body{};

  CreateSprintResponse() {}

  explicit CreateSprintResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSprintResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSprintResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSprintResponse() = default;
};
class CreateSshKeyResponseBodySshKey : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> publicKey{};

  CreateSshKeyResponseBodySshKey() {}

  explicit CreateSshKeyResponseBodySshKey(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (publicKey) {
      res["publicKey"] = boost::any(*publicKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("publicKey") != m.end() && !m["publicKey"].empty()) {
      publicKey = make_shared<string>(boost::any_cast<string>(m["publicKey"]));
    }
  }


  virtual ~CreateSshKeyResponseBodySshKey() = default;
};
class CreateSshKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateSshKeyResponseBodySshKey> sshKey{};
  shared_ptr<bool> success{};

  CreateSshKeyResponseBody() {}

  explicit CreateSshKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (sshKey) {
      res["sshKey"] = sshKey ? boost::any(sshKey->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("sshKey") != m.end() && !m["sshKey"].empty()) {
      if (typeid(map<string, boost::any>) == m["sshKey"].type()) {
        CreateSshKeyResponseBodySshKey model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["sshKey"]));
        sshKey = make_shared<CreateSshKeyResponseBodySshKey>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreateSshKeyResponseBody() = default;
};
class CreateSshKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSshKeyResponseBody> body{};

  CreateSshKeyResponse() {}

  explicit CreateSshKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSshKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSshKeyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSshKeyResponse() = default;
};
class CreateTagRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> message{};
  shared_ptr<string> ref{};
  shared_ptr<string> tagName{};
  shared_ptr<string> organizationId{};

  CreateTagRequest() {}

  explicit CreateTagRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (ref) {
      res["ref"] = boost::any(*ref);
    }
    if (tagName) {
      res["tagName"] = boost::any(*tagName);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("ref") != m.end() && !m["ref"].empty()) {
      ref = make_shared<string>(boost::any_cast<string>(m["ref"]));
    }
    if (m.find("tagName") != m.end() && !m["tagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["tagName"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~CreateTagRequest() = default;
};
class CreateTagResponseBodyResultCommit : public Darabonba::Model {
public:
  shared_ptr<string> authorEmail{};
  shared_ptr<string> authorName{};
  shared_ptr<string> authoredDate{};
  shared_ptr<string> committedDate{};
  shared_ptr<string> committerEmail{};
  shared_ptr<string> committerName{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> id{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> parentIds{};
  shared_ptr<string> shortId{};
  shared_ptr<string> title{};

  CreateTagResponseBodyResultCommit() {}

  explicit CreateTagResponseBodyResultCommit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorEmail) {
      res["authorEmail"] = boost::any(*authorEmail);
    }
    if (authorName) {
      res["authorName"] = boost::any(*authorName);
    }
    if (authoredDate) {
      res["authoredDate"] = boost::any(*authoredDate);
    }
    if (committedDate) {
      res["committedDate"] = boost::any(*committedDate);
    }
    if (committerEmail) {
      res["committerEmail"] = boost::any(*committerEmail);
    }
    if (committerName) {
      res["committerName"] = boost::any(*committerName);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (parentIds) {
      res["parentIds"] = boost::any(*parentIds);
    }
    if (shortId) {
      res["shortId"] = boost::any(*shortId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("authorEmail") != m.end() && !m["authorEmail"].empty()) {
      authorEmail = make_shared<string>(boost::any_cast<string>(m["authorEmail"]));
    }
    if (m.find("authorName") != m.end() && !m["authorName"].empty()) {
      authorName = make_shared<string>(boost::any_cast<string>(m["authorName"]));
    }
    if (m.find("authoredDate") != m.end() && !m["authoredDate"].empty()) {
      authoredDate = make_shared<string>(boost::any_cast<string>(m["authoredDate"]));
    }
    if (m.find("committedDate") != m.end() && !m["committedDate"].empty()) {
      committedDate = make_shared<string>(boost::any_cast<string>(m["committedDate"]));
    }
    if (m.find("committerEmail") != m.end() && !m["committerEmail"].empty()) {
      committerEmail = make_shared<string>(boost::any_cast<string>(m["committerEmail"]));
    }
    if (m.find("committerName") != m.end() && !m["committerName"].empty()) {
      committerName = make_shared<string>(boost::any_cast<string>(m["committerName"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("parentIds") != m.end() && !m["parentIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["parentIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["parentIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      parentIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("shortId") != m.end() && !m["shortId"].empty()) {
      shortId = make_shared<string>(boost::any_cast<string>(m["shortId"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~CreateTagResponseBodyResultCommit() = default;
};
class CreateTagResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<CreateTagResponseBodyResultCommit> commit{};
  shared_ptr<string> id{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};

  CreateTagResponseBodyResult() {}

  explicit CreateTagResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commit) {
      res["commit"] = commit ? boost::any(commit->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commit") != m.end() && !m["commit"].empty()) {
      if (typeid(map<string, boost::any>) == m["commit"].type()) {
        CreateTagResponseBodyResultCommit model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["commit"]));
        commit = make_shared<CreateTagResponseBodyResultCommit>(model1);
      }
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~CreateTagResponseBodyResult() = default;
};
class CreateTagResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateTagResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateTagResponseBody() {}

  explicit CreateTagResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        CreateTagResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<CreateTagResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreateTagResponseBody() = default;
};
class CreateTagResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTagResponseBody> body{};

  CreateTagResponse() {}

  explicit CreateTagResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTagResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTagResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTagResponse() = default;
};
class CreateTestCaseRequestFieldValueList : public Darabonba::Model {
public:
  shared_ptr<string> fieldIdentifier{};
  shared_ptr<string> value{};

  CreateTestCaseRequestFieldValueList() {}

  explicit CreateTestCaseRequestFieldValueList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldIdentifier) {
      res["fieldIdentifier"] = boost::any(*fieldIdentifier);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fieldIdentifier") != m.end() && !m["fieldIdentifier"].empty()) {
      fieldIdentifier = make_shared<string>(boost::any_cast<string>(m["fieldIdentifier"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~CreateTestCaseRequestFieldValueList() = default;
};
class CreateTestCaseRequestTestcaseStepContentInfoStepResultList : public Darabonba::Model {
public:
  shared_ptr<string> expected{};
  shared_ptr<string> step{};

  CreateTestCaseRequestTestcaseStepContentInfoStepResultList() {}

  explicit CreateTestCaseRequestTestcaseStepContentInfoStepResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expected) {
      res["expected"] = boost::any(*expected);
    }
    if (step) {
      res["step"] = boost::any(*step);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    expected = make_shared<string>(boost::any_cast<string>(m["expected"]));
    if (m.find("step") != m.end() && !m["step"].empty()) {
      step = make_shared<string>(boost::any_cast<string>(m["step"]));
    }
  }


  virtual ~CreateTestCaseRequestTestcaseStepContentInfoStepResultList() = default;
};
class CreateTestCaseRequestTestcaseStepContentInfo : public Darabonba::Model {
public:
  shared_ptr<string> precondition{};
  shared_ptr<vector<CreateTestCaseRequestTestcaseStepContentInfoStepResultList>> stepResultList{};
  shared_ptr<string> stepType{};

  CreateTestCaseRequestTestcaseStepContentInfo() {}

  explicit CreateTestCaseRequestTestcaseStepContentInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (precondition) {
      res["precondition"] = boost::any(*precondition);
    }
    if (stepResultList) {
      vector<boost::any> temp1;
      for(auto item1:*stepResultList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["stepResultList"] = boost::any(temp1);
    }
    if (stepType) {
      res["stepType"] = boost::any(*stepType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("precondition") != m.end() && !m["precondition"].empty()) {
      precondition = make_shared<string>(boost::any_cast<string>(m["precondition"]));
    }
    if (m.find("stepResultList") != m.end() && !m["stepResultList"].empty()) {
      if (typeid(vector<boost::any>) == m["stepResultList"].type()) {
        vector<CreateTestCaseRequestTestcaseStepContentInfoStepResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["stepResultList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateTestCaseRequestTestcaseStepContentInfoStepResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        stepResultList = make_shared<vector<CreateTestCaseRequestTestcaseStepContentInfoStepResultList>>(expect1);
      }
    }
    if (m.find("stepType") != m.end() && !m["stepType"].empty()) {
      stepType = make_shared<string>(boost::any_cast<string>(m["stepType"]));
    }
  }


  virtual ~CreateTestCaseRequestTestcaseStepContentInfo() = default;
};
class CreateTestCaseRequest : public Darabonba::Model {
public:
  shared_ptr<string> assignedTo{};
  shared_ptr<string> directoryIdentifier{};
  shared_ptr<vector<CreateTestCaseRequestFieldValueList>> fieldValueList{};
  shared_ptr<string> priority{};
  shared_ptr<string> spaceIdentifier{};
  shared_ptr<string> subject{};
  shared_ptr<vector<string>> tags{};
  shared_ptr<CreateTestCaseRequestTestcaseStepContentInfo> testcaseStepContentInfo{};

  CreateTestCaseRequest() {}

  explicit CreateTestCaseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignedTo) {
      res["assignedTo"] = boost::any(*assignedTo);
    }
    if (directoryIdentifier) {
      res["directoryIdentifier"] = boost::any(*directoryIdentifier);
    }
    if (fieldValueList) {
      vector<boost::any> temp1;
      for(auto item1:*fieldValueList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["fieldValueList"] = boost::any(temp1);
    }
    if (priority) {
      res["priority"] = boost::any(*priority);
    }
    if (spaceIdentifier) {
      res["spaceIdentifier"] = boost::any(*spaceIdentifier);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    if (tags) {
      res["tags"] = boost::any(*tags);
    }
    if (testcaseStepContentInfo) {
      res["testcaseStepContentInfo"] = testcaseStepContentInfo ? boost::any(testcaseStepContentInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignedTo") != m.end() && !m["assignedTo"].empty()) {
      assignedTo = make_shared<string>(boost::any_cast<string>(m["assignedTo"]));
    }
    if (m.find("directoryIdentifier") != m.end() && !m["directoryIdentifier"].empty()) {
      directoryIdentifier = make_shared<string>(boost::any_cast<string>(m["directoryIdentifier"]));
    }
    if (m.find("fieldValueList") != m.end() && !m["fieldValueList"].empty()) {
      if (typeid(vector<boost::any>) == m["fieldValueList"].type()) {
        vector<CreateTestCaseRequestFieldValueList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["fieldValueList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateTestCaseRequestFieldValueList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fieldValueList = make_shared<vector<CreateTestCaseRequestFieldValueList>>(expect1);
      }
    }
    if (m.find("priority") != m.end() && !m["priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["priority"]));
    }
    if (m.find("spaceIdentifier") != m.end() && !m["spaceIdentifier"].empty()) {
      spaceIdentifier = make_shared<string>(boost::any_cast<string>(m["spaceIdentifier"]));
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["tags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tags = make_shared<vector<string>>(toVec1);
    }
    if (m.find("testcaseStepContentInfo") != m.end() && !m["testcaseStepContentInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["testcaseStepContentInfo"].type()) {
        CreateTestCaseRequestTestcaseStepContentInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["testcaseStepContentInfo"]));
        testcaseStepContentInfo = make_shared<CreateTestCaseRequestTestcaseStepContentInfo>(model1);
      }
    }
  }


  virtual ~CreateTestCaseRequest() = default;
};
class CreateTestCaseResponseBodyTestcaseAssignedTo : public Darabonba::Model {
public:
  shared_ptr<string> assignIdentifier{};
  shared_ptr<string> name{};
  shared_ptr<string> tbRoleId{};

  CreateTestCaseResponseBodyTestcaseAssignedTo() {}

  explicit CreateTestCaseResponseBodyTestcaseAssignedTo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignIdentifier) {
      res["assignIdentifier"] = boost::any(*assignIdentifier);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (tbRoleId) {
      res["tbRoleId"] = boost::any(*tbRoleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignIdentifier") != m.end() && !m["assignIdentifier"].empty()) {
      assignIdentifier = make_shared<string>(boost::any_cast<string>(m["assignIdentifier"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("tbRoleId") != m.end() && !m["tbRoleId"].empty()) {
      tbRoleId = make_shared<string>(boost::any_cast<string>(m["tbRoleId"]));
    }
  }


  virtual ~CreateTestCaseResponseBodyTestcaseAssignedTo() = default;
};
class CreateTestCaseResponseBodyTestcaseCreator : public Darabonba::Model {
public:
  shared_ptr<string> createIdentifier{};
  shared_ptr<string> name{};

  CreateTestCaseResponseBodyTestcaseCreator() {}

  explicit CreateTestCaseResponseBodyTestcaseCreator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createIdentifier) {
      res["createIdentifier"] = boost::any(*createIdentifier);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createIdentifier") != m.end() && !m["createIdentifier"].empty()) {
      createIdentifier = make_shared<string>(boost::any_cast<string>(m["createIdentifier"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~CreateTestCaseResponseBodyTestcaseCreator() = default;
};
class CreateTestCaseResponseBodyTestcaseDetailInfoExpectedResult : public Darabonba::Model {
public:
  shared_ptr<string> expectContent{};
  shared_ptr<string> expectContentType{};
  shared_ptr<string> expectIdentifier{};

  CreateTestCaseResponseBodyTestcaseDetailInfoExpectedResult() {}

  explicit CreateTestCaseResponseBodyTestcaseDetailInfoExpectedResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expectContent) {
      res["expectContent"] = boost::any(*expectContent);
    }
    if (expectContentType) {
      res["expectContentType"] = boost::any(*expectContentType);
    }
    if (expectIdentifier) {
      res["expectIdentifier"] = boost::any(*expectIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    expectContent = make_shared<string>(boost::any_cast<string>(m["expectContent"]));
    expectContentType = make_shared<string>(boost::any_cast<string>(m["expectContentType"]));
    expectIdentifier = make_shared<string>(boost::any_cast<string>(m["expectIdentifier"]));
  }


  virtual ~CreateTestCaseResponseBodyTestcaseDetailInfoExpectedResult() = default;
};
class CreateTestCaseResponseBodyTestcaseDetailInfoPrecondition : public Darabonba::Model {
public:
  shared_ptr<string> preContent{};
  shared_ptr<string> preContentType{};
  shared_ptr<string> preIdentifier{};

  CreateTestCaseResponseBodyTestcaseDetailInfoPrecondition() {}

  explicit CreateTestCaseResponseBodyTestcaseDetailInfoPrecondition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preContent) {
      res["preContent"] = boost::any(*preContent);
    }
    if (preContentType) {
      res["preContentType"] = boost::any(*preContentType);
    }
    if (preIdentifier) {
      res["preIdentifier"] = boost::any(*preIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("preContent") != m.end() && !m["preContent"].empty()) {
      preContent = make_shared<string>(boost::any_cast<string>(m["preContent"]));
    }
    if (m.find("preContentType") != m.end() && !m["preContentType"].empty()) {
      preContentType = make_shared<string>(boost::any_cast<string>(m["preContentType"]));
    }
    if (m.find("preIdentifier") != m.end() && !m["preIdentifier"].empty()) {
      preIdentifier = make_shared<string>(boost::any_cast<string>(m["preIdentifier"]));
    }
  }


  virtual ~CreateTestCaseResponseBodyTestcaseDetailInfoPrecondition() = default;
};
class CreateTestCaseResponseBodyTestcaseDetailInfoStepContent : public Darabonba::Model {
public:
  shared_ptr<string> stepContent{};
  shared_ptr<string> stepContentType{};
  shared_ptr<string> stepIdentifier{};

  CreateTestCaseResponseBodyTestcaseDetailInfoStepContent() {}

  explicit CreateTestCaseResponseBodyTestcaseDetailInfoStepContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stepContent) {
      res["stepContent"] = boost::any(*stepContent);
    }
    if (stepContentType) {
      res["stepContentType"] = boost::any(*stepContentType);
    }
    if (stepIdentifier) {
      res["stepIdentifier"] = boost::any(*stepIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("stepContent") != m.end() && !m["stepContent"].empty()) {
      stepContent = make_shared<string>(boost::any_cast<string>(m["stepContent"]));
    }
    if (m.find("stepContentType") != m.end() && !m["stepContentType"].empty()) {
      stepContentType = make_shared<string>(boost::any_cast<string>(m["stepContentType"]));
    }
    if (m.find("stepIdentifier") != m.end() && !m["stepIdentifier"].empty()) {
      stepIdentifier = make_shared<string>(boost::any_cast<string>(m["stepIdentifier"]));
    }
  }


  virtual ~CreateTestCaseResponseBodyTestcaseDetailInfoStepContent() = default;
};
class CreateTestCaseResponseBodyTestcaseDetailInfo : public Darabonba::Model {
public:
  shared_ptr<CreateTestCaseResponseBodyTestcaseDetailInfoExpectedResult> expectedResult{};
  shared_ptr<CreateTestCaseResponseBodyTestcaseDetailInfoPrecondition> precondition{};
  shared_ptr<CreateTestCaseResponseBodyTestcaseDetailInfoStepContent> stepContent{};
  shared_ptr<string> stepType{};

  CreateTestCaseResponseBodyTestcaseDetailInfo() {}

  explicit CreateTestCaseResponseBodyTestcaseDetailInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expectedResult) {
      res["expectedResult"] = expectedResult ? boost::any(expectedResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (precondition) {
      res["precondition"] = precondition ? boost::any(precondition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stepContent) {
      res["stepContent"] = stepContent ? boost::any(stepContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stepType) {
      res["stepType"] = boost::any(*stepType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (typeid(map<string, boost::any>) == m["expectedResult"].type()) {
      CreateTestCaseResponseBodyTestcaseDetailInfoExpectedResult model1;
      model1.fromMap(boost::any_cast<map<string, boost::any>>(m["expectedResult"]));
      expectedResult = model1;
    }
    if (m.find("precondition") != m.end() && !m["precondition"].empty()) {
      if (typeid(map<string, boost::any>) == m["precondition"].type()) {
        CreateTestCaseResponseBodyTestcaseDetailInfoPrecondition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["precondition"]));
        precondition = make_shared<CreateTestCaseResponseBodyTestcaseDetailInfoPrecondition>(model1);
      }
    }
    if (m.find("stepContent") != m.end() && !m["stepContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["stepContent"].type()) {
        CreateTestCaseResponseBodyTestcaseDetailInfoStepContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["stepContent"]));
        stepContent = make_shared<CreateTestCaseResponseBodyTestcaseDetailInfoStepContent>(model1);
      }
    }
    if (m.find("stepType") != m.end() && !m["stepType"].empty()) {
      stepType = make_shared<string>(boost::any_cast<string>(m["stepType"]));
    }
  }


  virtual ~CreateTestCaseResponseBodyTestcaseDetailInfo() = default;
};
class CreateTestCaseResponseBodyTestcaseDirectory : public Darabonba::Model {
public:
  shared_ptr<string> childIdentifier{};
  shared_ptr<string> directoryIdentifier{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> pathName{};

  CreateTestCaseResponseBodyTestcaseDirectory() {}

  explicit CreateTestCaseResponseBodyTestcaseDirectory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (childIdentifier) {
      res["childIdentifier"] = boost::any(*childIdentifier);
    }
    if (directoryIdentifier) {
      res["directoryIdentifier"] = boost::any(*directoryIdentifier);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (pathName) {
      res["pathName"] = boost::any(*pathName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("childIdentifier") != m.end() && !m["childIdentifier"].empty()) {
      childIdentifier = make_shared<string>(boost::any_cast<string>(m["childIdentifier"]));
    }
    if (m.find("directoryIdentifier") != m.end() && !m["directoryIdentifier"].empty()) {
      directoryIdentifier = make_shared<string>(boost::any_cast<string>(m["directoryIdentifier"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("pathName") != m.end() && !m["pathName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["pathName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["pathName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      pathName = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateTestCaseResponseBodyTestcaseDirectory() = default;
};
class CreateTestCaseResponseBodyTestcaseModifier : public Darabonba::Model {
public:
  shared_ptr<string> modifyIdentifier{};
  shared_ptr<string> name{};

  CreateTestCaseResponseBodyTestcaseModifier() {}

  explicit CreateTestCaseResponseBodyTestcaseModifier(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (modifyIdentifier) {
      res["modifyIdentifier"] = boost::any(*modifyIdentifier);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("modifyIdentifier") != m.end() && !m["modifyIdentifier"].empty()) {
      modifyIdentifier = make_shared<string>(boost::any_cast<string>(m["modifyIdentifier"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~CreateTestCaseResponseBodyTestcaseModifier() = default;
};
class CreateTestCaseResponseBodyTestcase : public Darabonba::Model {
public:
  shared_ptr<CreateTestCaseResponseBodyTestcaseAssignedTo> assignedTo{};
  shared_ptr<string> categoryIdentifier{};
  shared_ptr<CreateTestCaseResponseBodyTestcaseCreator> creator{};
  shared_ptr<CreateTestCaseResponseBodyTestcaseDetailInfo> detailInfo{};
  shared_ptr<CreateTestCaseResponseBodyTestcaseDirectory> directory{};
  shared_ptr<string> identifier{};
  shared_ptr<CreateTestCaseResponseBodyTestcaseModifier> modifier{};
  shared_ptr<string> spaceIdentifier{};
  shared_ptr<string> spaceType{};
  shared_ptr<string> subject{};

  CreateTestCaseResponseBodyTestcase() {}

  explicit CreateTestCaseResponseBodyTestcase(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignedTo) {
      res["assignedTo"] = assignedTo ? boost::any(assignedTo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (categoryIdentifier) {
      res["categoryIdentifier"] = boost::any(*categoryIdentifier);
    }
    if (creator) {
      res["creator"] = creator ? boost::any(creator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (detailInfo) {
      res["detailInfo"] = detailInfo ? boost::any(detailInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (directory) {
      res["directory"] = directory ? boost::any(directory->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (modifier) {
      res["modifier"] = modifier ? boost::any(modifier->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spaceIdentifier) {
      res["spaceIdentifier"] = boost::any(*spaceIdentifier);
    }
    if (spaceType) {
      res["spaceType"] = boost::any(*spaceType);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignedTo") != m.end() && !m["assignedTo"].empty()) {
      if (typeid(map<string, boost::any>) == m["assignedTo"].type()) {
        CreateTestCaseResponseBodyTestcaseAssignedTo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["assignedTo"]));
        assignedTo = make_shared<CreateTestCaseResponseBodyTestcaseAssignedTo>(model1);
      }
    }
    if (m.find("categoryIdentifier") != m.end() && !m["categoryIdentifier"].empty()) {
      categoryIdentifier = make_shared<string>(boost::any_cast<string>(m["categoryIdentifier"]));
    }
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      if (typeid(map<string, boost::any>) == m["creator"].type()) {
        CreateTestCaseResponseBodyTestcaseCreator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["creator"]));
        creator = make_shared<CreateTestCaseResponseBodyTestcaseCreator>(model1);
      }
    }
    if (m.find("detailInfo") != m.end() && !m["detailInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["detailInfo"].type()) {
        CreateTestCaseResponseBodyTestcaseDetailInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["detailInfo"]));
        detailInfo = make_shared<CreateTestCaseResponseBodyTestcaseDetailInfo>(model1);
      }
    }
    if (m.find("directory") != m.end() && !m["directory"].empty()) {
      if (typeid(map<string, boost::any>) == m["directory"].type()) {
        CreateTestCaseResponseBodyTestcaseDirectory model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["directory"]));
        directory = make_shared<CreateTestCaseResponseBodyTestcaseDirectory>(model1);
      }
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("modifier") != m.end() && !m["modifier"].empty()) {
      if (typeid(map<string, boost::any>) == m["modifier"].type()) {
        CreateTestCaseResponseBodyTestcaseModifier model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["modifier"]));
        modifier = make_shared<CreateTestCaseResponseBodyTestcaseModifier>(model1);
      }
    }
    if (m.find("spaceIdentifier") != m.end() && !m["spaceIdentifier"].empty()) {
      spaceIdentifier = make_shared<string>(boost::any_cast<string>(m["spaceIdentifier"]));
    }
    if (m.find("spaceType") != m.end() && !m["spaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["spaceType"]));
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
  }


  virtual ~CreateTestCaseResponseBodyTestcase() = default;
};
class CreateTestCaseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<CreateTestCaseResponseBodyTestcase> testcase{};

  CreateTestCaseResponseBody() {}

  explicit CreateTestCaseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (testcase) {
      res["testcase"] = testcase ? boost::any(testcase->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("testcase") != m.end() && !m["testcase"].empty()) {
      if (typeid(map<string, boost::any>) == m["testcase"].type()) {
        CreateTestCaseResponseBodyTestcase model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["testcase"]));
        testcase = make_shared<CreateTestCaseResponseBodyTestcase>(model1);
      }
    }
  }


  virtual ~CreateTestCaseResponseBody() = default;
};
class CreateTestCaseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTestCaseResponseBody> body{};

  CreateTestCaseResponse() {}

  explicit CreateTestCaseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTestCaseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTestCaseResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTestCaseResponse() = default;
};
class CreateUserKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> keyScope{};
  shared_ptr<string> publicKey{};
  shared_ptr<string> title{};
  shared_ptr<string> organizationId{};

  CreateUserKeyRequest() {}

  explicit CreateUserKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (expireTime) {
      res["expireTime"] = boost::any(*expireTime);
    }
    if (keyScope) {
      res["keyScope"] = boost::any(*keyScope);
    }
    if (publicKey) {
      res["publicKey"] = boost::any(*publicKey);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("expireTime") != m.end() && !m["expireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["expireTime"]));
    }
    if (m.find("keyScope") != m.end() && !m["keyScope"].empty()) {
      keyScope = make_shared<string>(boost::any_cast<string>(m["keyScope"]));
    }
    if (m.find("publicKey") != m.end() && !m["publicKey"].empty()) {
      publicKey = make_shared<string>(boost::any_cast<string>(m["publicKey"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~CreateUserKeyRequest() = default;
};
class CreateUserKeyResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> createdAt{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> fingerPrint{};
  shared_ptr<long> id{};
  shared_ptr<string> keyScope{};
  shared_ptr<string> lastUsedTime{};
  shared_ptr<string> publicKey{};
  shared_ptr<string> title{};

  CreateUserKeyResponseBodyResult() {}

  explicit CreateUserKeyResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (expireTime) {
      res["expireTime"] = boost::any(*expireTime);
    }
    if (fingerPrint) {
      res["fingerPrint"] = boost::any(*fingerPrint);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (keyScope) {
      res["keyScope"] = boost::any(*keyScope);
    }
    if (lastUsedTime) {
      res["lastUsedTime"] = boost::any(*lastUsedTime);
    }
    if (publicKey) {
      res["publicKey"] = boost::any(*publicKey);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("expireTime") != m.end() && !m["expireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["expireTime"]));
    }
    if (m.find("fingerPrint") != m.end() && !m["fingerPrint"].empty()) {
      fingerPrint = make_shared<string>(boost::any_cast<string>(m["fingerPrint"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("keyScope") != m.end() && !m["keyScope"].empty()) {
      keyScope = make_shared<string>(boost::any_cast<string>(m["keyScope"]));
    }
    if (m.find("lastUsedTime") != m.end() && !m["lastUsedTime"].empty()) {
      lastUsedTime = make_shared<string>(boost::any_cast<string>(m["lastUsedTime"]));
    }
    if (m.find("publicKey") != m.end() && !m["publicKey"].empty()) {
      publicKey = make_shared<string>(boost::any_cast<string>(m["publicKey"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~CreateUserKeyResponseBodyResult() = default;
};
class CreateUserKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateUserKeyResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateUserKeyResponseBody() {}

  explicit CreateUserKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        CreateUserKeyResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<CreateUserKeyResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreateUserKeyResponseBody() = default;
};
class CreateUserKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateUserKeyResponseBody> body{};

  CreateUserKeyResponse() {}

  explicit CreateUserKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUserKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUserKeyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUserKeyResponse() = default;
};
class CreateVariableGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> variables{};

  CreateVariableGroupRequest() {}

  explicit CreateVariableGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (variables) {
      res["variables"] = boost::any(*variables);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("variables") != m.end() && !m["variables"].empty()) {
      variables = make_shared<string>(boost::any_cast<string>(m["variables"]));
    }
  }


  virtual ~CreateVariableGroupRequest() = default;
};
class CreateVariableGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> variableGroupId{};

  CreateVariableGroupResponseBody() {}

  explicit CreateVariableGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (variableGroupId) {
      res["variableGroupId"] = boost::any(*variableGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("variableGroupId") != m.end() && !m["variableGroupId"].empty()) {
      variableGroupId = make_shared<long>(boost::any_cast<long>(m["variableGroupId"]));
    }
  }


  virtual ~CreateVariableGroupResponseBody() = default;
};
class CreateVariableGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateVariableGroupResponseBody> body{};

  CreateVariableGroupResponse() {}

  explicit CreateVariableGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVariableGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVariableGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVariableGroupResponse() = default;
};
class CreateWorkitemRequestFieldValueList : public Darabonba::Model {
public:
  shared_ptr<string> fieldIdentifier{};
  shared_ptr<string> value{};
  shared_ptr<string> workitemIdentifier{};

  CreateWorkitemRequestFieldValueList() {}

  explicit CreateWorkitemRequestFieldValueList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldIdentifier) {
      res["fieldIdentifier"] = boost::any(*fieldIdentifier);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    if (workitemIdentifier) {
      res["workitemIdentifier"] = boost::any(*workitemIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fieldIdentifier") != m.end() && !m["fieldIdentifier"].empty()) {
      fieldIdentifier = make_shared<string>(boost::any_cast<string>(m["fieldIdentifier"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
    if (m.find("workitemIdentifier") != m.end() && !m["workitemIdentifier"].empty()) {
      workitemIdentifier = make_shared<string>(boost::any_cast<string>(m["workitemIdentifier"]));
    }
  }


  virtual ~CreateWorkitemRequestFieldValueList() = default;
};
class CreateWorkitemRequest : public Darabonba::Model {
public:
  shared_ptr<string> assignedTo{};
  shared_ptr<string> category{};
  shared_ptr<string> description{};
  shared_ptr<string> descriptionFormat{};
  shared_ptr<vector<CreateWorkitemRequestFieldValueList>> fieldValueList{};
  shared_ptr<string> parent{};
  shared_ptr<vector<string>> participant{};
  shared_ptr<string> space{};
  shared_ptr<string> spaceIdentifier{};
  shared_ptr<string> spaceType{};
  shared_ptr<vector<string>> sprint{};
  shared_ptr<string> subject{};
  shared_ptr<vector<string>> tracker{};
  shared_ptr<vector<string>> verifier{};
  shared_ptr<string> workitemType{};

  CreateWorkitemRequest() {}

  explicit CreateWorkitemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignedTo) {
      res["assignedTo"] = boost::any(*assignedTo);
    }
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (descriptionFormat) {
      res["descriptionFormat"] = boost::any(*descriptionFormat);
    }
    if (fieldValueList) {
      vector<boost::any> temp1;
      for(auto item1:*fieldValueList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["fieldValueList"] = boost::any(temp1);
    }
    if (parent) {
      res["parent"] = boost::any(*parent);
    }
    if (participant) {
      res["participant"] = boost::any(*participant);
    }
    if (space) {
      res["space"] = boost::any(*space);
    }
    if (spaceIdentifier) {
      res["spaceIdentifier"] = boost::any(*spaceIdentifier);
    }
    if (spaceType) {
      res["spaceType"] = boost::any(*spaceType);
    }
    if (sprint) {
      res["sprint"] = boost::any(*sprint);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    if (tracker) {
      res["tracker"] = boost::any(*tracker);
    }
    if (verifier) {
      res["verifier"] = boost::any(*verifier);
    }
    if (workitemType) {
      res["workitemType"] = boost::any(*workitemType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignedTo") != m.end() && !m["assignedTo"].empty()) {
      assignedTo = make_shared<string>(boost::any_cast<string>(m["assignedTo"]));
    }
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["category"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("descriptionFormat") != m.end() && !m["descriptionFormat"].empty()) {
      descriptionFormat = make_shared<string>(boost::any_cast<string>(m["descriptionFormat"]));
    }
    if (m.find("fieldValueList") != m.end() && !m["fieldValueList"].empty()) {
      if (typeid(vector<boost::any>) == m["fieldValueList"].type()) {
        vector<CreateWorkitemRequestFieldValueList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["fieldValueList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateWorkitemRequestFieldValueList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fieldValueList = make_shared<vector<CreateWorkitemRequestFieldValueList>>(expect1);
      }
    }
    if (m.find("parent") != m.end() && !m["parent"].empty()) {
      parent = make_shared<string>(boost::any_cast<string>(m["parent"]));
    }
    if (m.find("participant") != m.end() && !m["participant"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["participant"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["participant"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      participant = make_shared<vector<string>>(toVec1);
    }
    if (m.find("space") != m.end() && !m["space"].empty()) {
      space = make_shared<string>(boost::any_cast<string>(m["space"]));
    }
    if (m.find("spaceIdentifier") != m.end() && !m["spaceIdentifier"].empty()) {
      spaceIdentifier = make_shared<string>(boost::any_cast<string>(m["spaceIdentifier"]));
    }
    if (m.find("spaceType") != m.end() && !m["spaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["spaceType"]));
    }
    if (m.find("sprint") != m.end() && !m["sprint"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sprint"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sprint"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sprint = make_shared<vector<string>>(toVec1);
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
    if (m.find("tracker") != m.end() && !m["tracker"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["tracker"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["tracker"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tracker = make_shared<vector<string>>(toVec1);
    }
    if (m.find("verifier") != m.end() && !m["verifier"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["verifier"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["verifier"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      verifier = make_shared<vector<string>>(toVec1);
    }
    if (m.find("workitemType") != m.end() && !m["workitemType"].empty()) {
      workitemType = make_shared<string>(boost::any_cast<string>(m["workitemType"]));
    }
  }


  virtual ~CreateWorkitemRequest() = default;
};
class CreateWorkitemResponseBodyWorkitem : public Darabonba::Model {
public:
  shared_ptr<string> assignedTo{};
  shared_ptr<string> categoryIdentifier{};
  shared_ptr<string> creator{};
  shared_ptr<string> document{};
  shared_ptr<string> documentFormat{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> identifier{};
  shared_ptr<string> logicalStatus{};
  shared_ptr<string> modifier{};
  shared_ptr<string> parentIdentifier{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> spaceIdentifier{};
  shared_ptr<string> spaceName{};
  shared_ptr<string> spaceType{};
  shared_ptr<string> sprintIdentifier{};
  shared_ptr<string> status{};
  shared_ptr<string> statusIdentifier{};
  shared_ptr<string> statusStageIdentifier{};
  shared_ptr<string> subject{};
  shared_ptr<long> updateStatusAt{};
  shared_ptr<string> workitemTypeIdentifier{};

  CreateWorkitemResponseBodyWorkitem() {}

  explicit CreateWorkitemResponseBodyWorkitem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignedTo) {
      res["assignedTo"] = boost::any(*assignedTo);
    }
    if (categoryIdentifier) {
      res["categoryIdentifier"] = boost::any(*categoryIdentifier);
    }
    if (creator) {
      res["creator"] = boost::any(*creator);
    }
    if (document) {
      res["document"] = boost::any(*document);
    }
    if (documentFormat) {
      res["documentFormat"] = boost::any(*documentFormat);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (logicalStatus) {
      res["logicalStatus"] = boost::any(*logicalStatus);
    }
    if (modifier) {
      res["modifier"] = boost::any(*modifier);
    }
    if (parentIdentifier) {
      res["parentIdentifier"] = boost::any(*parentIdentifier);
    }
    if (serialNumber) {
      res["serialNumber"] = boost::any(*serialNumber);
    }
    if (spaceIdentifier) {
      res["spaceIdentifier"] = boost::any(*spaceIdentifier);
    }
    if (spaceName) {
      res["spaceName"] = boost::any(*spaceName);
    }
    if (spaceType) {
      res["spaceType"] = boost::any(*spaceType);
    }
    if (sprintIdentifier) {
      res["sprintIdentifier"] = boost::any(*sprintIdentifier);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (statusIdentifier) {
      res["statusIdentifier"] = boost::any(*statusIdentifier);
    }
    if (statusStageIdentifier) {
      res["statusStageIdentifier"] = boost::any(*statusStageIdentifier);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    if (updateStatusAt) {
      res["updateStatusAt"] = boost::any(*updateStatusAt);
    }
    if (workitemTypeIdentifier) {
      res["workitemTypeIdentifier"] = boost::any(*workitemTypeIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignedTo") != m.end() && !m["assignedTo"].empty()) {
      assignedTo = make_shared<string>(boost::any_cast<string>(m["assignedTo"]));
    }
    if (m.find("categoryIdentifier") != m.end() && !m["categoryIdentifier"].empty()) {
      categoryIdentifier = make_shared<string>(boost::any_cast<string>(m["categoryIdentifier"]));
    }
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["creator"]));
    }
    if (m.find("document") != m.end() && !m["document"].empty()) {
      document = make_shared<string>(boost::any_cast<string>(m["document"]));
    }
    if (m.find("documentFormat") != m.end() && !m["documentFormat"].empty()) {
      documentFormat = make_shared<string>(boost::any_cast<string>(m["documentFormat"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("logicalStatus") != m.end() && !m["logicalStatus"].empty()) {
      logicalStatus = make_shared<string>(boost::any_cast<string>(m["logicalStatus"]));
    }
    if (m.find("modifier") != m.end() && !m["modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["modifier"]));
    }
    if (m.find("parentIdentifier") != m.end() && !m["parentIdentifier"].empty()) {
      parentIdentifier = make_shared<string>(boost::any_cast<string>(m["parentIdentifier"]));
    }
    if (m.find("serialNumber") != m.end() && !m["serialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["serialNumber"]));
    }
    if (m.find("spaceIdentifier") != m.end() && !m["spaceIdentifier"].empty()) {
      spaceIdentifier = make_shared<string>(boost::any_cast<string>(m["spaceIdentifier"]));
    }
    if (m.find("spaceName") != m.end() && !m["spaceName"].empty()) {
      spaceName = make_shared<string>(boost::any_cast<string>(m["spaceName"]));
    }
    if (m.find("spaceType") != m.end() && !m["spaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["spaceType"]));
    }
    if (m.find("sprintIdentifier") != m.end() && !m["sprintIdentifier"].empty()) {
      sprintIdentifier = make_shared<string>(boost::any_cast<string>(m["sprintIdentifier"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("statusIdentifier") != m.end() && !m["statusIdentifier"].empty()) {
      statusIdentifier = make_shared<string>(boost::any_cast<string>(m["statusIdentifier"]));
    }
    if (m.find("statusStageIdentifier") != m.end() && !m["statusStageIdentifier"].empty()) {
      statusStageIdentifier = make_shared<string>(boost::any_cast<string>(m["statusStageIdentifier"]));
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
    if (m.find("updateStatusAt") != m.end() && !m["updateStatusAt"].empty()) {
      updateStatusAt = make_shared<long>(boost::any_cast<long>(m["updateStatusAt"]));
    }
    if (m.find("workitemTypeIdentifier") != m.end() && !m["workitemTypeIdentifier"].empty()) {
      workitemTypeIdentifier = make_shared<string>(boost::any_cast<string>(m["workitemTypeIdentifier"]));
    }
  }


  virtual ~CreateWorkitemResponseBodyWorkitem() = default;
};
class CreateWorkitemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<CreateWorkitemResponseBodyWorkitem> workitem{};

  CreateWorkitemResponseBody() {}

  explicit CreateWorkitemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (workitem) {
      res["workitem"] = workitem ? boost::any(workitem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("workitem") != m.end() && !m["workitem"].empty()) {
      if (typeid(map<string, boost::any>) == m["workitem"].type()) {
        CreateWorkitemResponseBodyWorkitem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["workitem"]));
        workitem = make_shared<CreateWorkitemResponseBodyWorkitem>(model1);
      }
    }
  }


  virtual ~CreateWorkitemResponseBody() = default;
};
class CreateWorkitemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateWorkitemResponseBody> body{};

  CreateWorkitemResponse() {}

  explicit CreateWorkitemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateWorkitemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateWorkitemResponseBody>(model1);
      }
    }
  }


  virtual ~CreateWorkitemResponse() = default;
};
class CreateWorkitemCommentRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> formatType{};
  shared_ptr<string> parentId{};
  shared_ptr<string> workitemIdentifier{};

  CreateWorkitemCommentRequest() {}

  explicit CreateWorkitemCommentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (formatType) {
      res["formatType"] = boost::any(*formatType);
    }
    if (parentId) {
      res["parentId"] = boost::any(*parentId);
    }
    if (workitemIdentifier) {
      res["workitemIdentifier"] = boost::any(*workitemIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("formatType") != m.end() && !m["formatType"].empty()) {
      formatType = make_shared<string>(boost::any_cast<string>(m["formatType"]));
    }
    if (m.find("parentId") != m.end() && !m["parentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["parentId"]));
    }
    if (m.find("workitemIdentifier") != m.end() && !m["workitemIdentifier"].empty()) {
      workitemIdentifier = make_shared<string>(boost::any_cast<string>(m["workitemIdentifier"]));
    }
  }


  virtual ~CreateWorkitemCommentRequest() = default;
};
class CreateWorkitemCommentResponseBodyCommentUser : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> avatar{};
  shared_ptr<string> displayName{};
  shared_ptr<string> identifier{};
  shared_ptr<string> nickName{};
  shared_ptr<string> realName{};
  shared_ptr<string> targetType{};

  CreateWorkitemCommentResponseBodyCommentUser() {}

  explicit CreateWorkitemCommentResponseBodyCommentUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["account"] = boost::any(*account);
    }
    if (avatar) {
      res["avatar"] = boost::any(*avatar);
    }
    if (displayName) {
      res["displayName"] = boost::any(*displayName);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (nickName) {
      res["nickName"] = boost::any(*nickName);
    }
    if (realName) {
      res["realName"] = boost::any(*realName);
    }
    if (targetType) {
      res["targetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("account") != m.end() && !m["account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["account"]));
    }
    if (m.find("avatar") != m.end() && !m["avatar"].empty()) {
      avatar = make_shared<string>(boost::any_cast<string>(m["avatar"]));
    }
    if (m.find("displayName") != m.end() && !m["displayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["displayName"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("nickName") != m.end() && !m["nickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["nickName"]));
    }
    if (m.find("realName") != m.end() && !m["realName"].empty()) {
      realName = make_shared<string>(boost::any_cast<string>(m["realName"]));
    }
    if (m.find("targetType") != m.end() && !m["targetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["targetType"]));
    }
  }


  virtual ~CreateWorkitemCommentResponseBodyCommentUser() = default;
};
class CreateWorkitemCommentResponseBodyComment : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> content{};
  shared_ptr<long> createTime{};
  shared_ptr<string> formatType{};
  shared_ptr<bool> isTop{};
  shared_ptr<long> modifiedTime{};
  shared_ptr<long> parentId{};
  shared_ptr<string> targetIdentifier{};
  shared_ptr<string> targetType{};
  shared_ptr<long> topTime{};
  shared_ptr<CreateWorkitemCommentResponseBodyCommentUser> user{};

  CreateWorkitemCommentResponseBodyComment() {}

  explicit CreateWorkitemCommentResponseBodyComment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (formatType) {
      res["formatType"] = boost::any(*formatType);
    }
    if (isTop) {
      res["isTop"] = boost::any(*isTop);
    }
    if (modifiedTime) {
      res["modifiedTime"] = boost::any(*modifiedTime);
    }
    if (parentId) {
      res["parentId"] = boost::any(*parentId);
    }
    if (targetIdentifier) {
      res["targetIdentifier"] = boost::any(*targetIdentifier);
    }
    if (targetType) {
      res["targetType"] = boost::any(*targetType);
    }
    if (topTime) {
      res["topTime"] = boost::any(*topTime);
    }
    if (user) {
      res["user"] = user ? boost::any(user->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["createTime"]));
    }
    if (m.find("formatType") != m.end() && !m["formatType"].empty()) {
      formatType = make_shared<string>(boost::any_cast<string>(m["formatType"]));
    }
    if (m.find("isTop") != m.end() && !m["isTop"].empty()) {
      isTop = make_shared<bool>(boost::any_cast<bool>(m["isTop"]));
    }
    if (m.find("modifiedTime") != m.end() && !m["modifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["modifiedTime"]));
    }
    if (m.find("parentId") != m.end() && !m["parentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["parentId"]));
    }
    if (m.find("targetIdentifier") != m.end() && !m["targetIdentifier"].empty()) {
      targetIdentifier = make_shared<string>(boost::any_cast<string>(m["targetIdentifier"]));
    }
    if (m.find("targetType") != m.end() && !m["targetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["targetType"]));
    }
    if (m.find("topTime") != m.end() && !m["topTime"].empty()) {
      topTime = make_shared<long>(boost::any_cast<long>(m["topTime"]));
    }
    if (m.find("user") != m.end() && !m["user"].empty()) {
      if (typeid(map<string, boost::any>) == m["user"].type()) {
        CreateWorkitemCommentResponseBodyCommentUser model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["user"]));
        user = make_shared<CreateWorkitemCommentResponseBodyCommentUser>(model1);
      }
    }
  }


  virtual ~CreateWorkitemCommentResponseBodyComment() = default;
};
class CreateWorkitemCommentResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateWorkitemCommentResponseBodyComment> comment{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  CreateWorkitemCommentResponseBody() {}

  explicit CreateWorkitemCommentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = comment ? boost::any(comment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Comment"].type()) {
        CreateWorkitemCommentResponseBodyComment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Comment"]));
        comment = make_shared<CreateWorkitemCommentResponseBodyComment>(model1);
      }
    }
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["success"]));
    }
  }


  virtual ~CreateWorkitemCommentResponseBody() = default;
};
class CreateWorkitemCommentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateWorkitemCommentResponseBody> body{};

  CreateWorkitemCommentResponse() {}

  explicit CreateWorkitemCommentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateWorkitemCommentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateWorkitemCommentResponseBody>(model1);
      }
    }
  }


  virtual ~CreateWorkitemCommentResponse() = default;
};
class CreateWorkitemEstimateRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> recordUserIdentifier{};
  shared_ptr<string> spentTime{};
  shared_ptr<string> type{};
  shared_ptr<string> workitemIdentifier{};

  CreateWorkitemEstimateRequest() {}

  explicit CreateWorkitemEstimateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (recordUserIdentifier) {
      res["recordUserIdentifier"] = boost::any(*recordUserIdentifier);
    }
    if (spentTime) {
      res["spentTime"] = boost::any(*spentTime);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (workitemIdentifier) {
      res["workitemIdentifier"] = boost::any(*workitemIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("recordUserIdentifier") != m.end() && !m["recordUserIdentifier"].empty()) {
      recordUserIdentifier = make_shared<string>(boost::any_cast<string>(m["recordUserIdentifier"]));
    }
    if (m.find("spentTime") != m.end() && !m["spentTime"].empty()) {
      spentTime = make_shared<string>(boost::any_cast<string>(m["spentTime"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("workitemIdentifier") != m.end() && !m["workitemIdentifier"].empty()) {
      workitemIdentifier = make_shared<string>(boost::any_cast<string>(m["workitemIdentifier"]));
    }
  }


  virtual ~CreateWorkitemEstimateRequest() = default;
};
class CreateWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> avatar{};
  shared_ptr<string> dingTalkId{};
  shared_ptr<string> displayName{};
  shared_ptr<string> displayNickName{};
  shared_ptr<string> displayRealName{};
  shared_ptr<string> email{};
  shared_ptr<string> gender{};
  shared_ptr<string> identifier{};
  shared_ptr<bool> isDisabled{};
  shared_ptr<string> mobile{};
  shared_ptr<string> nameEn{};
  shared_ptr<string> nickName{};
  shared_ptr<string> nickNamePinyin{};
  shared_ptr<string> realName{};
  shared_ptr<string> realNamePinyin{};
  shared_ptr<string> stamp{};
  shared_ptr<string> tbRoleId{};

  CreateWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser() {}

  explicit CreateWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["account"] = boost::any(*account);
    }
    if (avatar) {
      res["avatar"] = boost::any(*avatar);
    }
    if (dingTalkId) {
      res["dingTalkId"] = boost::any(*dingTalkId);
    }
    if (displayName) {
      res["displayName"] = boost::any(*displayName);
    }
    if (displayNickName) {
      res["displayNickName"] = boost::any(*displayNickName);
    }
    if (displayRealName) {
      res["displayRealName"] = boost::any(*displayRealName);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (gender) {
      res["gender"] = boost::any(*gender);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (isDisabled) {
      res["isDisabled"] = boost::any(*isDisabled);
    }
    if (mobile) {
      res["mobile"] = boost::any(*mobile);
    }
    if (nameEn) {
      res["nameEn"] = boost::any(*nameEn);
    }
    if (nickName) {
      res["nickName"] = boost::any(*nickName);
    }
    if (nickNamePinyin) {
      res["nickNamePinyin"] = boost::any(*nickNamePinyin);
    }
    if (realName) {
      res["realName"] = boost::any(*realName);
    }
    if (realNamePinyin) {
      res["realNamePinyin"] = boost::any(*realNamePinyin);
    }
    if (stamp) {
      res["stamp"] = boost::any(*stamp);
    }
    if (tbRoleId) {
      res["tbRoleId"] = boost::any(*tbRoleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("account") != m.end() && !m["account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["account"]));
    }
    if (m.find("avatar") != m.end() && !m["avatar"].empty()) {
      avatar = make_shared<string>(boost::any_cast<string>(m["avatar"]));
    }
    if (m.find("dingTalkId") != m.end() && !m["dingTalkId"].empty()) {
      dingTalkId = make_shared<string>(boost::any_cast<string>(m["dingTalkId"]));
    }
    if (m.find("displayName") != m.end() && !m["displayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["displayName"]));
    }
    if (m.find("displayNickName") != m.end() && !m["displayNickName"].empty()) {
      displayNickName = make_shared<string>(boost::any_cast<string>(m["displayNickName"]));
    }
    if (m.find("displayRealName") != m.end() && !m["displayRealName"].empty()) {
      displayRealName = make_shared<string>(boost::any_cast<string>(m["displayRealName"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("gender") != m.end() && !m["gender"].empty()) {
      gender = make_shared<string>(boost::any_cast<string>(m["gender"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("isDisabled") != m.end() && !m["isDisabled"].empty()) {
      isDisabled = make_shared<bool>(boost::any_cast<bool>(m["isDisabled"]));
    }
    if (m.find("mobile") != m.end() && !m["mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["mobile"]));
    }
    if (m.find("nameEn") != m.end() && !m["nameEn"].empty()) {
      nameEn = make_shared<string>(boost::any_cast<string>(m["nameEn"]));
    }
    if (m.find("nickName") != m.end() && !m["nickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["nickName"]));
    }
    if (m.find("nickNamePinyin") != m.end() && !m["nickNamePinyin"].empty()) {
      nickNamePinyin = make_shared<string>(boost::any_cast<string>(m["nickNamePinyin"]));
    }
    if (m.find("realName") != m.end() && !m["realName"].empty()) {
      realName = make_shared<string>(boost::any_cast<string>(m["realName"]));
    }
    if (m.find("realNamePinyin") != m.end() && !m["realNamePinyin"].empty()) {
      realNamePinyin = make_shared<string>(boost::any_cast<string>(m["realNamePinyin"]));
    }
    if (m.find("stamp") != m.end() && !m["stamp"].empty()) {
      stamp = make_shared<string>(boost::any_cast<string>(m["stamp"]));
    }
    if (m.find("tbRoleId") != m.end() && !m["tbRoleId"].empty()) {
      tbRoleId = make_shared<string>(boost::any_cast<string>(m["tbRoleId"]));
    }
  }


  virtual ~CreateWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser() = default;
};
class CreateWorkitemEstimateResponseBodyWorkitemTimeEstimate : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> identifier{};
  shared_ptr<CreateWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser> recordUser{};
  shared_ptr<long> spentTime{};
  shared_ptr<string> type{};
  shared_ptr<string> workitemIdentifier{};

  CreateWorkitemEstimateResponseBodyWorkitemTimeEstimate() {}

  explicit CreateWorkitemEstimateResponseBodyWorkitemTimeEstimate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (recordUser) {
      res["recordUser"] = recordUser ? boost::any(recordUser->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spentTime) {
      res["spentTime"] = boost::any(*spentTime);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (workitemIdentifier) {
      res["workitemIdentifier"] = boost::any(*workitemIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("recordUser") != m.end() && !m["recordUser"].empty()) {
      if (typeid(map<string, boost::any>) == m["recordUser"].type()) {
        CreateWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["recordUser"]));
        recordUser = make_shared<CreateWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser>(model1);
      }
    }
    if (m.find("spentTime") != m.end() && !m["spentTime"].empty()) {
      spentTime = make_shared<long>(boost::any_cast<long>(m["spentTime"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("workitemIdentifier") != m.end() && !m["workitemIdentifier"].empty()) {
      workitemIdentifier = make_shared<string>(boost::any_cast<string>(m["workitemIdentifier"]));
    }
  }


  virtual ~CreateWorkitemEstimateResponseBodyWorkitemTimeEstimate() = default;
};
class CreateWorkitemEstimateResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateWorkitemEstimateResponseBodyWorkitemTimeEstimate> workitemTimeEstimate{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateWorkitemEstimateResponseBody() {}

  explicit CreateWorkitemEstimateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (workitemTimeEstimate) {
      res["WorkitemTimeEstimate"] = workitemTimeEstimate ? boost::any(workitemTimeEstimate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WorkitemTimeEstimate") != m.end() && !m["WorkitemTimeEstimate"].empty()) {
      if (typeid(map<string, boost::any>) == m["WorkitemTimeEstimate"].type()) {
        CreateWorkitemEstimateResponseBodyWorkitemTimeEstimate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WorkitemTimeEstimate"]));
        workitemTimeEstimate = make_shared<CreateWorkitemEstimateResponseBodyWorkitemTimeEstimate>(model1);
      }
    }
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreateWorkitemEstimateResponseBody() = default;
};
class CreateWorkitemEstimateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateWorkitemEstimateResponseBody> body{};

  CreateWorkitemEstimateResponse() {}

  explicit CreateWorkitemEstimateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateWorkitemEstimateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateWorkitemEstimateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateWorkitemEstimateResponse() = default;
};
class CreateWorkitemRecordRequest : public Darabonba::Model {
public:
  shared_ptr<string> actualTime{};
  shared_ptr<string> description{};
  shared_ptr<string> gmtEnd{};
  shared_ptr<string> gmtStart{};
  shared_ptr<string> recordUserIdentifier{};
  shared_ptr<string> type{};
  shared_ptr<string> workitemIdentifier{};

  CreateWorkitemRecordRequest() {}

  explicit CreateWorkitemRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualTime) {
      res["actualTime"] = boost::any(*actualTime);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (gmtEnd) {
      res["gmtEnd"] = boost::any(*gmtEnd);
    }
    if (gmtStart) {
      res["gmtStart"] = boost::any(*gmtStart);
    }
    if (recordUserIdentifier) {
      res["recordUserIdentifier"] = boost::any(*recordUserIdentifier);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (workitemIdentifier) {
      res["workitemIdentifier"] = boost::any(*workitemIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("actualTime") != m.end() && !m["actualTime"].empty()) {
      actualTime = make_shared<string>(boost::any_cast<string>(m["actualTime"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("gmtEnd") != m.end() && !m["gmtEnd"].empty()) {
      gmtEnd = make_shared<string>(boost::any_cast<string>(m["gmtEnd"]));
    }
    if (m.find("gmtStart") != m.end() && !m["gmtStart"].empty()) {
      gmtStart = make_shared<string>(boost::any_cast<string>(m["gmtStart"]));
    }
    if (m.find("recordUserIdentifier") != m.end() && !m["recordUserIdentifier"].empty()) {
      recordUserIdentifier = make_shared<string>(boost::any_cast<string>(m["recordUserIdentifier"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("workitemIdentifier") != m.end() && !m["workitemIdentifier"].empty()) {
      workitemIdentifier = make_shared<string>(boost::any_cast<string>(m["workitemIdentifier"]));
    }
  }


  virtual ~CreateWorkitemRecordRequest() = default;
};
class CreateWorkitemRecordResponseBodyWorkitemTimeRecordUser : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> avatar{};
  shared_ptr<string> dingTalkId{};
  shared_ptr<string> displayName{};
  shared_ptr<string> displayNickName{};
  shared_ptr<string> displayRealName{};
  shared_ptr<string> email{};
  shared_ptr<string> gender{};
  shared_ptr<string> identifier{};
  shared_ptr<bool> isDisabled{};
  shared_ptr<string> mobile{};
  shared_ptr<string> nameEn{};
  shared_ptr<string> nickName{};
  shared_ptr<string> nickNamePinyin{};
  shared_ptr<string> realName{};
  shared_ptr<string> realNamePinyin{};
  shared_ptr<string> stamp{};
  shared_ptr<string> tbRoleId{};

  CreateWorkitemRecordResponseBodyWorkitemTimeRecordUser() {}

  explicit CreateWorkitemRecordResponseBodyWorkitemTimeRecordUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["account"] = boost::any(*account);
    }
    if (avatar) {
      res["avatar"] = boost::any(*avatar);
    }
    if (dingTalkId) {
      res["dingTalkId"] = boost::any(*dingTalkId);
    }
    if (displayName) {
      res["displayName"] = boost::any(*displayName);
    }
    if (displayNickName) {
      res["displayNickName"] = boost::any(*displayNickName);
    }
    if (displayRealName) {
      res["displayRealName"] = boost::any(*displayRealName);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (gender) {
      res["gender"] = boost::any(*gender);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (isDisabled) {
      res["isDisabled"] = boost::any(*isDisabled);
    }
    if (mobile) {
      res["mobile"] = boost::any(*mobile);
    }
    if (nameEn) {
      res["nameEn"] = boost::any(*nameEn);
    }
    if (nickName) {
      res["nickName"] = boost::any(*nickName);
    }
    if (nickNamePinyin) {
      res["nickNamePinyin"] = boost::any(*nickNamePinyin);
    }
    if (realName) {
      res["realName"] = boost::any(*realName);
    }
    if (realNamePinyin) {
      res["realNamePinyin"] = boost::any(*realNamePinyin);
    }
    if (stamp) {
      res["stamp"] = boost::any(*stamp);
    }
    if (tbRoleId) {
      res["tbRoleId"] = boost::any(*tbRoleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("account") != m.end() && !m["account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["account"]));
    }
    if (m.find("avatar") != m.end() && !m["avatar"].empty()) {
      avatar = make_shared<string>(boost::any_cast<string>(m["avatar"]));
    }
    if (m.find("dingTalkId") != m.end() && !m["dingTalkId"].empty()) {
      dingTalkId = make_shared<string>(boost::any_cast<string>(m["dingTalkId"]));
    }
    if (m.find("displayName") != m.end() && !m["displayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["displayName"]));
    }
    if (m.find("displayNickName") != m.end() && !m["displayNickName"].empty()) {
      displayNickName = make_shared<string>(boost::any_cast<string>(m["displayNickName"]));
    }
    if (m.find("displayRealName") != m.end() && !m["displayRealName"].empty()) {
      displayRealName = make_shared<string>(boost::any_cast<string>(m["displayRealName"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("gender") != m.end() && !m["gender"].empty()) {
      gender = make_shared<string>(boost::any_cast<string>(m["gender"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("isDisabled") != m.end() && !m["isDisabled"].empty()) {
      isDisabled = make_shared<bool>(boost::any_cast<bool>(m["isDisabled"]));
    }
    if (m.find("mobile") != m.end() && !m["mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["mobile"]));
    }
    if (m.find("nameEn") != m.end() && !m["nameEn"].empty()) {
      nameEn = make_shared<string>(boost::any_cast<string>(m["nameEn"]));
    }
    if (m.find("nickName") != m.end() && !m["nickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["nickName"]));
    }
    if (m.find("nickNamePinyin") != m.end() && !m["nickNamePinyin"].empty()) {
      nickNamePinyin = make_shared<string>(boost::any_cast<string>(m["nickNamePinyin"]));
    }
    if (m.find("realName") != m.end() && !m["realName"].empty()) {
      realName = make_shared<string>(boost::any_cast<string>(m["realName"]));
    }
    if (m.find("realNamePinyin") != m.end() && !m["realNamePinyin"].empty()) {
      realNamePinyin = make_shared<string>(boost::any_cast<string>(m["realNamePinyin"]));
    }
    if (m.find("stamp") != m.end() && !m["stamp"].empty()) {
      stamp = make_shared<string>(boost::any_cast<string>(m["stamp"]));
    }
    if (m.find("tbRoleId") != m.end() && !m["tbRoleId"].empty()) {
      tbRoleId = make_shared<string>(boost::any_cast<string>(m["tbRoleId"]));
    }
  }


  virtual ~CreateWorkitemRecordResponseBodyWorkitemTimeRecordUser() = default;
};
class CreateWorkitemRecordResponseBodyWorkitemTime : public Darabonba::Model {
public:
  shared_ptr<long> actualTime{};
  shared_ptr<string> description{};
  shared_ptr<long> gmtEnd{};
  shared_ptr<long> gmtStart{};
  shared_ptr<string> identifier{};
  shared_ptr<CreateWorkitemRecordResponseBodyWorkitemTimeRecordUser> recordUser{};
  shared_ptr<string> type{};
  shared_ptr<string> workitemIdentifier{};

  CreateWorkitemRecordResponseBodyWorkitemTime() {}

  explicit CreateWorkitemRecordResponseBodyWorkitemTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualTime) {
      res["actualTime"] = boost::any(*actualTime);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (gmtEnd) {
      res["gmtEnd"] = boost::any(*gmtEnd);
    }
    if (gmtStart) {
      res["gmtStart"] = boost::any(*gmtStart);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (recordUser) {
      res["recordUser"] = recordUser ? boost::any(recordUser->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (workitemIdentifier) {
      res["workitemIdentifier"] = boost::any(*workitemIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("actualTime") != m.end() && !m["actualTime"].empty()) {
      actualTime = make_shared<long>(boost::any_cast<long>(m["actualTime"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("gmtEnd") != m.end() && !m["gmtEnd"].empty()) {
      gmtEnd = make_shared<long>(boost::any_cast<long>(m["gmtEnd"]));
    }
    if (m.find("gmtStart") != m.end() && !m["gmtStart"].empty()) {
      gmtStart = make_shared<long>(boost::any_cast<long>(m["gmtStart"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("recordUser") != m.end() && !m["recordUser"].empty()) {
      if (typeid(map<string, boost::any>) == m["recordUser"].type()) {
        CreateWorkitemRecordResponseBodyWorkitemTimeRecordUser model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["recordUser"]));
        recordUser = make_shared<CreateWorkitemRecordResponseBodyWorkitemTimeRecordUser>(model1);
      }
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("workitemIdentifier") != m.end() && !m["workitemIdentifier"].empty()) {
      workitemIdentifier = make_shared<string>(boost::any_cast<string>(m["workitemIdentifier"]));
    }
  }


  virtual ~CreateWorkitemRecordResponseBodyWorkitemTime() = default;
};
class CreateWorkitemRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateWorkitemRecordResponseBodyWorkitemTime> workitemTime{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateWorkitemRecordResponseBody() {}

  explicit CreateWorkitemRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (workitemTime) {
      res["WorkitemTime"] = workitemTime ? boost::any(workitemTime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WorkitemTime") != m.end() && !m["WorkitemTime"].empty()) {
      if (typeid(map<string, boost::any>) == m["WorkitemTime"].type()) {
        CreateWorkitemRecordResponseBodyWorkitemTime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WorkitemTime"]));
        workitemTime = make_shared<CreateWorkitemRecordResponseBodyWorkitemTime>(model1);
      }
    }
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreateWorkitemRecordResponseBody() = default;
};
class CreateWorkitemRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateWorkitemRecordResponseBody> body{};

  CreateWorkitemRecordResponse() {}

  explicit CreateWorkitemRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateWorkitemRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateWorkitemRecordResponseBody>(model1);
      }
    }
  }


  virtual ~CreateWorkitemRecordResponse() = default;
};
class CreateWorkitemV2RequestFieldValueList : public Darabonba::Model {
public:
  shared_ptr<string> fieldIdentifier{};
  shared_ptr<string> value{};

  CreateWorkitemV2RequestFieldValueList() {}

  explicit CreateWorkitemV2RequestFieldValueList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldIdentifier) {
      res["fieldIdentifier"] = boost::any(*fieldIdentifier);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fieldIdentifier") != m.end() && !m["fieldIdentifier"].empty()) {
      fieldIdentifier = make_shared<string>(boost::any_cast<string>(m["fieldIdentifier"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~CreateWorkitemV2RequestFieldValueList() = default;
};
class CreateWorkitemV2Request : public Darabonba::Model {
public:
  shared_ptr<string> assignedTo{};
  shared_ptr<string> category{};
  shared_ptr<string> description{};
  shared_ptr<vector<CreateWorkitemV2RequestFieldValueList>> fieldValueList{};
  shared_ptr<string> parentIdentifier{};
  shared_ptr<vector<string>> participants{};
  shared_ptr<string> spaceIdentifier{};
  shared_ptr<string> sprintIdentifier{};
  shared_ptr<string> subject{};
  shared_ptr<vector<string>> tags{};
  shared_ptr<vector<string>> trackers{};
  shared_ptr<string> verifier{};
  shared_ptr<vector<string>> versions{};
  shared_ptr<string> workitemTypeIdentifier{};

  CreateWorkitemV2Request() {}

  explicit CreateWorkitemV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignedTo) {
      res["assignedTo"] = boost::any(*assignedTo);
    }
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (fieldValueList) {
      vector<boost::any> temp1;
      for(auto item1:*fieldValueList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["fieldValueList"] = boost::any(temp1);
    }
    if (parentIdentifier) {
      res["parentIdentifier"] = boost::any(*parentIdentifier);
    }
    if (participants) {
      res["participants"] = boost::any(*participants);
    }
    if (spaceIdentifier) {
      res["spaceIdentifier"] = boost::any(*spaceIdentifier);
    }
    if (sprintIdentifier) {
      res["sprintIdentifier"] = boost::any(*sprintIdentifier);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    if (tags) {
      res["tags"] = boost::any(*tags);
    }
    if (trackers) {
      res["trackers"] = boost::any(*trackers);
    }
    if (verifier) {
      res["verifier"] = boost::any(*verifier);
    }
    if (versions) {
      res["versions"] = boost::any(*versions);
    }
    if (workitemTypeIdentifier) {
      res["workitemTypeIdentifier"] = boost::any(*workitemTypeIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignedTo") != m.end() && !m["assignedTo"].empty()) {
      assignedTo = make_shared<string>(boost::any_cast<string>(m["assignedTo"]));
    }
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["category"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("fieldValueList") != m.end() && !m["fieldValueList"].empty()) {
      if (typeid(vector<boost::any>) == m["fieldValueList"].type()) {
        vector<CreateWorkitemV2RequestFieldValueList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["fieldValueList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateWorkitemV2RequestFieldValueList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fieldValueList = make_shared<vector<CreateWorkitemV2RequestFieldValueList>>(expect1);
      }
    }
    if (m.find("parentIdentifier") != m.end() && !m["parentIdentifier"].empty()) {
      parentIdentifier = make_shared<string>(boost::any_cast<string>(m["parentIdentifier"]));
    }
    if (m.find("participants") != m.end() && !m["participants"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["participants"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["participants"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      participants = make_shared<vector<string>>(toVec1);
    }
    if (m.find("spaceIdentifier") != m.end() && !m["spaceIdentifier"].empty()) {
      spaceIdentifier = make_shared<string>(boost::any_cast<string>(m["spaceIdentifier"]));
    }
    if (m.find("sprintIdentifier") != m.end() && !m["sprintIdentifier"].empty()) {
      sprintIdentifier = make_shared<string>(boost::any_cast<string>(m["sprintIdentifier"]));
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["tags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tags = make_shared<vector<string>>(toVec1);
    }
    if (m.find("trackers") != m.end() && !m["trackers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["trackers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["trackers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      trackers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("verifier") != m.end() && !m["verifier"].empty()) {
      verifier = make_shared<string>(boost::any_cast<string>(m["verifier"]));
    }
    if (m.find("versions") != m.end() && !m["versions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["versions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["versions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      versions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("workitemTypeIdentifier") != m.end() && !m["workitemTypeIdentifier"].empty()) {
      workitemTypeIdentifier = make_shared<string>(boost::any_cast<string>(m["workitemTypeIdentifier"]));
    }
  }


  virtual ~CreateWorkitemV2Request() = default;
};
class CreateWorkitemV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<string> workitemIdentifier{};

  CreateWorkitemV2ResponseBody() {}

  explicit CreateWorkitemV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (workitemIdentifier) {
      res["workitemIdentifier"] = boost::any(*workitemIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["success"]));
    }
    if (m.find("workitemIdentifier") != m.end() && !m["workitemIdentifier"].empty()) {
      workitemIdentifier = make_shared<string>(boost::any_cast<string>(m["workitemIdentifier"]));
    }
  }


  virtual ~CreateWorkitemV2ResponseBody() = default;
};
class CreateWorkitemV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateWorkitemV2ResponseBody> body{};

  CreateWorkitemV2Response() {}

  explicit CreateWorkitemV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateWorkitemV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateWorkitemV2ResponseBody>(model1);
      }
    }
  }


  virtual ~CreateWorkitemV2Response() = default;
};
class CreateWorkspaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> codeUrl{};
  shared_ptr<string> codeVersion{};
  shared_ptr<string> filePath{};
  shared_ptr<string> name{};
  shared_ptr<string> requestFrom{};
  shared_ptr<string> resourceIdentifier{};
  shared_ptr<bool> reuse{};
  shared_ptr<string> workspaceTemplate{};

  CreateWorkspaceRequest() {}

  explicit CreateWorkspaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codeUrl) {
      res["codeUrl"] = boost::any(*codeUrl);
    }
    if (codeVersion) {
      res["codeVersion"] = boost::any(*codeVersion);
    }
    if (filePath) {
      res["filePath"] = boost::any(*filePath);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (requestFrom) {
      res["requestFrom"] = boost::any(*requestFrom);
    }
    if (resourceIdentifier) {
      res["resourceIdentifier"] = boost::any(*resourceIdentifier);
    }
    if (reuse) {
      res["reuse"] = boost::any(*reuse);
    }
    if (workspaceTemplate) {
      res["workspaceTemplate"] = boost::any(*workspaceTemplate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("codeUrl") != m.end() && !m["codeUrl"].empty()) {
      codeUrl = make_shared<string>(boost::any_cast<string>(m["codeUrl"]));
    }
    if (m.find("codeVersion") != m.end() && !m["codeVersion"].empty()) {
      codeVersion = make_shared<string>(boost::any_cast<string>(m["codeVersion"]));
    }
    if (m.find("filePath") != m.end() && !m["filePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["filePath"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("requestFrom") != m.end() && !m["requestFrom"].empty()) {
      requestFrom = make_shared<string>(boost::any_cast<string>(m["requestFrom"]));
    }
    if (m.find("resourceIdentifier") != m.end() && !m["resourceIdentifier"].empty()) {
      resourceIdentifier = make_shared<string>(boost::any_cast<string>(m["resourceIdentifier"]));
    }
    if (m.find("reuse") != m.end() && !m["reuse"].empty()) {
      reuse = make_shared<bool>(boost::any_cast<bool>(m["reuse"]));
    }
    if (m.find("workspaceTemplate") != m.end() && !m["workspaceTemplate"].empty()) {
      workspaceTemplate = make_shared<string>(boost::any_cast<string>(m["workspaceTemplate"]));
    }
  }


  virtual ~CreateWorkspaceRequest() = default;
};
class CreateWorkspaceResponseBodyWorkspace : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};
  shared_ptr<string> template_{};

  CreateWorkspaceResponseBodyWorkspace() {}

  explicit CreateWorkspaceResponseBodyWorkspace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["creator"] = boost::any(*creator);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (template_) {
      res["template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["creator"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("template") != m.end() && !m["template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["template"]));
    }
  }


  virtual ~CreateWorkspaceResponseBodyWorkspace() = default;
};
class CreateWorkspaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<CreateWorkspaceResponseBodyWorkspace> workspace{};

  CreateWorkspaceResponseBody() {}

  explicit CreateWorkspaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (workspace) {
      res["workspace"] = workspace ? boost::any(workspace->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("workspace") != m.end() && !m["workspace"].empty()) {
      if (typeid(map<string, boost::any>) == m["workspace"].type()) {
        CreateWorkspaceResponseBodyWorkspace model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["workspace"]));
        workspace = make_shared<CreateWorkspaceResponseBodyWorkspace>(model1);
      }
    }
  }


  virtual ~CreateWorkspaceResponseBody() = default;
};
class CreateWorkspaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateWorkspaceResponseBody> body{};

  CreateWorkspaceResponse() {}

  explicit CreateWorkspaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateWorkspaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateWorkspaceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateWorkspaceResponse() = default;
};
class DeleteAppMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};
  shared_ptr<string> subjectId{};
  shared_ptr<string> subjectType{};

  DeleteAppMemberRequest() {}

  explicit DeleteAppMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (subjectId) {
      res["subjectId"] = boost::any(*subjectId);
    }
    if (subjectType) {
      res["subjectType"] = boost::any(*subjectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("subjectId") != m.end() && !m["subjectId"].empty()) {
      subjectId = make_shared<string>(boost::any_cast<string>(m["subjectId"]));
    }
    if (m.find("subjectType") != m.end() && !m["subjectType"].empty()) {
      subjectType = make_shared<string>(boost::any_cast<string>(m["subjectType"]));
    }
  }


  virtual ~DeleteAppMemberRequest() = default;
};
class DeleteAppMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<string> body{};

  DeleteAppMemberResponse() {}

  explicit DeleteAppMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~DeleteAppMemberResponse() = default;
};
class DeleteBranchRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> branchName{};
  shared_ptr<string> organizationId{};

  DeleteBranchRequest() {}

  explicit DeleteBranchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (branchName) {
      res["branchName"] = boost::any(*branchName);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("branchName") != m.end() && !m["branchName"].empty()) {
      branchName = make_shared<string>(boost::any_cast<string>(m["branchName"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~DeleteBranchRequest() = default;
};
class DeleteBranchResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> branchName{};

  DeleteBranchResponseBodyResult() {}

  explicit DeleteBranchResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (branchName) {
      res["branchName"] = boost::any(*branchName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("branchName") != m.end() && !m["branchName"].empty()) {
      branchName = make_shared<string>(boost::any_cast<string>(m["branchName"]));
    }
  }


  virtual ~DeleteBranchResponseBodyResult() = default;
};
class DeleteBranchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<DeleteBranchResponseBodyResult> result{};
  shared_ptr<string> success{};

  DeleteBranchResponseBody() {}

  explicit DeleteBranchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        DeleteBranchResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<DeleteBranchResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["success"]));
    }
  }


  virtual ~DeleteBranchResponseBody() = default;
};
class DeleteBranchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteBranchResponseBody> body{};

  DeleteBranchResponse() {}

  explicit DeleteBranchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBranchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBranchResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBranchResponse() = default;
};
class DeleteFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> branchName{};
  shared_ptr<string> commitMessage{};
  shared_ptr<string> filePath{};
  shared_ptr<string> organizationId{};

  DeleteFileRequest() {}

  explicit DeleteFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (branchName) {
      res["branchName"] = boost::any(*branchName);
    }
    if (commitMessage) {
      res["commitMessage"] = boost::any(*commitMessage);
    }
    if (filePath) {
      res["filePath"] = boost::any(*filePath);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("branchName") != m.end() && !m["branchName"].empty()) {
      branchName = make_shared<string>(boost::any_cast<string>(m["branchName"]));
    }
    if (m.find("commitMessage") != m.end() && !m["commitMessage"].empty()) {
      commitMessage = make_shared<string>(boost::any_cast<string>(m["commitMessage"]));
    }
    if (m.find("filePath") != m.end() && !m["filePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["filePath"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~DeleteFileRequest() = default;
};
class DeleteFileResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> branchName{};
  shared_ptr<string> filePath{};

  DeleteFileResponseBodyResult() {}

  explicit DeleteFileResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (branchName) {
      res["branchName"] = boost::any(*branchName);
    }
    if (filePath) {
      res["filePath"] = boost::any(*filePath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("branchName") != m.end() && !m["branchName"].empty()) {
      branchName = make_shared<string>(boost::any_cast<string>(m["branchName"]));
    }
    if (m.find("filePath") != m.end() && !m["filePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["filePath"]));
    }
  }


  virtual ~DeleteFileResponseBodyResult() = default;
};
class DeleteFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<DeleteFileResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DeleteFileResponseBody() {}

  explicit DeleteFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        DeleteFileResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<DeleteFileResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DeleteFileResponseBody() = default;
};
class DeleteFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteFileResponseBody> body{};

  DeleteFileResponse() {}

  explicit DeleteFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFileResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFileResponse() = default;
};
class DeleteFlowTagResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteFlowTagResponseBody() {}

  explicit DeleteFlowTagResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DeleteFlowTagResponseBody() = default;
};
class DeleteFlowTagResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteFlowTagResponseBody> body{};

  DeleteFlowTagResponse() {}

  explicit DeleteFlowTagResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFlowTagResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFlowTagResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFlowTagResponse() = default;
};
class DeleteFlowTagGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteFlowTagGroupResponseBody() {}

  explicit DeleteFlowTagGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DeleteFlowTagGroupResponseBody() = default;
};
class DeleteFlowTagGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteFlowTagGroupResponseBody> body{};

  DeleteFlowTagGroupResponse() {}

  explicit DeleteFlowTagGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFlowTagGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFlowTagGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFlowTagGroupResponse() = default;
};
class DeleteGroupMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> aliyunPk{};
  shared_ptr<string> memberType{};
  shared_ptr<string> organizationId{};

  DeleteGroupMemberRequest() {}

  explicit DeleteGroupMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (aliyunPk) {
      res["aliyunPk"] = boost::any(*aliyunPk);
    }
    if (memberType) {
      res["memberType"] = boost::any(*memberType);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("aliyunPk") != m.end() && !m["aliyunPk"].empty()) {
      aliyunPk = make_shared<string>(boost::any_cast<string>(m["aliyunPk"]));
    }
    if (m.find("memberType") != m.end() && !m["memberType"].empty()) {
      memberType = make_shared<string>(boost::any_cast<string>(m["memberType"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~DeleteGroupMemberRequest() = default;
};
class DeleteGroupMemberResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> accessLevel{};
  shared_ptr<string> avatarUrl{};
  shared_ptr<long> id{};
  shared_ptr<string> memberType{};
  shared_ptr<string> name{};
  shared_ptr<long> sourceId{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};

  DeleteGroupMemberResponseBodyResult() {}

  explicit DeleteGroupMemberResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessLevel) {
      res["accessLevel"] = boost::any(*accessLevel);
    }
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (memberType) {
      res["memberType"] = boost::any(*memberType);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sourceId) {
      res["sourceId"] = boost::any(*sourceId);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessLevel") != m.end() && !m["accessLevel"].empty()) {
      accessLevel = make_shared<long>(boost::any_cast<long>(m["accessLevel"]));
    }
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("memberType") != m.end() && !m["memberType"].empty()) {
      memberType = make_shared<string>(boost::any_cast<string>(m["memberType"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sourceId") != m.end() && !m["sourceId"].empty()) {
      sourceId = make_shared<long>(boost::any_cast<long>(m["sourceId"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~DeleteGroupMemberResponseBodyResult() = default;
};
class DeleteGroupMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<DeleteGroupMemberResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DeleteGroupMemberResponseBody() {}

  explicit DeleteGroupMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        DeleteGroupMemberResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<DeleteGroupMemberResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DeleteGroupMemberResponseBody() = default;
};
class DeleteGroupMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteGroupMemberResponseBody> body{};

  DeleteGroupMemberResponse() {}

  explicit DeleteGroupMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteGroupMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteGroupMemberResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteGroupMemberResponse() = default;
};
class DeleteHostGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteHostGroupResponseBody() {}

  explicit DeleteHostGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DeleteHostGroupResponseBody() = default;
};
class DeleteHostGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteHostGroupResponseBody> body{};

  DeleteHostGroupResponse() {}

  explicit DeleteHostGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteHostGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteHostGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteHostGroupResponse() = default;
};
class DeletePipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeletePipelineResponseBody() {}

  explicit DeletePipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DeletePipelineResponseBody() = default;
};
class DeletePipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePipelineResponseBody> body{};

  DeletePipelineResponse() {}

  explicit DeletePipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePipelineResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePipelineResponse() = default;
};
class DeletePipelineGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeletePipelineGroupResponseBody() {}

  explicit DeletePipelineGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DeletePipelineGroupResponseBody() = default;
};
class DeletePipelineGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePipelineGroupResponseBody> body{};

  DeletePipelineGroupResponse() {}

  explicit DeletePipelineGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePipelineGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePipelineGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePipelineGroupResponse() = default;
};
class DeletePipelineRelationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> relObjectId{};
  shared_ptr<string> relObjectType{};

  DeletePipelineRelationsRequest() {}

  explicit DeletePipelineRelationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (relObjectId) {
      res["relObjectId"] = boost::any(*relObjectId);
    }
    if (relObjectType) {
      res["relObjectType"] = boost::any(*relObjectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("relObjectId") != m.end() && !m["relObjectId"].empty()) {
      relObjectId = make_shared<string>(boost::any_cast<string>(m["relObjectId"]));
    }
    if (m.find("relObjectType") != m.end() && !m["relObjectType"].empty()) {
      relObjectType = make_shared<string>(boost::any_cast<string>(m["relObjectType"]));
    }
  }


  virtual ~DeletePipelineRelationsRequest() = default;
};
class DeletePipelineRelationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeletePipelineRelationsResponseBody() {}

  explicit DeletePipelineRelationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DeletePipelineRelationsResponseBody() = default;
};
class DeletePipelineRelationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePipelineRelationsResponseBody> body{};

  DeletePipelineRelationsResponse() {}

  explicit DeletePipelineRelationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePipelineRelationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePipelineRelationsResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePipelineRelationsResponse() = default;
};
class DeleteProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> identifier{};

  DeleteProjectRequest() {}

  explicit DeleteProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
  }


  virtual ~DeleteProjectRequest() = default;
};
class DeleteProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};
  shared_ptr<bool> success{};

  DeleteProjectResponseBody() {}

  explicit DeleteProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DeleteProjectResponseBody() = default;
};
class DeleteProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteProjectResponseBody> body{};

  DeleteProjectResponse() {}

  explicit DeleteProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteProjectResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteProjectResponse() = default;
};
class DeleteProjectLabelRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> repositoryIdentity{};

  DeleteProjectLabelRequest() {}

  explicit DeleteProjectLabelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (repositoryIdentity) {
      res["repositoryIdentity"] = boost::any(*repositoryIdentity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("repositoryIdentity") != m.end() && !m["repositoryIdentity"].empty()) {
      repositoryIdentity = make_shared<string>(boost::any_cast<string>(m["repositoryIdentity"]));
    }
  }


  virtual ~DeleteProjectLabelRequest() = default;
};
class DeleteProjectLabelResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> result{};

  DeleteProjectLabelResponseBodyResult() {}

  explicit DeleteProjectLabelResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~DeleteProjectLabelResponseBodyResult() = default;
};
class DeleteProjectLabelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<DeleteProjectLabelResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DeleteProjectLabelResponseBody() {}

  explicit DeleteProjectLabelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        DeleteProjectLabelResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<DeleteProjectLabelResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DeleteProjectLabelResponseBody() = default;
};
class DeleteProjectLabelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteProjectLabelResponseBody> body{};

  DeleteProjectLabelResponse() {}

  explicit DeleteProjectLabelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteProjectLabelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteProjectLabelResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteProjectLabelResponse() = default;
};
class DeleteProtectedBranchRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> organizationId{};

  DeleteProtectedBranchRequest() {}

  explicit DeleteProtectedBranchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~DeleteProtectedBranchRequest() = default;
};
class DeleteProtectedBranchResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> result{};

  DeleteProtectedBranchResponseBodyResult() {}

  explicit DeleteProtectedBranchResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~DeleteProtectedBranchResponseBodyResult() = default;
};
class DeleteProtectedBranchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<DeleteProtectedBranchResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DeleteProtectedBranchResponseBody() {}

  explicit DeleteProtectedBranchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        DeleteProtectedBranchResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<DeleteProtectedBranchResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DeleteProtectedBranchResponseBody() = default;
};
class DeleteProtectedBranchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteProtectedBranchResponseBody> body{};

  DeleteProtectedBranchResponse() {}

  explicit DeleteProtectedBranchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteProtectedBranchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteProtectedBranchResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteProtectedBranchResponse() = default;
};
class DeletePushRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> organizationId{};

  DeletePushRuleRequest() {}

  explicit DeletePushRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~DeletePushRuleRequest() = default;
};
class DeletePushRuleResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> result{};

  DeletePushRuleResponseBodyResult() {}

  explicit DeletePushRuleResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~DeletePushRuleResponseBodyResult() = default;
};
class DeletePushRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<DeletePushRuleResponseBodyResult> result{};
  shared_ptr<string> success{};

  DeletePushRuleResponseBody() {}

  explicit DeletePushRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        DeletePushRuleResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<DeletePushRuleResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["success"]));
    }
  }


  virtual ~DeletePushRuleResponseBody() = default;
};
class DeletePushRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePushRuleResponseBody> body{};

  DeletePushRuleResponse() {}

  explicit DeletePushRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePushRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePushRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePushRuleResponse() = default;
};
class DeleteRepositoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> reason{};
  shared_ptr<string> organizationId{};

  DeleteRepositoryRequest() {}

  explicit DeleteRepositoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (reason) {
      res["reason"] = boost::any(*reason);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("reason") != m.end() && !m["reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["reason"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~DeleteRepositoryRequest() = default;
};
class DeleteRepositoryResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> result{};

  DeleteRepositoryResponseBodyResult() {}

  explicit DeleteRepositoryResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~DeleteRepositoryResponseBodyResult() = default;
};
class DeleteRepositoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<DeleteRepositoryResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DeleteRepositoryResponseBody() {}

  explicit DeleteRepositoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        DeleteRepositoryResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<DeleteRepositoryResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DeleteRepositoryResponseBody() = default;
};
class DeleteRepositoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRepositoryResponseBody> body{};

  DeleteRepositoryResponse() {}

  explicit DeleteRepositoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRepositoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRepositoryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRepositoryResponse() = default;
};
class DeleteRepositoryGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> reason{};
  shared_ptr<string> organizationId{};

  DeleteRepositoryGroupRequest() {}

  explicit DeleteRepositoryGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (reason) {
      res["reason"] = boost::any(*reason);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("reason") != m.end() && !m["reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["reason"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~DeleteRepositoryGroupRequest() = default;
};
class DeleteRepositoryGroupResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> result{};

  DeleteRepositoryGroupResponseBodyResult() {}

  explicit DeleteRepositoryGroupResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~DeleteRepositoryGroupResponseBodyResult() = default;
};
class DeleteRepositoryGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<DeleteRepositoryGroupResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DeleteRepositoryGroupResponseBody() {}

  explicit DeleteRepositoryGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        DeleteRepositoryGroupResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<DeleteRepositoryGroupResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DeleteRepositoryGroupResponseBody() = default;
};
class DeleteRepositoryGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRepositoryGroupResponseBody> body{};

  DeleteRepositoryGroupResponse() {}

  explicit DeleteRepositoryGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRepositoryGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRepositoryGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRepositoryGroupResponse() = default;
};
class DeleteRepositoryMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> memberType{};
  shared_ptr<string> organizationId{};

  DeleteRepositoryMemberRequest() {}

  explicit DeleteRepositoryMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (memberType) {
      res["memberType"] = boost::any(*memberType);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("memberType") != m.end() && !m["memberType"].empty()) {
      memberType = make_shared<string>(boost::any_cast<string>(m["memberType"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~DeleteRepositoryMemberRequest() = default;
};
class DeleteRepositoryMemberResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> accessLevel{};
  shared_ptr<string> createAt{};
  shared_ptr<long> id{};
  shared_ptr<long> sourceId{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> updateAt{};
  shared_ptr<long> userId{};

  DeleteRepositoryMemberResponseBodyResult() {}

  explicit DeleteRepositoryMemberResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessLevel) {
      res["accessLevel"] = boost::any(*accessLevel);
    }
    if (createAt) {
      res["createAt"] = boost::any(*createAt);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (sourceId) {
      res["sourceId"] = boost::any(*sourceId);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (updateAt) {
      res["updateAt"] = boost::any(*updateAt);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessLevel") != m.end() && !m["accessLevel"].empty()) {
      accessLevel = make_shared<long>(boost::any_cast<long>(m["accessLevel"]));
    }
    if (m.find("createAt") != m.end() && !m["createAt"].empty()) {
      createAt = make_shared<string>(boost::any_cast<string>(m["createAt"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("sourceId") != m.end() && !m["sourceId"].empty()) {
      sourceId = make_shared<long>(boost::any_cast<long>(m["sourceId"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("updateAt") != m.end() && !m["updateAt"].empty()) {
      updateAt = make_shared<string>(boost::any_cast<string>(m["updateAt"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["userId"]));
    }
  }


  virtual ~DeleteRepositoryMemberResponseBodyResult() = default;
};
class DeleteRepositoryMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<DeleteRepositoryMemberResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DeleteRepositoryMemberResponseBody() {}

  explicit DeleteRepositoryMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        DeleteRepositoryMemberResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<DeleteRepositoryMemberResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DeleteRepositoryMemberResponseBody() = default;
};
class DeleteRepositoryMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRepositoryMemberResponseBody> body{};

  DeleteRepositoryMemberResponse() {}

  explicit DeleteRepositoryMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRepositoryMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRepositoryMemberResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRepositoryMemberResponse() = default;
};
class DeleteRepositoryWebhookRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> organizationId{};

  DeleteRepositoryWebhookRequest() {}

  explicit DeleteRepositoryWebhookRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~DeleteRepositoryWebhookRequest() = default;
};
class DeleteRepositoryWebhookResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> buildEvents{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> description{};
  shared_ptr<bool> enableSslVerification{};
  shared_ptr<long> id{};
  shared_ptr<bool> issuesEvents{};
  shared_ptr<string> lastTestResult{};
  shared_ptr<bool> mergeRequestsEvents{};
  shared_ptr<bool> noteEvents{};
  shared_ptr<long> projectId{};
  shared_ptr<bool> pushEvents{};
  shared_ptr<string> secretToken{};
  shared_ptr<bool> tagPushEvents{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};

  DeleteRepositoryWebhookResponseBodyResult() {}

  explicit DeleteRepositoryWebhookResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (buildEvents) {
      res["buildEvents"] = boost::any(*buildEvents);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (enableSslVerification) {
      res["enableSslVerification"] = boost::any(*enableSslVerification);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (issuesEvents) {
      res["issuesEvents"] = boost::any(*issuesEvents);
    }
    if (lastTestResult) {
      res["lastTestResult"] = boost::any(*lastTestResult);
    }
    if (mergeRequestsEvents) {
      res["mergeRequestsEvents"] = boost::any(*mergeRequestsEvents);
    }
    if (noteEvents) {
      res["noteEvents"] = boost::any(*noteEvents);
    }
    if (projectId) {
      res["projectId"] = boost::any(*projectId);
    }
    if (pushEvents) {
      res["pushEvents"] = boost::any(*pushEvents);
    }
    if (secretToken) {
      res["secretToken"] = boost::any(*secretToken);
    }
    if (tagPushEvents) {
      res["tagPushEvents"] = boost::any(*tagPushEvents);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("buildEvents") != m.end() && !m["buildEvents"].empty()) {
      buildEvents = make_shared<bool>(boost::any_cast<bool>(m["buildEvents"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("enableSslVerification") != m.end() && !m["enableSslVerification"].empty()) {
      enableSslVerification = make_shared<bool>(boost::any_cast<bool>(m["enableSslVerification"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("issuesEvents") != m.end() && !m["issuesEvents"].empty()) {
      issuesEvents = make_shared<bool>(boost::any_cast<bool>(m["issuesEvents"]));
    }
    if (m.find("lastTestResult") != m.end() && !m["lastTestResult"].empty()) {
      lastTestResult = make_shared<string>(boost::any_cast<string>(m["lastTestResult"]));
    }
    if (m.find("mergeRequestsEvents") != m.end() && !m["mergeRequestsEvents"].empty()) {
      mergeRequestsEvents = make_shared<bool>(boost::any_cast<bool>(m["mergeRequestsEvents"]));
    }
    if (m.find("noteEvents") != m.end() && !m["noteEvents"].empty()) {
      noteEvents = make_shared<bool>(boost::any_cast<bool>(m["noteEvents"]));
    }
    if (m.find("projectId") != m.end() && !m["projectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["projectId"]));
    }
    if (m.find("pushEvents") != m.end() && !m["pushEvents"].empty()) {
      pushEvents = make_shared<bool>(boost::any_cast<bool>(m["pushEvents"]));
    }
    if (m.find("secretToken") != m.end() && !m["secretToken"].empty()) {
      secretToken = make_shared<string>(boost::any_cast<string>(m["secretToken"]));
    }
    if (m.find("tagPushEvents") != m.end() && !m["tagPushEvents"].empty()) {
      tagPushEvents = make_shared<bool>(boost::any_cast<bool>(m["tagPushEvents"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~DeleteRepositoryWebhookResponseBodyResult() = default;
};
class DeleteRepositoryWebhookResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<DeleteRepositoryWebhookResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DeleteRepositoryWebhookResponseBody() {}

  explicit DeleteRepositoryWebhookResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        DeleteRepositoryWebhookResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<DeleteRepositoryWebhookResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DeleteRepositoryWebhookResponseBody() = default;
};
class DeleteRepositoryWebhookResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRepositoryWebhookResponseBody> body{};

  DeleteRepositoryWebhookResponse() {}

  explicit DeleteRepositoryWebhookResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRepositoryWebhookResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRepositoryWebhookResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRepositoryWebhookResponse() = default;
};
class DeleteResourceMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteResourceMemberResponseBody() {}

  explicit DeleteResourceMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DeleteResourceMemberResponseBody() = default;
};
class DeleteResourceMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteResourceMemberResponseBody> body{};

  DeleteResourceMemberResponse() {}

  explicit DeleteResourceMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteResourceMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteResourceMemberResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteResourceMemberResponse() = default;
};
class DeleteTagRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> tagName{};

  DeleteTagRequest() {}

  explicit DeleteTagRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (tagName) {
      res["tagName"] = boost::any(*tagName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("tagName") != m.end() && !m["tagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["tagName"]));
    }
  }


  virtual ~DeleteTagRequest() = default;
};
class DeleteTagResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> tagName{};

  DeleteTagResponseBodyResult() {}

  explicit DeleteTagResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagName) {
      res["tagName"] = boost::any(*tagName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tagName") != m.end() && !m["tagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["tagName"]));
    }
  }


  virtual ~DeleteTagResponseBodyResult() = default;
};
class DeleteTagResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<DeleteTagResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DeleteTagResponseBody() {}

  explicit DeleteTagResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        DeleteTagResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<DeleteTagResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DeleteTagResponseBody() = default;
};
class DeleteTagResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTagResponseBody> body{};

  DeleteTagResponse() {}

  explicit DeleteTagResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTagResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTagResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTagResponse() = default;
};
class DeleteUserKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> organizationId{};

  DeleteUserKeyRequest() {}

  explicit DeleteUserKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~DeleteUserKeyRequest() = default;
};
class DeleteUserKeyResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> context{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> fingerPrint{};
  shared_ptr<long> id{};
  shared_ptr<string> keyScope{};
  shared_ptr<string> lastUsedTime{};
  shared_ptr<string> publicKey{};
  shared_ptr<string> shaContext{};
  shared_ptr<string> title{};
  shared_ptr<string> updatedAt{};

  DeleteUserKeyResponseBodyResult() {}

  explicit DeleteUserKeyResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (context) {
      res["context"] = boost::any(*context);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (expireTime) {
      res["expireTime"] = boost::any(*expireTime);
    }
    if (fingerPrint) {
      res["fingerPrint"] = boost::any(*fingerPrint);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (keyScope) {
      res["keyScope"] = boost::any(*keyScope);
    }
    if (lastUsedTime) {
      res["lastUsedTime"] = boost::any(*lastUsedTime);
    }
    if (publicKey) {
      res["publicKey"] = boost::any(*publicKey);
    }
    if (shaContext) {
      res["shaContext"] = boost::any(*shaContext);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (updatedAt) {
      res["updatedAt"] = boost::any(*updatedAt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("context") != m.end() && !m["context"].empty()) {
      context = make_shared<string>(boost::any_cast<string>(m["context"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("expireTime") != m.end() && !m["expireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["expireTime"]));
    }
    if (m.find("fingerPrint") != m.end() && !m["fingerPrint"].empty()) {
      fingerPrint = make_shared<string>(boost::any_cast<string>(m["fingerPrint"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("keyScope") != m.end() && !m["keyScope"].empty()) {
      keyScope = make_shared<string>(boost::any_cast<string>(m["keyScope"]));
    }
    if (m.find("lastUsedTime") != m.end() && !m["lastUsedTime"].empty()) {
      lastUsedTime = make_shared<string>(boost::any_cast<string>(m["lastUsedTime"]));
    }
    if (m.find("publicKey") != m.end() && !m["publicKey"].empty()) {
      publicKey = make_shared<string>(boost::any_cast<string>(m["publicKey"]));
    }
    if (m.find("shaContext") != m.end() && !m["shaContext"].empty()) {
      shaContext = make_shared<string>(boost::any_cast<string>(m["shaContext"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("updatedAt") != m.end() && !m["updatedAt"].empty()) {
      updatedAt = make_shared<string>(boost::any_cast<string>(m["updatedAt"]));
    }
  }


  virtual ~DeleteUserKeyResponseBodyResult() = default;
};
class DeleteUserKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<DeleteUserKeyResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DeleteUserKeyResponseBody() {}

  explicit DeleteUserKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        DeleteUserKeyResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<DeleteUserKeyResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DeleteUserKeyResponseBody() = default;
};
class DeleteUserKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteUserKeyResponseBody> body{};

  DeleteUserKeyResponse() {}

  explicit DeleteUserKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteUserKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteUserKeyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteUserKeyResponse() = default;
};
class DeleteVariableGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteVariableGroupResponseBody() {}

  explicit DeleteVariableGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DeleteVariableGroupResponseBody() = default;
};
class DeleteVariableGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteVariableGroupResponseBody> body{};

  DeleteVariableGroupResponse() {}

  explicit DeleteVariableGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVariableGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVariableGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVariableGroupResponse() = default;
};
class DeleteWorkitemRequest : public Darabonba::Model {
public:
  shared_ptr<string> identifier{};

  DeleteWorkitemRequest() {}

  explicit DeleteWorkitemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
  }


  virtual ~DeleteWorkitemRequest() = default;
};
class DeleteWorkitemResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> deleteFlag{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteWorkitemResponseBody() {}

  explicit DeleteWorkitemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteFlag) {
      res["deleteFlag"] = boost::any(*deleteFlag);
    }
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("deleteFlag") != m.end() && !m["deleteFlag"].empty()) {
      deleteFlag = make_shared<bool>(boost::any_cast<bool>(m["deleteFlag"]));
    }
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DeleteWorkitemResponseBody() = default;
};
class DeleteWorkitemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteWorkitemResponseBody> body{};

  DeleteWorkitemResponse() {}

  explicit DeleteWorkitemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteWorkitemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteWorkitemResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteWorkitemResponse() = default;
};
class DeleteWorkitemAllCommentRequest : public Darabonba::Model {
public:
  shared_ptr<string> identifier{};

  DeleteWorkitemAllCommentRequest() {}

  explicit DeleteWorkitemAllCommentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
  }


  virtual ~DeleteWorkitemAllCommentRequest() = default;
};
class DeleteWorkitemAllCommentResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> deleteFlag{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DeleteWorkitemAllCommentResponseBody() {}

  explicit DeleteWorkitemAllCommentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteFlag) {
      res["deleteFlag"] = boost::any(*deleteFlag);
    }
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("deleteFlag") != m.end() && !m["deleteFlag"].empty()) {
      deleteFlag = make_shared<bool>(boost::any_cast<bool>(m["deleteFlag"]));
    }
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["success"]));
    }
  }


  virtual ~DeleteWorkitemAllCommentResponseBody() = default;
};
class DeleteWorkitemAllCommentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteWorkitemAllCommentResponseBody> body{};

  DeleteWorkitemAllCommentResponse() {}

  explicit DeleteWorkitemAllCommentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteWorkitemAllCommentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteWorkitemAllCommentResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteWorkitemAllCommentResponse() = default;
};
class DeleteWorkitemCommentRequest : public Darabonba::Model {
public:
  shared_ptr<long> commentId{};
  shared_ptr<string> identifier{};

  DeleteWorkitemCommentRequest() {}

  explicit DeleteWorkitemCommentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commentId) {
      res["commentId"] = boost::any(*commentId);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commentId") != m.end() && !m["commentId"].empty()) {
      commentId = make_shared<long>(boost::any_cast<long>(m["commentId"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
  }


  virtual ~DeleteWorkitemCommentRequest() = default;
};
class DeleteWorkitemCommentResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> deleteFlag{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DeleteWorkitemCommentResponseBody() {}

  explicit DeleteWorkitemCommentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteFlag) {
      res["deleteFlag"] = boost::any(*deleteFlag);
    }
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("deleteFlag") != m.end() && !m["deleteFlag"].empty()) {
      deleteFlag = make_shared<bool>(boost::any_cast<bool>(m["deleteFlag"]));
    }
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["success"]));
    }
  }


  virtual ~DeleteWorkitemCommentResponseBody() = default;
};
class DeleteWorkitemCommentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteWorkitemCommentResponseBody> body{};

  DeleteWorkitemCommentResponse() {}

  explicit DeleteWorkitemCommentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteWorkitemCommentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteWorkitemCommentResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteWorkitemCommentResponse() = default;
};
class EnableDeployKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> organizationId{};

  EnableDeployKeyRequest() {}

  explicit EnableDeployKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~EnableDeployKeyRequest() = default;
};
class EnableDeployKeyResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> result{};

  EnableDeployKeyResponseBodyResult() {}

  explicit EnableDeployKeyResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~EnableDeployKeyResponseBodyResult() = default;
};
class EnableDeployKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<EnableDeployKeyResponseBodyResult> result{};
  shared_ptr<bool> success{};

  EnableDeployKeyResponseBody() {}

  explicit EnableDeployKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        EnableDeployKeyResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<EnableDeployKeyResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~EnableDeployKeyResponseBody() = default;
};
class EnableDeployKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableDeployKeyResponseBody> body{};

  EnableDeployKeyResponse() {}

  explicit EnableDeployKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableDeployKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableDeployKeyResponseBody>(model1);
      }
    }
  }


  virtual ~EnableDeployKeyResponse() = default;
};
class ExecuteChangeRequestReleaseStageRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> params{};
  shared_ptr<string> organizationId{};

  ExecuteChangeRequestReleaseStageRequest() {}

  explicit ExecuteChangeRequestReleaseStageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (params) {
      res["params"] = boost::any(*params);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("params") != m.end() && !m["params"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["params"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      params = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~ExecuteChangeRequestReleaseStageRequest() = default;
};
class ExecuteChangeRequestReleaseStageResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> object{};
  shared_ptr<long> pipelineId{};
  shared_ptr<long> pipelineRunId{};

  ExecuteChangeRequestReleaseStageResponseBody() {}

  explicit ExecuteChangeRequestReleaseStageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (object) {
      res["object"] = boost::any(*object);
    }
    if (pipelineId) {
      res["pipelineId"] = boost::any(*pipelineId);
    }
    if (pipelineRunId) {
      res["pipelineRunId"] = boost::any(*pipelineRunId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("object") != m.end() && !m["object"].empty()) {
      object = make_shared<long>(boost::any_cast<long>(m["object"]));
    }
    if (m.find("pipelineId") != m.end() && !m["pipelineId"].empty()) {
      pipelineId = make_shared<long>(boost::any_cast<long>(m["pipelineId"]));
    }
    if (m.find("pipelineRunId") != m.end() && !m["pipelineRunId"].empty()) {
      pipelineRunId = make_shared<long>(boost::any_cast<long>(m["pipelineRunId"]));
    }
  }


  virtual ~ExecuteChangeRequestReleaseStageResponseBody() = default;
};
class ExecuteChangeRequestReleaseStageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExecuteChangeRequestReleaseStageResponseBody> body{};

  ExecuteChangeRequestReleaseStageResponse() {}

  explicit ExecuteChangeRequestReleaseStageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExecuteChangeRequestReleaseStageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExecuteChangeRequestReleaseStageResponseBody>(model1);
      }
    }
  }


  virtual ~ExecuteChangeRequestReleaseStageResponse() = default;
};
class ExportInsightCustomValueRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> startTime{};

  ExportInsightCustomValueRequest() {}

  explicit ExportInsightCustomValueRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["startTime"]));
    }
  }


  virtual ~ExportInsightCustomValueRequest() = default;
};
class ExportInsightCustomValueResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<double> doubleValue{};
  shared_ptr<string> fieldId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> identifier{};
  shared_ptr<string> isDeleted{};
  shared_ptr<long> longValue{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> targetId{};
  shared_ptr<string> targetType{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  ExportInsightCustomValueResponseBodyResult() {}

  explicit ExportInsightCustomValueResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (doubleValue) {
      res["doubleValue"] = boost::any(*doubleValue);
    }
    if (fieldId) {
      res["fieldId"] = boost::any(*fieldId);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (isDeleted) {
      res["isDeleted"] = boost::any(*isDeleted);
    }
    if (longValue) {
      res["longValue"] = boost::any(*longValue);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (targetId) {
      res["targetId"] = boost::any(*targetId);
    }
    if (targetType) {
      res["targetType"] = boost::any(*targetType);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("doubleValue") != m.end() && !m["doubleValue"].empty()) {
      doubleValue = make_shared<double>(boost::any_cast<double>(m["doubleValue"]));
    }
    if (m.find("fieldId") != m.end() && !m["fieldId"].empty()) {
      fieldId = make_shared<string>(boost::any_cast<string>(m["fieldId"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("isDeleted") != m.end() && !m["isDeleted"].empty()) {
      isDeleted = make_shared<string>(boost::any_cast<string>(m["isDeleted"]));
    }
    if (m.find("longValue") != m.end() && !m["longValue"].empty()) {
      longValue = make_shared<long>(boost::any_cast<long>(m["longValue"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("targetId") != m.end() && !m["targetId"].empty()) {
      targetId = make_shared<string>(boost::any_cast<string>(m["targetId"]));
    }
    if (m.find("targetType") != m.end() && !m["targetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["targetType"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~ExportInsightCustomValueResponseBodyResult() = default;
};
class ExportInsightCustomValueResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ExportInsightCustomValueResponseBodyResult>> result{};
  shared_ptr<long> totalCount{};

  ExportInsightCustomValueResponseBody() {}

  explicit ExportInsightCustomValueResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ExportInsightCustomValueResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExportInsightCustomValueResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ExportInsightCustomValueResponseBodyResult>>(expect1);
      }
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ExportInsightCustomValueResponseBody() = default;
};
class ExportInsightCustomValueResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportInsightCustomValueResponseBody> body{};

  ExportInsightCustomValueResponse() {}

  explicit ExportInsightCustomValueResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportInsightCustomValueResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportInsightCustomValueResponseBody>(model1);
      }
    }
  }


  virtual ~ExportInsightCustomValueResponse() = default;
};
class ExportInsightExpectedWorkTimeRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> startTime{};

  ExportInsightExpectedWorkTimeRequest() {}

  explicit ExportInsightExpectedWorkTimeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["startTime"]));
    }
  }


  virtual ~ExportInsightExpectedWorkTimeRequest() = default;
};
class ExportInsightExpectedWorkTimeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> identifier{};
  shared_ptr<string> isDeleted{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> recorderId{};
  shared_ptr<string> source{};
  shared_ptr<string> type{};
  shared_ptr<double> value{};
  shared_ptr<string> workitemId{};

  ExportInsightExpectedWorkTimeResponseBodyResult() {}

  explicit ExportInsightExpectedWorkTimeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (isDeleted) {
      res["isDeleted"] = boost::any(*isDeleted);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (projectId) {
      res["projectId"] = boost::any(*projectId);
    }
    if (recorderId) {
      res["recorderId"] = boost::any(*recorderId);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    if (workitemId) {
      res["workitemId"] = boost::any(*workitemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("isDeleted") != m.end() && !m["isDeleted"].empty()) {
      isDeleted = make_shared<string>(boost::any_cast<string>(m["isDeleted"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("projectId") != m.end() && !m["projectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["projectId"]));
    }
    if (m.find("recorderId") != m.end() && !m["recorderId"].empty()) {
      recorderId = make_shared<string>(boost::any_cast<string>(m["recorderId"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["value"]));
    }
    if (m.find("workitemId") != m.end() && !m["workitemId"].empty()) {
      workitemId = make_shared<string>(boost::any_cast<string>(m["workitemId"]));
    }
  }


  virtual ~ExportInsightExpectedWorkTimeResponseBodyResult() = default;
};
class ExportInsightExpectedWorkTimeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ExportInsightExpectedWorkTimeResponseBodyResult>> result{};
  shared_ptr<long> totalCount{};

  ExportInsightExpectedWorkTimeResponseBody() {}

  explicit ExportInsightExpectedWorkTimeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ExportInsightExpectedWorkTimeResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExportInsightExpectedWorkTimeResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ExportInsightExpectedWorkTimeResponseBodyResult>>(expect1);
      }
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ExportInsightExpectedWorkTimeResponseBody() = default;
};
class ExportInsightExpectedWorkTimeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportInsightExpectedWorkTimeResponseBody> body{};

  ExportInsightExpectedWorkTimeResponse() {}

  explicit ExportInsightExpectedWorkTimeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportInsightExpectedWorkTimeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportInsightExpectedWorkTimeResponseBody>(model1);
      }
    }
  }


  virtual ~ExportInsightExpectedWorkTimeResponse() = default;
};
class ExportInsightFieldRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> startTime{};

  ExportInsightFieldRequest() {}

  explicit ExportInsightFieldRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["startTime"]));
    }
  }


  virtual ~ExportInsightFieldRequest() = default;
};
class ExportInsightFieldResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> fieldId{};
  shared_ptr<string> fieldName{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> identifier{};
  shared_ptr<string> isDeleted{};
  shared_ptr<string> isSystem{};
  shared_ptr<string> optionValue{};
  shared_ptr<string> organizationId{};
  shared_ptr<long> position{};
  shared_ptr<string> scope{};
  shared_ptr<string> source{};
  shared_ptr<string> targetId{};
  shared_ptr<string> targetType{};
  shared_ptr<string> type{};

  ExportInsightFieldResponseBodyResult() {}

  explicit ExportInsightFieldResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldId) {
      res["fieldId"] = boost::any(*fieldId);
    }
    if (fieldName) {
      res["fieldName"] = boost::any(*fieldName);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (isDeleted) {
      res["isDeleted"] = boost::any(*isDeleted);
    }
    if (isSystem) {
      res["isSystem"] = boost::any(*isSystem);
    }
    if (optionValue) {
      res["optionValue"] = boost::any(*optionValue);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (position) {
      res["position"] = boost::any(*position);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (targetId) {
      res["targetId"] = boost::any(*targetId);
    }
    if (targetType) {
      res["targetType"] = boost::any(*targetType);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fieldId") != m.end() && !m["fieldId"].empty()) {
      fieldId = make_shared<string>(boost::any_cast<string>(m["fieldId"]));
    }
    if (m.find("fieldName") != m.end() && !m["fieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["fieldName"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("isDeleted") != m.end() && !m["isDeleted"].empty()) {
      isDeleted = make_shared<string>(boost::any_cast<string>(m["isDeleted"]));
    }
    if (m.find("isSystem") != m.end() && !m["isSystem"].empty()) {
      isSystem = make_shared<string>(boost::any_cast<string>(m["isSystem"]));
    }
    if (m.find("optionValue") != m.end() && !m["optionValue"].empty()) {
      optionValue = make_shared<string>(boost::any_cast<string>(m["optionValue"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("position") != m.end() && !m["position"].empty()) {
      position = make_shared<long>(boost::any_cast<long>(m["position"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["scope"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("targetId") != m.end() && !m["targetId"].empty()) {
      targetId = make_shared<string>(boost::any_cast<string>(m["targetId"]));
    }
    if (m.find("targetType") != m.end() && !m["targetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["targetType"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ExportInsightFieldResponseBodyResult() = default;
};
class ExportInsightFieldResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ExportInsightFieldResponseBodyResult>> result{};
  shared_ptr<long> totalCount{};

  ExportInsightFieldResponseBody() {}

  explicit ExportInsightFieldResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ExportInsightFieldResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExportInsightFieldResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ExportInsightFieldResponseBodyResult>>(expect1);
      }
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ExportInsightFieldResponseBody() = default;
};
class ExportInsightFieldResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportInsightFieldResponseBody> body{};

  ExportInsightFieldResponse() {}

  explicit ExportInsightFieldResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportInsightFieldResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportInsightFieldResponseBody>(model1);
      }
    }
  }


  virtual ~ExportInsightFieldResponse() = default;
};
class ExportInsightSpaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> startTime{};

  ExportInsightSpaceRequest() {}

  explicit ExportInsightSpaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["startTime"]));
    }
  }


  virtual ~ExportInsightSpaceRequest() = default;
};
class ExportInsightSpaceResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> customCode{};
  shared_ptr<string> description{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> identifier{};
  shared_ptr<string> isDeleted{};
  shared_ptr<string> name{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> source{};
  shared_ptr<string> stage{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  ExportInsightSpaceResponseBodyResult() {}

  explicit ExportInsightSpaceResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (customCode) {
      res["customCode"] = boost::any(*customCode);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (isDeleted) {
      res["isDeleted"] = boost::any(*isDeleted);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (stage) {
      res["stage"] = boost::any(*stage);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["category"]));
    }
    if (m.find("customCode") != m.end() && !m["customCode"].empty()) {
      customCode = make_shared<string>(boost::any_cast<string>(m["customCode"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("isDeleted") != m.end() && !m["isDeleted"].empty()) {
      isDeleted = make_shared<string>(boost::any_cast<string>(m["isDeleted"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("stage") != m.end() && !m["stage"].empty()) {
      stage = make_shared<string>(boost::any_cast<string>(m["stage"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ExportInsightSpaceResponseBodyResult() = default;
};
class ExportInsightSpaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ExportInsightSpaceResponseBodyResult>> result{};
  shared_ptr<long> totalCount{};

  ExportInsightSpaceResponseBody() {}

  explicit ExportInsightSpaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ExportInsightSpaceResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExportInsightSpaceResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ExportInsightSpaceResponseBodyResult>>(expect1);
      }
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ExportInsightSpaceResponseBody() = default;
};
class ExportInsightSpaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportInsightSpaceResponseBody> body{};

  ExportInsightSpaceResponse() {}

  explicit ExportInsightSpaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportInsightSpaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportInsightSpaceResponseBody>(model1);
      }
    }
  }


  virtual ~ExportInsightSpaceResponse() = default;
};
class ExportInsightSpaceRefRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> startTime{};

  ExportInsightSpaceRefRequest() {}

  explicit ExportInsightSpaceRefRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["startTime"]));
    }
  }


  virtual ~ExportInsightSpaceRefRequest() = default;
};
class ExportInsightSpaceRefResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> creatorId{};
  shared_ptr<string> fromId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> identifier{};
  shared_ptr<string> isDeleted{};
  shared_ptr<string> modifierId{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> toId{};
  shared_ptr<string> type{};

  ExportInsightSpaceRefResponseBodyResult() {}

  explicit ExportInsightSpaceRefResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creatorId) {
      res["creatorId"] = boost::any(*creatorId);
    }
    if (fromId) {
      res["fromId"] = boost::any(*fromId);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (isDeleted) {
      res["isDeleted"] = boost::any(*isDeleted);
    }
    if (modifierId) {
      res["modifierId"] = boost::any(*modifierId);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (toId) {
      res["toId"] = boost::any(*toId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("creatorId") != m.end() && !m["creatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["creatorId"]));
    }
    if (m.find("fromId") != m.end() && !m["fromId"].empty()) {
      fromId = make_shared<string>(boost::any_cast<string>(m["fromId"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("isDeleted") != m.end() && !m["isDeleted"].empty()) {
      isDeleted = make_shared<string>(boost::any_cast<string>(m["isDeleted"]));
    }
    if (m.find("modifierId") != m.end() && !m["modifierId"].empty()) {
      modifierId = make_shared<string>(boost::any_cast<string>(m["modifierId"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("toId") != m.end() && !m["toId"].empty()) {
      toId = make_shared<string>(boost::any_cast<string>(m["toId"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ExportInsightSpaceRefResponseBodyResult() = default;
};
class ExportInsightSpaceRefResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ExportInsightSpaceRefResponseBodyResult>> result{};
  shared_ptr<long> totalCount{};

  ExportInsightSpaceRefResponseBody() {}

  explicit ExportInsightSpaceRefResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ExportInsightSpaceRefResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExportInsightSpaceRefResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ExportInsightSpaceRefResponseBodyResult>>(expect1);
      }
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ExportInsightSpaceRefResponseBody() = default;
};
class ExportInsightSpaceRefResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportInsightSpaceRefResponseBody> body{};

  ExportInsightSpaceRefResponse() {}

  explicit ExportInsightSpaceRefResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportInsightSpaceRefResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportInsightSpaceRefResponseBody>(model1);
      }
    }
  }


  virtual ~ExportInsightSpaceRefResponse() = default;
};
class ExportInsightSprintRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> startTime{};

  ExportInsightSprintRequest() {}

  explicit ExportInsightSprintRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["startTime"]));
    }
  }


  virtual ~ExportInsightSprintRequest() = default;
};
class ExportInsightSprintResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> actualEnd{};
  shared_ptr<long> actualStart{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtEnd{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> gmtStart{};
  shared_ptr<long> id{};
  shared_ptr<string> identifier{};
  shared_ptr<string> isDeleted{};
  shared_ptr<string> name{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> source{};
  shared_ptr<long> status{};
  shared_ptr<double> workTimeCapacity{};

  ExportInsightSprintResponseBodyResult() {}

  explicit ExportInsightSprintResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualEnd) {
      res["actualEnd"] = boost::any(*actualEnd);
    }
    if (actualStart) {
      res["actualStart"] = boost::any(*actualStart);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtEnd) {
      res["gmtEnd"] = boost::any(*gmtEnd);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (gmtStart) {
      res["gmtStart"] = boost::any(*gmtStart);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (isDeleted) {
      res["isDeleted"] = boost::any(*isDeleted);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (projectId) {
      res["projectId"] = boost::any(*projectId);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (workTimeCapacity) {
      res["workTimeCapacity"] = boost::any(*workTimeCapacity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("actualEnd") != m.end() && !m["actualEnd"].empty()) {
      actualEnd = make_shared<long>(boost::any_cast<long>(m["actualEnd"]));
    }
    if (m.find("actualStart") != m.end() && !m["actualStart"].empty()) {
      actualStart = make_shared<long>(boost::any_cast<long>(m["actualStart"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtEnd") != m.end() && !m["gmtEnd"].empty()) {
      gmtEnd = make_shared<long>(boost::any_cast<long>(m["gmtEnd"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("gmtStart") != m.end() && !m["gmtStart"].empty()) {
      gmtStart = make_shared<long>(boost::any_cast<long>(m["gmtStart"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("isDeleted") != m.end() && !m["isDeleted"].empty()) {
      isDeleted = make_shared<string>(boost::any_cast<string>(m["isDeleted"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("projectId") != m.end() && !m["projectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["projectId"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("workTimeCapacity") != m.end() && !m["workTimeCapacity"].empty()) {
      workTimeCapacity = make_shared<double>(boost::any_cast<double>(m["workTimeCapacity"]));
    }
  }


  virtual ~ExportInsightSprintResponseBodyResult() = default;
};
class ExportInsightSprintResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ExportInsightSprintResponseBodyResult>> result{};
  shared_ptr<long> totalCount{};

  ExportInsightSprintResponseBody() {}

  explicit ExportInsightSprintResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ExportInsightSprintResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExportInsightSprintResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ExportInsightSprintResponseBodyResult>>(expect1);
      }
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ExportInsightSprintResponseBody() = default;
};
class ExportInsightSprintResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportInsightSprintResponseBody> body{};

  ExportInsightSprintResponse() {}

  explicit ExportInsightSprintResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportInsightSprintResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportInsightSprintResponseBody>(model1);
      }
    }
  }


  virtual ~ExportInsightSprintResponse() = default;
};
class ExportInsightTagRefRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> startTime{};

  ExportInsightTagRefRequest() {}

  explicit ExportInsightTagRefRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["startTime"]));
    }
  }


  virtual ~ExportInsightTagRefRequest() = default;
};
class ExportInsightTagRefResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> identifier{};
  shared_ptr<string> isDeleted{};
  shared_ptr<string> name{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> tagId{};
  shared_ptr<string> targetId{};
  shared_ptr<string> targetType{};

  ExportInsightTagRefResponseBodyResult() {}

  explicit ExportInsightTagRefResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (isDeleted) {
      res["isDeleted"] = boost::any(*isDeleted);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (tagId) {
      res["tagId"] = boost::any(*tagId);
    }
    if (targetId) {
      res["targetId"] = boost::any(*targetId);
    }
    if (targetType) {
      res["targetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("isDeleted") != m.end() && !m["isDeleted"].empty()) {
      isDeleted = make_shared<string>(boost::any_cast<string>(m["isDeleted"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("tagId") != m.end() && !m["tagId"].empty()) {
      tagId = make_shared<string>(boost::any_cast<string>(m["tagId"]));
    }
    if (m.find("targetId") != m.end() && !m["targetId"].empty()) {
      targetId = make_shared<string>(boost::any_cast<string>(m["targetId"]));
    }
    if (m.find("targetType") != m.end() && !m["targetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["targetType"]));
    }
  }


  virtual ~ExportInsightTagRefResponseBodyResult() = default;
};
class ExportInsightTagRefResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ExportInsightTagRefResponseBodyResult>> result{};
  shared_ptr<long> totalCount{};

  ExportInsightTagRefResponseBody() {}

  explicit ExportInsightTagRefResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ExportInsightTagRefResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExportInsightTagRefResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ExportInsightTagRefResponseBodyResult>>(expect1);
      }
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ExportInsightTagRefResponseBody() = default;
};
class ExportInsightTagRefResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportInsightTagRefResponseBody> body{};

  ExportInsightTagRefResponse() {}

  explicit ExportInsightTagRefResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportInsightTagRefResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportInsightTagRefResponseBody>(model1);
      }
    }
  }


  virtual ~ExportInsightTagRefResponse() = default;
};
class ExportInsightWorkTimeRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> startTime{};

  ExportInsightWorkTimeRequest() {}

  explicit ExportInsightWorkTimeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["startTime"]));
    }
  }


  virtual ~ExportInsightWorkTimeRequest() = default;
};
class ExportInsightWorkTimeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<double> actualValue{};
  shared_ptr<string> description{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtEnd{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> gmtStart{};
  shared_ptr<long> id{};
  shared_ptr<string> identifier{};
  shared_ptr<string> isDeleted{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> recorderId{};
  shared_ptr<string> source{};
  shared_ptr<string> type{};
  shared_ptr<string> uuid{};
  shared_ptr<long> value{};
  shared_ptr<string> workitemId{};

  ExportInsightWorkTimeResponseBodyResult() {}

  explicit ExportInsightWorkTimeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualValue) {
      res["actualValue"] = boost::any(*actualValue);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtEnd) {
      res["gmtEnd"] = boost::any(*gmtEnd);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (gmtStart) {
      res["gmtStart"] = boost::any(*gmtStart);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (isDeleted) {
      res["isDeleted"] = boost::any(*isDeleted);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (projectId) {
      res["projectId"] = boost::any(*projectId);
    }
    if (recorderId) {
      res["recorderId"] = boost::any(*recorderId);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (uuid) {
      res["uuid"] = boost::any(*uuid);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    if (workitemId) {
      res["workitemId"] = boost::any(*workitemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("actualValue") != m.end() && !m["actualValue"].empty()) {
      actualValue = make_shared<double>(boost::any_cast<double>(m["actualValue"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtEnd") != m.end() && !m["gmtEnd"].empty()) {
      gmtEnd = make_shared<long>(boost::any_cast<long>(m["gmtEnd"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("gmtStart") != m.end() && !m["gmtStart"].empty()) {
      gmtStart = make_shared<long>(boost::any_cast<long>(m["gmtStart"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("isDeleted") != m.end() && !m["isDeleted"].empty()) {
      isDeleted = make_shared<string>(boost::any_cast<string>(m["isDeleted"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("projectId") != m.end() && !m["projectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["projectId"]));
    }
    if (m.find("recorderId") != m.end() && !m["recorderId"].empty()) {
      recorderId = make_shared<string>(boost::any_cast<string>(m["recorderId"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("uuid") != m.end() && !m["uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["uuid"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["value"]));
    }
    if (m.find("workitemId") != m.end() && !m["workitemId"].empty()) {
      workitemId = make_shared<string>(boost::any_cast<string>(m["workitemId"]));
    }
  }


  virtual ~ExportInsightWorkTimeResponseBodyResult() = default;
};
class ExportInsightWorkTimeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ExportInsightWorkTimeResponseBodyResult>> result{};
  shared_ptr<long> totalCount{};

  ExportInsightWorkTimeResponseBody() {}

  explicit ExportInsightWorkTimeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ExportInsightWorkTimeResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExportInsightWorkTimeResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ExportInsightWorkTimeResponseBodyResult>>(expect1);
      }
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ExportInsightWorkTimeResponseBody() = default;
};
class ExportInsightWorkTimeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportInsightWorkTimeResponseBody> body{};

  ExportInsightWorkTimeResponse() {}

  explicit ExportInsightWorkTimeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportInsightWorkTimeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportInsightWorkTimeResponseBody>(model1);
      }
    }
  }


  virtual ~ExportInsightWorkTimeResponse() = default;
};
class ExportInsightWorkitemStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> startTime{};

  ExportInsightWorkitemStatusRequest() {}

  explicit ExportInsightWorkitemStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["startTime"]));
    }
  }


  virtual ~ExportInsightWorkitemStatusRequest() = default;
};
class ExportInsightWorkitemStatusResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> assignedToId{};
  shared_ptr<string> creatorId{};
  shared_ptr<long> expectedWorkTime{};
  shared_ptr<long> gmtClosed{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtDue{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> gmtStart{};
  shared_ptr<long> gmtTodo{};
  shared_ptr<long> id{};
  shared_ptr<string> isArchived{};
  shared_ptr<string> isDeleted{};
  shared_ptr<string> isDone{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> parentId{};
  shared_ptr<string> participantIds{};
  shared_ptr<long> phase{};
  shared_ptr<long> priority{};
  shared_ptr<string> productId{};
  shared_ptr<string> projectId{};
  shared_ptr<long> serialNumber{};
  shared_ptr<string> source{};
  shared_ptr<string> sprintId{};
  shared_ptr<long> stage{};
  shared_ptr<string> status{};
  shared_ptr<string> statusId{};
  shared_ptr<double> storyPoint{};
  shared_ptr<string> subType{};
  shared_ptr<string> subject{};
  shared_ptr<long> type{};
  shared_ptr<string> versionId{};
  shared_ptr<string> versions{};
  shared_ptr<long> workTime{};
  shared_ptr<string> workitemId{};

  ExportInsightWorkitemStatusResponseBodyResult() {}

  explicit ExportInsightWorkitemStatusResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignedToId) {
      res["assignedToId"] = boost::any(*assignedToId);
    }
    if (creatorId) {
      res["creatorId"] = boost::any(*creatorId);
    }
    if (expectedWorkTime) {
      res["expectedWorkTime"] = boost::any(*expectedWorkTime);
    }
    if (gmtClosed) {
      res["gmtClosed"] = boost::any(*gmtClosed);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtDue) {
      res["gmtDue"] = boost::any(*gmtDue);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (gmtStart) {
      res["gmtStart"] = boost::any(*gmtStart);
    }
    if (gmtTodo) {
      res["gmtTodo"] = boost::any(*gmtTodo);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (isArchived) {
      res["isArchived"] = boost::any(*isArchived);
    }
    if (isDeleted) {
      res["isDeleted"] = boost::any(*isDeleted);
    }
    if (isDone) {
      res["isDone"] = boost::any(*isDone);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (parentId) {
      res["parentId"] = boost::any(*parentId);
    }
    if (participantIds) {
      res["participantIds"] = boost::any(*participantIds);
    }
    if (phase) {
      res["phase"] = boost::any(*phase);
    }
    if (priority) {
      res["priority"] = boost::any(*priority);
    }
    if (productId) {
      res["productId"] = boost::any(*productId);
    }
    if (projectId) {
      res["projectId"] = boost::any(*projectId);
    }
    if (serialNumber) {
      res["serialNumber"] = boost::any(*serialNumber);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (sprintId) {
      res["sprintId"] = boost::any(*sprintId);
    }
    if (stage) {
      res["stage"] = boost::any(*stage);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (statusId) {
      res["statusId"] = boost::any(*statusId);
    }
    if (storyPoint) {
      res["storyPoint"] = boost::any(*storyPoint);
    }
    if (subType) {
      res["subType"] = boost::any(*subType);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (versionId) {
      res["versionId"] = boost::any(*versionId);
    }
    if (versions) {
      res["versions"] = boost::any(*versions);
    }
    if (workTime) {
      res["workTime"] = boost::any(*workTime);
    }
    if (workitemId) {
      res["workitemId"] = boost::any(*workitemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignedToId") != m.end() && !m["assignedToId"].empty()) {
      assignedToId = make_shared<string>(boost::any_cast<string>(m["assignedToId"]));
    }
    if (m.find("creatorId") != m.end() && !m["creatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["creatorId"]));
    }
    expectedWorkTime = make_shared<long>(boost::any_cast<long>(m["expectedWorkTime"]));
    if (m.find("gmtClosed") != m.end() && !m["gmtClosed"].empty()) {
      gmtClosed = make_shared<long>(boost::any_cast<long>(m["gmtClosed"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtDue") != m.end() && !m["gmtDue"].empty()) {
      gmtDue = make_shared<long>(boost::any_cast<long>(m["gmtDue"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("gmtStart") != m.end() && !m["gmtStart"].empty()) {
      gmtStart = make_shared<long>(boost::any_cast<long>(m["gmtStart"]));
    }
    if (m.find("gmtTodo") != m.end() && !m["gmtTodo"].empty()) {
      gmtTodo = make_shared<long>(boost::any_cast<long>(m["gmtTodo"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("isArchived") != m.end() && !m["isArchived"].empty()) {
      isArchived = make_shared<string>(boost::any_cast<string>(m["isArchived"]));
    }
    if (m.find("isDeleted") != m.end() && !m["isDeleted"].empty()) {
      isDeleted = make_shared<string>(boost::any_cast<string>(m["isDeleted"]));
    }
    if (m.find("isDone") != m.end() && !m["isDone"].empty()) {
      isDone = make_shared<string>(boost::any_cast<string>(m["isDone"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("parentId") != m.end() && !m["parentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["parentId"]));
    }
    if (m.find("participantIds") != m.end() && !m["participantIds"].empty()) {
      participantIds = make_shared<string>(boost::any_cast<string>(m["participantIds"]));
    }
    if (m.find("phase") != m.end() && !m["phase"].empty()) {
      phase = make_shared<long>(boost::any_cast<long>(m["phase"]));
    }
    if (m.find("priority") != m.end() && !m["priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["priority"]));
    }
    if (m.find("productId") != m.end() && !m["productId"].empty()) {
      productId = make_shared<string>(boost::any_cast<string>(m["productId"]));
    }
    if (m.find("projectId") != m.end() && !m["projectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["projectId"]));
    }
    if (m.find("serialNumber") != m.end() && !m["serialNumber"].empty()) {
      serialNumber = make_shared<long>(boost::any_cast<long>(m["serialNumber"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("sprintId") != m.end() && !m["sprintId"].empty()) {
      sprintId = make_shared<string>(boost::any_cast<string>(m["sprintId"]));
    }
    if (m.find("stage") != m.end() && !m["stage"].empty()) {
      stage = make_shared<long>(boost::any_cast<long>(m["stage"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("statusId") != m.end() && !m["statusId"].empty()) {
      statusId = make_shared<string>(boost::any_cast<string>(m["statusId"]));
    }
    if (m.find("storyPoint") != m.end() && !m["storyPoint"].empty()) {
      storyPoint = make_shared<double>(boost::any_cast<double>(m["storyPoint"]));
    }
    if (m.find("subType") != m.end() && !m["subType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["subType"]));
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
    if (m.find("versionId") != m.end() && !m["versionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["versionId"]));
    }
    if (m.find("versions") != m.end() && !m["versions"].empty()) {
      versions = make_shared<string>(boost::any_cast<string>(m["versions"]));
    }
    if (m.find("workTime") != m.end() && !m["workTime"].empty()) {
      workTime = make_shared<long>(boost::any_cast<long>(m["workTime"]));
    }
    if (m.find("workitemId") != m.end() && !m["workitemId"].empty()) {
      workitemId = make_shared<string>(boost::any_cast<string>(m["workitemId"]));
    }
  }


  virtual ~ExportInsightWorkitemStatusResponseBodyResult() = default;
};
class ExportInsightWorkitemStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ExportInsightWorkitemStatusResponseBodyResult>> result{};
  shared_ptr<long> totalCount{};

  ExportInsightWorkitemStatusResponseBody() {}

  explicit ExportInsightWorkitemStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ExportInsightWorkitemStatusResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExportInsightWorkitemStatusResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ExportInsightWorkitemStatusResponseBodyResult>>(expect1);
      }
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ExportInsightWorkitemStatusResponseBody() = default;
};
class ExportInsightWorkitemStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportInsightWorkitemStatusResponseBody> body{};

  ExportInsightWorkitemStatusResponse() {}

  explicit ExportInsightWorkitemStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportInsightWorkitemStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportInsightWorkitemStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ExportInsightWorkitemStatusResponse() = default;
};
class ExportInsightWorkitemStatusJoinWorkitemDefectExtraRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> startTime{};

  ExportInsightWorkitemStatusJoinWorkitemDefectExtraRequest() {}

  explicit ExportInsightWorkitemStatusJoinWorkitemDefectExtraRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["startTime"]));
    }
  }


  virtual ~ExportInsightWorkitemStatusJoinWorkitemDefectExtraRequest() = default;
};
class ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> assignedToId{};
  shared_ptr<string> creatorId{};
  shared_ptr<long> expectedWorkTime{};
  shared_ptr<long> extraId{};
  shared_ptr<string> extraIsDeleted{};
  shared_ptr<long> foundPhase{};
  shared_ptr<long> gmtClosed{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtDue{};
  shared_ptr<string> gmtFixed{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> gmtStart{};
  shared_ptr<long> gmtTodo{};
  shared_ptr<long> id{};
  shared_ptr<string> isArchived{};
  shared_ptr<string> isDeleted{};
  shared_ptr<string> isDone{};
  shared_ptr<string> isStupid{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> parentId{};
  shared_ptr<string> participantIds{};
  shared_ptr<long> phase{};
  shared_ptr<long> priority{};
  shared_ptr<string> productId{};
  shared_ptr<string> projectId{};
  shared_ptr<long> reopenNum{};
  shared_ptr<long> serialNumber{};
  shared_ptr<long> seriousLevel{};
  shared_ptr<string> solution{};
  shared_ptr<string> source{};
  shared_ptr<string> sprintId{};
  shared_ptr<long> stage{};
  shared_ptr<string> status{};
  shared_ptr<string> statusId{};
  shared_ptr<double> storyPoint{};
  shared_ptr<string> subType{};
  shared_ptr<string> subject{};
  shared_ptr<long> type{};
  shared_ptr<string> verifierId{};
  shared_ptr<string> versionId{};
  shared_ptr<string> versions{};
  shared_ptr<long> workTime{};
  shared_ptr<string> workitemId{};

  ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBodyResult() {}

  explicit ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignedToId) {
      res["assignedToId"] = boost::any(*assignedToId);
    }
    if (creatorId) {
      res["creatorId"] = boost::any(*creatorId);
    }
    if (expectedWorkTime) {
      res["expectedWorkTime"] = boost::any(*expectedWorkTime);
    }
    if (extraId) {
      res["extraId"] = boost::any(*extraId);
    }
    if (extraIsDeleted) {
      res["extraIsDeleted"] = boost::any(*extraIsDeleted);
    }
    if (foundPhase) {
      res["foundPhase"] = boost::any(*foundPhase);
    }
    if (gmtClosed) {
      res["gmtClosed"] = boost::any(*gmtClosed);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtDue) {
      res["gmtDue"] = boost::any(*gmtDue);
    }
    if (gmtFixed) {
      res["gmtFixed"] = boost::any(*gmtFixed);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (gmtStart) {
      res["gmtStart"] = boost::any(*gmtStart);
    }
    if (gmtTodo) {
      res["gmtTodo"] = boost::any(*gmtTodo);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (isArchived) {
      res["isArchived"] = boost::any(*isArchived);
    }
    if (isDeleted) {
      res["isDeleted"] = boost::any(*isDeleted);
    }
    if (isDone) {
      res["isDone"] = boost::any(*isDone);
    }
    if (isStupid) {
      res["isStupid"] = boost::any(*isStupid);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (parentId) {
      res["parentId"] = boost::any(*parentId);
    }
    if (participantIds) {
      res["participantIds"] = boost::any(*participantIds);
    }
    if (phase) {
      res["phase"] = boost::any(*phase);
    }
    if (priority) {
      res["priority"] = boost::any(*priority);
    }
    if (productId) {
      res["productId"] = boost::any(*productId);
    }
    if (projectId) {
      res["projectId"] = boost::any(*projectId);
    }
    if (reopenNum) {
      res["reopenNum"] = boost::any(*reopenNum);
    }
    if (serialNumber) {
      res["serialNumber"] = boost::any(*serialNumber);
    }
    if (seriousLevel) {
      res["seriousLevel"] = boost::any(*seriousLevel);
    }
    if (solution) {
      res["solution"] = boost::any(*solution);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (sprintId) {
      res["sprintId"] = boost::any(*sprintId);
    }
    if (stage) {
      res["stage"] = boost::any(*stage);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (statusId) {
      res["statusId"] = boost::any(*statusId);
    }
    if (storyPoint) {
      res["storyPoint"] = boost::any(*storyPoint);
    }
    if (subType) {
      res["subType"] = boost::any(*subType);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (verifierId) {
      res["verifierId"] = boost::any(*verifierId);
    }
    if (versionId) {
      res["versionId"] = boost::any(*versionId);
    }
    if (versions) {
      res["versions"] = boost::any(*versions);
    }
    if (workTime) {
      res["workTime"] = boost::any(*workTime);
    }
    if (workitemId) {
      res["workitemId"] = boost::any(*workitemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignedToId") != m.end() && !m["assignedToId"].empty()) {
      assignedToId = make_shared<string>(boost::any_cast<string>(m["assignedToId"]));
    }
    if (m.find("creatorId") != m.end() && !m["creatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["creatorId"]));
    }
    expectedWorkTime = make_shared<long>(boost::any_cast<long>(m["expectedWorkTime"]));
    if (m.find("extraId") != m.end() && !m["extraId"].empty()) {
      extraId = make_shared<long>(boost::any_cast<long>(m["extraId"]));
    }
    if (m.find("extraIsDeleted") != m.end() && !m["extraIsDeleted"].empty()) {
      extraIsDeleted = make_shared<string>(boost::any_cast<string>(m["extraIsDeleted"]));
    }
    if (m.find("foundPhase") != m.end() && !m["foundPhase"].empty()) {
      foundPhase = make_shared<long>(boost::any_cast<long>(m["foundPhase"]));
    }
    if (m.find("gmtClosed") != m.end() && !m["gmtClosed"].empty()) {
      gmtClosed = make_shared<long>(boost::any_cast<long>(m["gmtClosed"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtDue") != m.end() && !m["gmtDue"].empty()) {
      gmtDue = make_shared<long>(boost::any_cast<long>(m["gmtDue"]));
    }
    if (m.find("gmtFixed") != m.end() && !m["gmtFixed"].empty()) {
      gmtFixed = make_shared<string>(boost::any_cast<string>(m["gmtFixed"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("gmtStart") != m.end() && !m["gmtStart"].empty()) {
      gmtStart = make_shared<long>(boost::any_cast<long>(m["gmtStart"]));
    }
    if (m.find("gmtTodo") != m.end() && !m["gmtTodo"].empty()) {
      gmtTodo = make_shared<long>(boost::any_cast<long>(m["gmtTodo"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("isArchived") != m.end() && !m["isArchived"].empty()) {
      isArchived = make_shared<string>(boost::any_cast<string>(m["isArchived"]));
    }
    if (m.find("isDeleted") != m.end() && !m["isDeleted"].empty()) {
      isDeleted = make_shared<string>(boost::any_cast<string>(m["isDeleted"]));
    }
    if (m.find("isDone") != m.end() && !m["isDone"].empty()) {
      isDone = make_shared<string>(boost::any_cast<string>(m["isDone"]));
    }
    if (m.find("isStupid") != m.end() && !m["isStupid"].empty()) {
      isStupid = make_shared<string>(boost::any_cast<string>(m["isStupid"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("parentId") != m.end() && !m["parentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["parentId"]));
    }
    if (m.find("participantIds") != m.end() && !m["participantIds"].empty()) {
      participantIds = make_shared<string>(boost::any_cast<string>(m["participantIds"]));
    }
    if (m.find("phase") != m.end() && !m["phase"].empty()) {
      phase = make_shared<long>(boost::any_cast<long>(m["phase"]));
    }
    if (m.find("priority") != m.end() && !m["priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["priority"]));
    }
    if (m.find("productId") != m.end() && !m["productId"].empty()) {
      productId = make_shared<string>(boost::any_cast<string>(m["productId"]));
    }
    if (m.find("projectId") != m.end() && !m["projectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["projectId"]));
    }
    if (m.find("reopenNum") != m.end() && !m["reopenNum"].empty()) {
      reopenNum = make_shared<long>(boost::any_cast<long>(m["reopenNum"]));
    }
    if (m.find("serialNumber") != m.end() && !m["serialNumber"].empty()) {
      serialNumber = make_shared<long>(boost::any_cast<long>(m["serialNumber"]));
    }
    if (m.find("seriousLevel") != m.end() && !m["seriousLevel"].empty()) {
      seriousLevel = make_shared<long>(boost::any_cast<long>(m["seriousLevel"]));
    }
    if (m.find("solution") != m.end() && !m["solution"].empty()) {
      solution = make_shared<string>(boost::any_cast<string>(m["solution"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("sprintId") != m.end() && !m["sprintId"].empty()) {
      sprintId = make_shared<string>(boost::any_cast<string>(m["sprintId"]));
    }
    if (m.find("stage") != m.end() && !m["stage"].empty()) {
      stage = make_shared<long>(boost::any_cast<long>(m["stage"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("statusId") != m.end() && !m["statusId"].empty()) {
      statusId = make_shared<string>(boost::any_cast<string>(m["statusId"]));
    }
    if (m.find("storyPoint") != m.end() && !m["storyPoint"].empty()) {
      storyPoint = make_shared<double>(boost::any_cast<double>(m["storyPoint"]));
    }
    if (m.find("subType") != m.end() && !m["subType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["subType"]));
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
    if (m.find("verifierId") != m.end() && !m["verifierId"].empty()) {
      verifierId = make_shared<string>(boost::any_cast<string>(m["verifierId"]));
    }
    if (m.find("versionId") != m.end() && !m["versionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["versionId"]));
    }
    if (m.find("versions") != m.end() && !m["versions"].empty()) {
      versions = make_shared<string>(boost::any_cast<string>(m["versions"]));
    }
    if (m.find("workTime") != m.end() && !m["workTime"].empty()) {
      workTime = make_shared<long>(boost::any_cast<long>(m["workTime"]));
    }
    if (m.find("workitemId") != m.end() && !m["workitemId"].empty()) {
      workitemId = make_shared<string>(boost::any_cast<string>(m["workitemId"]));
    }
  }


  virtual ~ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBodyResult() = default;
};
class ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBodyResult>> result{};
  shared_ptr<long> totalCount{};

  ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBody() {}

  explicit ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBodyResult>>(expect1);
      }
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBody() = default;
};
class ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBody> body{};

  ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponse() {}

  explicit ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBody>(model1);
      }
    }
  }


  virtual ~ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponse() = default;
};
class ExportInsightWorkitemVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> startTime{};

  ExportInsightWorkitemVersionRequest() {}

  explicit ExportInsightWorkitemVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["startTime"]));
    }
  }


  virtual ~ExportInsightWorkitemVersionRequest() = default;
};
class ExportInsightWorkitemVersionResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> gmtPublish{};
  shared_ptr<long> gmtStart{};
  shared_ptr<long> id{};
  shared_ptr<string> identifier{};
  shared_ptr<string> isDeleted{};
  shared_ptr<long> lockStatus{};
  shared_ptr<string> name{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> source{};
  shared_ptr<long> status{};
  shared_ptr<string> targetId{};
  shared_ptr<string> targetType{};

  ExportInsightWorkitemVersionResponseBodyResult() {}

  explicit ExportInsightWorkitemVersionResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (gmtPublish) {
      res["gmtPublish"] = boost::any(*gmtPublish);
    }
    if (gmtStart) {
      res["gmtStart"] = boost::any(*gmtStart);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (isDeleted) {
      res["isDeleted"] = boost::any(*isDeleted);
    }
    if (lockStatus) {
      res["lockStatus"] = boost::any(*lockStatus);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (targetId) {
      res["targetId"] = boost::any(*targetId);
    }
    if (targetType) {
      res["targetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("gmtPublish") != m.end() && !m["gmtPublish"].empty()) {
      gmtPublish = make_shared<long>(boost::any_cast<long>(m["gmtPublish"]));
    }
    if (m.find("gmtStart") != m.end() && !m["gmtStart"].empty()) {
      gmtStart = make_shared<long>(boost::any_cast<long>(m["gmtStart"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("isDeleted") != m.end() && !m["isDeleted"].empty()) {
      isDeleted = make_shared<string>(boost::any_cast<string>(m["isDeleted"]));
    }
    if (m.find("lockStatus") != m.end() && !m["lockStatus"].empty()) {
      lockStatus = make_shared<long>(boost::any_cast<long>(m["lockStatus"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("targetId") != m.end() && !m["targetId"].empty()) {
      targetId = make_shared<string>(boost::any_cast<string>(m["targetId"]));
    }
    if (m.find("targetType") != m.end() && !m["targetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["targetType"]));
    }
  }


  virtual ~ExportInsightWorkitemVersionResponseBodyResult() = default;
};
class ExportInsightWorkitemVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ExportInsightWorkitemVersionResponseBodyResult>> result{};
  shared_ptr<long> totalCount{};

  ExportInsightWorkitemVersionResponseBody() {}

  explicit ExportInsightWorkitemVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ExportInsightWorkitemVersionResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExportInsightWorkitemVersionResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ExportInsightWorkitemVersionResponseBodyResult>>(expect1);
      }
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ExportInsightWorkitemVersionResponseBody() = default;
};
class ExportInsightWorkitemVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportInsightWorkitemVersionResponseBody> body{};

  ExportInsightWorkitemVersionResponse() {}

  explicit ExportInsightWorkitemVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportInsightWorkitemVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportInsightWorkitemVersionResponseBody>(model1);
      }
    }
  }


  virtual ~ExportInsightWorkitemVersionResponse() = default;
};
class ExportWorkitemActivityRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> startTime{};

  ExportWorkitemActivityRequest() {}

  explicit ExportWorkitemActivityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["startTime"]));
    }
  }


  virtual ~ExportWorkitemActivityRequest() = default;
};
class ExportWorkitemActivityResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> gmtEvent{};
  shared_ptr<long> id{};
  shared_ptr<string> identifier{};
  shared_ptr<string> newValue{};
  shared_ptr<string> oldValue{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> source{};
  shared_ptr<string> type{};
  shared_ptr<string> workitemId{};

  ExportWorkitemActivityResponseBodyResult() {}

  explicit ExportWorkitemActivityResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtEvent) {
      res["gmtEvent"] = boost::any(*gmtEvent);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (newValue) {
      res["newValue"] = boost::any(*newValue);
    }
    if (oldValue) {
      res["oldValue"] = boost::any(*oldValue);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (projectId) {
      res["projectId"] = boost::any(*projectId);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (workitemId) {
      res["workitemId"] = boost::any(*workitemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gmtEvent") != m.end() && !m["gmtEvent"].empty()) {
      gmtEvent = make_shared<long>(boost::any_cast<long>(m["gmtEvent"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("newValue") != m.end() && !m["newValue"].empty()) {
      newValue = make_shared<string>(boost::any_cast<string>(m["newValue"]));
    }
    if (m.find("oldValue") != m.end() && !m["oldValue"].empty()) {
      oldValue = make_shared<string>(boost::any_cast<string>(m["oldValue"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("projectId") != m.end() && !m["projectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["projectId"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("workitemId") != m.end() && !m["workitemId"].empty()) {
      workitemId = make_shared<string>(boost::any_cast<string>(m["workitemId"]));
    }
  }


  virtual ~ExportWorkitemActivityResponseBodyResult() = default;
};
class ExportWorkitemActivityResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ExportWorkitemActivityResponseBodyResult>> result{};
  shared_ptr<long> totalCount{};

  ExportWorkitemActivityResponseBody() {}

  explicit ExportWorkitemActivityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ExportWorkitemActivityResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExportWorkitemActivityResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ExportWorkitemActivityResponseBodyResult>>(expect1);
      }
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ExportWorkitemActivityResponseBody() = default;
};
class ExportWorkitemActivityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportWorkitemActivityResponseBody> body{};

  ExportWorkitemActivityResponse() {}

  explicit ExportWorkitemActivityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportWorkitemActivityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportWorkitemActivityResponseBody>(model1);
      }
    }
  }


  virtual ~ExportWorkitemActivityResponse() = default;
};
class FrozenWorkspaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  FrozenWorkspaceResponseBody() {}

  explicit FrozenWorkspaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~FrozenWorkspaceResponseBody() = default;
};
class FrozenWorkspaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FrozenWorkspaceResponseBody> body{};

  FrozenWorkspaceResponse() {}

  explicit FrozenWorkspaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FrozenWorkspaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FrozenWorkspaceResponseBody>(model1);
      }
    }
  }


  virtual ~FrozenWorkspaceResponse() = default;
};
class GetApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};

  GetApplicationRequest() {}

  explicit GetApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~GetApplicationRequest() = default;
};
class GetApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> appTemplateDisplayName{};
  shared_ptr<string> appTemplateName{};
  shared_ptr<string> creatorAccountId{};
  shared_ptr<string> description{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};

  GetApplicationResponseBody() {}

  explicit GetApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appTemplateDisplayName) {
      res["appTemplateDisplayName"] = boost::any(*appTemplateDisplayName);
    }
    if (appTemplateName) {
      res["appTemplateName"] = boost::any(*appTemplateName);
    }
    if (creatorAccountId) {
      res["creatorAccountId"] = boost::any(*creatorAccountId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("appTemplateDisplayName") != m.end() && !m["appTemplateDisplayName"].empty()) {
      appTemplateDisplayName = make_shared<string>(boost::any_cast<string>(m["appTemplateDisplayName"]));
    }
    if (m.find("appTemplateName") != m.end() && !m["appTemplateName"].empty()) {
      appTemplateName = make_shared<string>(boost::any_cast<string>(m["appTemplateName"]));
    }
    if (m.find("creatorAccountId") != m.end() && !m["creatorAccountId"].empty()) {
      creatorAccountId = make_shared<string>(boost::any_cast<string>(m["creatorAccountId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmtCreate"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetApplicationResponseBody() = default;
};
class GetApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetApplicationResponseBody> body{};

  GetApplicationResponse() {}

  explicit GetApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~GetApplicationResponse() = default;
};
class GetBranchInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> branchName{};
  shared_ptr<string> organizationId{};

  GetBranchInfoRequest() {}

  explicit GetBranchInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (branchName) {
      res["branchName"] = boost::any(*branchName);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("branchName") != m.end() && !m["branchName"].empty()) {
      branchName = make_shared<string>(boost::any_cast<string>(m["branchName"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~GetBranchInfoRequest() = default;
};
class GetBranchInfoResponseBodyResultCommitAuthor : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};

  GetBranchInfoResponseBodyResultCommitAuthor() {}

  explicit GetBranchInfoResponseBodyResultCommitAuthor(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~GetBranchInfoResponseBodyResultCommitAuthor() = default;
};
class GetBranchInfoResponseBodyResultCommitCommitter : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};

  GetBranchInfoResponseBodyResultCommitCommitter() {}

  explicit GetBranchInfoResponseBodyResultCommitCommitter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~GetBranchInfoResponseBodyResultCommitCommitter() = default;
};
class GetBranchInfoResponseBodyResultCommitSignature : public Darabonba::Model {
public:
  shared_ptr<string> gpgKeyId{};
  shared_ptr<string> verificationStatus{};

  GetBranchInfoResponseBodyResultCommitSignature() {}

  explicit GetBranchInfoResponseBodyResultCommitSignature(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gpgKeyId) {
      res["gpgKeyId"] = boost::any(*gpgKeyId);
    }
    if (verificationStatus) {
      res["verificationStatus"] = boost::any(*verificationStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gpgKeyId") != m.end() && !m["gpgKeyId"].empty()) {
      gpgKeyId = make_shared<string>(boost::any_cast<string>(m["gpgKeyId"]));
    }
    if (m.find("verificationStatus") != m.end() && !m["verificationStatus"].empty()) {
      verificationStatus = make_shared<string>(boost::any_cast<string>(m["verificationStatus"]));
    }
  }


  virtual ~GetBranchInfoResponseBodyResultCommitSignature() = default;
};
class GetBranchInfoResponseBodyResultCommit : public Darabonba::Model {
public:
  shared_ptr<GetBranchInfoResponseBodyResultCommitAuthor> author{};
  shared_ptr<string> authorEmail{};
  shared_ptr<string> authorName{};
  shared_ptr<string> authoredDate{};
  shared_ptr<long> commentsCount{};
  shared_ptr<string> committedDate{};
  shared_ptr<GetBranchInfoResponseBodyResultCommitCommitter> committer{};
  shared_ptr<string> committerEmail{};
  shared_ptr<string> committerName{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> id{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> parentIds{};
  shared_ptr<string> shortId{};
  shared_ptr<GetBranchInfoResponseBodyResultCommitSignature> signature{};
  shared_ptr<string> title{};

  GetBranchInfoResponseBodyResultCommit() {}

  explicit GetBranchInfoResponseBodyResultCommit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (author) {
      res["author"] = author ? boost::any(author->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (authorEmail) {
      res["authorEmail"] = boost::any(*authorEmail);
    }
    if (authorName) {
      res["authorName"] = boost::any(*authorName);
    }
    if (authoredDate) {
      res["authoredDate"] = boost::any(*authoredDate);
    }
    if (commentsCount) {
      res["commentsCount"] = boost::any(*commentsCount);
    }
    if (committedDate) {
      res["committedDate"] = boost::any(*committedDate);
    }
    if (committer) {
      res["committer"] = committer ? boost::any(committer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (committerEmail) {
      res["committerEmail"] = boost::any(*committerEmail);
    }
    if (committerName) {
      res["committerName"] = boost::any(*committerName);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (parentIds) {
      res["parentIds"] = boost::any(*parentIds);
    }
    if (shortId) {
      res["shortId"] = boost::any(*shortId);
    }
    if (signature) {
      res["signature"] = signature ? boost::any(signature->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("author") != m.end() && !m["author"].empty()) {
      if (typeid(map<string, boost::any>) == m["author"].type()) {
        GetBranchInfoResponseBodyResultCommitAuthor model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["author"]));
        author = make_shared<GetBranchInfoResponseBodyResultCommitAuthor>(model1);
      }
    }
    if (m.find("authorEmail") != m.end() && !m["authorEmail"].empty()) {
      authorEmail = make_shared<string>(boost::any_cast<string>(m["authorEmail"]));
    }
    if (m.find("authorName") != m.end() && !m["authorName"].empty()) {
      authorName = make_shared<string>(boost::any_cast<string>(m["authorName"]));
    }
    if (m.find("authoredDate") != m.end() && !m["authoredDate"].empty()) {
      authoredDate = make_shared<string>(boost::any_cast<string>(m["authoredDate"]));
    }
    if (m.find("commentsCount") != m.end() && !m["commentsCount"].empty()) {
      commentsCount = make_shared<long>(boost::any_cast<long>(m["commentsCount"]));
    }
    if (m.find("committedDate") != m.end() && !m["committedDate"].empty()) {
      committedDate = make_shared<string>(boost::any_cast<string>(m["committedDate"]));
    }
    if (m.find("committer") != m.end() && !m["committer"].empty()) {
      if (typeid(map<string, boost::any>) == m["committer"].type()) {
        GetBranchInfoResponseBodyResultCommitCommitter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["committer"]));
        committer = make_shared<GetBranchInfoResponseBodyResultCommitCommitter>(model1);
      }
    }
    if (m.find("committerEmail") != m.end() && !m["committerEmail"].empty()) {
      committerEmail = make_shared<string>(boost::any_cast<string>(m["committerEmail"]));
    }
    if (m.find("committerName") != m.end() && !m["committerName"].empty()) {
      committerName = make_shared<string>(boost::any_cast<string>(m["committerName"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("parentIds") != m.end() && !m["parentIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["parentIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["parentIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      parentIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("shortId") != m.end() && !m["shortId"].empty()) {
      shortId = make_shared<string>(boost::any_cast<string>(m["shortId"]));
    }
    if (m.find("signature") != m.end() && !m["signature"].empty()) {
      if (typeid(map<string, boost::any>) == m["signature"].type()) {
        GetBranchInfoResponseBodyResultCommitSignature model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["signature"]));
        signature = make_shared<GetBranchInfoResponseBodyResultCommitSignature>(model1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~GetBranchInfoResponseBodyResultCommit() = default;
};
class GetBranchInfoResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<GetBranchInfoResponseBodyResultCommit> commit{};
  shared_ptr<string> name{};
  shared_ptr<string> protected_{};

  GetBranchInfoResponseBodyResult() {}

  explicit GetBranchInfoResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commit) {
      res["commit"] = commit ? boost::any(commit->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (protected_) {
      res["protected"] = boost::any(*protected_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commit") != m.end() && !m["commit"].empty()) {
      if (typeid(map<string, boost::any>) == m["commit"].type()) {
        GetBranchInfoResponseBodyResultCommit model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["commit"]));
        commit = make_shared<GetBranchInfoResponseBodyResultCommit>(model1);
      }
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("protected") != m.end() && !m["protected"].empty()) {
      protected_ = make_shared<string>(boost::any_cast<string>(m["protected"]));
    }
  }


  virtual ~GetBranchInfoResponseBodyResult() = default;
};
class GetBranchInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<GetBranchInfoResponseBodyResult> result{};
  shared_ptr<bool> success{};

  GetBranchInfoResponseBody() {}

  explicit GetBranchInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        GetBranchInfoResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<GetBranchInfoResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetBranchInfoResponseBody() = default;
};
class GetBranchInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetBranchInfoResponseBody> body{};

  GetBranchInfoResponse() {}

  explicit GetBranchInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBranchInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBranchInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetBranchInfoResponse() = default;
};
class GetCheckRunRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<long> checkRunId{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> repositoryIdentity{};

  GetCheckRunRequest() {}

  explicit GetCheckRunRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (checkRunId) {
      res["checkRunId"] = boost::any(*checkRunId);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (repositoryIdentity) {
      res["repositoryIdentity"] = boost::any(*repositoryIdentity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("checkRunId") != m.end() && !m["checkRunId"].empty()) {
      checkRunId = make_shared<long>(boost::any_cast<long>(m["checkRunId"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("repositoryIdentity") != m.end() && !m["repositoryIdentity"].empty()) {
      repositoryIdentity = make_shared<string>(boost::any_cast<string>(m["repositoryIdentity"]));
    }
  }


  virtual ~GetCheckRunRequest() = default;
};
class GetCheckRunResponseBodyResultAnnotations : public Darabonba::Model {
public:
  shared_ptr<string> annotationLevel{};
  shared_ptr<long> endColumn{};
  shared_ptr<long> endLine{};
  shared_ptr<long> id{};
  shared_ptr<string> message{};
  shared_ptr<string> path{};
  shared_ptr<string> rawDetails{};
  shared_ptr<long> startColumn{};
  shared_ptr<long> startLine{};
  shared_ptr<string> title{};

  GetCheckRunResponseBodyResultAnnotations() {}

  explicit GetCheckRunResponseBodyResultAnnotations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationLevel) {
      res["annotationLevel"] = boost::any(*annotationLevel);
    }
    if (endColumn) {
      res["endColumn"] = boost::any(*endColumn);
    }
    if (endLine) {
      res["endLine"] = boost::any(*endLine);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (rawDetails) {
      res["rawDetails"] = boost::any(*rawDetails);
    }
    if (startColumn) {
      res["startColumn"] = boost::any(*startColumn);
    }
    if (startLine) {
      res["startLine"] = boost::any(*startLine);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("annotationLevel") != m.end() && !m["annotationLevel"].empty()) {
      annotationLevel = make_shared<string>(boost::any_cast<string>(m["annotationLevel"]));
    }
    if (m.find("endColumn") != m.end() && !m["endColumn"].empty()) {
      endColumn = make_shared<long>(boost::any_cast<long>(m["endColumn"]));
    }
    if (m.find("endLine") != m.end() && !m["endLine"].empty()) {
      endLine = make_shared<long>(boost::any_cast<long>(m["endLine"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("rawDetails") != m.end() && !m["rawDetails"].empty()) {
      rawDetails = make_shared<string>(boost::any_cast<string>(m["rawDetails"]));
    }
    if (m.find("startColumn") != m.end() && !m["startColumn"].empty()) {
      startColumn = make_shared<long>(boost::any_cast<long>(m["startColumn"]));
    }
    if (m.find("startLine") != m.end() && !m["startLine"].empty()) {
      startLine = make_shared<long>(boost::any_cast<long>(m["startLine"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~GetCheckRunResponseBodyResultAnnotations() = default;
};
class GetCheckRunResponseBodyResultCheckSuite : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  GetCheckRunResponseBodyResultCheckSuite() {}

  explicit GetCheckRunResponseBodyResultCheckSuite(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
  }


  virtual ~GetCheckRunResponseBodyResultCheckSuite() = default;
};
class GetCheckRunResponseBodyResultOutputImages : public Darabonba::Model {
public:
  shared_ptr<string> alt{};
  shared_ptr<string> caption{};
  shared_ptr<string> imageUrl{};

  GetCheckRunResponseBodyResultOutputImages() {}

  explicit GetCheckRunResponseBodyResultOutputImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alt) {
      res["alt"] = boost::any(*alt);
    }
    if (caption) {
      res["caption"] = boost::any(*caption);
    }
    if (imageUrl) {
      res["imageUrl"] = boost::any(*imageUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alt") != m.end() && !m["alt"].empty()) {
      alt = make_shared<string>(boost::any_cast<string>(m["alt"]));
    }
    if (m.find("caption") != m.end() && !m["caption"].empty()) {
      caption = make_shared<string>(boost::any_cast<string>(m["caption"]));
    }
    if (m.find("imageUrl") != m.end() && !m["imageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["imageUrl"]));
    }
  }


  virtual ~GetCheckRunResponseBodyResultOutputImages() = default;
};
class GetCheckRunResponseBodyResultOutput : public Darabonba::Model {
public:
  shared_ptr<vector<GetCheckRunResponseBodyResultOutputImages>> images{};
  shared_ptr<string> summary{};
  shared_ptr<string> text{};
  shared_ptr<string> title{};

  GetCheckRunResponseBodyResultOutput() {}

  explicit GetCheckRunResponseBodyResultOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (images) {
      vector<boost::any> temp1;
      for(auto item1:*images){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["images"] = boost::any(temp1);
    }
    if (summary) {
      res["summary"] = boost::any(*summary);
    }
    if (text) {
      res["text"] = boost::any(*text);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("images") != m.end() && !m["images"].empty()) {
      if (typeid(vector<boost::any>) == m["images"].type()) {
        vector<GetCheckRunResponseBodyResultOutputImages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["images"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCheckRunResponseBodyResultOutputImages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        images = make_shared<vector<GetCheckRunResponseBodyResultOutputImages>>(expect1);
      }
    }
    if (m.find("summary") != m.end() && !m["summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["summary"]));
    }
    if (m.find("text") != m.end() && !m["text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["text"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~GetCheckRunResponseBodyResultOutput() = default;
};
class GetCheckRunResponseBodyResultWriter : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> logoUrl{};
  shared_ptr<string> name{};
  shared_ptr<string> slug{};
  shared_ptr<string> type{};

  GetCheckRunResponseBodyResultWriter() {}

  explicit GetCheckRunResponseBodyResultWriter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (logoUrl) {
      res["logoUrl"] = boost::any(*logoUrl);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (slug) {
      res["slug"] = boost::any(*slug);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("logoUrl") != m.end() && !m["logoUrl"].empty()) {
      logoUrl = make_shared<string>(boost::any_cast<string>(m["logoUrl"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("slug") != m.end() && !m["slug"].empty()) {
      slug = make_shared<string>(boost::any_cast<string>(m["slug"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~GetCheckRunResponseBodyResultWriter() = default;
};
class GetCheckRunResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<GetCheckRunResponseBodyResultAnnotations>> annotations{};
  shared_ptr<GetCheckRunResponseBodyResultCheckSuite> checkSuite{};
  shared_ptr<string> completedAt{};
  shared_ptr<string> conclusion{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> detailsUrl{};
  shared_ptr<string> externalId{};
  shared_ptr<string> headSha{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<GetCheckRunResponseBodyResultOutput> output{};
  shared_ptr<string> startedAt{};
  shared_ptr<string> status{};
  shared_ptr<string> updatedAt{};
  shared_ptr<GetCheckRunResponseBodyResultWriter> writer{};

  GetCheckRunResponseBodyResult() {}

  explicit GetCheckRunResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotations) {
      vector<boost::any> temp1;
      for(auto item1:*annotations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["annotations"] = boost::any(temp1);
    }
    if (checkSuite) {
      res["checkSuite"] = checkSuite ? boost::any(checkSuite->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (completedAt) {
      res["completedAt"] = boost::any(*completedAt);
    }
    if (conclusion) {
      res["conclusion"] = boost::any(*conclusion);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (detailsUrl) {
      res["detailsUrl"] = boost::any(*detailsUrl);
    }
    if (externalId) {
      res["externalId"] = boost::any(*externalId);
    }
    if (headSha) {
      res["headSha"] = boost::any(*headSha);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (output) {
      res["output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startedAt) {
      res["startedAt"] = boost::any(*startedAt);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (updatedAt) {
      res["updatedAt"] = boost::any(*updatedAt);
    }
    if (writer) {
      res["writer"] = writer ? boost::any(writer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("annotations") != m.end() && !m["annotations"].empty()) {
      if (typeid(vector<boost::any>) == m["annotations"].type()) {
        vector<GetCheckRunResponseBodyResultAnnotations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["annotations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCheckRunResponseBodyResultAnnotations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotations = make_shared<vector<GetCheckRunResponseBodyResultAnnotations>>(expect1);
      }
    }
    if (m.find("checkSuite") != m.end() && !m["checkSuite"].empty()) {
      if (typeid(map<string, boost::any>) == m["checkSuite"].type()) {
        GetCheckRunResponseBodyResultCheckSuite model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["checkSuite"]));
        checkSuite = make_shared<GetCheckRunResponseBodyResultCheckSuite>(model1);
      }
    }
    if (m.find("completedAt") != m.end() && !m["completedAt"].empty()) {
      completedAt = make_shared<string>(boost::any_cast<string>(m["completedAt"]));
    }
    if (m.find("conclusion") != m.end() && !m["conclusion"].empty()) {
      conclusion = make_shared<string>(boost::any_cast<string>(m["conclusion"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("detailsUrl") != m.end() && !m["detailsUrl"].empty()) {
      detailsUrl = make_shared<string>(boost::any_cast<string>(m["detailsUrl"]));
    }
    if (m.find("externalId") != m.end() && !m["externalId"].empty()) {
      externalId = make_shared<string>(boost::any_cast<string>(m["externalId"]));
    }
    if (m.find("headSha") != m.end() && !m["headSha"].empty()) {
      headSha = make_shared<string>(boost::any_cast<string>(m["headSha"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("output") != m.end() && !m["output"].empty()) {
      if (typeid(map<string, boost::any>) == m["output"].type()) {
        GetCheckRunResponseBodyResultOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["output"]));
        output = make_shared<GetCheckRunResponseBodyResultOutput>(model1);
      }
    }
    if (m.find("startedAt") != m.end() && !m["startedAt"].empty()) {
      startedAt = make_shared<string>(boost::any_cast<string>(m["startedAt"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("updatedAt") != m.end() && !m["updatedAt"].empty()) {
      updatedAt = make_shared<string>(boost::any_cast<string>(m["updatedAt"]));
    }
    if (m.find("writer") != m.end() && !m["writer"].empty()) {
      if (typeid(map<string, boost::any>) == m["writer"].type()) {
        GetCheckRunResponseBodyResultWriter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["writer"]));
        writer = make_shared<GetCheckRunResponseBodyResultWriter>(model1);
      }
    }
  }


  virtual ~GetCheckRunResponseBodyResult() = default;
};
class GetCheckRunResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<GetCheckRunResponseBodyResult> result{};
  shared_ptr<bool> success{};

  GetCheckRunResponseBody() {}

  explicit GetCheckRunResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        GetCheckRunResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<GetCheckRunResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetCheckRunResponseBody() = default;
};
class GetCheckRunResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCheckRunResponseBody> body{};

  GetCheckRunResponse() {}

  explicit GetCheckRunResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCheckRunResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCheckRunResponseBody>(model1);
      }
    }
  }


  virtual ~GetCheckRunResponse() = default;
};
class GetCodeupOrganizationRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};

  GetCodeupOrganizationRequest() {}

  explicit GetCodeupOrganizationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
  }


  virtual ~GetCodeupOrganizationRequest() = default;
};
class GetCodeupOrganizationResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> createdAt{};
  shared_ptr<long> id{};
  shared_ptr<long> namespaceId{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> path{};
  shared_ptr<string> updatedAt{};
  shared_ptr<string> userRole{};

  GetCodeupOrganizationResponseBodyResult() {}

  explicit GetCodeupOrganizationResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (namespaceId) {
      res["namespaceId"] = boost::any(*namespaceId);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (updatedAt) {
      res["updatedAt"] = boost::any(*updatedAt);
    }
    if (userRole) {
      res["userRole"] = boost::any(*userRole);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("namespaceId") != m.end() && !m["namespaceId"].empty()) {
      namespaceId = make_shared<long>(boost::any_cast<long>(m["namespaceId"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("updatedAt") != m.end() && !m["updatedAt"].empty()) {
      updatedAt = make_shared<string>(boost::any_cast<string>(m["updatedAt"]));
    }
    if (m.find("userRole") != m.end() && !m["userRole"].empty()) {
      userRole = make_shared<string>(boost::any_cast<string>(m["userRole"]));
    }
  }


  virtual ~GetCodeupOrganizationResponseBodyResult() = default;
};
class GetCodeupOrganizationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<GetCodeupOrganizationResponseBodyResult> result{};
  shared_ptr<bool> success{};

  GetCodeupOrganizationResponseBody() {}

  explicit GetCodeupOrganizationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        GetCodeupOrganizationResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<GetCodeupOrganizationResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetCodeupOrganizationResponseBody() = default;
};
class GetCodeupOrganizationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCodeupOrganizationResponseBody> body{};

  GetCodeupOrganizationResponse() {}

  explicit GetCodeupOrganizationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCodeupOrganizationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCodeupOrganizationResponseBody>(model1);
      }
    }
  }


  virtual ~GetCodeupOrganizationResponse() = default;
};
class GetCompareDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> from{};
  shared_ptr<long> maxDiffByte{};
  shared_ptr<long> maxDiffFile{};
  shared_ptr<bool> mergeBase{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> to{};

  GetCompareDetailRequest() {}

  explicit GetCompareDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["from"] = boost::any(*from);
    }
    if (maxDiffByte) {
      res["maxDiffByte"] = boost::any(*maxDiffByte);
    }
    if (maxDiffFile) {
      res["maxDiffFile"] = boost::any(*maxDiffFile);
    }
    if (mergeBase) {
      res["mergeBase"] = boost::any(*mergeBase);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (to) {
      res["to"] = boost::any(*to);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("from") != m.end() && !m["from"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["from"]));
    }
    if (m.find("maxDiffByte") != m.end() && !m["maxDiffByte"].empty()) {
      maxDiffByte = make_shared<long>(boost::any_cast<long>(m["maxDiffByte"]));
    }
    if (m.find("maxDiffFile") != m.end() && !m["maxDiffFile"].empty()) {
      maxDiffFile = make_shared<long>(boost::any_cast<long>(m["maxDiffFile"]));
    }
    if (m.find("mergeBase") != m.end() && !m["mergeBase"].empty()) {
      mergeBase = make_shared<bool>(boost::any_cast<bool>(m["mergeBase"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("to") != m.end() && !m["to"].empty()) {
      to = make_shared<string>(boost::any_cast<string>(m["to"]));
    }
  }


  virtual ~GetCompareDetailRequest() = default;
};
class GetCompareDetailResponseBodyResultCommitsAuthor : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};

  GetCompareDetailResponseBodyResultCommitsAuthor() {}

  explicit GetCompareDetailResponseBodyResultCommitsAuthor(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~GetCompareDetailResponseBodyResultCommitsAuthor() = default;
};
class GetCompareDetailResponseBodyResultCommitsCommitter : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};

  GetCompareDetailResponseBodyResultCommitsCommitter() {}

  explicit GetCompareDetailResponseBodyResultCommitsCommitter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~GetCompareDetailResponseBodyResultCommitsCommitter() = default;
};
class GetCompareDetailResponseBodyResultCommits : public Darabonba::Model {
public:
  shared_ptr<GetCompareDetailResponseBodyResultCommitsAuthor> author{};
  shared_ptr<string> authorEmail{};
  shared_ptr<string> authorName{};
  shared_ptr<string> authoredDate{};
  shared_ptr<long> commentsCount{};
  shared_ptr<string> committedDate{};
  shared_ptr<GetCompareDetailResponseBodyResultCommitsCommitter> committer{};
  shared_ptr<string> committerEmail{};
  shared_ptr<string> committerName{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> id{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> parentIds{};
  shared_ptr<string> shortId{};
  shared_ptr<string> title{};

  GetCompareDetailResponseBodyResultCommits() {}

  explicit GetCompareDetailResponseBodyResultCommits(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (author) {
      res["author"] = author ? boost::any(author->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (authorEmail) {
      res["authorEmail"] = boost::any(*authorEmail);
    }
    if (authorName) {
      res["authorName"] = boost::any(*authorName);
    }
    if (authoredDate) {
      res["authoredDate"] = boost::any(*authoredDate);
    }
    if (commentsCount) {
      res["commentsCount"] = boost::any(*commentsCount);
    }
    if (committedDate) {
      res["committedDate"] = boost::any(*committedDate);
    }
    if (committer) {
      res["committer"] = committer ? boost::any(committer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (committerEmail) {
      res["committerEmail"] = boost::any(*committerEmail);
    }
    if (committerName) {
      res["committerName"] = boost::any(*committerName);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (parentIds) {
      res["parentIds"] = boost::any(*parentIds);
    }
    if (shortId) {
      res["shortId"] = boost::any(*shortId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("author") != m.end() && !m["author"].empty()) {
      if (typeid(map<string, boost::any>) == m["author"].type()) {
        GetCompareDetailResponseBodyResultCommitsAuthor model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["author"]));
        author = make_shared<GetCompareDetailResponseBodyResultCommitsAuthor>(model1);
      }
    }
    if (m.find("authorEmail") != m.end() && !m["authorEmail"].empty()) {
      authorEmail = make_shared<string>(boost::any_cast<string>(m["authorEmail"]));
    }
    if (m.find("authorName") != m.end() && !m["authorName"].empty()) {
      authorName = make_shared<string>(boost::any_cast<string>(m["authorName"]));
    }
    if (m.find("authoredDate") != m.end() && !m["authoredDate"].empty()) {
      authoredDate = make_shared<string>(boost::any_cast<string>(m["authoredDate"]));
    }
    if (m.find("commentsCount") != m.end() && !m["commentsCount"].empty()) {
      commentsCount = make_shared<long>(boost::any_cast<long>(m["commentsCount"]));
    }
    if (m.find("committedDate") != m.end() && !m["committedDate"].empty()) {
      committedDate = make_shared<string>(boost::any_cast<string>(m["committedDate"]));
    }
    if (m.find("committer") != m.end() && !m["committer"].empty()) {
      if (typeid(map<string, boost::any>) == m["committer"].type()) {
        GetCompareDetailResponseBodyResultCommitsCommitter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["committer"]));
        committer = make_shared<GetCompareDetailResponseBodyResultCommitsCommitter>(model1);
      }
    }
    if (m.find("committerEmail") != m.end() && !m["committerEmail"].empty()) {
      committerEmail = make_shared<string>(boost::any_cast<string>(m["committerEmail"]));
    }
    if (m.find("committerName") != m.end() && !m["committerName"].empty()) {
      committerName = make_shared<string>(boost::any_cast<string>(m["committerName"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("parentIds") != m.end() && !m["parentIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["parentIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["parentIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      parentIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("shortId") != m.end() && !m["shortId"].empty()) {
      shortId = make_shared<string>(boost::any_cast<string>(m["shortId"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~GetCompareDetailResponseBodyResultCommits() = default;
};
class GetCompareDetailResponseBodyResultDiffs : public Darabonba::Model {
public:
  shared_ptr<string> aMode{};
  shared_ptr<string> bMode{};
  shared_ptr<bool> deletedFile{};
  shared_ptr<string> diff{};
  shared_ptr<bool> isBinary{};
  shared_ptr<bool> isNewLfs{};
  shared_ptr<bool> isOldLfs{};
  shared_ptr<bool> newFile{};
  shared_ptr<string> newId{};
  shared_ptr<string> newPath{};
  shared_ptr<string> oldId{};
  shared_ptr<string> oldPath{};
  shared_ptr<bool> renamedFile{};

  GetCompareDetailResponseBodyResultDiffs() {}

  explicit GetCompareDetailResponseBodyResultDiffs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aMode) {
      res["aMode"] = boost::any(*aMode);
    }
    if (bMode) {
      res["bMode"] = boost::any(*bMode);
    }
    if (deletedFile) {
      res["deletedFile"] = boost::any(*deletedFile);
    }
    if (diff) {
      res["diff"] = boost::any(*diff);
    }
    if (isBinary) {
      res["isBinary"] = boost::any(*isBinary);
    }
    if (isNewLfs) {
      res["isNewLfs"] = boost::any(*isNewLfs);
    }
    if (isOldLfs) {
      res["isOldLfs"] = boost::any(*isOldLfs);
    }
    if (newFile) {
      res["newFile"] = boost::any(*newFile);
    }
    if (newId) {
      res["newId"] = boost::any(*newId);
    }
    if (newPath) {
      res["newPath"] = boost::any(*newPath);
    }
    if (oldId) {
      res["oldId"] = boost::any(*oldId);
    }
    if (oldPath) {
      res["oldPath"] = boost::any(*oldPath);
    }
    if (renamedFile) {
      res["renamedFile"] = boost::any(*renamedFile);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aMode") != m.end() && !m["aMode"].empty()) {
      aMode = make_shared<string>(boost::any_cast<string>(m["aMode"]));
    }
    if (m.find("bMode") != m.end() && !m["bMode"].empty()) {
      bMode = make_shared<string>(boost::any_cast<string>(m["bMode"]));
    }
    if (m.find("deletedFile") != m.end() && !m["deletedFile"].empty()) {
      deletedFile = make_shared<bool>(boost::any_cast<bool>(m["deletedFile"]));
    }
    if (m.find("diff") != m.end() && !m["diff"].empty()) {
      diff = make_shared<string>(boost::any_cast<string>(m["diff"]));
    }
    if (m.find("isBinary") != m.end() && !m["isBinary"].empty()) {
      isBinary = make_shared<bool>(boost::any_cast<bool>(m["isBinary"]));
    }
    if (m.find("isNewLfs") != m.end() && !m["isNewLfs"].empty()) {
      isNewLfs = make_shared<bool>(boost::any_cast<bool>(m["isNewLfs"]));
    }
    if (m.find("isOldLfs") != m.end() && !m["isOldLfs"].empty()) {
      isOldLfs = make_shared<bool>(boost::any_cast<bool>(m["isOldLfs"]));
    }
    if (m.find("newFile") != m.end() && !m["newFile"].empty()) {
      newFile = make_shared<bool>(boost::any_cast<bool>(m["newFile"]));
    }
    if (m.find("newId") != m.end() && !m["newId"].empty()) {
      newId = make_shared<string>(boost::any_cast<string>(m["newId"]));
    }
    if (m.find("newPath") != m.end() && !m["newPath"].empty()) {
      newPath = make_shared<string>(boost::any_cast<string>(m["newPath"]));
    }
    if (m.find("oldId") != m.end() && !m["oldId"].empty()) {
      oldId = make_shared<string>(boost::any_cast<string>(m["oldId"]));
    }
    if (m.find("oldPath") != m.end() && !m["oldPath"].empty()) {
      oldPath = make_shared<string>(boost::any_cast<string>(m["oldPath"]));
    }
    if (m.find("renamedFile") != m.end() && !m["renamedFile"].empty()) {
      renamedFile = make_shared<bool>(boost::any_cast<bool>(m["renamedFile"]));
    }
  }


  virtual ~GetCompareDetailResponseBodyResultDiffs() = default;
};
class GetCompareDetailResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<GetCompareDetailResponseBodyResultCommits>> commits{};
  shared_ptr<vector<GetCompareDetailResponseBodyResultDiffs>> diffs{};
  shared_ptr<vector<string>> messages{};

  GetCompareDetailResponseBodyResult() {}

  explicit GetCompareDetailResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commits) {
      vector<boost::any> temp1;
      for(auto item1:*commits){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["commits"] = boost::any(temp1);
    }
    if (diffs) {
      vector<boost::any> temp1;
      for(auto item1:*diffs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["diffs"] = boost::any(temp1);
    }
    if (messages) {
      res["messages"] = boost::any(*messages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commits") != m.end() && !m["commits"].empty()) {
      if (typeid(vector<boost::any>) == m["commits"].type()) {
        vector<GetCompareDetailResponseBodyResultCommits> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["commits"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCompareDetailResponseBodyResultCommits model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        commits = make_shared<vector<GetCompareDetailResponseBodyResultCommits>>(expect1);
      }
    }
    if (m.find("diffs") != m.end() && !m["diffs"].empty()) {
      if (typeid(vector<boost::any>) == m["diffs"].type()) {
        vector<GetCompareDetailResponseBodyResultDiffs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["diffs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCompareDetailResponseBodyResultDiffs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        diffs = make_shared<vector<GetCompareDetailResponseBodyResultDiffs>>(expect1);
      }
    }
    if (m.find("messages") != m.end() && !m["messages"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["messages"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["messages"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      messages = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetCompareDetailResponseBodyResult() = default;
};
class GetCompareDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<GetCompareDetailResponseBodyResult> result{};
  shared_ptr<bool> success{};

  GetCompareDetailResponseBody() {}

  explicit GetCompareDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        GetCompareDetailResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<GetCompareDetailResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetCompareDetailResponseBody() = default;
};
class GetCompareDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCompareDetailResponseBody> body{};

  GetCompareDetailResponse() {}

  explicit GetCompareDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCompareDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCompareDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetCompareDetailResponse() = default;
};
class GetCustomFieldOptionRequest : public Darabonba::Model {
public:
  shared_ptr<string> spaceIdentifier{};
  shared_ptr<string> spaceType{};
  shared_ptr<string> workitemTypeIdentifier{};

  GetCustomFieldOptionRequest() {}

  explicit GetCustomFieldOptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (spaceIdentifier) {
      res["spaceIdentifier"] = boost::any(*spaceIdentifier);
    }
    if (spaceType) {
      res["spaceType"] = boost::any(*spaceType);
    }
    if (workitemTypeIdentifier) {
      res["workitemTypeIdentifier"] = boost::any(*workitemTypeIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("spaceIdentifier") != m.end() && !m["spaceIdentifier"].empty()) {
      spaceIdentifier = make_shared<string>(boost::any_cast<string>(m["spaceIdentifier"]));
    }
    if (m.find("spaceType") != m.end() && !m["spaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["spaceType"]));
    }
    if (m.find("workitemTypeIdentifier") != m.end() && !m["workitemTypeIdentifier"].empty()) {
      workitemTypeIdentifier = make_shared<string>(boost::any_cast<string>(m["workitemTypeIdentifier"]));
    }
  }


  virtual ~GetCustomFieldOptionRequest() = default;
};
class GetCustomFieldOptionResponseBodyFileds : public Darabonba::Model {
public:
  shared_ptr<string> displayValue{};
  shared_ptr<string> fieldIdentifier{};
  shared_ptr<string> identifier{};
  shared_ptr<long> level{};
  shared_ptr<long> position{};
  shared_ptr<string> value{};
  shared_ptr<string> valueEn{};

  GetCustomFieldOptionResponseBodyFileds() {}

  explicit GetCustomFieldOptionResponseBodyFileds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayValue) {
      res["displayValue"] = boost::any(*displayValue);
    }
    if (fieldIdentifier) {
      res["fieldIdentifier"] = boost::any(*fieldIdentifier);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (level) {
      res["level"] = boost::any(*level);
    }
    if (position) {
      res["position"] = boost::any(*position);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    if (valueEn) {
      res["valueEn"] = boost::any(*valueEn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("displayValue") != m.end() && !m["displayValue"].empty()) {
      displayValue = make_shared<string>(boost::any_cast<string>(m["displayValue"]));
    }
    if (m.find("fieldIdentifier") != m.end() && !m["fieldIdentifier"].empty()) {
      fieldIdentifier = make_shared<string>(boost::any_cast<string>(m["fieldIdentifier"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("level") != m.end() && !m["level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["level"]));
    }
    if (m.find("position") != m.end() && !m["position"].empty()) {
      position = make_shared<long>(boost::any_cast<long>(m["position"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
    if (m.find("valueEn") != m.end() && !m["valueEn"].empty()) {
      valueEn = make_shared<string>(boost::any_cast<string>(m["valueEn"]));
    }
  }


  virtual ~GetCustomFieldOptionResponseBodyFileds() = default;
};
class GetCustomFieldOptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<vector<GetCustomFieldOptionResponseBodyFileds>> fileds{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetCustomFieldOptionResponseBody() {}

  explicit GetCustomFieldOptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (fileds) {
      vector<boost::any> temp1;
      for(auto item1:*fileds){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["fileds"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("fileds") != m.end() && !m["fileds"].empty()) {
      if (typeid(vector<boost::any>) == m["fileds"].type()) {
        vector<GetCustomFieldOptionResponseBodyFileds> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["fileds"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCustomFieldOptionResponseBodyFileds model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileds = make_shared<vector<GetCustomFieldOptionResponseBodyFileds>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetCustomFieldOptionResponseBody() = default;
};
class GetCustomFieldOptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCustomFieldOptionResponseBody> body{};

  GetCustomFieldOptionResponse() {}

  explicit GetCustomFieldOptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCustomFieldOptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCustomFieldOptionResponseBody>(model1);
      }
    }
  }


  virtual ~GetCustomFieldOptionResponse() = default;
};
class GetFileBlobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> filePath{};
  shared_ptr<long> from{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> ref{};
  shared_ptr<long> to{};

  GetFileBlobsRequest() {}

  explicit GetFileBlobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (filePath) {
      res["filePath"] = boost::any(*filePath);
    }
    if (from) {
      res["from"] = boost::any(*from);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (ref) {
      res["ref"] = boost::any(*ref);
    }
    if (to) {
      res["to"] = boost::any(*to);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("filePath") != m.end() && !m["filePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["filePath"]));
    }
    if (m.find("from") != m.end() && !m["from"].empty()) {
      from = make_shared<long>(boost::any_cast<long>(m["from"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("ref") != m.end() && !m["ref"].empty()) {
      ref = make_shared<string>(boost::any_cast<string>(m["ref"]));
    }
    if (m.find("to") != m.end() && !m["to"].empty()) {
      to = make_shared<long>(boost::any_cast<long>(m["to"]));
    }
  }


  virtual ~GetFileBlobsRequest() = default;
};
class GetFileBlobsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> size{};
  shared_ptr<long> totalLines{};

  GetFileBlobsResponseBodyResult() {}

  explicit GetFileBlobsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    if (totalLines) {
      res["totalLines"] = boost::any(*totalLines);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
    if (m.find("totalLines") != m.end() && !m["totalLines"].empty()) {
      totalLines = make_shared<long>(boost::any_cast<long>(m["totalLines"]));
    }
  }


  virtual ~GetFileBlobsResponseBodyResult() = default;
};
class GetFileBlobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<GetFileBlobsResponseBodyResult> result{};
  shared_ptr<bool> success{};

  GetFileBlobsResponseBody() {}

  explicit GetFileBlobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        GetFileBlobsResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<GetFileBlobsResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetFileBlobsResponseBody() = default;
};
class GetFileBlobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetFileBlobsResponseBody> body{};

  GetFileBlobsResponse() {}

  explicit GetFileBlobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetFileBlobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetFileBlobsResponseBody>(model1);
      }
    }
  }


  virtual ~GetFileBlobsResponse() = default;
};
class GetFileLastCommitRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> filePath{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> sha{};
  shared_ptr<bool> showSignature{};

  GetFileLastCommitRequest() {}

  explicit GetFileLastCommitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (filePath) {
      res["filePath"] = boost::any(*filePath);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (sha) {
      res["sha"] = boost::any(*sha);
    }
    if (showSignature) {
      res["showSignature"] = boost::any(*showSignature);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("filePath") != m.end() && !m["filePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["filePath"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("sha") != m.end() && !m["sha"].empty()) {
      sha = make_shared<string>(boost::any_cast<string>(m["sha"]));
    }
    if (m.find("showSignature") != m.end() && !m["showSignature"].empty()) {
      showSignature = make_shared<bool>(boost::any_cast<bool>(m["showSignature"]));
    }
  }


  virtual ~GetFileLastCommitRequest() = default;
};
class GetFileLastCommitResponseBodyResultSignature : public Darabonba::Model {
public:
  shared_ptr<string> gpgKeyId{};
  shared_ptr<string> verificationStatus{};

  GetFileLastCommitResponseBodyResultSignature() {}

  explicit GetFileLastCommitResponseBodyResultSignature(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gpgKeyId) {
      res["gpgKeyId"] = boost::any(*gpgKeyId);
    }
    if (verificationStatus) {
      res["verificationStatus"] = boost::any(*verificationStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gpgKeyId") != m.end() && !m["gpgKeyId"].empty()) {
      gpgKeyId = make_shared<string>(boost::any_cast<string>(m["gpgKeyId"]));
    }
    if (m.find("verificationStatus") != m.end() && !m["verificationStatus"].empty()) {
      verificationStatus = make_shared<string>(boost::any_cast<string>(m["verificationStatus"]));
    }
  }


  virtual ~GetFileLastCommitResponseBodyResultSignature() = default;
};
class GetFileLastCommitResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> authorDate{};
  shared_ptr<string> authorEmail{};
  shared_ptr<string> authorName{};
  shared_ptr<string> committedDate{};
  shared_ptr<string> committerEmail{};
  shared_ptr<string> committerName{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> id{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> parentIds{};
  shared_ptr<string> shortId{};
  shared_ptr<GetFileLastCommitResponseBodyResultSignature> signature{};
  shared_ptr<string> title{};

  GetFileLastCommitResponseBodyResult() {}

  explicit GetFileLastCommitResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorDate) {
      res["authorDate"] = boost::any(*authorDate);
    }
    if (authorEmail) {
      res["authorEmail"] = boost::any(*authorEmail);
    }
    if (authorName) {
      res["authorName"] = boost::any(*authorName);
    }
    if (committedDate) {
      res["committedDate"] = boost::any(*committedDate);
    }
    if (committerEmail) {
      res["committerEmail"] = boost::any(*committerEmail);
    }
    if (committerName) {
      res["committerName"] = boost::any(*committerName);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (parentIds) {
      res["parentIds"] = boost::any(*parentIds);
    }
    if (shortId) {
      res["shortId"] = boost::any(*shortId);
    }
    if (signature) {
      res["signature"] = signature ? boost::any(signature->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("authorDate") != m.end() && !m["authorDate"].empty()) {
      authorDate = make_shared<string>(boost::any_cast<string>(m["authorDate"]));
    }
    if (m.find("authorEmail") != m.end() && !m["authorEmail"].empty()) {
      authorEmail = make_shared<string>(boost::any_cast<string>(m["authorEmail"]));
    }
    if (m.find("authorName") != m.end() && !m["authorName"].empty()) {
      authorName = make_shared<string>(boost::any_cast<string>(m["authorName"]));
    }
    if (m.find("committedDate") != m.end() && !m["committedDate"].empty()) {
      committedDate = make_shared<string>(boost::any_cast<string>(m["committedDate"]));
    }
    if (m.find("committerEmail") != m.end() && !m["committerEmail"].empty()) {
      committerEmail = make_shared<string>(boost::any_cast<string>(m["committerEmail"]));
    }
    if (m.find("committerName") != m.end() && !m["committerName"].empty()) {
      committerName = make_shared<string>(boost::any_cast<string>(m["committerName"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("parentIds") != m.end() && !m["parentIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["parentIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["parentIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      parentIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("shortId") != m.end() && !m["shortId"].empty()) {
      shortId = make_shared<string>(boost::any_cast<string>(m["shortId"]));
    }
    if (m.find("signature") != m.end() && !m["signature"].empty()) {
      if (typeid(map<string, boost::any>) == m["signature"].type()) {
        GetFileLastCommitResponseBodyResultSignature model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["signature"]));
        signature = make_shared<GetFileLastCommitResponseBodyResultSignature>(model1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~GetFileLastCommitResponseBodyResult() = default;
};
class GetFileLastCommitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<GetFileLastCommitResponseBodyResult> result{};
  shared_ptr<bool> success{};

  GetFileLastCommitResponseBody() {}

  explicit GetFileLastCommitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        GetFileLastCommitResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<GetFileLastCommitResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetFileLastCommitResponseBody() = default;
};
class GetFileLastCommitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetFileLastCommitResponseBody> body{};

  GetFileLastCommitResponse() {}

  explicit GetFileLastCommitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetFileLastCommitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetFileLastCommitResponseBody>(model1);
      }
    }
  }


  virtual ~GetFileLastCommitResponse() = default;
};
class GetFlowTagGroupResponseBodyFlowTagGroupFlowTagList : public Darabonba::Model {
public:
  shared_ptr<string> color{};
  shared_ptr<string> creatorAccountId{};
  shared_ptr<long> id{};
  shared_ptr<string> modiferAccountId{};
  shared_ptr<string> name{};

  GetFlowTagGroupResponseBodyFlowTagGroupFlowTagList() {}

  explicit GetFlowTagGroupResponseBodyFlowTagGroupFlowTagList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (color) {
      res["color"] = boost::any(*color);
    }
    if (creatorAccountId) {
      res["creatorAccountId"] = boost::any(*creatorAccountId);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (modiferAccountId) {
      res["modiferAccountId"] = boost::any(*modiferAccountId);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("color") != m.end() && !m["color"].empty()) {
      color = make_shared<string>(boost::any_cast<string>(m["color"]));
    }
    if (m.find("creatorAccountId") != m.end() && !m["creatorAccountId"].empty()) {
      creatorAccountId = make_shared<string>(boost::any_cast<string>(m["creatorAccountId"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("modiferAccountId") != m.end() && !m["modiferAccountId"].empty()) {
      modiferAccountId = make_shared<string>(boost::any_cast<string>(m["modiferAccountId"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~GetFlowTagGroupResponseBodyFlowTagGroupFlowTagList() = default;
};
class GetFlowTagGroupResponseBodyFlowTagGroup : public Darabonba::Model {
public:
  shared_ptr<string> creatorAccountId{};
  shared_ptr<vector<GetFlowTagGroupResponseBodyFlowTagGroupFlowTagList>> flowTagList{};
  shared_ptr<long> id{};
  shared_ptr<string> modiferAccountId{};
  shared_ptr<string> name{};

  GetFlowTagGroupResponseBodyFlowTagGroup() {}

  explicit GetFlowTagGroupResponseBodyFlowTagGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creatorAccountId) {
      res["creatorAccountId"] = boost::any(*creatorAccountId);
    }
    if (flowTagList) {
      vector<boost::any> temp1;
      for(auto item1:*flowTagList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flowTagList"] = boost::any(temp1);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (modiferAccountId) {
      res["modiferAccountId"] = boost::any(*modiferAccountId);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("creatorAccountId") != m.end() && !m["creatorAccountId"].empty()) {
      creatorAccountId = make_shared<string>(boost::any_cast<string>(m["creatorAccountId"]));
    }
    if (m.find("flowTagList") != m.end() && !m["flowTagList"].empty()) {
      if (typeid(vector<boost::any>) == m["flowTagList"].type()) {
        vector<GetFlowTagGroupResponseBodyFlowTagGroupFlowTagList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flowTagList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetFlowTagGroupResponseBodyFlowTagGroupFlowTagList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flowTagList = make_shared<vector<GetFlowTagGroupResponseBodyFlowTagGroupFlowTagList>>(expect1);
      }
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("modiferAccountId") != m.end() && !m["modiferAccountId"].empty()) {
      modiferAccountId = make_shared<string>(boost::any_cast<string>(m["modiferAccountId"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~GetFlowTagGroupResponseBodyFlowTagGroup() = default;
};
class GetFlowTagGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetFlowTagGroupResponseBodyFlowTagGroup> flowTagGroup{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetFlowTagGroupResponseBody() {}

  explicit GetFlowTagGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (flowTagGroup) {
      res["flowTagGroup"] = flowTagGroup ? boost::any(flowTagGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("flowTagGroup") != m.end() && !m["flowTagGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["flowTagGroup"].type()) {
        GetFlowTagGroupResponseBodyFlowTagGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["flowTagGroup"]));
        flowTagGroup = make_shared<GetFlowTagGroupResponseBodyFlowTagGroup>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetFlowTagGroupResponseBody() = default;
};
class GetFlowTagGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetFlowTagGroupResponseBody> body{};

  GetFlowTagGroupResponse() {}

  explicit GetFlowTagGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetFlowTagGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetFlowTagGroupResponseBody>(model1);
      }
    }
  }


  virtual ~GetFlowTagGroupResponse() = default;
};
class GetGroupByPathRequest : public Darabonba::Model {
public:
  shared_ptr<string> identity{};
  shared_ptr<string> organizationId{};

  GetGroupByPathRequest() {}

  explicit GetGroupByPathRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identity) {
      res["identity"] = boost::any(*identity);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("identity") != m.end() && !m["identity"].empty()) {
      identity = make_shared<string>(boost::any_cast<string>(m["identity"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~GetGroupByPathRequest() = default;
};
class GetGroupByPathResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> nameWithNamespace{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> parentId{};
  shared_ptr<string> path{};
  shared_ptr<string> pathWithNamespace{};
  shared_ptr<long> visibilityLevel{};
  shared_ptr<string> webUrl{};

  GetGroupByPathResponseBodyResult() {}

  explicit GetGroupByPathResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nameWithNamespace) {
      res["nameWithNamespace"] = boost::any(*nameWithNamespace);
    }
    if (ownerId) {
      res["ownerId"] = boost::any(*ownerId);
    }
    if (parentId) {
      res["parentId"] = boost::any(*parentId);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (pathWithNamespace) {
      res["pathWithNamespace"] = boost::any(*pathWithNamespace);
    }
    if (visibilityLevel) {
      res["visibilityLevel"] = boost::any(*visibilityLevel);
    }
    if (webUrl) {
      res["webUrl"] = boost::any(*webUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nameWithNamespace") != m.end() && !m["nameWithNamespace"].empty()) {
      nameWithNamespace = make_shared<string>(boost::any_cast<string>(m["nameWithNamespace"]));
    }
    if (m.find("ownerId") != m.end() && !m["ownerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["ownerId"]));
    }
    if (m.find("parentId") != m.end() && !m["parentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["parentId"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("pathWithNamespace") != m.end() && !m["pathWithNamespace"].empty()) {
      pathWithNamespace = make_shared<string>(boost::any_cast<string>(m["pathWithNamespace"]));
    }
    if (m.find("visibilityLevel") != m.end() && !m["visibilityLevel"].empty()) {
      visibilityLevel = make_shared<long>(boost::any_cast<long>(m["visibilityLevel"]));
    }
    if (m.find("webUrl") != m.end() && !m["webUrl"].empty()) {
      webUrl = make_shared<string>(boost::any_cast<string>(m["webUrl"]));
    }
  }


  virtual ~GetGroupByPathResponseBodyResult() = default;
};
class GetGroupByPathResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<GetGroupByPathResponseBodyResult> result{};
  shared_ptr<bool> success{};

  GetGroupByPathResponseBody() {}

  explicit GetGroupByPathResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        GetGroupByPathResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<GetGroupByPathResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetGroupByPathResponseBody() = default;
};
class GetGroupByPathResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetGroupByPathResponseBody> body{};

  GetGroupByPathResponse() {}

  explicit GetGroupByPathResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetGroupByPathResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetGroupByPathResponseBody>(model1);
      }
    }
  }


  virtual ~GetGroupByPathResponse() = default;
};
class GetGroupDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<long> groupId{};
  shared_ptr<string> organizationId{};

  GetGroupDetailRequest() {}

  explicit GetGroupDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (groupId) {
      res["groupId"] = boost::any(*groupId);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("groupId") != m.end() && !m["groupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["groupId"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~GetGroupDetailRequest() = default;
};
class GetGroupDetailResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> nameWithNamespace{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> parentId{};
  shared_ptr<string> path{};
  shared_ptr<string> pathWithNamespace{};
  shared_ptr<string> type{};
  shared_ptr<long> visibilityLevel{};
  shared_ptr<string> webUrl{};

  GetGroupDetailResponseBodyResult() {}

  explicit GetGroupDetailResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nameWithNamespace) {
      res["nameWithNamespace"] = boost::any(*nameWithNamespace);
    }
    if (ownerId) {
      res["ownerId"] = boost::any(*ownerId);
    }
    if (parentId) {
      res["parentId"] = boost::any(*parentId);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (pathWithNamespace) {
      res["pathWithNamespace"] = boost::any(*pathWithNamespace);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (visibilityLevel) {
      res["visibilityLevel"] = boost::any(*visibilityLevel);
    }
    if (webUrl) {
      res["webUrl"] = boost::any(*webUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nameWithNamespace") != m.end() && !m["nameWithNamespace"].empty()) {
      nameWithNamespace = make_shared<string>(boost::any_cast<string>(m["nameWithNamespace"]));
    }
    if (m.find("ownerId") != m.end() && !m["ownerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["ownerId"]));
    }
    if (m.find("parentId") != m.end() && !m["parentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["parentId"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("pathWithNamespace") != m.end() && !m["pathWithNamespace"].empty()) {
      pathWithNamespace = make_shared<string>(boost::any_cast<string>(m["pathWithNamespace"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("visibilityLevel") != m.end() && !m["visibilityLevel"].empty()) {
      visibilityLevel = make_shared<long>(boost::any_cast<long>(m["visibilityLevel"]));
    }
    if (m.find("webUrl") != m.end() && !m["webUrl"].empty()) {
      webUrl = make_shared<string>(boost::any_cast<string>(m["webUrl"]));
    }
  }


  virtual ~GetGroupDetailResponseBodyResult() = default;
};
class GetGroupDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<GetGroupDetailResponseBodyResult> result{};
  shared_ptr<bool> success{};

  GetGroupDetailResponseBody() {}

  explicit GetGroupDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        GetGroupDetailResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<GetGroupDetailResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetGroupDetailResponseBody() = default;
};
class GetGroupDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetGroupDetailResponseBody> body{};

  GetGroupDetailResponse() {}

  explicit GetGroupDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetGroupDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetGroupDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetGroupDetailResponse() = default;
};
class GetHostGroupResponseBodyHostGroupHostInfos : public Darabonba::Model {
public:
  shared_ptr<string> aliyunRegionId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> creatorAccountId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> ip{};
  shared_ptr<string> machineSn{};
  shared_ptr<string> modifierAccountId{};
  shared_ptr<string> objectType{};
  shared_ptr<long> updateTime{};

  GetHostGroupResponseBodyHostGroupHostInfos() {}

  explicit GetHostGroupResponseBodyHostGroupHostInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunRegionId) {
      res["aliyunRegionId"] = boost::any(*aliyunRegionId);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (creatorAccountId) {
      res["creatorAccountId"] = boost::any(*creatorAccountId);
    }
    if (instanceName) {
      res["instanceName"] = boost::any(*instanceName);
    }
    if (ip) {
      res["ip"] = boost::any(*ip);
    }
    if (machineSn) {
      res["machineSn"] = boost::any(*machineSn);
    }
    if (modifierAccountId) {
      res["modifierAccountId"] = boost::any(*modifierAccountId);
    }
    if (objectType) {
      res["objectType"] = boost::any(*objectType);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aliyunRegionId") != m.end() && !m["aliyunRegionId"].empty()) {
      aliyunRegionId = make_shared<string>(boost::any_cast<string>(m["aliyunRegionId"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["createTime"]));
    }
    if (m.find("creatorAccountId") != m.end() && !m["creatorAccountId"].empty()) {
      creatorAccountId = make_shared<string>(boost::any_cast<string>(m["creatorAccountId"]));
    }
    if (m.find("instanceName") != m.end() && !m["instanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["instanceName"]));
    }
    if (m.find("ip") != m.end() && !m["ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["ip"]));
    }
    if (m.find("machineSn") != m.end() && !m["machineSn"].empty()) {
      machineSn = make_shared<string>(boost::any_cast<string>(m["machineSn"]));
    }
    if (m.find("modifierAccountId") != m.end() && !m["modifierAccountId"].empty()) {
      modifierAccountId = make_shared<string>(boost::any_cast<string>(m["modifierAccountId"]));
    }
    if (m.find("objectType") != m.end() && !m["objectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["objectType"]));
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["updateTime"]));
    }
  }


  virtual ~GetHostGroupResponseBodyHostGroupHostInfos() = default;
};
class GetHostGroupResponseBodyHostGroup : public Darabonba::Model {
public:
  shared_ptr<string> aliyunRegion{};
  shared_ptr<long> createTime{};
  shared_ptr<string> creatorAccountId{};
  shared_ptr<string> description{};
  shared_ptr<string> ecsLabelKey{};
  shared_ptr<string> ecsLabelValue{};
  shared_ptr<string> ecsType{};
  shared_ptr<vector<GetHostGroupResponseBodyHostGroupHostInfos>> hostInfos{};
  shared_ptr<long> hostNum{};
  shared_ptr<long> id{};
  shared_ptr<string> modifierAccountId{};
  shared_ptr<string> name{};
  shared_ptr<long> serviceConnectionId{};
  shared_ptr<string> type{};
  shared_ptr<long> upateTIme{};

  GetHostGroupResponseBodyHostGroup() {}

  explicit GetHostGroupResponseBodyHostGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunRegion) {
      res["aliyunRegion"] = boost::any(*aliyunRegion);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (creatorAccountId) {
      res["creatorAccountId"] = boost::any(*creatorAccountId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (ecsLabelKey) {
      res["ecsLabelKey"] = boost::any(*ecsLabelKey);
    }
    if (ecsLabelValue) {
      res["ecsLabelValue"] = boost::any(*ecsLabelValue);
    }
    if (ecsType) {
      res["ecsType"] = boost::any(*ecsType);
    }
    if (hostInfos) {
      vector<boost::any> temp1;
      for(auto item1:*hostInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["hostInfos"] = boost::any(temp1);
    }
    if (hostNum) {
      res["hostNum"] = boost::any(*hostNum);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (modifierAccountId) {
      res["modifierAccountId"] = boost::any(*modifierAccountId);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (serviceConnectionId) {
      res["serviceConnectionId"] = boost::any(*serviceConnectionId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (upateTIme) {
      res["upateTIme"] = boost::any(*upateTIme);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aliyunRegion") != m.end() && !m["aliyunRegion"].empty()) {
      aliyunRegion = make_shared<string>(boost::any_cast<string>(m["aliyunRegion"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["createTime"]));
    }
    if (m.find("creatorAccountId") != m.end() && !m["creatorAccountId"].empty()) {
      creatorAccountId = make_shared<string>(boost::any_cast<string>(m["creatorAccountId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("ecsLabelKey") != m.end() && !m["ecsLabelKey"].empty()) {
      ecsLabelKey = make_shared<string>(boost::any_cast<string>(m["ecsLabelKey"]));
    }
    if (m.find("ecsLabelValue") != m.end() && !m["ecsLabelValue"].empty()) {
      ecsLabelValue = make_shared<string>(boost::any_cast<string>(m["ecsLabelValue"]));
    }
    if (m.find("ecsType") != m.end() && !m["ecsType"].empty()) {
      ecsType = make_shared<string>(boost::any_cast<string>(m["ecsType"]));
    }
    if (m.find("hostInfos") != m.end() && !m["hostInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["hostInfos"].type()) {
        vector<GetHostGroupResponseBodyHostGroupHostInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["hostInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetHostGroupResponseBodyHostGroupHostInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostInfos = make_shared<vector<GetHostGroupResponseBodyHostGroupHostInfos>>(expect1);
      }
    }
    if (m.find("hostNum") != m.end() && !m["hostNum"].empty()) {
      hostNum = make_shared<long>(boost::any_cast<long>(m["hostNum"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("modifierAccountId") != m.end() && !m["modifierAccountId"].empty()) {
      modifierAccountId = make_shared<string>(boost::any_cast<string>(m["modifierAccountId"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("serviceConnectionId") != m.end() && !m["serviceConnectionId"].empty()) {
      serviceConnectionId = make_shared<long>(boost::any_cast<long>(m["serviceConnectionId"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("upateTIme") != m.end() && !m["upateTIme"].empty()) {
      upateTIme = make_shared<long>(boost::any_cast<long>(m["upateTIme"]));
    }
  }


  virtual ~GetHostGroupResponseBodyHostGroup() = default;
};
class GetHostGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetHostGroupResponseBodyHostGroup> hostGroup{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetHostGroupResponseBody() {}

  explicit GetHostGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (hostGroup) {
      res["hostGroup"] = hostGroup ? boost::any(hostGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("hostGroup") != m.end() && !m["hostGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["hostGroup"].type()) {
        GetHostGroupResponseBodyHostGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["hostGroup"]));
        hostGroup = make_shared<GetHostGroupResponseBodyHostGroup>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetHostGroupResponseBody() = default;
};
class GetHostGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetHostGroupResponseBody> body{};

  GetHostGroupResponse() {}

  explicit GetHostGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetHostGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetHostGroupResponseBody>(model1);
      }
    }
  }


  virtual ~GetHostGroupResponse() = default;
};
class GetMergeRequestRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> organizationId{};

  GetMergeRequestRequest() {}

  explicit GetMergeRequestRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~GetMergeRequestRequest() = default;
};
class GetMergeRequestResponseBodyResultAuthor : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};

  GetMergeRequestResponseBodyResultAuthor() {}

  explicit GetMergeRequestResponseBodyResultAuthor(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~GetMergeRequestResponseBodyResultAuthor() = default;
};
class GetMergeRequestResponseBodyResultReviewers : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<bool> hasCommented{};
  shared_ptr<bool> hasReviewed{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> reviewOpinionStatus{};
  shared_ptr<string> reviewTime{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};

  GetMergeRequestResponseBodyResultReviewers() {}

  explicit GetMergeRequestResponseBodyResultReviewers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (hasCommented) {
      res["hasCommented"] = boost::any(*hasCommented);
    }
    if (hasReviewed) {
      res["hasReviewed"] = boost::any(*hasReviewed);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (reviewOpinionStatus) {
      res["reviewOpinionStatus"] = boost::any(*reviewOpinionStatus);
    }
    if (reviewTime) {
      res["reviewTime"] = boost::any(*reviewTime);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("hasCommented") != m.end() && !m["hasCommented"].empty()) {
      hasCommented = make_shared<bool>(boost::any_cast<bool>(m["hasCommented"]));
    }
    if (m.find("hasReviewed") != m.end() && !m["hasReviewed"].empty()) {
      hasReviewed = make_shared<bool>(boost::any_cast<bool>(m["hasReviewed"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("reviewOpinionStatus") != m.end() && !m["reviewOpinionStatus"].empty()) {
      reviewOpinionStatus = make_shared<string>(boost::any_cast<string>(m["reviewOpinionStatus"]));
    }
    if (m.find("reviewTime") != m.end() && !m["reviewTime"].empty()) {
      reviewTime = make_shared<string>(boost::any_cast<string>(m["reviewTime"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~GetMergeRequestResponseBodyResultReviewers() = default;
};
class GetMergeRequestResponseBodyResultSubscribers : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};

  GetMergeRequestResponseBodyResultSubscribers() {}

  explicit GetMergeRequestResponseBodyResultSubscribers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~GetMergeRequestResponseBodyResultSubscribers() = default;
};
class GetMergeRequestResponseBodyResultTodoListRequirementCheckItems : public Darabonba::Model {
public:
  shared_ptr<string> itemType{};
  shared_ptr<bool> pass{};

  GetMergeRequestResponseBodyResultTodoListRequirementCheckItems() {}

  explicit GetMergeRequestResponseBodyResultTodoListRequirementCheckItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemType) {
      res["itemType"] = boost::any(*itemType);
    }
    if (pass) {
      res["pass"] = boost::any(*pass);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("itemType") != m.end() && !m["itemType"].empty()) {
      itemType = make_shared<string>(boost::any_cast<string>(m["itemType"]));
    }
    if (m.find("pass") != m.end() && !m["pass"].empty()) {
      pass = make_shared<bool>(boost::any_cast<bool>(m["pass"]));
    }
  }


  virtual ~GetMergeRequestResponseBodyResultTodoListRequirementCheckItems() = default;
};
class GetMergeRequestResponseBodyResultTodoList : public Darabonba::Model {
public:
  shared_ptr<vector<GetMergeRequestResponseBodyResultTodoListRequirementCheckItems>> requirementCheckItems{};

  GetMergeRequestResponseBodyResultTodoList() {}

  explicit GetMergeRequestResponseBodyResultTodoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requirementCheckItems) {
      vector<boost::any> temp1;
      for(auto item1:*requirementCheckItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["requirementCheckItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requirementCheckItems") != m.end() && !m["requirementCheckItems"].empty()) {
      if (typeid(vector<boost::any>) == m["requirementCheckItems"].type()) {
        vector<GetMergeRequestResponseBodyResultTodoListRequirementCheckItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["requirementCheckItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMergeRequestResponseBodyResultTodoListRequirementCheckItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requirementCheckItems = make_shared<vector<GetMergeRequestResponseBodyResultTodoListRequirementCheckItems>>(expect1);
      }
    }
  }


  virtual ~GetMergeRequestResponseBodyResultTodoList() = default;
};
class GetMergeRequestResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> ahead{};
  shared_ptr<bool> allRequirementsPass{};
  shared_ptr<GetMergeRequestResponseBodyResultAuthor> author{};
  shared_ptr<long> behind{};
  shared_ptr<string> createFrom{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> detailUrl{};
  shared_ptr<long> localId{};
  shared_ptr<string> mergedRevision{};
  shared_ptr<string> mrBizId{};
  shared_ptr<string> mrType{};
  shared_ptr<long> projectId{};
  shared_ptr<vector<GetMergeRequestResponseBodyResultReviewers>> reviewers{};
  shared_ptr<string> sourceBranch{};
  shared_ptr<long> sourceProjectId{};
  shared_ptr<string> status{};
  shared_ptr<vector<GetMergeRequestResponseBodyResultSubscribers>> subscribers{};
  shared_ptr<bool> supportMergeFastForwardOnly{};
  shared_ptr<string> targetBranch{};
  shared_ptr<long> targetProjectId{};
  shared_ptr<string> targetProjectNameWithNamespace{};
  shared_ptr<string> targetProjectPathWithNamespace{};
  shared_ptr<string> title{};
  shared_ptr<GetMergeRequestResponseBodyResultTodoList> todoList{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> webUrl{};

  GetMergeRequestResponseBodyResult() {}

  explicit GetMergeRequestResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ahead) {
      res["ahead"] = boost::any(*ahead);
    }
    if (allRequirementsPass) {
      res["allRequirementsPass"] = boost::any(*allRequirementsPass);
    }
    if (author) {
      res["author"] = author ? boost::any(author->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (behind) {
      res["behind"] = boost::any(*behind);
    }
    if (createFrom) {
      res["createFrom"] = boost::any(*createFrom);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (detailUrl) {
      res["detailUrl"] = boost::any(*detailUrl);
    }
    if (localId) {
      res["localId"] = boost::any(*localId);
    }
    if (mergedRevision) {
      res["mergedRevision"] = boost::any(*mergedRevision);
    }
    if (mrBizId) {
      res["mrBizId"] = boost::any(*mrBizId);
    }
    if (mrType) {
      res["mrType"] = boost::any(*mrType);
    }
    if (projectId) {
      res["projectId"] = boost::any(*projectId);
    }
    if (reviewers) {
      vector<boost::any> temp1;
      for(auto item1:*reviewers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["reviewers"] = boost::any(temp1);
    }
    if (sourceBranch) {
      res["sourceBranch"] = boost::any(*sourceBranch);
    }
    if (sourceProjectId) {
      res["sourceProjectId"] = boost::any(*sourceProjectId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (subscribers) {
      vector<boost::any> temp1;
      for(auto item1:*subscribers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["subscribers"] = boost::any(temp1);
    }
    if (supportMergeFastForwardOnly) {
      res["supportMergeFastForwardOnly"] = boost::any(*supportMergeFastForwardOnly);
    }
    if (targetBranch) {
      res["targetBranch"] = boost::any(*targetBranch);
    }
    if (targetProjectId) {
      res["targetProjectId"] = boost::any(*targetProjectId);
    }
    if (targetProjectNameWithNamespace) {
      res["targetProjectNameWithNamespace"] = boost::any(*targetProjectNameWithNamespace);
    }
    if (targetProjectPathWithNamespace) {
      res["targetProjectPathWithNamespace"] = boost::any(*targetProjectPathWithNamespace);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (todoList) {
      res["todoList"] = todoList ? boost::any(todoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    if (webUrl) {
      res["webUrl"] = boost::any(*webUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ahead") != m.end() && !m["ahead"].empty()) {
      ahead = make_shared<long>(boost::any_cast<long>(m["ahead"]));
    }
    if (m.find("allRequirementsPass") != m.end() && !m["allRequirementsPass"].empty()) {
      allRequirementsPass = make_shared<bool>(boost::any_cast<bool>(m["allRequirementsPass"]));
    }
    if (m.find("author") != m.end() && !m["author"].empty()) {
      if (typeid(map<string, boost::any>) == m["author"].type()) {
        GetMergeRequestResponseBodyResultAuthor model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["author"]));
        author = make_shared<GetMergeRequestResponseBodyResultAuthor>(model1);
      }
    }
    if (m.find("behind") != m.end() && !m["behind"].empty()) {
      behind = make_shared<long>(boost::any_cast<long>(m["behind"]));
    }
    if (m.find("createFrom") != m.end() && !m["createFrom"].empty()) {
      createFrom = make_shared<string>(boost::any_cast<string>(m["createFrom"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("detailUrl") != m.end() && !m["detailUrl"].empty()) {
      detailUrl = make_shared<string>(boost::any_cast<string>(m["detailUrl"]));
    }
    if (m.find("localId") != m.end() && !m["localId"].empty()) {
      localId = make_shared<long>(boost::any_cast<long>(m["localId"]));
    }
    if (m.find("mergedRevision") != m.end() && !m["mergedRevision"].empty()) {
      mergedRevision = make_shared<string>(boost::any_cast<string>(m["mergedRevision"]));
    }
    if (m.find("mrBizId") != m.end() && !m["mrBizId"].empty()) {
      mrBizId = make_shared<string>(boost::any_cast<string>(m["mrBizId"]));
    }
    if (m.find("mrType") != m.end() && !m["mrType"].empty()) {
      mrType = make_shared<string>(boost::any_cast<string>(m["mrType"]));
    }
    if (m.find("projectId") != m.end() && !m["projectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["projectId"]));
    }
    if (m.find("reviewers") != m.end() && !m["reviewers"].empty()) {
      if (typeid(vector<boost::any>) == m["reviewers"].type()) {
        vector<GetMergeRequestResponseBodyResultReviewers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["reviewers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMergeRequestResponseBodyResultReviewers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reviewers = make_shared<vector<GetMergeRequestResponseBodyResultReviewers>>(expect1);
      }
    }
    if (m.find("sourceBranch") != m.end() && !m["sourceBranch"].empty()) {
      sourceBranch = make_shared<string>(boost::any_cast<string>(m["sourceBranch"]));
    }
    if (m.find("sourceProjectId") != m.end() && !m["sourceProjectId"].empty()) {
      sourceProjectId = make_shared<long>(boost::any_cast<long>(m["sourceProjectId"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("subscribers") != m.end() && !m["subscribers"].empty()) {
      if (typeid(vector<boost::any>) == m["subscribers"].type()) {
        vector<GetMergeRequestResponseBodyResultSubscribers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["subscribers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMergeRequestResponseBodyResultSubscribers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subscribers = make_shared<vector<GetMergeRequestResponseBodyResultSubscribers>>(expect1);
      }
    }
    if (m.find("supportMergeFastForwardOnly") != m.end() && !m["supportMergeFastForwardOnly"].empty()) {
      supportMergeFastForwardOnly = make_shared<bool>(boost::any_cast<bool>(m["supportMergeFastForwardOnly"]));
    }
    if (m.find("targetBranch") != m.end() && !m["targetBranch"].empty()) {
      targetBranch = make_shared<string>(boost::any_cast<string>(m["targetBranch"]));
    }
    if (m.find("targetProjectId") != m.end() && !m["targetProjectId"].empty()) {
      targetProjectId = make_shared<long>(boost::any_cast<long>(m["targetProjectId"]));
    }
    if (m.find("targetProjectNameWithNamespace") != m.end() && !m["targetProjectNameWithNamespace"].empty()) {
      targetProjectNameWithNamespace = make_shared<string>(boost::any_cast<string>(m["targetProjectNameWithNamespace"]));
    }
    if (m.find("targetProjectPathWithNamespace") != m.end() && !m["targetProjectPathWithNamespace"].empty()) {
      targetProjectPathWithNamespace = make_shared<string>(boost::any_cast<string>(m["targetProjectPathWithNamespace"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("todoList") != m.end() && !m["todoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["todoList"].type()) {
        GetMergeRequestResponseBodyResultTodoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["todoList"]));
        todoList = make_shared<GetMergeRequestResponseBodyResultTodoList>(model1);
      }
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["updateTime"]));
    }
    if (m.find("webUrl") != m.end() && !m["webUrl"].empty()) {
      webUrl = make_shared<string>(boost::any_cast<string>(m["webUrl"]));
    }
  }


  virtual ~GetMergeRequestResponseBodyResult() = default;
};
class GetMergeRequestResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<GetMergeRequestResponseBodyResult> result{};
  shared_ptr<bool> success{};

  GetMergeRequestResponseBody() {}

  explicit GetMergeRequestResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        GetMergeRequestResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<GetMergeRequestResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetMergeRequestResponseBody() = default;
};
class GetMergeRequestResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMergeRequestResponseBody> body{};

  GetMergeRequestResponse() {}

  explicit GetMergeRequestResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMergeRequestResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMergeRequestResponseBody>(model1);
      }
    }
  }


  virtual ~GetMergeRequestResponse() = default;
};
class GetMergeRequestChangeTreeRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> fromPatchSetBizId{};
  shared_ptr<long> localId{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> repositoryIdentity{};
  shared_ptr<string> toPatchSetBizId{};

  GetMergeRequestChangeTreeRequest() {}

  explicit GetMergeRequestChangeTreeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (fromPatchSetBizId) {
      res["fromPatchSetBizId"] = boost::any(*fromPatchSetBizId);
    }
    if (localId) {
      res["localId"] = boost::any(*localId);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (repositoryIdentity) {
      res["repositoryIdentity"] = boost::any(*repositoryIdentity);
    }
    if (toPatchSetBizId) {
      res["toPatchSetBizId"] = boost::any(*toPatchSetBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("fromPatchSetBizId") != m.end() && !m["fromPatchSetBizId"].empty()) {
      fromPatchSetBizId = make_shared<string>(boost::any_cast<string>(m["fromPatchSetBizId"]));
    }
    if (m.find("localId") != m.end() && !m["localId"].empty()) {
      localId = make_shared<long>(boost::any_cast<long>(m["localId"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("repositoryIdentity") != m.end() && !m["repositoryIdentity"].empty()) {
      repositoryIdentity = make_shared<string>(boost::any_cast<string>(m["repositoryIdentity"]));
    }
    if (m.find("toPatchSetBizId") != m.end() && !m["toPatchSetBizId"].empty()) {
      toPatchSetBizId = make_shared<string>(boost::any_cast<string>(m["toPatchSetBizId"]));
    }
  }


  virtual ~GetMergeRequestChangeTreeRequest() = default;
};
class GetMergeRequestChangeTreeResponseBodyResultChangedFilesInfos : public Darabonba::Model {
public:
  shared_ptr<long> addLines{};
  shared_ptr<bool> binaryFile{};
  shared_ptr<long> delLines{};
  shared_ptr<bool> deletedFile{};
  shared_ptr<bool> newFile{};
  shared_ptr<string> newPath{};
  shared_ptr<string> oldPath{};
  shared_ptr<bool> renamedFile{};

  GetMergeRequestChangeTreeResponseBodyResultChangedFilesInfos() {}

  explicit GetMergeRequestChangeTreeResponseBodyResultChangedFilesInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addLines) {
      res["addLines"] = boost::any(*addLines);
    }
    if (binaryFile) {
      res["binaryFile"] = boost::any(*binaryFile);
    }
    if (delLines) {
      res["delLines"] = boost::any(*delLines);
    }
    if (deletedFile) {
      res["deletedFile"] = boost::any(*deletedFile);
    }
    if (newFile) {
      res["newFile"] = boost::any(*newFile);
    }
    if (newPath) {
      res["newPath"] = boost::any(*newPath);
    }
    if (oldPath) {
      res["oldPath"] = boost::any(*oldPath);
    }
    if (renamedFile) {
      res["renamedFile"] = boost::any(*renamedFile);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("addLines") != m.end() && !m["addLines"].empty()) {
      addLines = make_shared<long>(boost::any_cast<long>(m["addLines"]));
    }
    if (m.find("binaryFile") != m.end() && !m["binaryFile"].empty()) {
      binaryFile = make_shared<bool>(boost::any_cast<bool>(m["binaryFile"]));
    }
    if (m.find("delLines") != m.end() && !m["delLines"].empty()) {
      delLines = make_shared<long>(boost::any_cast<long>(m["delLines"]));
    }
    if (m.find("deletedFile") != m.end() && !m["deletedFile"].empty()) {
      deletedFile = make_shared<bool>(boost::any_cast<bool>(m["deletedFile"]));
    }
    if (m.find("newFile") != m.end() && !m["newFile"].empty()) {
      newFile = make_shared<bool>(boost::any_cast<bool>(m["newFile"]));
    }
    if (m.find("newPath") != m.end() && !m["newPath"].empty()) {
      newPath = make_shared<string>(boost::any_cast<string>(m["newPath"]));
    }
    if (m.find("oldPath") != m.end() && !m["oldPath"].empty()) {
      oldPath = make_shared<string>(boost::any_cast<string>(m["oldPath"]));
    }
    if (m.find("renamedFile") != m.end() && !m["renamedFile"].empty()) {
      renamedFile = make_shared<bool>(boost::any_cast<bool>(m["renamedFile"]));
    }
  }


  virtual ~GetMergeRequestChangeTreeResponseBodyResultChangedFilesInfos() = default;
};
class GetMergeRequestChangeTreeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> changedFilesCount{};
  shared_ptr<vector<GetMergeRequestChangeTreeResponseBodyResultChangedFilesInfos>> changedFilesInfos{};
  shared_ptr<long> totalAddLines{};
  shared_ptr<long> totalDelLines{};

  GetMergeRequestChangeTreeResponseBodyResult() {}

  explicit GetMergeRequestChangeTreeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changedFilesCount) {
      res["changedFilesCount"] = boost::any(*changedFilesCount);
    }
    if (changedFilesInfos) {
      vector<boost::any> temp1;
      for(auto item1:*changedFilesInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["changedFilesInfos"] = boost::any(temp1);
    }
    if (totalAddLines) {
      res["totalAddLines"] = boost::any(*totalAddLines);
    }
    if (totalDelLines) {
      res["totalDelLines"] = boost::any(*totalDelLines);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("changedFilesCount") != m.end() && !m["changedFilesCount"].empty()) {
      changedFilesCount = make_shared<long>(boost::any_cast<long>(m["changedFilesCount"]));
    }
    if (m.find("changedFilesInfos") != m.end() && !m["changedFilesInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["changedFilesInfos"].type()) {
        vector<GetMergeRequestChangeTreeResponseBodyResultChangedFilesInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["changedFilesInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMergeRequestChangeTreeResponseBodyResultChangedFilesInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        changedFilesInfos = make_shared<vector<GetMergeRequestChangeTreeResponseBodyResultChangedFilesInfos>>(expect1);
      }
    }
    if (m.find("totalAddLines") != m.end() && !m["totalAddLines"].empty()) {
      totalAddLines = make_shared<long>(boost::any_cast<long>(m["totalAddLines"]));
    }
    if (m.find("totalDelLines") != m.end() && !m["totalDelLines"].empty()) {
      totalDelLines = make_shared<long>(boost::any_cast<long>(m["totalDelLines"]));
    }
  }


  virtual ~GetMergeRequestChangeTreeResponseBodyResult() = default;
};
class GetMergeRequestChangeTreeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<GetMergeRequestChangeTreeResponseBodyResult> result{};
  shared_ptr<bool> success{};

  GetMergeRequestChangeTreeResponseBody() {}

  explicit GetMergeRequestChangeTreeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        GetMergeRequestChangeTreeResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<GetMergeRequestChangeTreeResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetMergeRequestChangeTreeResponseBody() = default;
};
class GetMergeRequestChangeTreeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMergeRequestChangeTreeResponseBody> body{};

  GetMergeRequestChangeTreeResponse() {}

  explicit GetMergeRequestChangeTreeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMergeRequestChangeTreeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMergeRequestChangeTreeResponseBody>(model1);
      }
    }
  }


  virtual ~GetMergeRequestChangeTreeResponse() = default;
};
class GetOrganizationMemberResponseBodyMemberIdentities : public Darabonba::Model {
public:
  shared_ptr<string> externUid{};
  shared_ptr<string> provider{};

  GetOrganizationMemberResponseBodyMemberIdentities() {}

  explicit GetOrganizationMemberResponseBodyMemberIdentities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (externUid) {
      res["externUid"] = boost::any(*externUid);
    }
    if (provider) {
      res["provider"] = boost::any(*provider);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("externUid") != m.end() && !m["externUid"].empty()) {
      externUid = make_shared<string>(boost::any_cast<string>(m["externUid"]));
    }
    if (m.find("provider") != m.end() && !m["provider"].empty()) {
      provider = make_shared<string>(boost::any_cast<string>(m["provider"]));
    }
  }


  virtual ~GetOrganizationMemberResponseBodyMemberIdentities() = default;
};
class GetOrganizationMemberResponseBodyMember : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<long> birthday{};
  shared_ptr<vector<string>> deptLists{};
  shared_ptr<string> email{};
  shared_ptr<long> hiredDate{};
  shared_ptr<GetOrganizationMemberResponseBodyMemberIdentities> identities{};
  shared_ptr<string> jobNumber{};
  shared_ptr<long> joinTime{};
  shared_ptr<long> lastVisitTime{};
  shared_ptr<string> mobile{};
  shared_ptr<string> organizationMemberName{};
  shared_ptr<string> organizationRoleId{};
  shared_ptr<string> organizationRoleName{};
  shared_ptr<string> state{};

  GetOrganizationMemberResponseBodyMember() {}

  explicit GetOrganizationMemberResponseBodyMember(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    if (birthday) {
      res["birthday"] = boost::any(*birthday);
    }
    if (deptLists) {
      res["deptLists"] = boost::any(*deptLists);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (hiredDate) {
      res["hiredDate"] = boost::any(*hiredDate);
    }
    if (identities) {
      res["identities"] = identities ? boost::any(identities->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobNumber) {
      res["jobNumber"] = boost::any(*jobNumber);
    }
    if (joinTime) {
      res["joinTime"] = boost::any(*joinTime);
    }
    if (lastVisitTime) {
      res["lastVisitTime"] = boost::any(*lastVisitTime);
    }
    if (mobile) {
      res["mobile"] = boost::any(*mobile);
    }
    if (organizationMemberName) {
      res["organizationMemberName"] = boost::any(*organizationMemberName);
    }
    if (organizationRoleId) {
      res["organizationRoleId"] = boost::any(*organizationRoleId);
    }
    if (organizationRoleName) {
      res["organizationRoleName"] = boost::any(*organizationRoleName);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
    if (m.find("birthday") != m.end() && !m["birthday"].empty()) {
      birthday = make_shared<long>(boost::any_cast<long>(m["birthday"]));
    }
    if (m.find("deptLists") != m.end() && !m["deptLists"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["deptLists"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["deptLists"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deptLists = make_shared<vector<string>>(toVec1);
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("hiredDate") != m.end() && !m["hiredDate"].empty()) {
      hiredDate = make_shared<long>(boost::any_cast<long>(m["hiredDate"]));
    }
    if (m.find("identities") != m.end() && !m["identities"].empty()) {
      if (typeid(map<string, boost::any>) == m["identities"].type()) {
        GetOrganizationMemberResponseBodyMemberIdentities model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["identities"]));
        identities = make_shared<GetOrganizationMemberResponseBodyMemberIdentities>(model1);
      }
    }
    if (m.find("jobNumber") != m.end() && !m["jobNumber"].empty()) {
      jobNumber = make_shared<string>(boost::any_cast<string>(m["jobNumber"]));
    }
    if (m.find("joinTime") != m.end() && !m["joinTime"].empty()) {
      joinTime = make_shared<long>(boost::any_cast<long>(m["joinTime"]));
    }
    if (m.find("lastVisitTime") != m.end() && !m["lastVisitTime"].empty()) {
      lastVisitTime = make_shared<long>(boost::any_cast<long>(m["lastVisitTime"]));
    }
    if (m.find("mobile") != m.end() && !m["mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["mobile"]));
    }
    if (m.find("organizationMemberName") != m.end() && !m["organizationMemberName"].empty()) {
      organizationMemberName = make_shared<string>(boost::any_cast<string>(m["organizationMemberName"]));
    }
    if (m.find("organizationRoleId") != m.end() && !m["organizationRoleId"].empty()) {
      organizationRoleId = make_shared<string>(boost::any_cast<string>(m["organizationRoleId"]));
    }
    if (m.find("organizationRoleName") != m.end() && !m["organizationRoleName"].empty()) {
      organizationRoleName = make_shared<string>(boost::any_cast<string>(m["organizationRoleName"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
  }


  virtual ~GetOrganizationMemberResponseBodyMember() = default;
};
class GetOrganizationMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetOrganizationMemberResponseBodyMember> member{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetOrganizationMemberResponseBody() {}

  explicit GetOrganizationMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (member) {
      res["member"] = member ? boost::any(member->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("member") != m.end() && !m["member"].empty()) {
      if (typeid(map<string, boost::any>) == m["member"].type()) {
        GetOrganizationMemberResponseBodyMember model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["member"]));
        member = make_shared<GetOrganizationMemberResponseBodyMember>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetOrganizationMemberResponseBody() = default;
};
class GetOrganizationMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetOrganizationMemberResponseBody> body{};

  GetOrganizationMemberResponse() {}

  explicit GetOrganizationMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOrganizationMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOrganizationMemberResponseBody>(model1);
      }
    }
  }


  virtual ~GetOrganizationMemberResponse() = default;
};
class GetPipelineResponseBodyPipelinePipelineConfigSourcesData : public Darabonba::Model {
public:
  shared_ptr<string> branch{};
  shared_ptr<long> cloneDepth{};
  shared_ptr<long> credentialId{};
  shared_ptr<string> credentialLabel{};
  shared_ptr<string> credentialType{};
  shared_ptr<vector<string>> events{};
  shared_ptr<bool> isBranchMode{};
  shared_ptr<bool> isCloneDepth{};
  shared_ptr<bool> isSubmodule{};
  shared_ptr<bool> isTrigger{};
  shared_ptr<string> label{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> repo{};
  shared_ptr<long> serviceConnectionId{};
  shared_ptr<string> triggerFilter{};
  shared_ptr<string> webhook{};

  GetPipelineResponseBodyPipelinePipelineConfigSourcesData() {}

  explicit GetPipelineResponseBodyPipelinePipelineConfigSourcesData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (branch) {
      res["branch"] = boost::any(*branch);
    }
    if (cloneDepth) {
      res["cloneDepth"] = boost::any(*cloneDepth);
    }
    if (credentialId) {
      res["credentialId"] = boost::any(*credentialId);
    }
    if (credentialLabel) {
      res["credentialLabel"] = boost::any(*credentialLabel);
    }
    if (credentialType) {
      res["credentialType"] = boost::any(*credentialType);
    }
    if (events) {
      res["events"] = boost::any(*events);
    }
    if (isBranchMode) {
      res["isBranchMode"] = boost::any(*isBranchMode);
    }
    if (isCloneDepth) {
      res["isCloneDepth"] = boost::any(*isCloneDepth);
    }
    if (isSubmodule) {
      res["isSubmodule"] = boost::any(*isSubmodule);
    }
    if (isTrigger) {
      res["isTrigger"] = boost::any(*isTrigger);
    }
    if (label) {
      res["label"] = boost::any(*label);
    }
    if (namespace_) {
      res["namespace"] = boost::any(*namespace_);
    }
    if (repo) {
      res["repo"] = boost::any(*repo);
    }
    if (serviceConnectionId) {
      res["serviceConnectionId"] = boost::any(*serviceConnectionId);
    }
    if (triggerFilter) {
      res["triggerFilter"] = boost::any(*triggerFilter);
    }
    if (webhook) {
      res["webhook"] = boost::any(*webhook);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("branch") != m.end() && !m["branch"].empty()) {
      branch = make_shared<string>(boost::any_cast<string>(m["branch"]));
    }
    if (m.find("cloneDepth") != m.end() && !m["cloneDepth"].empty()) {
      cloneDepth = make_shared<long>(boost::any_cast<long>(m["cloneDepth"]));
    }
    if (m.find("credentialId") != m.end() && !m["credentialId"].empty()) {
      credentialId = make_shared<long>(boost::any_cast<long>(m["credentialId"]));
    }
    if (m.find("credentialLabel") != m.end() && !m["credentialLabel"].empty()) {
      credentialLabel = make_shared<string>(boost::any_cast<string>(m["credentialLabel"]));
    }
    if (m.find("credentialType") != m.end() && !m["credentialType"].empty()) {
      credentialType = make_shared<string>(boost::any_cast<string>(m["credentialType"]));
    }
    if (m.find("events") != m.end() && !m["events"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["events"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["events"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      events = make_shared<vector<string>>(toVec1);
    }
    if (m.find("isBranchMode") != m.end() && !m["isBranchMode"].empty()) {
      isBranchMode = make_shared<bool>(boost::any_cast<bool>(m["isBranchMode"]));
    }
    if (m.find("isCloneDepth") != m.end() && !m["isCloneDepth"].empty()) {
      isCloneDepth = make_shared<bool>(boost::any_cast<bool>(m["isCloneDepth"]));
    }
    if (m.find("isSubmodule") != m.end() && !m["isSubmodule"].empty()) {
      isSubmodule = make_shared<bool>(boost::any_cast<bool>(m["isSubmodule"]));
    }
    if (m.find("isTrigger") != m.end() && !m["isTrigger"].empty()) {
      isTrigger = make_shared<bool>(boost::any_cast<bool>(m["isTrigger"]));
    }
    if (m.find("label") != m.end() && !m["label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["label"]));
    }
    if (m.find("namespace") != m.end() && !m["namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["namespace"]));
    }
    if (m.find("repo") != m.end() && !m["repo"].empty()) {
      repo = make_shared<string>(boost::any_cast<string>(m["repo"]));
    }
    if (m.find("serviceConnectionId") != m.end() && !m["serviceConnectionId"].empty()) {
      serviceConnectionId = make_shared<long>(boost::any_cast<long>(m["serviceConnectionId"]));
    }
    if (m.find("triggerFilter") != m.end() && !m["triggerFilter"].empty()) {
      triggerFilter = make_shared<string>(boost::any_cast<string>(m["triggerFilter"]));
    }
    if (m.find("webhook") != m.end() && !m["webhook"].empty()) {
      webhook = make_shared<string>(boost::any_cast<string>(m["webhook"]));
    }
  }


  virtual ~GetPipelineResponseBodyPipelinePipelineConfigSourcesData() = default;
};
class GetPipelineResponseBodyPipelinePipelineConfigSources : public Darabonba::Model {
public:
  shared_ptr<GetPipelineResponseBodyPipelinePipelineConfigSourcesData> data{};
  shared_ptr<string> sign{};
  shared_ptr<string> type{};

  GetPipelineResponseBodyPipelinePipelineConfigSources() {}

  explicit GetPipelineResponseBodyPipelinePipelineConfigSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sign) {
      res["sign"] = boost::any(*sign);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        GetPipelineResponseBodyPipelinePipelineConfigSourcesData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<GetPipelineResponseBodyPipelinePipelineConfigSourcesData>(model1);
      }
    }
    if (m.find("sign") != m.end() && !m["sign"].empty()) {
      sign = make_shared<string>(boost::any_cast<string>(m["sign"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~GetPipelineResponseBodyPipelinePipelineConfigSources() = default;
};
class GetPipelineResponseBodyPipelinePipelineConfig : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<string> settings{};
  shared_ptr<vector<GetPipelineResponseBodyPipelinePipelineConfigSources>> sources{};

  GetPipelineResponseBodyPipelinePipelineConfig() {}

  explicit GetPipelineResponseBodyPipelinePipelineConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["flow"] = boost::any(*flow);
    }
    if (settings) {
      res["settings"] = boost::any(*settings);
    }
    if (sources) {
      vector<boost::any> temp1;
      for(auto item1:*sources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["sources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("flow") != m.end() && !m["flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["flow"]));
    }
    if (m.find("settings") != m.end() && !m["settings"].empty()) {
      settings = make_shared<string>(boost::any_cast<string>(m["settings"]));
    }
    if (m.find("sources") != m.end() && !m["sources"].empty()) {
      if (typeid(vector<boost::any>) == m["sources"].type()) {
        vector<GetPipelineResponseBodyPipelinePipelineConfigSources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["sources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPipelineResponseBodyPipelinePipelineConfigSources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sources = make_shared<vector<GetPipelineResponseBodyPipelinePipelineConfigSources>>(expect1);
      }
    }
  }


  virtual ~GetPipelineResponseBodyPipelinePipelineConfig() = default;
};
class GetPipelineResponseBodyPipelineTagList : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  GetPipelineResponseBodyPipelineTagList() {}

  explicit GetPipelineResponseBodyPipelineTagList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~GetPipelineResponseBodyPipelineTagList() = default;
};
class GetPipelineResponseBodyPipeline : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> creatorAccountId{};
  shared_ptr<long> envId{};
  shared_ptr<string> envName{};
  shared_ptr<long> groupId{};
  shared_ptr<string> modifierAccountId{};
  shared_ptr<string> name{};
  shared_ptr<GetPipelineResponseBodyPipelinePipelineConfig> pipelineConfig{};
  shared_ptr<vector<GetPipelineResponseBodyPipelineTagList>> tagList{};
  shared_ptr<long> updateTime{};

  GetPipelineResponseBodyPipeline() {}

  explicit GetPipelineResponseBodyPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (creatorAccountId) {
      res["creatorAccountId"] = boost::any(*creatorAccountId);
    }
    if (envId) {
      res["envId"] = boost::any(*envId);
    }
    if (envName) {
      res["envName"] = boost::any(*envName);
    }
    if (groupId) {
      res["groupId"] = boost::any(*groupId);
    }
    if (modifierAccountId) {
      res["modifierAccountId"] = boost::any(*modifierAccountId);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (pipelineConfig) {
      res["pipelineConfig"] = pipelineConfig ? boost::any(pipelineConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tagList) {
      vector<boost::any> temp1;
      for(auto item1:*tagList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tagList"] = boost::any(temp1);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["createTime"]));
    }
    if (m.find("creatorAccountId") != m.end() && !m["creatorAccountId"].empty()) {
      creatorAccountId = make_shared<string>(boost::any_cast<string>(m["creatorAccountId"]));
    }
    if (m.find("envId") != m.end() && !m["envId"].empty()) {
      envId = make_shared<long>(boost::any_cast<long>(m["envId"]));
    }
    if (m.find("envName") != m.end() && !m["envName"].empty()) {
      envName = make_shared<string>(boost::any_cast<string>(m["envName"]));
    }
    if (m.find("groupId") != m.end() && !m["groupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["groupId"]));
    }
    if (m.find("modifierAccountId") != m.end() && !m["modifierAccountId"].empty()) {
      modifierAccountId = make_shared<string>(boost::any_cast<string>(m["modifierAccountId"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("pipelineConfig") != m.end() && !m["pipelineConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["pipelineConfig"].type()) {
        GetPipelineResponseBodyPipelinePipelineConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["pipelineConfig"]));
        pipelineConfig = make_shared<GetPipelineResponseBodyPipelinePipelineConfig>(model1);
      }
    }
    if (m.find("tagList") != m.end() && !m["tagList"].empty()) {
      if (typeid(vector<boost::any>) == m["tagList"].type()) {
        vector<GetPipelineResponseBodyPipelineTagList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tagList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPipelineResponseBodyPipelineTagList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagList = make_shared<vector<GetPipelineResponseBodyPipelineTagList>>(expect1);
      }
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["updateTime"]));
    }
  }


  virtual ~GetPipelineResponseBodyPipeline() = default;
};
class GetPipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetPipelineResponseBodyPipeline> pipeline{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetPipelineResponseBody() {}

  explicit GetPipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (pipeline) {
      res["pipeline"] = pipeline ? boost::any(pipeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("pipeline") != m.end() && !m["pipeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["pipeline"].type()) {
        GetPipelineResponseBodyPipeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["pipeline"]));
        pipeline = make_shared<GetPipelineResponseBodyPipeline>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetPipelineResponseBody() = default;
};
class GetPipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPipelineResponseBody> body{};

  GetPipelineResponse() {}

  explicit GetPipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPipelineResponseBody>(model1);
      }
    }
  }


  virtual ~GetPipelineResponse() = default;
};
class GetPipelineArtifactUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<string> filePath{};

  GetPipelineArtifactUrlRequest() {}

  explicit GetPipelineArtifactUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["fileName"] = boost::any(*fileName);
    }
    if (filePath) {
      res["filePath"] = boost::any(*filePath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fileName") != m.end() && !m["fileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["fileName"]));
    }
    if (m.find("filePath") != m.end() && !m["filePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["filePath"]));
    }
  }


  virtual ~GetPipelineArtifactUrlRequest() = default;
};
class GetPipelineArtifactUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetPipelineArtifactUrlResponseBody() {}

  explicit GetPipelineArtifactUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (fileUrl) {
      res["fileUrl"] = boost::any(*fileUrl);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("fileUrl") != m.end() && !m["fileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["fileUrl"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetPipelineArtifactUrlResponseBody() = default;
};
class GetPipelineArtifactUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPipelineArtifactUrlResponseBody> body{};

  GetPipelineArtifactUrlResponse() {}

  explicit GetPipelineArtifactUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPipelineArtifactUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPipelineArtifactUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetPipelineArtifactUrlResponse() = default;
};
class GetPipelineEmasArtifactUrlRequest : public Darabonba::Model {
public:
  shared_ptr<long> serviceConnectionId{};

  GetPipelineEmasArtifactUrlRequest() {}

  explicit GetPipelineEmasArtifactUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceConnectionId) {
      res["serviceConnectionId"] = boost::any(*serviceConnectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("serviceConnectionId") != m.end() && !m["serviceConnectionId"].empty()) {
      serviceConnectionId = make_shared<long>(boost::any_cast<long>(m["serviceConnectionId"]));
    }
  }


  virtual ~GetPipelineEmasArtifactUrlRequest() = default;
};
class GetPipelineEmasArtifactUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetPipelineEmasArtifactUrlResponseBody() {}

  explicit GetPipelineEmasArtifactUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (fileUrl) {
      res["fileUrl"] = boost::any(*fileUrl);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("fileUrl") != m.end() && !m["fileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["fileUrl"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetPipelineEmasArtifactUrlResponseBody() = default;
};
class GetPipelineEmasArtifactUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPipelineEmasArtifactUrlResponseBody> body{};

  GetPipelineEmasArtifactUrlResponse() {}

  explicit GetPipelineEmasArtifactUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPipelineEmasArtifactUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPipelineEmasArtifactUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetPipelineEmasArtifactUrlResponse() = default;
};
class GetPipelineGroupResponseBodyPipelineGroup : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  GetPipelineGroupResponseBodyPipelineGroup() {}

  explicit GetPipelineGroupResponseBodyPipelineGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["createTime"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~GetPipelineGroupResponseBodyPipelineGroup() = default;
};
class GetPipelineGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetPipelineGroupResponseBodyPipelineGroup> pipelineGroup{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetPipelineGroupResponseBody() {}

  explicit GetPipelineGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (pipelineGroup) {
      res["pipelineGroup"] = pipelineGroup ? boost::any(pipelineGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("pipelineGroup") != m.end() && !m["pipelineGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["pipelineGroup"].type()) {
        GetPipelineGroupResponseBodyPipelineGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["pipelineGroup"]));
        pipelineGroup = make_shared<GetPipelineGroupResponseBodyPipelineGroup>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetPipelineGroupResponseBody() = default;
};
class GetPipelineGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPipelineGroupResponseBody> body{};

  GetPipelineGroupResponse() {}

  explicit GetPipelineGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPipelineGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPipelineGroupResponseBody>(model1);
      }
    }
  }


  virtual ~GetPipelineGroupResponse() = default;
};
class GetPipelineRunResponseBodyPipelineRunSourcesData : public Darabonba::Model {
public:
  shared_ptr<string> branch{};
  shared_ptr<string> commint{};
  shared_ptr<string> repo{};

  GetPipelineRunResponseBodyPipelineRunSourcesData() {}

  explicit GetPipelineRunResponseBodyPipelineRunSourcesData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (branch) {
      res["branch"] = boost::any(*branch);
    }
    if (commint) {
      res["commint"] = boost::any(*commint);
    }
    if (repo) {
      res["repo"] = boost::any(*repo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("branch") != m.end() && !m["branch"].empty()) {
      branch = make_shared<string>(boost::any_cast<string>(m["branch"]));
    }
    if (m.find("commint") != m.end() && !m["commint"].empty()) {
      commint = make_shared<string>(boost::any_cast<string>(m["commint"]));
    }
    if (m.find("repo") != m.end() && !m["repo"].empty()) {
      repo = make_shared<string>(boost::any_cast<string>(m["repo"]));
    }
  }


  virtual ~GetPipelineRunResponseBodyPipelineRunSourcesData() = default;
};
class GetPipelineRunResponseBodyPipelineRunSources : public Darabonba::Model {
public:
  shared_ptr<GetPipelineRunResponseBodyPipelineRunSourcesData> data{};
  shared_ptr<string> sign{};
  shared_ptr<string> type{};

  GetPipelineRunResponseBodyPipelineRunSources() {}

  explicit GetPipelineRunResponseBodyPipelineRunSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sign) {
      res["sign"] = boost::any(*sign);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        GetPipelineRunResponseBodyPipelineRunSourcesData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<GetPipelineRunResponseBodyPipelineRunSourcesData>(model1);
      }
    }
    if (m.find("sign") != m.end() && !m["sign"].empty()) {
      sign = make_shared<string>(boost::any_cast<string>(m["sign"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~GetPipelineRunResponseBodyPipelineRunSources() = default;
};
class GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions : public Darabonba::Model {
public:
  shared_ptr<bool> disable{};
  shared_ptr<map<string, boost::any>> params{};
  shared_ptr<string> type{};

  GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions() {}

  explicit GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disable) {
      res["disable"] = boost::any(*disable);
    }
    if (params) {
      res["params"] = boost::any(*params);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("disable") != m.end() && !m["disable"].empty()) {
      disable = make_shared<bool>(boost::any_cast<bool>(m["disable"]));
    }
    if (m.find("params") != m.end() && !m["params"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["params"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      params = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions() = default;
};
class GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobs : public Darabonba::Model {
public:
  shared_ptr<vector<GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions>> actions{};
  shared_ptr<long> endTime{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> params{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};

  GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobs() {}

  explicit GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actions) {
      vector<boost::any> temp1;
      for(auto item1:*actions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["actions"] = boost::any(temp1);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (params) {
      res["params"] = boost::any(*params);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("actions") != m.end() && !m["actions"].empty()) {
      if (typeid(vector<boost::any>) == m["actions"].type()) {
        vector<GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["actions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        actions = make_shared<vector<GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions>>(expect1);
      }
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("params") != m.end() && !m["params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["params"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobs() = default;
};
class GetPipelineRunResponseBodyPipelineRunStagesStageInfo : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<vector<GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobs>> jobs{};
  shared_ptr<string> name{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};

  GetPipelineRunResponseBodyPipelineRunStagesStageInfo() {}

  explicit GetPipelineRunResponseBodyPipelineRunStagesStageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (jobs) {
      vector<boost::any> temp1;
      for(auto item1:*jobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["jobs"] = boost::any(temp1);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("jobs") != m.end() && !m["jobs"].empty()) {
      if (typeid(vector<boost::any>) == m["jobs"].type()) {
        vector<GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["jobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobs = make_shared<vector<GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobs>>(expect1);
      }
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~GetPipelineRunResponseBodyPipelineRunStagesStageInfo() = default;
};
class GetPipelineRunResponseBodyPipelineRunStages : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<GetPipelineRunResponseBodyPipelineRunStagesStageInfo> stageInfo{};

  GetPipelineRunResponseBodyPipelineRunStages() {}

  explicit GetPipelineRunResponseBodyPipelineRunStages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (stageInfo) {
      res["stageInfo"] = stageInfo ? boost::any(stageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("stageInfo") != m.end() && !m["stageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["stageInfo"].type()) {
        GetPipelineRunResponseBodyPipelineRunStagesStageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["stageInfo"]));
        stageInfo = make_shared<GetPipelineRunResponseBodyPipelineRunStagesStageInfo>(model1);
      }
    }
  }


  virtual ~GetPipelineRunResponseBodyPipelineRunStages() = default;
};
class GetPipelineRunResponseBodyPipelineRun : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> creatorAccountId{};
  shared_ptr<string> modifierAccountId{};
  shared_ptr<long> pipelineId{};
  shared_ptr<long> pipelineRunId{};
  shared_ptr<vector<GetPipelineRunResponseBodyPipelineRunSources>> sources{};
  shared_ptr<vector<vector<string>>> stageGroup{};
  shared_ptr<vector<GetPipelineRunResponseBodyPipelineRunStages>> stages{};
  shared_ptr<string> status{};
  shared_ptr<long> triggerMode{};
  shared_ptr<long> updateTime{};

  GetPipelineRunResponseBodyPipelineRun() {}

  explicit GetPipelineRunResponseBodyPipelineRun(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (creatorAccountId) {
      res["creatorAccountId"] = boost::any(*creatorAccountId);
    }
    if (modifierAccountId) {
      res["modifierAccountId"] = boost::any(*modifierAccountId);
    }
    if (pipelineId) {
      res["pipelineId"] = boost::any(*pipelineId);
    }
    if (pipelineRunId) {
      res["pipelineRunId"] = boost::any(*pipelineRunId);
    }
    if (sources) {
      vector<boost::any> temp1;
      for(auto item1:*sources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["sources"] = boost::any(temp1);
    }
    if (stageGroup) {
      res["stageGroup"] = boost::any(*stageGroup);
    }
    if (stages) {
      vector<boost::any> temp1;
      for(auto item1:*stages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["stages"] = boost::any(temp1);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (triggerMode) {
      res["triggerMode"] = boost::any(*triggerMode);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["createTime"]));
    }
    if (m.find("creatorAccountId") != m.end() && !m["creatorAccountId"].empty()) {
      creatorAccountId = make_shared<string>(boost::any_cast<string>(m["creatorAccountId"]));
    }
    if (m.find("modifierAccountId") != m.end() && !m["modifierAccountId"].empty()) {
      modifierAccountId = make_shared<string>(boost::any_cast<string>(m["modifierAccountId"]));
    }
    if (m.find("pipelineId") != m.end() && !m["pipelineId"].empty()) {
      pipelineId = make_shared<long>(boost::any_cast<long>(m["pipelineId"]));
    }
    if (m.find("pipelineRunId") != m.end() && !m["pipelineRunId"].empty()) {
      pipelineRunId = make_shared<long>(boost::any_cast<long>(m["pipelineRunId"]));
    }
    if (m.find("sources") != m.end() && !m["sources"].empty()) {
      if (typeid(vector<boost::any>) == m["sources"].type()) {
        vector<GetPipelineRunResponseBodyPipelineRunSources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["sources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPipelineRunResponseBodyPipelineRunSources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sources = make_shared<vector<GetPipelineRunResponseBodyPipelineRunSources>>(expect1);
      }
    }
    if (m.find("stageGroup") != m.end() && !m["stageGroup"].empty()) {
      vector<vector<string>> toVec1;
      if (typeid(vector<boost::any>) == m["stageGroup"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["stageGroup"]);
        for (auto item:vec1) {
          vector<string> toVec2;
          if (typeid(vector<boost::any>) == item.type()) {
            vector<boost::any> vec2 = boost::any_cast<vector<boost::any>>(item);
            for (auto item:vec2) {
               toVec2.push_back(boost::any_cast<string>(item));
            }
          }
           toVec1 = toVec2;
        }
      }
      stageGroup = make_shared<vector<vector<string>>>(toVec1);
    }
    if (m.find("stages") != m.end() && !m["stages"].empty()) {
      if (typeid(vector<boost::any>) == m["stages"].type()) {
        vector<GetPipelineRunResponseBodyPipelineRunStages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["stages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPipelineRunResponseBodyPipelineRunStages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        stages = make_shared<vector<GetPipelineRunResponseBodyPipelineRunStages>>(expect1);
      }
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("triggerMode") != m.end() && !m["triggerMode"].empty()) {
      triggerMode = make_shared<long>(boost::any_cast<long>(m["triggerMode"]));
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["updateTime"]));
    }
  }


  virtual ~GetPipelineRunResponseBodyPipelineRun() = default;
};
class GetPipelineRunResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetPipelineRunResponseBodyPipelineRun> pipelineRun{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetPipelineRunResponseBody() {}

  explicit GetPipelineRunResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (pipelineRun) {
      res["pipelineRun"] = pipelineRun ? boost::any(pipelineRun->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("pipelineRun") != m.end() && !m["pipelineRun"].empty()) {
      if (typeid(map<string, boost::any>) == m["pipelineRun"].type()) {
        GetPipelineRunResponseBodyPipelineRun model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["pipelineRun"]));
        pipelineRun = make_shared<GetPipelineRunResponseBodyPipelineRun>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetPipelineRunResponseBody() = default;
};
class GetPipelineRunResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPipelineRunResponseBody> body{};

  GetPipelineRunResponse() {}

  explicit GetPipelineRunResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPipelineRunResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPipelineRunResponseBody>(model1);
      }
    }
  }


  virtual ~GetPipelineRunResponse() = default;
};
class GetPipelineScanReportUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> reportPath{};

  GetPipelineScanReportUrlRequest() {}

  explicit GetPipelineScanReportUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reportPath) {
      res["reportPath"] = boost::any(*reportPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("reportPath") != m.end() && !m["reportPath"].empty()) {
      reportPath = make_shared<string>(boost::any_cast<string>(m["reportPath"]));
    }
  }


  virtual ~GetPipelineScanReportUrlRequest() = default;
};
class GetPipelineScanReportUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> reportUrl{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetPipelineScanReportUrlResponseBody() {}

  explicit GetPipelineScanReportUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (reportUrl) {
      res["reportUrl"] = boost::any(*reportUrl);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("reportUrl") != m.end() && !m["reportUrl"].empty()) {
      reportUrl = make_shared<string>(boost::any_cast<string>(m["reportUrl"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetPipelineScanReportUrlResponseBody() = default;
};
class GetPipelineScanReportUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPipelineScanReportUrlResponseBody> body{};

  GetPipelineScanReportUrlResponse() {}

  explicit GetPipelineScanReportUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPipelineScanReportUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPipelineScanReportUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetPipelineScanReportUrlResponse() = default;
};
class GetProjectInfoResponseBodyProject : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> categoryIdentifier{};
  shared_ptr<string> creator{};
  shared_ptr<string> customCode{};
  shared_ptr<string> description{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> icon{};
  shared_ptr<string> iconBig{};
  shared_ptr<string> iconGroup{};
  shared_ptr<string> iconSmall{};
  shared_ptr<string> id{};
  shared_ptr<string> identifier{};
  shared_ptr<string> identifierPath{};
  shared_ptr<string> logicalStatus{};
  shared_ptr<string> modifier{};
  shared_ptr<string> name{};
  shared_ptr<string> organizationIdentifier{};
  shared_ptr<string> parentIdentifier{};
  shared_ptr<string> scope{};
  shared_ptr<string> statusIdentifier{};
  shared_ptr<string> statusStageIdentifier{};
  shared_ptr<string> subType{};
  shared_ptr<string> typeIdentifier{};

  GetProjectInfoResponseBodyProject() {}

  explicit GetProjectInfoResponseBodyProject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (categoryIdentifier) {
      res["categoryIdentifier"] = boost::any(*categoryIdentifier);
    }
    if (creator) {
      res["creator"] = boost::any(*creator);
    }
    if (customCode) {
      res["customCode"] = boost::any(*customCode);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (icon) {
      res["icon"] = boost::any(*icon);
    }
    if (iconBig) {
      res["iconBig"] = boost::any(*iconBig);
    }
    if (iconGroup) {
      res["iconGroup"] = boost::any(*iconGroup);
    }
    if (iconSmall) {
      res["iconSmall"] = boost::any(*iconSmall);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (identifierPath) {
      res["identifierPath"] = boost::any(*identifierPath);
    }
    if (logicalStatus) {
      res["logicalStatus"] = boost::any(*logicalStatus);
    }
    if (modifier) {
      res["modifier"] = boost::any(*modifier);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (organizationIdentifier) {
      res["organizationIdentifier"] = boost::any(*organizationIdentifier);
    }
    if (parentIdentifier) {
      res["parentIdentifier"] = boost::any(*parentIdentifier);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (statusIdentifier) {
      res["statusIdentifier"] = boost::any(*statusIdentifier);
    }
    if (statusStageIdentifier) {
      res["statusStageIdentifier"] = boost::any(*statusStageIdentifier);
    }
    if (subType) {
      res["subType"] = boost::any(*subType);
    }
    if (typeIdentifier) {
      res["typeIdentifier"] = boost::any(*typeIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["category"]));
    }
    if (m.find("categoryIdentifier") != m.end() && !m["categoryIdentifier"].empty()) {
      categoryIdentifier = make_shared<string>(boost::any_cast<string>(m["categoryIdentifier"]));
    }
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["creator"]));
    }
    if (m.find("customCode") != m.end() && !m["customCode"].empty()) {
      customCode = make_shared<string>(boost::any_cast<string>(m["customCode"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("icon") != m.end() && !m["icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["icon"]));
    }
    if (m.find("iconBig") != m.end() && !m["iconBig"].empty()) {
      iconBig = make_shared<string>(boost::any_cast<string>(m["iconBig"]));
    }
    if (m.find("iconGroup") != m.end() && !m["iconGroup"].empty()) {
      iconGroup = make_shared<string>(boost::any_cast<string>(m["iconGroup"]));
    }
    if (m.find("iconSmall") != m.end() && !m["iconSmall"].empty()) {
      iconSmall = make_shared<string>(boost::any_cast<string>(m["iconSmall"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("identifierPath") != m.end() && !m["identifierPath"].empty()) {
      identifierPath = make_shared<string>(boost::any_cast<string>(m["identifierPath"]));
    }
    if (m.find("logicalStatus") != m.end() && !m["logicalStatus"].empty()) {
      logicalStatus = make_shared<string>(boost::any_cast<string>(m["logicalStatus"]));
    }
    if (m.find("modifier") != m.end() && !m["modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["modifier"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("organizationIdentifier") != m.end() && !m["organizationIdentifier"].empty()) {
      organizationIdentifier = make_shared<string>(boost::any_cast<string>(m["organizationIdentifier"]));
    }
    if (m.find("parentIdentifier") != m.end() && !m["parentIdentifier"].empty()) {
      parentIdentifier = make_shared<string>(boost::any_cast<string>(m["parentIdentifier"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["scope"]));
    }
    if (m.find("statusIdentifier") != m.end() && !m["statusIdentifier"].empty()) {
      statusIdentifier = make_shared<string>(boost::any_cast<string>(m["statusIdentifier"]));
    }
    if (m.find("statusStageIdentifier") != m.end() && !m["statusStageIdentifier"].empty()) {
      statusStageIdentifier = make_shared<string>(boost::any_cast<string>(m["statusStageIdentifier"]));
    }
    if (m.find("subType") != m.end() && !m["subType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["subType"]));
    }
    if (m.find("typeIdentifier") != m.end() && !m["typeIdentifier"].empty()) {
      typeIdentifier = make_shared<string>(boost::any_cast<string>(m["typeIdentifier"]));
    }
  }


  virtual ~GetProjectInfoResponseBodyProject() = default;
};
class GetProjectInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetProjectInfoResponseBodyProject> project{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetProjectInfoResponseBody() {}

  explicit GetProjectInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (project) {
      res["project"] = project ? boost::any(project->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("project") != m.end() && !m["project"].empty()) {
      if (typeid(map<string, boost::any>) == m["project"].type()) {
        GetProjectInfoResponseBodyProject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["project"]));
        project = make_shared<GetProjectInfoResponseBodyProject>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetProjectInfoResponseBody() = default;
};
class GetProjectInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetProjectInfoResponseBody> body{};

  GetProjectInfoResponse() {}

  explicit GetProjectInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetProjectInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetProjectInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetProjectInfoResponse() = default;
};
class GetProjectMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> organizationId{};

  GetProjectMemberRequest() {}

  explicit GetProjectMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~GetProjectMemberRequest() = default;
};
class GetProjectMemberResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> accessLevel{};
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  GetProjectMemberResponseBodyResult() {}

  explicit GetProjectMemberResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessLevel) {
      res["accessLevel"] = boost::any(*accessLevel);
    }
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessLevel") != m.end() && !m["accessLevel"].empty()) {
      accessLevel = make_shared<long>(boost::any_cast<long>(m["accessLevel"]));
    }
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~GetProjectMemberResponseBodyResult() = default;
};
class GetProjectMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<GetProjectMemberResponseBodyResult> result{};
  shared_ptr<bool> success{};

  GetProjectMemberResponseBody() {}

  explicit GetProjectMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        GetProjectMemberResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<GetProjectMemberResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetProjectMemberResponseBody() = default;
};
class GetProjectMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetProjectMemberResponseBody> body{};

  GetProjectMemberResponse() {}

  explicit GetProjectMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetProjectMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetProjectMemberResponseBody>(model1);
      }
    }
  }


  virtual ~GetProjectMemberResponse() = default;
};
class GetPushRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> organizationId{};

  GetPushRuleRequest() {}

  explicit GetPushRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~GetPushRuleRequest() = default;
};
class GetPushRuleResponseBodyResultRuleInfos : public Darabonba::Model {
public:
  shared_ptr<string> checkerName{};
  shared_ptr<string> checkerType{};
  shared_ptr<string> extraMessage{};
  shared_ptr<vector<string>> fileRuleRegexes{};

  GetPushRuleResponseBodyResultRuleInfos() {}

  explicit GetPushRuleResponseBodyResultRuleInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkerName) {
      res["checkerName"] = boost::any(*checkerName);
    }
    if (checkerType) {
      res["checkerType"] = boost::any(*checkerType);
    }
    if (extraMessage) {
      res["extraMessage"] = boost::any(*extraMessage);
    }
    if (fileRuleRegexes) {
      res["fileRuleRegexes"] = boost::any(*fileRuleRegexes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("checkerName") != m.end() && !m["checkerName"].empty()) {
      checkerName = make_shared<string>(boost::any_cast<string>(m["checkerName"]));
    }
    if (m.find("checkerType") != m.end() && !m["checkerType"].empty()) {
      checkerType = make_shared<string>(boost::any_cast<string>(m["checkerType"]));
    }
    if (m.find("extraMessage") != m.end() && !m["extraMessage"].empty()) {
      extraMessage = make_shared<string>(boost::any_cast<string>(m["extraMessage"]));
    }
    if (m.find("fileRuleRegexes") != m.end() && !m["fileRuleRegexes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["fileRuleRegexes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["fileRuleRegexes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fileRuleRegexes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetPushRuleResponseBodyResultRuleInfos() = default;
};
class GetPushRuleResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<vector<GetPushRuleResponseBodyResultRuleInfos>> ruleInfos{};

  GetPushRuleResponseBodyResult() {}

  explicit GetPushRuleResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (ruleInfos) {
      vector<boost::any> temp1;
      for(auto item1:*ruleInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ruleInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("ruleInfos") != m.end() && !m["ruleInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["ruleInfos"].type()) {
        vector<GetPushRuleResponseBodyResultRuleInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ruleInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPushRuleResponseBodyResultRuleInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleInfos = make_shared<vector<GetPushRuleResponseBodyResultRuleInfos>>(expect1);
      }
    }
  }


  virtual ~GetPushRuleResponseBodyResult() = default;
};
class GetPushRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<GetPushRuleResponseBodyResult> result{};
  shared_ptr<bool> success{};

  GetPushRuleResponseBody() {}

  explicit GetPushRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        GetPushRuleResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<GetPushRuleResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetPushRuleResponseBody() = default;
};
class GetPushRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPushRuleResponseBody> body{};

  GetPushRuleResponse() {}

  explicit GetPushRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPushRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPushRuleResponseBody>(model1);
      }
    }
  }


  virtual ~GetPushRuleResponse() = default;
};
class GetReleaseStagePipelineRunRequest : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};

  GetReleaseStagePipelineRunRequest() {}

  explicit GetReleaseStagePipelineRunRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~GetReleaseStagePipelineRunRequest() = default;
};
class GetReleaseStagePipelineRunResponseBodyPipelineRunSourcesData : public Darabonba::Model {
public:
  shared_ptr<string> branch{};
  shared_ptr<string> commit{};
  shared_ptr<string> repo{};

  GetReleaseStagePipelineRunResponseBodyPipelineRunSourcesData() {}

  explicit GetReleaseStagePipelineRunResponseBodyPipelineRunSourcesData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (branch) {
      res["branch"] = boost::any(*branch);
    }
    if (commit) {
      res["commit"] = boost::any(*commit);
    }
    if (repo) {
      res["repo"] = boost::any(*repo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("branch") != m.end() && !m["branch"].empty()) {
      branch = make_shared<string>(boost::any_cast<string>(m["branch"]));
    }
    if (m.find("commit") != m.end() && !m["commit"].empty()) {
      commit = make_shared<string>(boost::any_cast<string>(m["commit"]));
    }
    if (m.find("repo") != m.end() && !m["repo"].empty()) {
      repo = make_shared<string>(boost::any_cast<string>(m["repo"]));
    }
  }


  virtual ~GetReleaseStagePipelineRunResponseBodyPipelineRunSourcesData() = default;
};
class GetReleaseStagePipelineRunResponseBodyPipelineRunSources : public Darabonba::Model {
public:
  shared_ptr<GetReleaseStagePipelineRunResponseBodyPipelineRunSourcesData> data{};
  shared_ptr<string> sign{};
  shared_ptr<string> type{};

  GetReleaseStagePipelineRunResponseBodyPipelineRunSources() {}

  explicit GetReleaseStagePipelineRunResponseBodyPipelineRunSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sign) {
      res["sign"] = boost::any(*sign);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        GetReleaseStagePipelineRunResponseBodyPipelineRunSourcesData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<GetReleaseStagePipelineRunResponseBodyPipelineRunSourcesData>(model1);
      }
    }
    if (m.find("sign") != m.end() && !m["sign"].empty()) {
      sign = make_shared<string>(boost::any_cast<string>(m["sign"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~GetReleaseStagePipelineRunResponseBodyPipelineRunSources() = default;
};
class GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions : public Darabonba::Model {
public:
  shared_ptr<bool> disable{};
  shared_ptr<boost::any> params{};
  shared_ptr<string> type{};

  GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions() {}

  explicit GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disable) {
      res["disable"] = boost::any(*disable);
    }
    if (params) {
      res["params"] = boost::any(*params);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("disable") != m.end() && !m["disable"].empty()) {
      disable = make_shared<bool>(boost::any_cast<bool>(m["disable"]));
    }
    if (m.find("params") != m.end() && !m["params"].empty()) {
      params = make_shared<boost::any>(boost::any_cast<boost::any>(m["params"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions() = default;
};
class GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfoJobs : public Darabonba::Model {
public:
  shared_ptr<vector<GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions>> actions{};
  shared_ptr<long> endTime{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> params{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};

  GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfoJobs() {}

  explicit GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfoJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actions) {
      vector<boost::any> temp1;
      for(auto item1:*actions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["actions"] = boost::any(temp1);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (params) {
      res["params"] = boost::any(*params);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("actions") != m.end() && !m["actions"].empty()) {
      if (typeid(vector<boost::any>) == m["actions"].type()) {
        vector<GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["actions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        actions = make_shared<vector<GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions>>(expect1);
      }
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("params") != m.end() && !m["params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["params"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfoJobs() = default;
};
class GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfo : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<vector<GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfoJobs>> jobs{};
  shared_ptr<string> name{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};

  GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfo() {}

  explicit GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (jobs) {
      vector<boost::any> temp1;
      for(auto item1:*jobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["jobs"] = boost::any(temp1);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("jobs") != m.end() && !m["jobs"].empty()) {
      if (typeid(vector<boost::any>) == m["jobs"].type()) {
        vector<GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfoJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["jobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfoJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobs = make_shared<vector<GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfoJobs>>(expect1);
      }
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfo() = default;
};
class GetReleaseStagePipelineRunResponseBodyPipelineRunStages : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfo> stageInfo{};

  GetReleaseStagePipelineRunResponseBodyPipelineRunStages() {}

  explicit GetReleaseStagePipelineRunResponseBodyPipelineRunStages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (stageInfo) {
      res["stageInfo"] = stageInfo ? boost::any(stageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("stageInfo") != m.end() && !m["stageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["stageInfo"].type()) {
        GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["stageInfo"]));
        stageInfo = make_shared<GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfo>(model1);
      }
    }
  }


  virtual ~GetReleaseStagePipelineRunResponseBodyPipelineRunStages() = default;
};
class GetReleaseStagePipelineRunResponseBodyPipelineRun : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> creatorAccountId{};
  shared_ptr<string> modifierAccountId{};
  shared_ptr<long> pipelineId{};
  shared_ptr<long> pipelineRunId{};
  shared_ptr<vector<GetReleaseStagePipelineRunResponseBodyPipelineRunSources>> sources{};
  shared_ptr<vector<vector<string>>> stageGroup{};
  shared_ptr<vector<GetReleaseStagePipelineRunResponseBodyPipelineRunStages>> stages{};
  shared_ptr<string> status{};
  shared_ptr<long> triggerMode{};
  shared_ptr<long> updateTime{};

  GetReleaseStagePipelineRunResponseBodyPipelineRun() {}

  explicit GetReleaseStagePipelineRunResponseBodyPipelineRun(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (creatorAccountId) {
      res["creatorAccountId"] = boost::any(*creatorAccountId);
    }
    if (modifierAccountId) {
      res["modifierAccountId"] = boost::any(*modifierAccountId);
    }
    if (pipelineId) {
      res["pipelineId"] = boost::any(*pipelineId);
    }
    if (pipelineRunId) {
      res["pipelineRunId"] = boost::any(*pipelineRunId);
    }
    if (sources) {
      vector<boost::any> temp1;
      for(auto item1:*sources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["sources"] = boost::any(temp1);
    }
    if (stageGroup) {
      res["stageGroup"] = boost::any(*stageGroup);
    }
    if (stages) {
      vector<boost::any> temp1;
      for(auto item1:*stages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["stages"] = boost::any(temp1);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (triggerMode) {
      res["triggerMode"] = boost::any(*triggerMode);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["createTime"]));
    }
    if (m.find("creatorAccountId") != m.end() && !m["creatorAccountId"].empty()) {
      creatorAccountId = make_shared<string>(boost::any_cast<string>(m["creatorAccountId"]));
    }
    if (m.find("modifierAccountId") != m.end() && !m["modifierAccountId"].empty()) {
      modifierAccountId = make_shared<string>(boost::any_cast<string>(m["modifierAccountId"]));
    }
    if (m.find("pipelineId") != m.end() && !m["pipelineId"].empty()) {
      pipelineId = make_shared<long>(boost::any_cast<long>(m["pipelineId"]));
    }
    if (m.find("pipelineRunId") != m.end() && !m["pipelineRunId"].empty()) {
      pipelineRunId = make_shared<long>(boost::any_cast<long>(m["pipelineRunId"]));
    }
    if (m.find("sources") != m.end() && !m["sources"].empty()) {
      if (typeid(vector<boost::any>) == m["sources"].type()) {
        vector<GetReleaseStagePipelineRunResponseBodyPipelineRunSources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["sources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetReleaseStagePipelineRunResponseBodyPipelineRunSources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sources = make_shared<vector<GetReleaseStagePipelineRunResponseBodyPipelineRunSources>>(expect1);
      }
    }
    if (m.find("stageGroup") != m.end() && !m["stageGroup"].empty()) {
      vector<vector<string>> toVec1;
      if (typeid(vector<boost::any>) == m["stageGroup"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["stageGroup"]);
        for (auto item:vec1) {
          vector<string> toVec2;
          if (typeid(vector<boost::any>) == item.type()) {
            vector<boost::any> vec2 = boost::any_cast<vector<boost::any>>(item);
            for (auto item:vec2) {
               toVec2.push_back(boost::any_cast<string>(item));
            }
          }
           toVec1 = toVec2;
        }
      }
      stageGroup = make_shared<vector<vector<string>>>(toVec1);
    }
    if (m.find("stages") != m.end() && !m["stages"].empty()) {
      if (typeid(vector<boost::any>) == m["stages"].type()) {
        vector<GetReleaseStagePipelineRunResponseBodyPipelineRunStages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["stages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetReleaseStagePipelineRunResponseBodyPipelineRunStages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        stages = make_shared<vector<GetReleaseStagePipelineRunResponseBodyPipelineRunStages>>(expect1);
      }
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("triggerMode") != m.end() && !m["triggerMode"].empty()) {
      triggerMode = make_shared<long>(boost::any_cast<long>(m["triggerMode"]));
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["updateTime"]));
    }
  }


  virtual ~GetReleaseStagePipelineRunResponseBodyPipelineRun() = default;
};
class GetReleaseStagePipelineRunResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetReleaseStagePipelineRunResponseBodyPipelineRun> pipelineRun{};

  GetReleaseStagePipelineRunResponseBody() {}

  explicit GetReleaseStagePipelineRunResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineRun) {
      res["pipelineRun"] = pipelineRun ? boost::any(pipelineRun->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("pipelineRun") != m.end() && !m["pipelineRun"].empty()) {
      if (typeid(map<string, boost::any>) == m["pipelineRun"].type()) {
        GetReleaseStagePipelineRunResponseBodyPipelineRun model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["pipelineRun"]));
        pipelineRun = make_shared<GetReleaseStagePipelineRunResponseBodyPipelineRun>(model1);
      }
    }
  }


  virtual ~GetReleaseStagePipelineRunResponseBody() = default;
};
class GetReleaseStagePipelineRunResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetReleaseStagePipelineRunResponseBody> body{};

  GetReleaseStagePipelineRunResponse() {}

  explicit GetReleaseStagePipelineRunResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetReleaseStagePipelineRunResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetReleaseStagePipelineRunResponseBody>(model1);
      }
    }
  }


  virtual ~GetReleaseStagePipelineRunResponse() = default;
};
class GetRepositoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> identity{};
  shared_ptr<string> organizationId{};

  GetRepositoryRequest() {}

  explicit GetRepositoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (identity) {
      res["identity"] = boost::any(*identity);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("identity") != m.end() && !m["identity"].empty()) {
      identity = make_shared<string>(boost::any_cast<string>(m["identity"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~GetRepositoryRequest() = default;
};
class GetRepositoryResponseBodyRepositoryNamespace : public Darabonba::Model {
public:
  shared_ptr<string> avatar{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> path{};
  shared_ptr<string> updatedAt{};
  shared_ptr<long> visibilityLevel{};

  GetRepositoryResponseBodyRepositoryNamespace() {}

  explicit GetRepositoryResponseBodyRepositoryNamespace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatar) {
      res["avatar"] = boost::any(*avatar);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (ownerId) {
      res["ownerId"] = boost::any(*ownerId);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (updatedAt) {
      res["updatedAt"] = boost::any(*updatedAt);
    }
    if (visibilityLevel) {
      res["visibilityLevel"] = boost::any(*visibilityLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatar") != m.end() && !m["avatar"].empty()) {
      avatar = make_shared<string>(boost::any_cast<string>(m["avatar"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("ownerId") != m.end() && !m["ownerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["ownerId"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("updatedAt") != m.end() && !m["updatedAt"].empty()) {
      updatedAt = make_shared<string>(boost::any_cast<string>(m["updatedAt"]));
    }
    if (m.find("visibilityLevel") != m.end() && !m["visibilityLevel"].empty()) {
      visibilityLevel = make_shared<long>(boost::any_cast<long>(m["visibilityLevel"]));
    }
  }


  virtual ~GetRepositoryResponseBodyRepositoryNamespace() = default;
};
class GetRepositoryResponseBodyRepository : public Darabonba::Model {
public:
  shared_ptr<bool> archive{};
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> createdAt{};
  shared_ptr<long> creatorId{};
  shared_ptr<string> defaultBranch{};
  shared_ptr<bool> demoProjectStatus{};
  shared_ptr<string> description{};
  shared_ptr<string> httpUrlToRepository{};
  shared_ptr<long> id{};
  shared_ptr<string> lastActivityAt{};
  shared_ptr<string> name{};
  shared_ptr<string> nameWithNamespace{};
  shared_ptr<GetRepositoryResponseBodyRepositoryNamespace> namespace_{};
  shared_ptr<string> path{};
  shared_ptr<string> pathWithNamespace{};
  shared_ptr<string> sshUrlToRepository{};
  shared_ptr<long> visibilityLevel{};
  shared_ptr<string> webUrl{};

  GetRepositoryResponseBodyRepository() {}

  explicit GetRepositoryResponseBodyRepository(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (archive) {
      res["archive"] = boost::any(*archive);
    }
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (creatorId) {
      res["creatorId"] = boost::any(*creatorId);
    }
    if (defaultBranch) {
      res["defaultBranch"] = boost::any(*defaultBranch);
    }
    if (demoProjectStatus) {
      res["demoProjectStatus"] = boost::any(*demoProjectStatus);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (httpUrlToRepository) {
      res["httpUrlToRepository"] = boost::any(*httpUrlToRepository);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (lastActivityAt) {
      res["lastActivityAt"] = boost::any(*lastActivityAt);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nameWithNamespace) {
      res["nameWithNamespace"] = boost::any(*nameWithNamespace);
    }
    if (namespace_) {
      res["namespace"] = namespace_ ? boost::any(namespace_->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (pathWithNamespace) {
      res["pathWithNamespace"] = boost::any(*pathWithNamespace);
    }
    if (sshUrlToRepository) {
      res["sshUrlToRepository"] = boost::any(*sshUrlToRepository);
    }
    if (visibilityLevel) {
      res["visibilityLevel"] = boost::any(*visibilityLevel);
    }
    if (webUrl) {
      res["webUrl"] = boost::any(*webUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("archive") != m.end() && !m["archive"].empty()) {
      archive = make_shared<bool>(boost::any_cast<bool>(m["archive"]));
    }
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("creatorId") != m.end() && !m["creatorId"].empty()) {
      creatorId = make_shared<long>(boost::any_cast<long>(m["creatorId"]));
    }
    if (m.find("defaultBranch") != m.end() && !m["defaultBranch"].empty()) {
      defaultBranch = make_shared<string>(boost::any_cast<string>(m["defaultBranch"]));
    }
    if (m.find("demoProjectStatus") != m.end() && !m["demoProjectStatus"].empty()) {
      demoProjectStatus = make_shared<bool>(boost::any_cast<bool>(m["demoProjectStatus"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("httpUrlToRepository") != m.end() && !m["httpUrlToRepository"].empty()) {
      httpUrlToRepository = make_shared<string>(boost::any_cast<string>(m["httpUrlToRepository"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("lastActivityAt") != m.end() && !m["lastActivityAt"].empty()) {
      lastActivityAt = make_shared<string>(boost::any_cast<string>(m["lastActivityAt"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nameWithNamespace") != m.end() && !m["nameWithNamespace"].empty()) {
      nameWithNamespace = make_shared<string>(boost::any_cast<string>(m["nameWithNamespace"]));
    }
    if (m.find("namespace") != m.end() && !m["namespace"].empty()) {
      if (typeid(map<string, boost::any>) == m["namespace"].type()) {
        GetRepositoryResponseBodyRepositoryNamespace model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["namespace"]));
        namespace_ = make_shared<GetRepositoryResponseBodyRepositoryNamespace>(model1);
      }
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("pathWithNamespace") != m.end() && !m["pathWithNamespace"].empty()) {
      pathWithNamespace = make_shared<string>(boost::any_cast<string>(m["pathWithNamespace"]));
    }
    if (m.find("sshUrlToRepository") != m.end() && !m["sshUrlToRepository"].empty()) {
      sshUrlToRepository = make_shared<string>(boost::any_cast<string>(m["sshUrlToRepository"]));
    }
    if (m.find("visibilityLevel") != m.end() && !m["visibilityLevel"].empty()) {
      visibilityLevel = make_shared<long>(boost::any_cast<long>(m["visibilityLevel"]));
    }
    if (m.find("webUrl") != m.end() && !m["webUrl"].empty()) {
      webUrl = make_shared<string>(boost::any_cast<string>(m["webUrl"]));
    }
  }


  virtual ~GetRepositoryResponseBodyRepository() = default;
};
class GetRepositoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetRepositoryResponseBodyRepository> repository{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetRepositoryResponseBody() {}

  explicit GetRepositoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (repository) {
      res["repository"] = repository ? boost::any(repository->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("repository") != m.end() && !m["repository"].empty()) {
      if (typeid(map<string, boost::any>) == m["repository"].type()) {
        GetRepositoryResponseBodyRepository model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["repository"]));
        repository = make_shared<GetRepositoryResponseBodyRepository>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetRepositoryResponseBody() = default;
};
class GetRepositoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRepositoryResponseBody> body{};

  GetRepositoryResponse() {}

  explicit GetRepositoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRepositoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRepositoryResponseBody>(model1);
      }
    }
  }


  virtual ~GetRepositoryResponse() = default;
};
class GetRepositoryCommitRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> organizationId{};
  shared_ptr<bool> showSignature{};

  GetRepositoryCommitRequest() {}

  explicit GetRepositoryCommitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (showSignature) {
      res["showSignature"] = boost::any(*showSignature);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("showSignature") != m.end() && !m["showSignature"].empty()) {
      showSignature = make_shared<bool>(boost::any_cast<bool>(m["showSignature"]));
    }
  }


  virtual ~GetRepositoryCommitRequest() = default;
};
class GetRepositoryCommitResponseBodyResultAuthor : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};
  shared_ptr<string> websiteUrl{};

  GetRepositoryCommitResponseBodyResultAuthor() {}

  explicit GetRepositoryCommitResponseBodyResultAuthor(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    if (websiteUrl) {
      res["websiteUrl"] = boost::any(*websiteUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
    if (m.find("websiteUrl") != m.end() && !m["websiteUrl"].empty()) {
      websiteUrl = make_shared<string>(boost::any_cast<string>(m["websiteUrl"]));
    }
  }


  virtual ~GetRepositoryCommitResponseBodyResultAuthor() = default;
};
class GetRepositoryCommitResponseBodyResultCommitter : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};
  shared_ptr<string> websiteUrl{};

  GetRepositoryCommitResponseBodyResultCommitter() {}

  explicit GetRepositoryCommitResponseBodyResultCommitter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    if (websiteUrl) {
      res["websiteUrl"] = boost::any(*websiteUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
    if (m.find("websiteUrl") != m.end() && !m["websiteUrl"].empty()) {
      websiteUrl = make_shared<string>(boost::any_cast<string>(m["websiteUrl"]));
    }
  }


  virtual ~GetRepositoryCommitResponseBodyResultCommitter() = default;
};
class GetRepositoryCommitResponseBodyResultSignature : public Darabonba::Model {
public:
  shared_ptr<string> gpgKeyId{};
  shared_ptr<string> verificationStatus{};

  GetRepositoryCommitResponseBodyResultSignature() {}

  explicit GetRepositoryCommitResponseBodyResultSignature(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gpgKeyId) {
      res["gpgKeyId"] = boost::any(*gpgKeyId);
    }
    if (verificationStatus) {
      res["verificationStatus"] = boost::any(*verificationStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gpgKeyId") != m.end() && !m["gpgKeyId"].empty()) {
      gpgKeyId = make_shared<string>(boost::any_cast<string>(m["gpgKeyId"]));
    }
    if (m.find("verificationStatus") != m.end() && !m["verificationStatus"].empty()) {
      verificationStatus = make_shared<string>(boost::any_cast<string>(m["verificationStatus"]));
    }
  }


  virtual ~GetRepositoryCommitResponseBodyResultSignature() = default;
};
class GetRepositoryCommitResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<GetRepositoryCommitResponseBodyResultAuthor> author{};
  shared_ptr<string> authorEmail{};
  shared_ptr<string> authorName{};
  shared_ptr<string> authoredDate{};
  shared_ptr<long> commentsCount{};
  shared_ptr<string> committedDate{};
  shared_ptr<GetRepositoryCommitResponseBodyResultCommitter> committer{};
  shared_ptr<string> committerEmail{};
  shared_ptr<string> committerName{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> id{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> parentIds{};
  shared_ptr<string> shortId{};
  shared_ptr<GetRepositoryCommitResponseBodyResultSignature> signature{};
  shared_ptr<string> title{};

  GetRepositoryCommitResponseBodyResult() {}

  explicit GetRepositoryCommitResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (author) {
      res["author"] = author ? boost::any(author->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (authorEmail) {
      res["authorEmail"] = boost::any(*authorEmail);
    }
    if (authorName) {
      res["authorName"] = boost::any(*authorName);
    }
    if (authoredDate) {
      res["authoredDate"] = boost::any(*authoredDate);
    }
    if (commentsCount) {
      res["commentsCount"] = boost::any(*commentsCount);
    }
    if (committedDate) {
      res["committedDate"] = boost::any(*committedDate);
    }
    if (committer) {
      res["committer"] = committer ? boost::any(committer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (committerEmail) {
      res["committerEmail"] = boost::any(*committerEmail);
    }
    if (committerName) {
      res["committerName"] = boost::any(*committerName);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (parentIds) {
      res["parentIds"] = boost::any(*parentIds);
    }
    if (shortId) {
      res["shortId"] = boost::any(*shortId);
    }
    if (signature) {
      res["signature"] = signature ? boost::any(signature->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("author") != m.end() && !m["author"].empty()) {
      if (typeid(map<string, boost::any>) == m["author"].type()) {
        GetRepositoryCommitResponseBodyResultAuthor model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["author"]));
        author = make_shared<GetRepositoryCommitResponseBodyResultAuthor>(model1);
      }
    }
    if (m.find("authorEmail") != m.end() && !m["authorEmail"].empty()) {
      authorEmail = make_shared<string>(boost::any_cast<string>(m["authorEmail"]));
    }
    if (m.find("authorName") != m.end() && !m["authorName"].empty()) {
      authorName = make_shared<string>(boost::any_cast<string>(m["authorName"]));
    }
    if (m.find("authoredDate") != m.end() && !m["authoredDate"].empty()) {
      authoredDate = make_shared<string>(boost::any_cast<string>(m["authoredDate"]));
    }
    if (m.find("commentsCount") != m.end() && !m["commentsCount"].empty()) {
      commentsCount = make_shared<long>(boost::any_cast<long>(m["commentsCount"]));
    }
    if (m.find("committedDate") != m.end() && !m["committedDate"].empty()) {
      committedDate = make_shared<string>(boost::any_cast<string>(m["committedDate"]));
    }
    if (m.find("committer") != m.end() && !m["committer"].empty()) {
      if (typeid(map<string, boost::any>) == m["committer"].type()) {
        GetRepositoryCommitResponseBodyResultCommitter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["committer"]));
        committer = make_shared<GetRepositoryCommitResponseBodyResultCommitter>(model1);
      }
    }
    if (m.find("committerEmail") != m.end() && !m["committerEmail"].empty()) {
      committerEmail = make_shared<string>(boost::any_cast<string>(m["committerEmail"]));
    }
    if (m.find("committerName") != m.end() && !m["committerName"].empty()) {
      committerName = make_shared<string>(boost::any_cast<string>(m["committerName"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("parentIds") != m.end() && !m["parentIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["parentIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["parentIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      parentIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("shortId") != m.end() && !m["shortId"].empty()) {
      shortId = make_shared<string>(boost::any_cast<string>(m["shortId"]));
    }
    if (m.find("signature") != m.end() && !m["signature"].empty()) {
      if (typeid(map<string, boost::any>) == m["signature"].type()) {
        GetRepositoryCommitResponseBodyResultSignature model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["signature"]));
        signature = make_shared<GetRepositoryCommitResponseBodyResultSignature>(model1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~GetRepositoryCommitResponseBodyResult() = default;
};
class GetRepositoryCommitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<GetRepositoryCommitResponseBodyResult> result{};
  shared_ptr<bool> success{};

  GetRepositoryCommitResponseBody() {}

  explicit GetRepositoryCommitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        GetRepositoryCommitResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<GetRepositoryCommitResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetRepositoryCommitResponseBody() = default;
};
class GetRepositoryCommitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRepositoryCommitResponseBody> body{};

  GetRepositoryCommitResponse() {}

  explicit GetRepositoryCommitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRepositoryCommitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRepositoryCommitResponseBody>(model1);
      }
    }
  }


  virtual ~GetRepositoryCommitResponse() = default;
};
class GetRepositoryTagRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> tagName{};

  GetRepositoryTagRequest() {}

  explicit GetRepositoryTagRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (tagName) {
      res["tagName"] = boost::any(*tagName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("tagName") != m.end() && !m["tagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["tagName"]));
    }
  }


  virtual ~GetRepositoryTagRequest() = default;
};
class GetRepositoryTagResponseBodyResultCommitSignature : public Darabonba::Model {
public:
  shared_ptr<string> gpgKeyId{};
  shared_ptr<string> verificationStatus{};

  GetRepositoryTagResponseBodyResultCommitSignature() {}

  explicit GetRepositoryTagResponseBodyResultCommitSignature(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gpgKeyId) {
      res["gpgKeyId"] = boost::any(*gpgKeyId);
    }
    if (verificationStatus) {
      res["verificationStatus"] = boost::any(*verificationStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gpgKeyId") != m.end() && !m["gpgKeyId"].empty()) {
      gpgKeyId = make_shared<string>(boost::any_cast<string>(m["gpgKeyId"]));
    }
    if (m.find("verificationStatus") != m.end() && !m["verificationStatus"].empty()) {
      verificationStatus = make_shared<string>(boost::any_cast<string>(m["verificationStatus"]));
    }
  }


  virtual ~GetRepositoryTagResponseBodyResultCommitSignature() = default;
};
class GetRepositoryTagResponseBodyResultCommit : public Darabonba::Model {
public:
  shared_ptr<string> authorEmail{};
  shared_ptr<string> authorName{};
  shared_ptr<string> authoredDate{};
  shared_ptr<string> committedDate{};
  shared_ptr<string> committerEmail{};
  shared_ptr<string> committerName{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> id{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> parentIds{};
  shared_ptr<string> shortId{};
  shared_ptr<GetRepositoryTagResponseBodyResultCommitSignature> signature{};
  shared_ptr<string> title{};

  GetRepositoryTagResponseBodyResultCommit() {}

  explicit GetRepositoryTagResponseBodyResultCommit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorEmail) {
      res["authorEmail"] = boost::any(*authorEmail);
    }
    if (authorName) {
      res["authorName"] = boost::any(*authorName);
    }
    if (authoredDate) {
      res["authoredDate"] = boost::any(*authoredDate);
    }
    if (committedDate) {
      res["committedDate"] = boost::any(*committedDate);
    }
    if (committerEmail) {
      res["committerEmail"] = boost::any(*committerEmail);
    }
    if (committerName) {
      res["committerName"] = boost::any(*committerName);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (parentIds) {
      res["parentIds"] = boost::any(*parentIds);
    }
    if (shortId) {
      res["shortId"] = boost::any(*shortId);
    }
    if (signature) {
      res["signature"] = signature ? boost::any(signature->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("authorEmail") != m.end() && !m["authorEmail"].empty()) {
      authorEmail = make_shared<string>(boost::any_cast<string>(m["authorEmail"]));
    }
    if (m.find("authorName") != m.end() && !m["authorName"].empty()) {
      authorName = make_shared<string>(boost::any_cast<string>(m["authorName"]));
    }
    if (m.find("authoredDate") != m.end() && !m["authoredDate"].empty()) {
      authoredDate = make_shared<string>(boost::any_cast<string>(m["authoredDate"]));
    }
    if (m.find("committedDate") != m.end() && !m["committedDate"].empty()) {
      committedDate = make_shared<string>(boost::any_cast<string>(m["committedDate"]));
    }
    if (m.find("committerEmail") != m.end() && !m["committerEmail"].empty()) {
      committerEmail = make_shared<string>(boost::any_cast<string>(m["committerEmail"]));
    }
    if (m.find("committerName") != m.end() && !m["committerName"].empty()) {
      committerName = make_shared<string>(boost::any_cast<string>(m["committerName"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("parentIds") != m.end() && !m["parentIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["parentIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["parentIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      parentIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("shortId") != m.end() && !m["shortId"].empty()) {
      shortId = make_shared<string>(boost::any_cast<string>(m["shortId"]));
    }
    if (m.find("signature") != m.end() && !m["signature"].empty()) {
      if (typeid(map<string, boost::any>) == m["signature"].type()) {
        GetRepositoryTagResponseBodyResultCommitSignature model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["signature"]));
        signature = make_shared<GetRepositoryTagResponseBodyResultCommitSignature>(model1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~GetRepositoryTagResponseBodyResultCommit() = default;
};
class GetRepositoryTagResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<GetRepositoryTagResponseBodyResultCommit> commit{};
  shared_ptr<string> id{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};

  GetRepositoryTagResponseBodyResult() {}

  explicit GetRepositoryTagResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commit) {
      res["commit"] = commit ? boost::any(commit->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commit") != m.end() && !m["commit"].empty()) {
      if (typeid(map<string, boost::any>) == m["commit"].type()) {
        GetRepositoryTagResponseBodyResultCommit model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["commit"]));
        commit = make_shared<GetRepositoryTagResponseBodyResultCommit>(model1);
      }
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~GetRepositoryTagResponseBodyResult() = default;
};
class GetRepositoryTagResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<GetRepositoryTagResponseBodyResult> result{};
  shared_ptr<bool> success{};

  GetRepositoryTagResponseBody() {}

  explicit GetRepositoryTagResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        GetRepositoryTagResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<GetRepositoryTagResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetRepositoryTagResponseBody() = default;
};
class GetRepositoryTagResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRepositoryTagResponseBody> body{};

  GetRepositoryTagResponse() {}

  explicit GetRepositoryTagResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRepositoryTagResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRepositoryTagResponseBody>(model1);
      }
    }
  }


  virtual ~GetRepositoryTagResponse() = default;
};
class GetSearchCodePreviewRequest : public Darabonba::Model {
public:
  shared_ptr<string> docId{};
  shared_ptr<bool> isDsl{};
  shared_ptr<string> keyword{};
  shared_ptr<string> organizationId{};

  GetSearchCodePreviewRequest() {}

  explicit GetSearchCodePreviewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docId) {
      res["docId"] = boost::any(*docId);
    }
    if (isDsl) {
      res["isDsl"] = boost::any(*isDsl);
    }
    if (keyword) {
      res["keyword"] = boost::any(*keyword);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("docId") != m.end() && !m["docId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["docId"]));
    }
    if (m.find("isDsl") != m.end() && !m["isDsl"].empty()) {
      isDsl = make_shared<bool>(boost::any_cast<bool>(m["isDsl"]));
    }
    if (m.find("keyword") != m.end() && !m["keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["keyword"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~GetSearchCodePreviewRequest() = default;
};
class GetSearchCodePreviewResponseBodyResultHighlightTextMap : public Darabonba::Model {
public:
  shared_ptr<string> clob{};
  shared_ptr<string> fileName{};
  shared_ptr<string> organizationId{};

  GetSearchCodePreviewResponseBodyResultHighlightTextMap() {}

  explicit GetSearchCodePreviewResponseBodyResultHighlightTextMap(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clob) {
      res["clob"] = boost::any(*clob);
    }
    if (fileName) {
      res["fileName"] = boost::any(*fileName);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clob") != m.end() && !m["clob"].empty()) {
      clob = make_shared<string>(boost::any_cast<string>(m["clob"]));
    }
    if (m.find("fileName") != m.end() && !m["fileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["fileName"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~GetSearchCodePreviewResponseBodyResultHighlightTextMap() = default;
};
class GetSearchCodePreviewResponseBodyResultSource : public Darabonba::Model {
public:
  shared_ptr<string> branch{};
  shared_ptr<string> checkinDate{};
  shared_ptr<string> fileName{};
  shared_ptr<string> filePath{};
  shared_ptr<string> language{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> repoPath{};

  GetSearchCodePreviewResponseBodyResultSource() {}

  explicit GetSearchCodePreviewResponseBodyResultSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (branch) {
      res["branch"] = boost::any(*branch);
    }
    if (checkinDate) {
      res["checkinDate"] = boost::any(*checkinDate);
    }
    if (fileName) {
      res["fileName"] = boost::any(*fileName);
    }
    if (filePath) {
      res["filePath"] = boost::any(*filePath);
    }
    if (language) {
      res["language"] = boost::any(*language);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (repoPath) {
      res["repoPath"] = boost::any(*repoPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("branch") != m.end() && !m["branch"].empty()) {
      branch = make_shared<string>(boost::any_cast<string>(m["branch"]));
    }
    if (m.find("checkinDate") != m.end() && !m["checkinDate"].empty()) {
      checkinDate = make_shared<string>(boost::any_cast<string>(m["checkinDate"]));
    }
    if (m.find("fileName") != m.end() && !m["fileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["fileName"]));
    }
    if (m.find("filePath") != m.end() && !m["filePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["filePath"]));
    }
    if (m.find("language") != m.end() && !m["language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["language"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("repoPath") != m.end() && !m["repoPath"].empty()) {
      repoPath = make_shared<string>(boost::any_cast<string>(m["repoPath"]));
    }
  }


  virtual ~GetSearchCodePreviewResponseBodyResultSource() = default;
};
class GetSearchCodePreviewResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> docId{};
  shared_ptr<GetSearchCodePreviewResponseBodyResultHighlightTextMap> highlightTextMap{};
  shared_ptr<GetSearchCodePreviewResponseBodyResultSource> source{};

  GetSearchCodePreviewResponseBodyResult() {}

  explicit GetSearchCodePreviewResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docId) {
      res["docId"] = boost::any(*docId);
    }
    if (highlightTextMap) {
      res["highlightTextMap"] = highlightTextMap ? boost::any(highlightTextMap->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (source) {
      res["source"] = source ? boost::any(source->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("docId") != m.end() && !m["docId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["docId"]));
    }
    if (m.find("highlightTextMap") != m.end() && !m["highlightTextMap"].empty()) {
      if (typeid(map<string, boost::any>) == m["highlightTextMap"].type()) {
        GetSearchCodePreviewResponseBodyResultHighlightTextMap model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["highlightTextMap"]));
        highlightTextMap = make_shared<GetSearchCodePreviewResponseBodyResultHighlightTextMap>(model1);
      }
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      if (typeid(map<string, boost::any>) == m["source"].type()) {
        GetSearchCodePreviewResponseBodyResultSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["source"]));
        source = make_shared<GetSearchCodePreviewResponseBodyResultSource>(model1);
      }
    }
  }


  virtual ~GetSearchCodePreviewResponseBodyResult() = default;
};
class GetSearchCodePreviewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<GetSearchCodePreviewResponseBodyResult> result{};
  shared_ptr<bool> success{};

  GetSearchCodePreviewResponseBody() {}

  explicit GetSearchCodePreviewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        GetSearchCodePreviewResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<GetSearchCodePreviewResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetSearchCodePreviewResponseBody() = default;
};
class GetSearchCodePreviewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSearchCodePreviewResponseBody> body{};

  GetSearchCodePreviewResponse() {}

  explicit GetSearchCodePreviewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSearchCodePreviewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSearchCodePreviewResponseBody>(model1);
      }
    }
  }


  virtual ~GetSearchCodePreviewResponse() = default;
};
class GetSprintInfoResponseBodySprint : public Darabonba::Model {
public:
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<long> endDate{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> identifier{};
  shared_ptr<string> modifier{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> owners{};
  shared_ptr<string> scope{};
  shared_ptr<string> spaceIdentifier{};
  shared_ptr<long> startDate{};
  shared_ptr<string> status{};

  GetSprintInfoResponseBodySprint() {}

  explicit GetSprintInfoResponseBodySprint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creator) {
      res["creator"] = boost::any(*creator);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (endDate) {
      res["endDate"] = boost::any(*endDate);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (modifier) {
      res["modifier"] = boost::any(*modifier);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (owners) {
      res["owners"] = boost::any(*owners);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (spaceIdentifier) {
      res["spaceIdentifier"] = boost::any(*spaceIdentifier);
    }
    if (startDate) {
      res["startDate"] = boost::any(*startDate);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["creator"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("endDate") != m.end() && !m["endDate"].empty()) {
      endDate = make_shared<long>(boost::any_cast<long>(m["endDate"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("modifier") != m.end() && !m["modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["modifier"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("owners") != m.end() && !m["owners"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["owners"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["owners"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      owners = make_shared<vector<string>>(toVec1);
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["scope"]));
    }
    if (m.find("spaceIdentifier") != m.end() && !m["spaceIdentifier"].empty()) {
      spaceIdentifier = make_shared<string>(boost::any_cast<string>(m["spaceIdentifier"]));
    }
    if (m.find("startDate") != m.end() && !m["startDate"].empty()) {
      startDate = make_shared<long>(boost::any_cast<long>(m["startDate"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~GetSprintInfoResponseBodySprint() = default;
};
class GetSprintInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<GetSprintInfoResponseBodySprint> sprint{};
  shared_ptr<bool> success{};

  GetSprintInfoResponseBody() {}

  explicit GetSprintInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (sprint) {
      res["sprint"] = sprint ? boost::any(sprint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("sprint") != m.end() && !m["sprint"].empty()) {
      if (typeid(map<string, boost::any>) == m["sprint"].type()) {
        GetSprintInfoResponseBodySprint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["sprint"]));
        sprint = make_shared<GetSprintInfoResponseBodySprint>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetSprintInfoResponseBody() = default;
};
class GetSprintInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSprintInfoResponseBody> body{};

  GetSprintInfoResponse() {}

  explicit GetSprintInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSprintInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSprintInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetSprintInfoResponse() = default;
};
class GetTestResultListRequest : public Darabonba::Model {
public:
  shared_ptr<string> conditions{};
  shared_ptr<string> directoryIdentifier{};

  GetTestResultListRequest() {}

  explicit GetTestResultListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditions) {
      res["conditions"] = boost::any(*conditions);
    }
    if (directoryIdentifier) {
      res["directoryIdentifier"] = boost::any(*directoryIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("conditions") != m.end() && !m["conditions"].empty()) {
      conditions = make_shared<string>(boost::any_cast<string>(m["conditions"]));
    }
    if (m.find("directoryIdentifier") != m.end() && !m["directoryIdentifier"].empty()) {
      directoryIdentifier = make_shared<string>(boost::any_cast<string>(m["directoryIdentifier"]));
    }
  }


  virtual ~GetTestResultListRequest() = default;
};
class GetTestResultListResponseBodyTestResultAssignedTo : public Darabonba::Model {
public:
  shared_ptr<string> assignedToIdenttifier{};
  shared_ptr<string> name{};

  GetTestResultListResponseBodyTestResultAssignedTo() {}

  explicit GetTestResultListResponseBodyTestResultAssignedTo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignedToIdenttifier) {
      res["assignedToIdenttifier"] = boost::any(*assignedToIdenttifier);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignedToIdenttifier") != m.end() && !m["assignedToIdenttifier"].empty()) {
      assignedToIdenttifier = make_shared<string>(boost::any_cast<string>(m["assignedToIdenttifier"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~GetTestResultListResponseBodyTestResultAssignedTo() = default;
};
class GetTestResultListResponseBodyTestResultCustomFields : public Darabonba::Model {
public:
  shared_ptr<string> fieldClassName{};
  shared_ptr<string> fieldFormat{};
  shared_ptr<string> fieldIdentifier{};
  shared_ptr<string> value{};

  GetTestResultListResponseBodyTestResultCustomFields() {}

  explicit GetTestResultListResponseBodyTestResultCustomFields(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldClassName) {
      res["fieldClassName"] = boost::any(*fieldClassName);
    }
    if (fieldFormat) {
      res["fieldFormat"] = boost::any(*fieldFormat);
    }
    if (fieldIdentifier) {
      res["fieldIdentifier"] = boost::any(*fieldIdentifier);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fieldClassName") != m.end() && !m["fieldClassName"].empty()) {
      fieldClassName = make_shared<string>(boost::any_cast<string>(m["fieldClassName"]));
    }
    if (m.find("fieldFormat") != m.end() && !m["fieldFormat"].empty()) {
      fieldFormat = make_shared<string>(boost::any_cast<string>(m["fieldFormat"]));
    }
    if (m.find("fieldIdentifier") != m.end() && !m["fieldIdentifier"].empty()) {
      fieldIdentifier = make_shared<string>(boost::any_cast<string>(m["fieldIdentifier"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~GetTestResultListResponseBodyTestResultCustomFields() = default;
};
class GetTestResultListResponseBodyTestResultTestResultExecutor : public Darabonba::Model {
public:
  shared_ptr<string> executorIdentifier{};
  shared_ptr<string> name{};

  GetTestResultListResponseBodyTestResultTestResultExecutor() {}

  explicit GetTestResultListResponseBodyTestResultTestResultExecutor(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (executorIdentifier) {
      res["executorIdentifier"] = boost::any(*executorIdentifier);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("executorIdentifier") != m.end() && !m["executorIdentifier"].empty()) {
      executorIdentifier = make_shared<string>(boost::any_cast<string>(m["executorIdentifier"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~GetTestResultListResponseBodyTestResultTestResultExecutor() = default;
};
class GetTestResultListResponseBodyTestResult : public Darabonba::Model {
public:
  shared_ptr<GetTestResultListResponseBodyTestResultAssignedTo> assignedTo{};
  shared_ptr<long> bugCount{};
  shared_ptr<string> categoryIdentifier{};
  shared_ptr<vector<GetTestResultListResponseBodyTestResultCustomFields>> customFields{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> spaceIdentifier{};
  shared_ptr<string> subject{};
  shared_ptr<GetTestResultListResponseBodyTestResultTestResultExecutor> testResultExecutor{};
  shared_ptr<long> testResultGmtCreate{};
  shared_ptr<string> testResultIdentifier{};
  shared_ptr<string> testResultStatus{};
  shared_ptr<string> testcaseIdentifier{};

  GetTestResultListResponseBodyTestResult() {}

  explicit GetTestResultListResponseBodyTestResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignedTo) {
      res["assignedTo"] = assignedTo ? boost::any(assignedTo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bugCount) {
      res["bugCount"] = boost::any(*bugCount);
    }
    if (categoryIdentifier) {
      res["categoryIdentifier"] = boost::any(*categoryIdentifier);
    }
    if (customFields) {
      vector<boost::any> temp1;
      for(auto item1:*customFields){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["customFields"] = boost::any(temp1);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (spaceIdentifier) {
      res["spaceIdentifier"] = boost::any(*spaceIdentifier);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    if (testResultExecutor) {
      res["testResultExecutor"] = testResultExecutor ? boost::any(testResultExecutor->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (testResultGmtCreate) {
      res["testResultGmtCreate"] = boost::any(*testResultGmtCreate);
    }
    if (testResultIdentifier) {
      res["testResultIdentifier"] = boost::any(*testResultIdentifier);
    }
    if (testResultStatus) {
      res["testResultStatus"] = boost::any(*testResultStatus);
    }
    if (testcaseIdentifier) {
      res["testcaseIdentifier"] = boost::any(*testcaseIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignedTo") != m.end() && !m["assignedTo"].empty()) {
      if (typeid(map<string, boost::any>) == m["assignedTo"].type()) {
        GetTestResultListResponseBodyTestResultAssignedTo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["assignedTo"]));
        assignedTo = make_shared<GetTestResultListResponseBodyTestResultAssignedTo>(model1);
      }
    }
    if (m.find("bugCount") != m.end() && !m["bugCount"].empty()) {
      bugCount = make_shared<long>(boost::any_cast<long>(m["bugCount"]));
    }
    if (m.find("categoryIdentifier") != m.end() && !m["categoryIdentifier"].empty()) {
      categoryIdentifier = make_shared<string>(boost::any_cast<string>(m["categoryIdentifier"]));
    }
    if (m.find("customFields") != m.end() && !m["customFields"].empty()) {
      if (typeid(vector<boost::any>) == m["customFields"].type()) {
        vector<GetTestResultListResponseBodyTestResultCustomFields> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["customFields"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTestResultListResponseBodyTestResultCustomFields model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customFields = make_shared<vector<GetTestResultListResponseBodyTestResultCustomFields>>(expect1);
      }
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("spaceIdentifier") != m.end() && !m["spaceIdentifier"].empty()) {
      spaceIdentifier = make_shared<string>(boost::any_cast<string>(m["spaceIdentifier"]));
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
    if (m.find("testResultExecutor") != m.end() && !m["testResultExecutor"].empty()) {
      if (typeid(map<string, boost::any>) == m["testResultExecutor"].type()) {
        GetTestResultListResponseBodyTestResultTestResultExecutor model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["testResultExecutor"]));
        testResultExecutor = make_shared<GetTestResultListResponseBodyTestResultTestResultExecutor>(model1);
      }
    }
    if (m.find("testResultGmtCreate") != m.end() && !m["testResultGmtCreate"].empty()) {
      testResultGmtCreate = make_shared<long>(boost::any_cast<long>(m["testResultGmtCreate"]));
    }
    if (m.find("testResultIdentifier") != m.end() && !m["testResultIdentifier"].empty()) {
      testResultIdentifier = make_shared<string>(boost::any_cast<string>(m["testResultIdentifier"]));
    }
    if (m.find("testResultStatus") != m.end() && !m["testResultStatus"].empty()) {
      testResultStatus = make_shared<string>(boost::any_cast<string>(m["testResultStatus"]));
    }
    if (m.find("testcaseIdentifier") != m.end() && !m["testcaseIdentifier"].empty()) {
      testcaseIdentifier = make_shared<string>(boost::any_cast<string>(m["testcaseIdentifier"]));
    }
  }


  virtual ~GetTestResultListResponseBodyTestResult() = default;
};
class GetTestResultListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<vector<GetTestResultListResponseBodyTestResult>> testResult{};

  GetTestResultListResponseBody() {}

  explicit GetTestResultListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (testResult) {
      vector<boost::any> temp1;
      for(auto item1:*testResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["testResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("testResult") != m.end() && !m["testResult"].empty()) {
      if (typeid(vector<boost::any>) == m["testResult"].type()) {
        vector<GetTestResultListResponseBodyTestResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["testResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTestResultListResponseBodyTestResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        testResult = make_shared<vector<GetTestResultListResponseBodyTestResult>>(expect1);
      }
    }
  }


  virtual ~GetTestResultListResponseBody() = default;
};
class GetTestResultListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTestResultListResponseBody> body{};

  GetTestResultListResponse() {}

  explicit GetTestResultListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTestResultListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTestResultListResponseBody>(model1);
      }
    }
  }


  virtual ~GetTestResultListResponse() = default;
};
class GetTestcaseListRequest : public Darabonba::Model {
public:
  shared_ptr<string> conditions{};
  shared_ptr<string> directoryIdentifier{};
  shared_ptr<string> maxResult{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> spaceIdentifier{};

  GetTestcaseListRequest() {}

  explicit GetTestcaseListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditions) {
      res["conditions"] = boost::any(*conditions);
    }
    if (directoryIdentifier) {
      res["directoryIdentifier"] = boost::any(*directoryIdentifier);
    }
    if (maxResult) {
      res["maxResult"] = boost::any(*maxResult);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (spaceIdentifier) {
      res["spaceIdentifier"] = boost::any(*spaceIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("conditions") != m.end() && !m["conditions"].empty()) {
      conditions = make_shared<string>(boost::any_cast<string>(m["conditions"]));
    }
    if (m.find("directoryIdentifier") != m.end() && !m["directoryIdentifier"].empty()) {
      directoryIdentifier = make_shared<string>(boost::any_cast<string>(m["directoryIdentifier"]));
    }
    if (m.find("maxResult") != m.end() && !m["maxResult"].empty()) {
      maxResult = make_shared<string>(boost::any_cast<string>(m["maxResult"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("spaceIdentifier") != m.end() && !m["spaceIdentifier"].empty()) {
      spaceIdentifier = make_shared<string>(boost::any_cast<string>(m["spaceIdentifier"]));
    }
  }


  virtual ~GetTestcaseListRequest() = default;
};
class GetTestcaseListResponseBodyTestcaseAssignedTo : public Darabonba::Model {
public:
  shared_ptr<string> assignedToIdenttifier{};
  shared_ptr<string> name{};

  GetTestcaseListResponseBodyTestcaseAssignedTo() {}

  explicit GetTestcaseListResponseBodyTestcaseAssignedTo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignedToIdenttifier) {
      res["assignedToIdenttifier"] = boost::any(*assignedToIdenttifier);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignedToIdenttifier") != m.end() && !m["assignedToIdenttifier"].empty()) {
      assignedToIdenttifier = make_shared<string>(boost::any_cast<string>(m["assignedToIdenttifier"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~GetTestcaseListResponseBodyTestcaseAssignedTo() = default;
};
class GetTestcaseListResponseBodyTestcaseCustomFields : public Darabonba::Model {
public:
  shared_ptr<string> fieldClassName{};
  shared_ptr<string> fieldFormat{};
  shared_ptr<string> fieldIdentifier{};
  shared_ptr<string> value{};

  GetTestcaseListResponseBodyTestcaseCustomFields() {}

  explicit GetTestcaseListResponseBodyTestcaseCustomFields(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldClassName) {
      res["fieldClassName"] = boost::any(*fieldClassName);
    }
    if (fieldFormat) {
      res["fieldFormat"] = boost::any(*fieldFormat);
    }
    if (fieldIdentifier) {
      res["fieldIdentifier"] = boost::any(*fieldIdentifier);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fieldClassName") != m.end() && !m["fieldClassName"].empty()) {
      fieldClassName = make_shared<string>(boost::any_cast<string>(m["fieldClassName"]));
    }
    if (m.find("fieldFormat") != m.end() && !m["fieldFormat"].empty()) {
      fieldFormat = make_shared<string>(boost::any_cast<string>(m["fieldFormat"]));
    }
    if (m.find("fieldIdentifier") != m.end() && !m["fieldIdentifier"].empty()) {
      fieldIdentifier = make_shared<string>(boost::any_cast<string>(m["fieldIdentifier"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~GetTestcaseListResponseBodyTestcaseCustomFields() = default;
};
class GetTestcaseListResponseBodyTestcaseSpace : public Darabonba::Model {
public:
  shared_ptr<string> spaceIdentifier{};
  shared_ptr<string> type{};

  GetTestcaseListResponseBodyTestcaseSpace() {}

  explicit GetTestcaseListResponseBodyTestcaseSpace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (spaceIdentifier) {
      res["spaceIdentifier"] = boost::any(*spaceIdentifier);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("spaceIdentifier") != m.end() && !m["spaceIdentifier"].empty()) {
      spaceIdentifier = make_shared<string>(boost::any_cast<string>(m["spaceIdentifier"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~GetTestcaseListResponseBodyTestcaseSpace() = default;
};
class GetTestcaseListResponseBodyTestcaseTags : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> tagIdentifier{};

  GetTestcaseListResponseBodyTestcaseTags() {}

  explicit GetTestcaseListResponseBodyTestcaseTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (tagIdentifier) {
      res["tagIdentifier"] = boost::any(*tagIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("tagIdentifier") != m.end() && !m["tagIdentifier"].empty()) {
      tagIdentifier = make_shared<string>(boost::any_cast<string>(m["tagIdentifier"]));
    }
  }


  virtual ~GetTestcaseListResponseBodyTestcaseTags() = default;
};
class GetTestcaseListResponseBodyTestcase : public Darabonba::Model {
public:
  shared_ptr<GetTestcaseListResponseBodyTestcaseAssignedTo> assignedTo{};
  shared_ptr<string> categoryIdentifier{};
  shared_ptr<vector<GetTestcaseListResponseBodyTestcaseCustomFields>> customFields{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> identifier{};
  shared_ptr<GetTestcaseListResponseBodyTestcaseSpace> space{};
  shared_ptr<string> subject{};
  shared_ptr<vector<GetTestcaseListResponseBodyTestcaseTags>> tags{};

  GetTestcaseListResponseBodyTestcase() {}

  explicit GetTestcaseListResponseBodyTestcase(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignedTo) {
      res["assignedTo"] = assignedTo ? boost::any(assignedTo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (categoryIdentifier) {
      res["categoryIdentifier"] = boost::any(*categoryIdentifier);
    }
    if (customFields) {
      vector<boost::any> temp1;
      for(auto item1:*customFields){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["customFields"] = boost::any(temp1);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (space) {
      res["space"] = space ? boost::any(space->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignedTo") != m.end() && !m["assignedTo"].empty()) {
      if (typeid(map<string, boost::any>) == m["assignedTo"].type()) {
        GetTestcaseListResponseBodyTestcaseAssignedTo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["assignedTo"]));
        assignedTo = make_shared<GetTestcaseListResponseBodyTestcaseAssignedTo>(model1);
      }
    }
    if (m.find("categoryIdentifier") != m.end() && !m["categoryIdentifier"].empty()) {
      categoryIdentifier = make_shared<string>(boost::any_cast<string>(m["categoryIdentifier"]));
    }
    if (m.find("customFields") != m.end() && !m["customFields"].empty()) {
      if (typeid(vector<boost::any>) == m["customFields"].type()) {
        vector<GetTestcaseListResponseBodyTestcaseCustomFields> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["customFields"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTestcaseListResponseBodyTestcaseCustomFields model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customFields = make_shared<vector<GetTestcaseListResponseBodyTestcaseCustomFields>>(expect1);
      }
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("space") != m.end() && !m["space"].empty()) {
      if (typeid(map<string, boost::any>) == m["space"].type()) {
        GetTestcaseListResponseBodyTestcaseSpace model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["space"]));
        space = make_shared<GetTestcaseListResponseBodyTestcaseSpace>(model1);
      }
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<GetTestcaseListResponseBodyTestcaseTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTestcaseListResponseBodyTestcaseTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetTestcaseListResponseBodyTestcaseTags>>(expect1);
      }
    }
  }


  virtual ~GetTestcaseListResponseBodyTestcase() = default;
};
class GetTestcaseListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<vector<GetTestcaseListResponseBodyTestcase>> testcase{};
  shared_ptr<long> totalCount{};

  GetTestcaseListResponseBody() {}

  explicit GetTestcaseListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (testcase) {
      vector<boost::any> temp1;
      for(auto item1:*testcase){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["testcase"] = boost::any(temp1);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("testcase") != m.end() && !m["testcase"].empty()) {
      if (typeid(vector<boost::any>) == m["testcase"].type()) {
        vector<GetTestcaseListResponseBodyTestcase> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["testcase"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTestcaseListResponseBodyTestcase model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        testcase = make_shared<vector<GetTestcaseListResponseBodyTestcase>>(expect1);
      }
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~GetTestcaseListResponseBody() = default;
};
class GetTestcaseListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTestcaseListResponseBody> body{};

  GetTestcaseListResponse() {}

  explicit GetTestcaseListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTestcaseListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTestcaseListResponseBody>(model1);
      }
    }
  }


  virtual ~GetTestcaseListResponse() = default;
};
class GetUserInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};

  GetUserInfoRequest() {}

  explicit GetUserInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~GetUserInfoRequest() = default;
};
class GetUserInfoResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> username{};

  GetUserInfoResponseBodyResult() {}

  explicit GetUserInfoResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~GetUserInfoResponseBodyResult() = default;
};
class GetUserInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<GetUserInfoResponseBodyResult> result{};
  shared_ptr<bool> success{};

  GetUserInfoResponseBody() {}

  explicit GetUserInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        GetUserInfoResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<GetUserInfoResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetUserInfoResponseBody() = default;
};
class GetUserInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUserInfoResponseBody> body{};

  GetUserInfoResponse() {}

  explicit GetUserInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUserInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUserInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetUserInfoResponse() = default;
};
class GetVMDeployOrderResponseBodyDeployOrderActions : public Darabonba::Model {
public:
  shared_ptr<bool> disable{};
  shared_ptr<boost::any> params{};
  shared_ptr<string> type{};

  GetVMDeployOrderResponseBodyDeployOrderActions() {}

  explicit GetVMDeployOrderResponseBodyDeployOrderActions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disable) {
      res["disable"] = boost::any(*disable);
    }
    if (params) {
      res["params"] = boost::any(*params);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("disable") != m.end() && !m["disable"].empty()) {
      disable = make_shared<bool>(boost::any_cast<bool>(m["disable"]));
    }
    if (m.find("params") != m.end() && !m["params"].empty()) {
      params = make_shared<boost::any>(boost::any_cast<boost::any>(m["params"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~GetVMDeployOrderResponseBodyDeployOrderActions() = default;
};
class GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachinesActions : public Darabonba::Model {
public:
  shared_ptr<bool> disable{};
  shared_ptr<boost::any> params{};
  shared_ptr<string> type{};

  GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachinesActions() {}

  explicit GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachinesActions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disable) {
      res["disable"] = boost::any(*disable);
    }
    if (params) {
      res["params"] = boost::any(*params);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("disable") != m.end() && !m["disable"].empty()) {
      disable = make_shared<bool>(boost::any_cast<bool>(m["disable"]));
    }
    if (m.find("params") != m.end() && !m["params"].empty()) {
      params = make_shared<boost::any>(boost::any_cast<boost::any>(m["params"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachinesActions() = default;
};
class GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachines : public Darabonba::Model {
public:
  shared_ptr<vector<GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachinesActions>> actions{};
  shared_ptr<long> batchNum{};
  shared_ptr<string> clientStatus{};
  shared_ptr<long> createTime{};
  shared_ptr<string> ip{};
  shared_ptr<string> machineSn{};
  shared_ptr<string> status{};
  shared_ptr<long> updateTime{};

  GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachines() {}

  explicit GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actions) {
      vector<boost::any> temp1;
      for(auto item1:*actions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["actions"] = boost::any(temp1);
    }
    if (batchNum) {
      res["batchNum"] = boost::any(*batchNum);
    }
    if (clientStatus) {
      res["clientStatus"] = boost::any(*clientStatus);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (ip) {
      res["ip"] = boost::any(*ip);
    }
    if (machineSn) {
      res["machineSn"] = boost::any(*machineSn);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("actions") != m.end() && !m["actions"].empty()) {
      if (typeid(vector<boost::any>) == m["actions"].type()) {
        vector<GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachinesActions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["actions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachinesActions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        actions = make_shared<vector<GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachinesActions>>(expect1);
      }
    }
    if (m.find("batchNum") != m.end() && !m["batchNum"].empty()) {
      batchNum = make_shared<long>(boost::any_cast<long>(m["batchNum"]));
    }
    if (m.find("clientStatus") != m.end() && !m["clientStatus"].empty()) {
      clientStatus = make_shared<string>(boost::any_cast<string>(m["clientStatus"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["createTime"]));
    }
    if (m.find("ip") != m.end() && !m["ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["ip"]));
    }
    if (m.find("machineSn") != m.end() && !m["machineSn"].empty()) {
      machineSn = make_shared<string>(boost::any_cast<string>(m["machineSn"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["updateTime"]));
    }
  }


  virtual ~GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachines() = default;
};
class GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfo : public Darabonba::Model {
public:
  shared_ptr<long> batchNum{};
  shared_ptr<vector<GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachines>> deployMachines{};
  shared_ptr<long> hostGroupId{};

  GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfo() {}

  explicit GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchNum) {
      res["batchNum"] = boost::any(*batchNum);
    }
    if (deployMachines) {
      vector<boost::any> temp1;
      for(auto item1:*deployMachines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["deployMachines"] = boost::any(temp1);
    }
    if (hostGroupId) {
      res["hostGroupId"] = boost::any(*hostGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("batchNum") != m.end() && !m["batchNum"].empty()) {
      batchNum = make_shared<long>(boost::any_cast<long>(m["batchNum"]));
    }
    if (m.find("deployMachines") != m.end() && !m["deployMachines"].empty()) {
      if (typeid(vector<boost::any>) == m["deployMachines"].type()) {
        vector<GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["deployMachines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deployMachines = make_shared<vector<GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachines>>(expect1);
      }
    }
    if (m.find("hostGroupId") != m.end() && !m["hostGroupId"].empty()) {
      hostGroupId = make_shared<long>(boost::any_cast<long>(m["hostGroupId"]));
    }
  }


  virtual ~GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfo() = default;
};
class GetVMDeployOrderResponseBodyDeployOrder : public Darabonba::Model {
public:
  shared_ptr<vector<GetVMDeployOrderResponseBodyDeployOrderActions>> actions{};
  shared_ptr<long> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<long> currentBatch{};
  shared_ptr<GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfo> deployMachineInfo{};
  shared_ptr<string> deployOrderId{};
  shared_ptr<string> exceptionCode{};
  shared_ptr<string> status{};
  shared_ptr<long> totalBatch{};
  shared_ptr<long> updateTime{};

  GetVMDeployOrderResponseBodyDeployOrder() {}

  explicit GetVMDeployOrderResponseBodyDeployOrder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actions) {
      vector<boost::any> temp1;
      for(auto item1:*actions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["actions"] = boost::any(temp1);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["creator"] = boost::any(*creator);
    }
    if (currentBatch) {
      res["currentBatch"] = boost::any(*currentBatch);
    }
    if (deployMachineInfo) {
      res["deployMachineInfo"] = deployMachineInfo ? boost::any(deployMachineInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deployOrderId) {
      res["deployOrderId"] = boost::any(*deployOrderId);
    }
    if (exceptionCode) {
      res["exceptionCode"] = boost::any(*exceptionCode);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (totalBatch) {
      res["totalBatch"] = boost::any(*totalBatch);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("actions") != m.end() && !m["actions"].empty()) {
      if (typeid(vector<boost::any>) == m["actions"].type()) {
        vector<GetVMDeployOrderResponseBodyDeployOrderActions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["actions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetVMDeployOrderResponseBodyDeployOrderActions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        actions = make_shared<vector<GetVMDeployOrderResponseBodyDeployOrderActions>>(expect1);
      }
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["createTime"]));
    }
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["creator"]));
    }
    if (m.find("currentBatch") != m.end() && !m["currentBatch"].empty()) {
      currentBatch = make_shared<long>(boost::any_cast<long>(m["currentBatch"]));
    }
    if (m.find("deployMachineInfo") != m.end() && !m["deployMachineInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["deployMachineInfo"].type()) {
        GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["deployMachineInfo"]));
        deployMachineInfo = make_shared<GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfo>(model1);
      }
    }
    if (m.find("deployOrderId") != m.end() && !m["deployOrderId"].empty()) {
      deployOrderId = make_shared<string>(boost::any_cast<string>(m["deployOrderId"]));
    }
    if (m.find("exceptionCode") != m.end() && !m["exceptionCode"].empty()) {
      exceptionCode = make_shared<string>(boost::any_cast<string>(m["exceptionCode"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("totalBatch") != m.end() && !m["totalBatch"].empty()) {
      totalBatch = make_shared<long>(boost::any_cast<long>(m["totalBatch"]));
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["updateTime"]));
    }
  }


  virtual ~GetVMDeployOrderResponseBodyDeployOrder() = default;
};
class GetVMDeployOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetVMDeployOrderResponseBodyDeployOrder> deployOrder{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetVMDeployOrderResponseBody() {}

  explicit GetVMDeployOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployOrder) {
      res["deployOrder"] = deployOrder ? boost::any(deployOrder->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("deployOrder") != m.end() && !m["deployOrder"].empty()) {
      if (typeid(map<string, boost::any>) == m["deployOrder"].type()) {
        GetVMDeployOrderResponseBodyDeployOrder model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["deployOrder"]));
        deployOrder = make_shared<GetVMDeployOrderResponseBodyDeployOrder>(model1);
      }
    }
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetVMDeployOrderResponseBody() = default;
};
class GetVMDeployOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetVMDeployOrderResponseBody> body{};

  GetVMDeployOrderResponse() {}

  explicit GetVMDeployOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVMDeployOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVMDeployOrderResponseBody>(model1);
      }
    }
  }


  virtual ~GetVMDeployOrderResponse() = default;
};
class GetVariableGroupResponseBodyVariableGroupRelatedPipelines : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  GetVariableGroupResponseBodyVariableGroupRelatedPipelines() {}

  explicit GetVariableGroupResponseBodyVariableGroupRelatedPipelines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~GetVariableGroupResponseBodyVariableGroupRelatedPipelines() = default;
};
class GetVariableGroupResponseBodyVariableGroupVariables : public Darabonba::Model {
public:
  shared_ptr<bool> isEncrypted{};
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  GetVariableGroupResponseBodyVariableGroupVariables() {}

  explicit GetVariableGroupResponseBodyVariableGroupVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isEncrypted) {
      res["isEncrypted"] = boost::any(*isEncrypted);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("isEncrypted") != m.end() && !m["isEncrypted"].empty()) {
      isEncrypted = make_shared<bool>(boost::any_cast<bool>(m["isEncrypted"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~GetVariableGroupResponseBodyVariableGroupVariables() = default;
};
class GetVariableGroupResponseBodyVariableGroup : public Darabonba::Model {
public:
  shared_ptr<string> ccreatorAccountId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> modifierAccountId{};
  shared_ptr<string> name{};
  shared_ptr<vector<GetVariableGroupResponseBodyVariableGroupRelatedPipelines>> relatedPipelines{};
  shared_ptr<long> updateTime{};
  shared_ptr<vector<GetVariableGroupResponseBodyVariableGroupVariables>> variables{};

  GetVariableGroupResponseBodyVariableGroup() {}

  explicit GetVariableGroupResponseBodyVariableGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ccreatorAccountId) {
      res["ccreatorAccountId"] = boost::any(*ccreatorAccountId);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (modifierAccountId) {
      res["modifierAccountId"] = boost::any(*modifierAccountId);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (relatedPipelines) {
      vector<boost::any> temp1;
      for(auto item1:*relatedPipelines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["relatedPipelines"] = boost::any(temp1);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ccreatorAccountId") != m.end() && !m["ccreatorAccountId"].empty()) {
      ccreatorAccountId = make_shared<string>(boost::any_cast<string>(m["ccreatorAccountId"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["createTime"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("modifierAccountId") != m.end() && !m["modifierAccountId"].empty()) {
      modifierAccountId = make_shared<string>(boost::any_cast<string>(m["modifierAccountId"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("relatedPipelines") != m.end() && !m["relatedPipelines"].empty()) {
      if (typeid(vector<boost::any>) == m["relatedPipelines"].type()) {
        vector<GetVariableGroupResponseBodyVariableGroupRelatedPipelines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["relatedPipelines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetVariableGroupResponseBodyVariableGroupRelatedPipelines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        relatedPipelines = make_shared<vector<GetVariableGroupResponseBodyVariableGroupRelatedPipelines>>(expect1);
      }
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["updateTime"]));
    }
    if (m.find("variables") != m.end() && !m["variables"].empty()) {
      if (typeid(vector<boost::any>) == m["variables"].type()) {
        vector<GetVariableGroupResponseBodyVariableGroupVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetVariableGroupResponseBodyVariableGroupVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<GetVariableGroupResponseBodyVariableGroupVariables>>(expect1);
      }
    }
  }


  virtual ~GetVariableGroupResponseBodyVariableGroup() = default;
};
class GetVariableGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<GetVariableGroupResponseBodyVariableGroup> variableGroup{};

  GetVariableGroupResponseBody() {}

  explicit GetVariableGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (variableGroup) {
      res["variableGroup"] = variableGroup ? boost::any(variableGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("variableGroup") != m.end() && !m["variableGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["variableGroup"].type()) {
        GetVariableGroupResponseBodyVariableGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["variableGroup"]));
        variableGroup = make_shared<GetVariableGroupResponseBodyVariableGroup>(model1);
      }
    }
  }


  virtual ~GetVariableGroupResponseBody() = default;
};
class GetVariableGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetVariableGroupResponseBody> body{};

  GetVariableGroupResponse() {}

  explicit GetVariableGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVariableGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVariableGroupResponseBody>(model1);
      }
    }
  }


  virtual ~GetVariableGroupResponse() = default;
};
class GetWorkItemActivityResponseBodyActivitiesNewValue : public Darabonba::Model {
public:
  shared_ptr<string> displayValue{};
  shared_ptr<string> plainValue{};
  shared_ptr<string> resourceType{};

  GetWorkItemActivityResponseBodyActivitiesNewValue() {}

  explicit GetWorkItemActivityResponseBodyActivitiesNewValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayValue) {
      res["displayValue"] = boost::any(*displayValue);
    }
    if (plainValue) {
      res["plainValue"] = boost::any(*plainValue);
    }
    if (resourceType) {
      res["resourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("displayValue") != m.end() && !m["displayValue"].empty()) {
      displayValue = make_shared<string>(boost::any_cast<string>(m["displayValue"]));
    }
    if (m.find("plainValue") != m.end() && !m["plainValue"].empty()) {
      plainValue = make_shared<string>(boost::any_cast<string>(m["plainValue"]));
    }
    if (m.find("resourceType") != m.end() && !m["resourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["resourceType"]));
    }
  }


  virtual ~GetWorkItemActivityResponseBodyActivitiesNewValue() = default;
};
class GetWorkItemActivityResponseBodyActivitiesOldValue : public Darabonba::Model {
public:
  shared_ptr<string> displayValue{};
  shared_ptr<string> plainValue{};
  shared_ptr<string> resourceType{};

  GetWorkItemActivityResponseBodyActivitiesOldValue() {}

  explicit GetWorkItemActivityResponseBodyActivitiesOldValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayValue) {
      res["displayValue"] = boost::any(*displayValue);
    }
    if (plainValue) {
      res["plainValue"] = boost::any(*plainValue);
    }
    if (resourceType) {
      res["resourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("displayValue") != m.end() && !m["displayValue"].empty()) {
      displayValue = make_shared<string>(boost::any_cast<string>(m["displayValue"]));
    }
    if (m.find("plainValue") != m.end() && !m["plainValue"].empty()) {
      plainValue = make_shared<string>(boost::any_cast<string>(m["plainValue"]));
    }
    if (m.find("resourceType") != m.end() && !m["resourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["resourceType"]));
    }
  }


  virtual ~GetWorkItemActivityResponseBodyActivitiesOldValue() = default;
};
class GetWorkItemActivityResponseBodyActivitiesProperty : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> propertyIdentifier{};
  shared_ptr<string> propertyName{};
  shared_ptr<string> propertyType{};

  GetWorkItemActivityResponseBodyActivitiesProperty() {}

  explicit GetWorkItemActivityResponseBodyActivitiesProperty(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["displayName"] = boost::any(*displayName);
    }
    if (propertyIdentifier) {
      res["propertyIdentifier"] = boost::any(*propertyIdentifier);
    }
    if (propertyName) {
      res["propertyName"] = boost::any(*propertyName);
    }
    if (propertyType) {
      res["propertyType"] = boost::any(*propertyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("displayName") != m.end() && !m["displayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["displayName"]));
    }
    if (m.find("propertyIdentifier") != m.end() && !m["propertyIdentifier"].empty()) {
      propertyIdentifier = make_shared<string>(boost::any_cast<string>(m["propertyIdentifier"]));
    }
    if (m.find("propertyName") != m.end() && !m["propertyName"].empty()) {
      propertyName = make_shared<string>(boost::any_cast<string>(m["propertyName"]));
    }
    if (m.find("propertyType") != m.end() && !m["propertyType"].empty()) {
      propertyType = make_shared<string>(boost::any_cast<string>(m["propertyType"]));
    }
  }


  virtual ~GetWorkItemActivityResponseBodyActivitiesProperty() = default;
};
class GetWorkItemActivityResponseBodyActivities : public Darabonba::Model {
public:
  shared_ptr<string> actionType{};
  shared_ptr<long> eventId{};
  shared_ptr<long> eventTime{};
  shared_ptr<string> eventType{};
  shared_ptr<vector<GetWorkItemActivityResponseBodyActivitiesNewValue>> newValue{};
  shared_ptr<vector<GetWorkItemActivityResponseBodyActivitiesOldValue>> oldValue{};
  shared_ptr<string> operator_{};
  shared_ptr<long> parentEventId{};
  shared_ptr<GetWorkItemActivityResponseBodyActivitiesProperty> property{};
  shared_ptr<string> resourceIdentifier{};

  GetWorkItemActivityResponseBodyActivities() {}

  explicit GetWorkItemActivityResponseBodyActivities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionType) {
      res["actionType"] = boost::any(*actionType);
    }
    if (eventId) {
      res["eventId"] = boost::any(*eventId);
    }
    if (eventTime) {
      res["eventTime"] = boost::any(*eventTime);
    }
    if (eventType) {
      res["eventType"] = boost::any(*eventType);
    }
    if (newValue) {
      vector<boost::any> temp1;
      for(auto item1:*newValue){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["newValue"] = boost::any(temp1);
    }
    if (oldValue) {
      vector<boost::any> temp1;
      for(auto item1:*oldValue){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["oldValue"] = boost::any(temp1);
    }
    if (operator_) {
      res["operator"] = boost::any(*operator_);
    }
    if (parentEventId) {
      res["parentEventId"] = boost::any(*parentEventId);
    }
    if (property) {
      res["property"] = property ? boost::any(property->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resourceIdentifier) {
      res["resourceIdentifier"] = boost::any(*resourceIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("actionType") != m.end() && !m["actionType"].empty()) {
      actionType = make_shared<string>(boost::any_cast<string>(m["actionType"]));
    }
    if (m.find("eventId") != m.end() && !m["eventId"].empty()) {
      eventId = make_shared<long>(boost::any_cast<long>(m["eventId"]));
    }
    if (m.find("eventTime") != m.end() && !m["eventTime"].empty()) {
      eventTime = make_shared<long>(boost::any_cast<long>(m["eventTime"]));
    }
    if (m.find("eventType") != m.end() && !m["eventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["eventType"]));
    }
    if (m.find("newValue") != m.end() && !m["newValue"].empty()) {
      if (typeid(vector<boost::any>) == m["newValue"].type()) {
        vector<GetWorkItemActivityResponseBodyActivitiesNewValue> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["newValue"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetWorkItemActivityResponseBodyActivitiesNewValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        newValue = make_shared<vector<GetWorkItemActivityResponseBodyActivitiesNewValue>>(expect1);
      }
    }
    if (m.find("oldValue") != m.end() && !m["oldValue"].empty()) {
      if (typeid(vector<boost::any>) == m["oldValue"].type()) {
        vector<GetWorkItemActivityResponseBodyActivitiesOldValue> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["oldValue"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetWorkItemActivityResponseBodyActivitiesOldValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        oldValue = make_shared<vector<GetWorkItemActivityResponseBodyActivitiesOldValue>>(expect1);
      }
    }
    if (m.find("operator") != m.end() && !m["operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["operator"]));
    }
    if (m.find("parentEventId") != m.end() && !m["parentEventId"].empty()) {
      parentEventId = make_shared<long>(boost::any_cast<long>(m["parentEventId"]));
    }
    if (m.find("property") != m.end() && !m["property"].empty()) {
      if (typeid(map<string, boost::any>) == m["property"].type()) {
        GetWorkItemActivityResponseBodyActivitiesProperty model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["property"]));
        property = make_shared<GetWorkItemActivityResponseBodyActivitiesProperty>(model1);
      }
    }
    if (m.find("resourceIdentifier") != m.end() && !m["resourceIdentifier"].empty()) {
      resourceIdentifier = make_shared<string>(boost::any_cast<string>(m["resourceIdentifier"]));
    }
  }


  virtual ~GetWorkItemActivityResponseBodyActivities() = default;
};
class GetWorkItemActivityResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetWorkItemActivityResponseBodyActivities>> activities{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetWorkItemActivityResponseBody() {}

  explicit GetWorkItemActivityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activities) {
      vector<boost::any> temp1;
      for(auto item1:*activities){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["activities"] = boost::any(temp1);
    }
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("activities") != m.end() && !m["activities"].empty()) {
      if (typeid(vector<boost::any>) == m["activities"].type()) {
        vector<GetWorkItemActivityResponseBodyActivities> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["activities"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetWorkItemActivityResponseBodyActivities model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        activities = make_shared<vector<GetWorkItemActivityResponseBodyActivities>>(expect1);
      }
    }
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetWorkItemActivityResponseBody() = default;
};
class GetWorkItemActivityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWorkItemActivityResponseBody> body{};

  GetWorkItemActivityResponse() {}

  explicit GetWorkItemActivityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWorkItemActivityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWorkItemActivityResponseBody>(model1);
      }
    }
  }


  virtual ~GetWorkItemActivityResponse() = default;
};
class GetWorkItemInfoResponseBodyWorkitemCustomFieldsValueList : public Darabonba::Model {
public:
  shared_ptr<string> displayValue{};
  shared_ptr<string> identifier{};
  shared_ptr<long> level{};
  shared_ptr<string> value{};
  shared_ptr<string> valueEn{};

  GetWorkItemInfoResponseBodyWorkitemCustomFieldsValueList() {}

  explicit GetWorkItemInfoResponseBodyWorkitemCustomFieldsValueList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayValue) {
      res["displayValue"] = boost::any(*displayValue);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (level) {
      res["level"] = boost::any(*level);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    if (valueEn) {
      res["valueEn"] = boost::any(*valueEn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("displayValue") != m.end() && !m["displayValue"].empty()) {
      displayValue = make_shared<string>(boost::any_cast<string>(m["displayValue"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("level") != m.end() && !m["level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["level"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
    if (m.find("valueEn") != m.end() && !m["valueEn"].empty()) {
      valueEn = make_shared<string>(boost::any_cast<string>(m["valueEn"]));
    }
  }


  virtual ~GetWorkItemInfoResponseBodyWorkitemCustomFieldsValueList() = default;
};
class GetWorkItemInfoResponseBodyWorkitemCustomFields : public Darabonba::Model {
public:
  shared_ptr<string> fieldClassName{};
  shared_ptr<string> fieldFormat{};
  shared_ptr<string> fieldIdentifier{};
  shared_ptr<long> level{};
  shared_ptr<string> objectValue{};
  shared_ptr<long> position{};
  shared_ptr<string> value{};
  shared_ptr<vector<GetWorkItemInfoResponseBodyWorkitemCustomFieldsValueList>> valueList{};
  shared_ptr<string> workitemIdentifier{};

  GetWorkItemInfoResponseBodyWorkitemCustomFields() {}

  explicit GetWorkItemInfoResponseBodyWorkitemCustomFields(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldClassName) {
      res["fieldClassName"] = boost::any(*fieldClassName);
    }
    if (fieldFormat) {
      res["fieldFormat"] = boost::any(*fieldFormat);
    }
    if (fieldIdentifier) {
      res["fieldIdentifier"] = boost::any(*fieldIdentifier);
    }
    if (level) {
      res["level"] = boost::any(*level);
    }
    if (objectValue) {
      res["objectValue"] = boost::any(*objectValue);
    }
    if (position) {
      res["position"] = boost::any(*position);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    if (valueList) {
      vector<boost::any> temp1;
      for(auto item1:*valueList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["valueList"] = boost::any(temp1);
    }
    if (workitemIdentifier) {
      res["workitemIdentifier"] = boost::any(*workitemIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fieldClassName") != m.end() && !m["fieldClassName"].empty()) {
      fieldClassName = make_shared<string>(boost::any_cast<string>(m["fieldClassName"]));
    }
    if (m.find("fieldFormat") != m.end() && !m["fieldFormat"].empty()) {
      fieldFormat = make_shared<string>(boost::any_cast<string>(m["fieldFormat"]));
    }
    if (m.find("fieldIdentifier") != m.end() && !m["fieldIdentifier"].empty()) {
      fieldIdentifier = make_shared<string>(boost::any_cast<string>(m["fieldIdentifier"]));
    }
    if (m.find("level") != m.end() && !m["level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["level"]));
    }
    if (m.find("objectValue") != m.end() && !m["objectValue"].empty()) {
      objectValue = make_shared<string>(boost::any_cast<string>(m["objectValue"]));
    }
    if (m.find("position") != m.end() && !m["position"].empty()) {
      position = make_shared<long>(boost::any_cast<long>(m["position"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
    if (m.find("valueList") != m.end() && !m["valueList"].empty()) {
      if (typeid(vector<boost::any>) == m["valueList"].type()) {
        vector<GetWorkItemInfoResponseBodyWorkitemCustomFieldsValueList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["valueList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetWorkItemInfoResponseBodyWorkitemCustomFieldsValueList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        valueList = make_shared<vector<GetWorkItemInfoResponseBodyWorkitemCustomFieldsValueList>>(expect1);
      }
    }
    if (m.find("workitemIdentifier") != m.end() && !m["workitemIdentifier"].empty()) {
      workitemIdentifier = make_shared<string>(boost::any_cast<string>(m["workitemIdentifier"]));
    }
  }


  virtual ~GetWorkItemInfoResponseBodyWorkitemCustomFields() = default;
};
class GetWorkItemInfoResponseBodyWorkitemTagDetails : public Darabonba::Model {
public:
  shared_ptr<string> color{};
  shared_ptr<string> identifier{};
  shared_ptr<string> name{};

  GetWorkItemInfoResponseBodyWorkitemTagDetails() {}

  explicit GetWorkItemInfoResponseBodyWorkitemTagDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (color) {
      res["color"] = boost::any(*color);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("color") != m.end() && !m["color"].empty()) {
      color = make_shared<string>(boost::any_cast<string>(m["color"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~GetWorkItemInfoResponseBodyWorkitemTagDetails() = default;
};
class GetWorkItemInfoResponseBodyWorkitem : public Darabonba::Model {
public:
  shared_ptr<string> assignedTo{};
  shared_ptr<string> categoryIdentifier{};
  shared_ptr<string> creator{};
  shared_ptr<vector<GetWorkItemInfoResponseBodyWorkitemCustomFields>> customFields{};
  shared_ptr<string> document{};
  shared_ptr<string> documentFormat{};
  shared_ptr<long> finishTime{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> identifier{};
  shared_ptr<string> logicalStatus{};
  shared_ptr<string> modifier{};
  shared_ptr<string> parentIdentifier{};
  shared_ptr<vector<string>> participant{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> spaceIdentifier{};
  shared_ptr<string> spaceName{};
  shared_ptr<string> spaceType{};
  shared_ptr<vector<string>> sprint{};
  shared_ptr<string> status{};
  shared_ptr<string> statusIdentifier{};
  shared_ptr<string> statusStageIdentifier{};
  shared_ptr<string> subject{};
  shared_ptr<vector<string>> tag{};
  shared_ptr<vector<GetWorkItemInfoResponseBodyWorkitemTagDetails>> tagDetails{};
  shared_ptr<vector<string>> tracker{};
  shared_ptr<long> updateStatusAt{};
  shared_ptr<vector<string>> verifier{};
  shared_ptr<string> workitemTypeIdentifier{};

  GetWorkItemInfoResponseBodyWorkitem() {}

  explicit GetWorkItemInfoResponseBodyWorkitem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignedTo) {
      res["assignedTo"] = boost::any(*assignedTo);
    }
    if (categoryIdentifier) {
      res["categoryIdentifier"] = boost::any(*categoryIdentifier);
    }
    if (creator) {
      res["creator"] = boost::any(*creator);
    }
    if (customFields) {
      vector<boost::any> temp1;
      for(auto item1:*customFields){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["customFields"] = boost::any(temp1);
    }
    if (document) {
      res["document"] = boost::any(*document);
    }
    if (documentFormat) {
      res["documentFormat"] = boost::any(*documentFormat);
    }
    if (finishTime) {
      res["finishTime"] = boost::any(*finishTime);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (logicalStatus) {
      res["logicalStatus"] = boost::any(*logicalStatus);
    }
    if (modifier) {
      res["modifier"] = boost::any(*modifier);
    }
    if (parentIdentifier) {
      res["parentIdentifier"] = boost::any(*parentIdentifier);
    }
    if (participant) {
      res["participant"] = boost::any(*participant);
    }
    if (serialNumber) {
      res["serialNumber"] = boost::any(*serialNumber);
    }
    if (spaceIdentifier) {
      res["spaceIdentifier"] = boost::any(*spaceIdentifier);
    }
    if (spaceName) {
      res["spaceName"] = boost::any(*spaceName);
    }
    if (spaceType) {
      res["spaceType"] = boost::any(*spaceType);
    }
    if (sprint) {
      res["sprint"] = boost::any(*sprint);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (statusIdentifier) {
      res["statusIdentifier"] = boost::any(*statusIdentifier);
    }
    if (statusStageIdentifier) {
      res["statusStageIdentifier"] = boost::any(*statusStageIdentifier);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    if (tag) {
      res["tag"] = boost::any(*tag);
    }
    if (tagDetails) {
      vector<boost::any> temp1;
      for(auto item1:*tagDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tagDetails"] = boost::any(temp1);
    }
    if (tracker) {
      res["tracker"] = boost::any(*tracker);
    }
    if (updateStatusAt) {
      res["updateStatusAt"] = boost::any(*updateStatusAt);
    }
    if (verifier) {
      res["verifier"] = boost::any(*verifier);
    }
    if (workitemTypeIdentifier) {
      res["workitemTypeIdentifier"] = boost::any(*workitemTypeIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignedTo") != m.end() && !m["assignedTo"].empty()) {
      assignedTo = make_shared<string>(boost::any_cast<string>(m["assignedTo"]));
    }
    if (m.find("categoryIdentifier") != m.end() && !m["categoryIdentifier"].empty()) {
      categoryIdentifier = make_shared<string>(boost::any_cast<string>(m["categoryIdentifier"]));
    }
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["creator"]));
    }
    if (m.find("customFields") != m.end() && !m["customFields"].empty()) {
      if (typeid(vector<boost::any>) == m["customFields"].type()) {
        vector<GetWorkItemInfoResponseBodyWorkitemCustomFields> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["customFields"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetWorkItemInfoResponseBodyWorkitemCustomFields model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customFields = make_shared<vector<GetWorkItemInfoResponseBodyWorkitemCustomFields>>(expect1);
      }
    }
    if (m.find("document") != m.end() && !m["document"].empty()) {
      document = make_shared<string>(boost::any_cast<string>(m["document"]));
    }
    if (m.find("documentFormat") != m.end() && !m["documentFormat"].empty()) {
      documentFormat = make_shared<string>(boost::any_cast<string>(m["documentFormat"]));
    }
    if (m.find("finishTime") != m.end() && !m["finishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["finishTime"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("logicalStatus") != m.end() && !m["logicalStatus"].empty()) {
      logicalStatus = make_shared<string>(boost::any_cast<string>(m["logicalStatus"]));
    }
    if (m.find("modifier") != m.end() && !m["modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["modifier"]));
    }
    if (m.find("parentIdentifier") != m.end() && !m["parentIdentifier"].empty()) {
      parentIdentifier = make_shared<string>(boost::any_cast<string>(m["parentIdentifier"]));
    }
    if (m.find("participant") != m.end() && !m["participant"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["participant"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["participant"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      participant = make_shared<vector<string>>(toVec1);
    }
    if (m.find("serialNumber") != m.end() && !m["serialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["serialNumber"]));
    }
    if (m.find("spaceIdentifier") != m.end() && !m["spaceIdentifier"].empty()) {
      spaceIdentifier = make_shared<string>(boost::any_cast<string>(m["spaceIdentifier"]));
    }
    if (m.find("spaceName") != m.end() && !m["spaceName"].empty()) {
      spaceName = make_shared<string>(boost::any_cast<string>(m["spaceName"]));
    }
    if (m.find("spaceType") != m.end() && !m["spaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["spaceType"]));
    }
    if (m.find("sprint") != m.end() && !m["sprint"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sprint"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sprint"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sprint = make_shared<vector<string>>(toVec1);
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("statusIdentifier") != m.end() && !m["statusIdentifier"].empty()) {
      statusIdentifier = make_shared<string>(boost::any_cast<string>(m["statusIdentifier"]));
    }
    if (m.find("statusStageIdentifier") != m.end() && !m["statusStageIdentifier"].empty()) {
      statusStageIdentifier = make_shared<string>(boost::any_cast<string>(m["statusStageIdentifier"]));
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
    if (m.find("tag") != m.end() && !m["tag"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["tag"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["tag"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tag = make_shared<vector<string>>(toVec1);
    }
    if (m.find("tagDetails") != m.end() && !m["tagDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["tagDetails"].type()) {
        vector<GetWorkItemInfoResponseBodyWorkitemTagDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tagDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetWorkItemInfoResponseBodyWorkitemTagDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagDetails = make_shared<vector<GetWorkItemInfoResponseBodyWorkitemTagDetails>>(expect1);
      }
    }
    if (m.find("tracker") != m.end() && !m["tracker"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["tracker"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["tracker"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tracker = make_shared<vector<string>>(toVec1);
    }
    if (m.find("updateStatusAt") != m.end() && !m["updateStatusAt"].empty()) {
      updateStatusAt = make_shared<long>(boost::any_cast<long>(m["updateStatusAt"]));
    }
    if (m.find("verifier") != m.end() && !m["verifier"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["verifier"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["verifier"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      verifier = make_shared<vector<string>>(toVec1);
    }
    if (m.find("workitemTypeIdentifier") != m.end() && !m["workitemTypeIdentifier"].empty()) {
      workitemTypeIdentifier = make_shared<string>(boost::any_cast<string>(m["workitemTypeIdentifier"]));
    }
  }


  virtual ~GetWorkItemInfoResponseBodyWorkitem() = default;
};
class GetWorkItemInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<GetWorkItemInfoResponseBodyWorkitem> workitem{};

  GetWorkItemInfoResponseBody() {}

  explicit GetWorkItemInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (workitem) {
      res["workitem"] = workitem ? boost::any(workitem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("workitem") != m.end() && !m["workitem"].empty()) {
      if (typeid(map<string, boost::any>) == m["workitem"].type()) {
        GetWorkItemInfoResponseBodyWorkitem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["workitem"]));
        workitem = make_shared<GetWorkItemInfoResponseBodyWorkitem>(model1);
      }
    }
  }


  virtual ~GetWorkItemInfoResponseBody() = default;
};
class GetWorkItemInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWorkItemInfoResponseBody> body{};

  GetWorkItemInfoResponse() {}

  explicit GetWorkItemInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWorkItemInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWorkItemInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetWorkItemInfoResponse() = default;
};
class GetWorkItemWorkFlowInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> configurationId{};

  GetWorkItemWorkFlowInfoRequest() {}

  explicit GetWorkItemWorkFlowInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configurationId) {
      res["configurationId"] = boost::any(*configurationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("configurationId") != m.end() && !m["configurationId"].empty()) {
      configurationId = make_shared<string>(boost::any_cast<string>(m["configurationId"]));
    }
  }


  virtual ~GetWorkItemWorkFlowInfoRequest() = default;
};
class GetWorkItemWorkFlowInfoResponseBodyWorkflowStatuses : public Darabonba::Model {
public:
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> identifier{};
  shared_ptr<string> modifier{};
  shared_ptr<string> name{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> source{};
  shared_ptr<string> workflowStageIdentifier{};
  shared_ptr<string> workflowStageName{};

  GetWorkItemWorkFlowInfoResponseBodyWorkflowStatuses() {}

  explicit GetWorkItemWorkFlowInfoResponseBodyWorkflowStatuses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creator) {
      res["creator"] = boost::any(*creator);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (modifier) {
      res["modifier"] = boost::any(*modifier);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (resourceType) {
      res["resourceType"] = boost::any(*resourceType);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (workflowStageIdentifier) {
      res["workflowStageIdentifier"] = boost::any(*workflowStageIdentifier);
    }
    if (workflowStageName) {
      res["workflowStageName"] = boost::any(*workflowStageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["creator"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("modifier") != m.end() && !m["modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["modifier"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("resourceType") != m.end() && !m["resourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["resourceType"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("workflowStageIdentifier") != m.end() && !m["workflowStageIdentifier"].empty()) {
      workflowStageIdentifier = make_shared<string>(boost::any_cast<string>(m["workflowStageIdentifier"]));
    }
    if (m.find("workflowStageName") != m.end() && !m["workflowStageName"].empty()) {
      workflowStageName = make_shared<string>(boost::any_cast<string>(m["workflowStageName"]));
    }
  }


  virtual ~GetWorkItemWorkFlowInfoResponseBodyWorkflowStatuses() = default;
};
class GetWorkItemWorkFlowInfoResponseBodyWorkflowWorkflowActions : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> nextWorkflowStatusIdentifier{};
  shared_ptr<string> workflowIdentifier{};
  shared_ptr<string> workflowStatusIdentifier{};

  GetWorkItemWorkFlowInfoResponseBodyWorkflowWorkflowActions() {}

  explicit GetWorkItemWorkFlowInfoResponseBodyWorkflowWorkflowActions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nextWorkflowStatusIdentifier) {
      res["nextWorkflowStatusIdentifier"] = boost::any(*nextWorkflowStatusIdentifier);
    }
    if (workflowIdentifier) {
      res["workflowIdentifier"] = boost::any(*workflowIdentifier);
    }
    if (workflowStatusIdentifier) {
      res["workflowStatusIdentifier"] = boost::any(*workflowStatusIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nextWorkflowStatusIdentifier") != m.end() && !m["nextWorkflowStatusIdentifier"].empty()) {
      nextWorkflowStatusIdentifier = make_shared<string>(boost::any_cast<string>(m["nextWorkflowStatusIdentifier"]));
    }
    if (m.find("workflowIdentifier") != m.end() && !m["workflowIdentifier"].empty()) {
      workflowIdentifier = make_shared<string>(boost::any_cast<string>(m["workflowIdentifier"]));
    }
    if (m.find("workflowStatusIdentifier") != m.end() && !m["workflowStatusIdentifier"].empty()) {
      workflowStatusIdentifier = make_shared<string>(boost::any_cast<string>(m["workflowStatusIdentifier"]));
    }
  }


  virtual ~GetWorkItemWorkFlowInfoResponseBodyWorkflowWorkflowActions() = default;
};
class GetWorkItemWorkFlowInfoResponseBodyWorkflow : public Darabonba::Model {
public:
  shared_ptr<string> creator{};
  shared_ptr<string> defaultStatusIdentifier{};
  shared_ptr<string> description{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> identifier{};
  shared_ptr<string> modifier{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerSpaceIdentifier{};
  shared_ptr<string> ownerSpaceType{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> source{};
  shared_ptr<string> statusOrder{};
  shared_ptr<vector<GetWorkItemWorkFlowInfoResponseBodyWorkflowStatuses>> statuses{};
  shared_ptr<vector<GetWorkItemWorkFlowInfoResponseBodyWorkflowWorkflowActions>> workflowActions{};

  GetWorkItemWorkFlowInfoResponseBodyWorkflow() {}

  explicit GetWorkItemWorkFlowInfoResponseBodyWorkflow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creator) {
      res["creator"] = boost::any(*creator);
    }
    if (defaultStatusIdentifier) {
      res["defaultStatusIdentifier"] = boost::any(*defaultStatusIdentifier);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (modifier) {
      res["modifier"] = boost::any(*modifier);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (ownerSpaceIdentifier) {
      res["ownerSpaceIdentifier"] = boost::any(*ownerSpaceIdentifier);
    }
    if (ownerSpaceType) {
      res["ownerSpaceType"] = boost::any(*ownerSpaceType);
    }
    if (resourceType) {
      res["resourceType"] = boost::any(*resourceType);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (statusOrder) {
      res["statusOrder"] = boost::any(*statusOrder);
    }
    if (statuses) {
      vector<boost::any> temp1;
      for(auto item1:*statuses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["statuses"] = boost::any(temp1);
    }
    if (workflowActions) {
      vector<boost::any> temp1;
      for(auto item1:*workflowActions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["workflowActions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["creator"]));
    }
    if (m.find("defaultStatusIdentifier") != m.end() && !m["defaultStatusIdentifier"].empty()) {
      defaultStatusIdentifier = make_shared<string>(boost::any_cast<string>(m["defaultStatusIdentifier"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("modifier") != m.end() && !m["modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["modifier"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("ownerSpaceIdentifier") != m.end() && !m["ownerSpaceIdentifier"].empty()) {
      ownerSpaceIdentifier = make_shared<string>(boost::any_cast<string>(m["ownerSpaceIdentifier"]));
    }
    if (m.find("ownerSpaceType") != m.end() && !m["ownerSpaceType"].empty()) {
      ownerSpaceType = make_shared<string>(boost::any_cast<string>(m["ownerSpaceType"]));
    }
    if (m.find("resourceType") != m.end() && !m["resourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["resourceType"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("statusOrder") != m.end() && !m["statusOrder"].empty()) {
      statusOrder = make_shared<string>(boost::any_cast<string>(m["statusOrder"]));
    }
    if (m.find("statuses") != m.end() && !m["statuses"].empty()) {
      if (typeid(vector<boost::any>) == m["statuses"].type()) {
        vector<GetWorkItemWorkFlowInfoResponseBodyWorkflowStatuses> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["statuses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetWorkItemWorkFlowInfoResponseBodyWorkflowStatuses model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statuses = make_shared<vector<GetWorkItemWorkFlowInfoResponseBodyWorkflowStatuses>>(expect1);
      }
    }
    if (m.find("workflowActions") != m.end() && !m["workflowActions"].empty()) {
      if (typeid(vector<boost::any>) == m["workflowActions"].type()) {
        vector<GetWorkItemWorkFlowInfoResponseBodyWorkflowWorkflowActions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["workflowActions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetWorkItemWorkFlowInfoResponseBodyWorkflowWorkflowActions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workflowActions = make_shared<vector<GetWorkItemWorkFlowInfoResponseBodyWorkflowWorkflowActions>>(expect1);
      }
    }
  }


  virtual ~GetWorkItemWorkFlowInfoResponseBodyWorkflow() = default;
};
class GetWorkItemWorkFlowInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<GetWorkItemWorkFlowInfoResponseBodyWorkflow> workflow{};

  GetWorkItemWorkFlowInfoResponseBody() {}

  explicit GetWorkItemWorkFlowInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (workflow) {
      res["workflow"] = workflow ? boost::any(workflow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("workflow") != m.end() && !m["workflow"].empty()) {
      if (typeid(map<string, boost::any>) == m["workflow"].type()) {
        GetWorkItemWorkFlowInfoResponseBodyWorkflow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["workflow"]));
        workflow = make_shared<GetWorkItemWorkFlowInfoResponseBodyWorkflow>(model1);
      }
    }
  }


  virtual ~GetWorkItemWorkFlowInfoResponseBody() = default;
};
class GetWorkItemWorkFlowInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWorkItemWorkFlowInfoResponseBody> body{};

  GetWorkItemWorkFlowInfoResponse() {}

  explicit GetWorkItemWorkFlowInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWorkItemWorkFlowInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWorkItemWorkFlowInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetWorkItemWorkFlowInfoResponse() = default;
};
class GetWorkitemAttachmentCreatemetaRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};

  GetWorkitemAttachmentCreatemetaRequest() {}

  explicit GetWorkitemAttachmentCreatemetaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["fileName"] = boost::any(*fileName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fileName") != m.end() && !m["fileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["fileName"]));
    }
  }


  virtual ~GetWorkitemAttachmentCreatemetaRequest() = default;
};
class GetWorkitemAttachmentCreatemetaResponseBodyUploadInfo : public Darabonba::Model {
public:
  shared_ptr<string> accessid{};
  shared_ptr<string> dir{};
  shared_ptr<string> host{};
  shared_ptr<string> policy{};
  shared_ptr<string> signature{};

  GetWorkitemAttachmentCreatemetaResponseBodyUploadInfo() {}

  explicit GetWorkitemAttachmentCreatemetaResponseBodyUploadInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessid) {
      res["accessid"] = boost::any(*accessid);
    }
    if (dir) {
      res["dir"] = boost::any(*dir);
    }
    if (host) {
      res["host"] = boost::any(*host);
    }
    if (policy) {
      res["policy"] = boost::any(*policy);
    }
    if (signature) {
      res["signature"] = boost::any(*signature);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessid") != m.end() && !m["accessid"].empty()) {
      accessid = make_shared<string>(boost::any_cast<string>(m["accessid"]));
    }
    if (m.find("dir") != m.end() && !m["dir"].empty()) {
      dir = make_shared<string>(boost::any_cast<string>(m["dir"]));
    }
    if (m.find("host") != m.end() && !m["host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["host"]));
    }
    if (m.find("policy") != m.end() && !m["policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["policy"]));
    }
    if (m.find("signature") != m.end() && !m["signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["signature"]));
    }
  }


  virtual ~GetWorkitemAttachmentCreatemetaResponseBodyUploadInfo() = default;
};
class GetWorkitemAttachmentCreatemetaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<GetWorkitemAttachmentCreatemetaResponseBodyUploadInfo> uploadInfo{};

  GetWorkitemAttachmentCreatemetaResponseBody() {}

  explicit GetWorkitemAttachmentCreatemetaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (uploadInfo) {
      res["uploadInfo"] = uploadInfo ? boost::any(uploadInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["success"]));
    }
    if (m.find("uploadInfo") != m.end() && !m["uploadInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["uploadInfo"].type()) {
        GetWorkitemAttachmentCreatemetaResponseBodyUploadInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["uploadInfo"]));
        uploadInfo = make_shared<GetWorkitemAttachmentCreatemetaResponseBodyUploadInfo>(model1);
      }
    }
  }


  virtual ~GetWorkitemAttachmentCreatemetaResponseBody() = default;
};
class GetWorkitemAttachmentCreatemetaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWorkitemAttachmentCreatemetaResponseBody> body{};

  GetWorkitemAttachmentCreatemetaResponse() {}

  explicit GetWorkitemAttachmentCreatemetaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWorkitemAttachmentCreatemetaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWorkitemAttachmentCreatemetaResponseBody>(model1);
      }
    }
  }


  virtual ~GetWorkitemAttachmentCreatemetaResponse() = default;
};
class GetWorkitemCommentListResponseBodyCommentListUser : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> avatar{};
  shared_ptr<string> identifier{};
  shared_ptr<string> nickName{};
  shared_ptr<string> realName{};

  GetWorkitemCommentListResponseBodyCommentListUser() {}

  explicit GetWorkitemCommentListResponseBodyCommentListUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["account"] = boost::any(*account);
    }
    if (avatar) {
      res["avatar"] = boost::any(*avatar);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (nickName) {
      res["nickName"] = boost::any(*nickName);
    }
    if (realName) {
      res["realName"] = boost::any(*realName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("account") != m.end() && !m["account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["account"]));
    }
    if (m.find("avatar") != m.end() && !m["avatar"].empty()) {
      avatar = make_shared<string>(boost::any_cast<string>(m["avatar"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("nickName") != m.end() && !m["nickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["nickName"]));
    }
    if (m.find("realName") != m.end() && !m["realName"].empty()) {
      realName = make_shared<string>(boost::any_cast<string>(m["realName"]));
    }
  }


  virtual ~GetWorkitemCommentListResponseBodyCommentListUser() = default;
};
class GetWorkitemCommentListResponseBodyCommentList : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> createTime{};
  shared_ptr<string> formatType{};
  shared_ptr<long> id{};
  shared_ptr<bool> isTop{};
  shared_ptr<long> modifiedTime{};
  shared_ptr<long> parentId{};
  shared_ptr<string> targetIdentifier{};
  shared_ptr<string> targetType{};
  shared_ptr<long> topTime{};
  shared_ptr<GetWorkitemCommentListResponseBodyCommentListUser> user{};

  GetWorkitemCommentListResponseBodyCommentList() {}

  explicit GetWorkitemCommentListResponseBodyCommentList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (formatType) {
      res["formatType"] = boost::any(*formatType);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (isTop) {
      res["isTop"] = boost::any(*isTop);
    }
    if (modifiedTime) {
      res["modifiedTime"] = boost::any(*modifiedTime);
    }
    if (parentId) {
      res["parentId"] = boost::any(*parentId);
    }
    if (targetIdentifier) {
      res["targetIdentifier"] = boost::any(*targetIdentifier);
    }
    if (targetType) {
      res["targetType"] = boost::any(*targetType);
    }
    if (topTime) {
      res["topTime"] = boost::any(*topTime);
    }
    if (user) {
      res["user"] = user ? boost::any(user->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["createTime"]));
    }
    if (m.find("formatType") != m.end() && !m["formatType"].empty()) {
      formatType = make_shared<string>(boost::any_cast<string>(m["formatType"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("isTop") != m.end() && !m["isTop"].empty()) {
      isTop = make_shared<bool>(boost::any_cast<bool>(m["isTop"]));
    }
    if (m.find("modifiedTime") != m.end() && !m["modifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["modifiedTime"]));
    }
    if (m.find("parentId") != m.end() && !m["parentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["parentId"]));
    }
    if (m.find("targetIdentifier") != m.end() && !m["targetIdentifier"].empty()) {
      targetIdentifier = make_shared<string>(boost::any_cast<string>(m["targetIdentifier"]));
    }
    if (m.find("targetType") != m.end() && !m["targetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["targetType"]));
    }
    if (m.find("topTime") != m.end() && !m["topTime"].empty()) {
      topTime = make_shared<long>(boost::any_cast<long>(m["topTime"]));
    }
    if (m.find("user") != m.end() && !m["user"].empty()) {
      if (typeid(map<string, boost::any>) == m["user"].type()) {
        GetWorkitemCommentListResponseBodyCommentListUser model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["user"]));
        user = make_shared<GetWorkitemCommentListResponseBodyCommentListUser>(model1);
      }
    }
  }


  virtual ~GetWorkitemCommentListResponseBodyCommentList() = default;
};
class GetWorkitemCommentListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetWorkitemCommentListResponseBodyCommentList>> commentList{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetWorkitemCommentListResponseBody() {}

  explicit GetWorkitemCommentListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commentList) {
      vector<boost::any> temp1;
      for(auto item1:*commentList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["commentList"] = boost::any(temp1);
    }
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commentList") != m.end() && !m["commentList"].empty()) {
      if (typeid(vector<boost::any>) == m["commentList"].type()) {
        vector<GetWorkitemCommentListResponseBodyCommentList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["commentList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetWorkitemCommentListResponseBodyCommentList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        commentList = make_shared<vector<GetWorkitemCommentListResponseBodyCommentList>>(expect1);
      }
    }
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["success"]));
    }
  }


  virtual ~GetWorkitemCommentListResponseBody() = default;
};
class GetWorkitemCommentListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWorkitemCommentListResponseBody> body{};

  GetWorkitemCommentListResponse() {}

  explicit GetWorkitemCommentListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWorkitemCommentListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWorkitemCommentListResponseBody>(model1);
      }
    }
  }


  virtual ~GetWorkitemCommentListResponse() = default;
};
class GetWorkitemFileResponseBodyWorkitemFile : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<long> size{};
  shared_ptr<string> suffix{};
  shared_ptr<string> url{};

  GetWorkitemFileResponseBodyWorkitemFile() {}

  explicit GetWorkitemFileResponseBodyWorkitemFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    if (suffix) {
      res["suffix"] = boost::any(*suffix);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
    if (m.find("suffix") != m.end() && !m["suffix"].empty()) {
      suffix = make_shared<string>(boost::any_cast<string>(m["suffix"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~GetWorkitemFileResponseBodyWorkitemFile() = default;
};
class GetWorkitemFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<GetWorkitemFileResponseBodyWorkitemFile> workitemFile{};

  GetWorkitemFileResponseBody() {}

  explicit GetWorkitemFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (workitemFile) {
      res["workitemFile"] = workitemFile ? boost::any(workitemFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["success"]));
    }
    if (m.find("workitemFile") != m.end() && !m["workitemFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["workitemFile"].type()) {
        GetWorkitemFileResponseBodyWorkitemFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["workitemFile"]));
        workitemFile = make_shared<GetWorkitemFileResponseBodyWorkitemFile>(model1);
      }
    }
  }


  virtual ~GetWorkitemFileResponseBody() = default;
};
class GetWorkitemFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWorkitemFileResponseBody> body{};

  GetWorkitemFileResponse() {}

  explicit GetWorkitemFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWorkitemFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWorkitemFileResponseBody>(model1);
      }
    }
  }


  virtual ~GetWorkitemFileResponse() = default;
};
class GetWorkitemRelationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> relationType{};

  GetWorkitemRelationsRequest() {}

  explicit GetWorkitemRelationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (relationType) {
      res["relationType"] = boost::any(*relationType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("relationType") != m.end() && !m["relationType"].empty()) {
      relationType = make_shared<string>(boost::any_cast<string>(m["relationType"]));
    }
  }


  virtual ~GetWorkitemRelationsRequest() = default;
};
class GetWorkitemRelationsResponseBodyRelationList : public Darabonba::Model {
public:
  shared_ptr<string> assignedTo{};
  shared_ptr<string> categoryIdentifier{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> identifier{};
  shared_ptr<string> spaceIdentifier{};
  shared_ptr<string> subject{};
  shared_ptr<string> workitemTypeIdentifier{};

  GetWorkitemRelationsResponseBodyRelationList() {}

  explicit GetWorkitemRelationsResponseBodyRelationList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignedTo) {
      res["assignedTo"] = boost::any(*assignedTo);
    }
    if (categoryIdentifier) {
      res["categoryIdentifier"] = boost::any(*categoryIdentifier);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (spaceIdentifier) {
      res["spaceIdentifier"] = boost::any(*spaceIdentifier);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    if (workitemTypeIdentifier) {
      res["workitemTypeIdentifier"] = boost::any(*workitemTypeIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignedTo") != m.end() && !m["assignedTo"].empty()) {
      assignedTo = make_shared<string>(boost::any_cast<string>(m["assignedTo"]));
    }
    if (m.find("categoryIdentifier") != m.end() && !m["categoryIdentifier"].empty()) {
      categoryIdentifier = make_shared<string>(boost::any_cast<string>(m["categoryIdentifier"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmtModified"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("spaceIdentifier") != m.end() && !m["spaceIdentifier"].empty()) {
      spaceIdentifier = make_shared<string>(boost::any_cast<string>(m["spaceIdentifier"]));
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
    if (m.find("workitemTypeIdentifier") != m.end() && !m["workitemTypeIdentifier"].empty()) {
      workitemTypeIdentifier = make_shared<string>(boost::any_cast<string>(m["workitemTypeIdentifier"]));
    }
  }


  virtual ~GetWorkitemRelationsResponseBodyRelationList() = default;
};
class GetWorkitemRelationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<vector<GetWorkitemRelationsResponseBodyRelationList>> relationList{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetWorkitemRelationsResponseBody() {}

  explicit GetWorkitemRelationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (relationList) {
      vector<boost::any> temp1;
      for(auto item1:*relationList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["relationList"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("relationList") != m.end() && !m["relationList"].empty()) {
      if (typeid(vector<boost::any>) == m["relationList"].type()) {
        vector<GetWorkitemRelationsResponseBodyRelationList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["relationList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetWorkitemRelationsResponseBodyRelationList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        relationList = make_shared<vector<GetWorkitemRelationsResponseBodyRelationList>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~GetWorkitemRelationsResponseBody() = default;
};
class GetWorkitemRelationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWorkitemRelationsResponseBody> body{};

  GetWorkitemRelationsResponse() {}

  explicit GetWorkitemRelationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWorkitemRelationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWorkitemRelationsResponseBody>(model1);
      }
    }
  }


  virtual ~GetWorkitemRelationsResponse() = default;
};
class GetWorkitemTimeTypeListResponseBodyTimeType : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> identifier{};
  shared_ptr<string> name{};
  shared_ptr<long> position{};

  GetWorkitemTimeTypeListResponseBodyTimeType() {}

  explicit GetWorkitemTimeTypeListResponseBodyTimeType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (displayName) {
      res["displayName"] = boost::any(*displayName);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (position) {
      res["position"] = boost::any(*position);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("displayName") != m.end() && !m["displayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["displayName"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("position") != m.end() && !m["position"].empty()) {
      position = make_shared<long>(boost::any_cast<long>(m["position"]));
    }
  }


  virtual ~GetWorkitemTimeTypeListResponseBodyTimeType() = default;
};
class GetWorkitemTimeTypeListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<vector<GetWorkitemTimeTypeListResponseBodyTimeType>> timeType{};

  GetWorkitemTimeTypeListResponseBody() {}

  explicit GetWorkitemTimeTypeListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (timeType) {
      vector<boost::any> temp1;
      for(auto item1:*timeType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["timeType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["success"]));
    }
    if (m.find("timeType") != m.end() && !m["timeType"].empty()) {
      if (typeid(vector<boost::any>) == m["timeType"].type()) {
        vector<GetWorkitemTimeTypeListResponseBodyTimeType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["timeType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetWorkitemTimeTypeListResponseBodyTimeType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        timeType = make_shared<vector<GetWorkitemTimeTypeListResponseBodyTimeType>>(expect1);
      }
    }
  }


  virtual ~GetWorkitemTimeTypeListResponseBody() = default;
};
class GetWorkitemTimeTypeListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWorkitemTimeTypeListResponseBody> body{};

  GetWorkitemTimeTypeListResponse() {}

  explicit GetWorkitemTimeTypeListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWorkitemTimeTypeListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWorkitemTimeTypeListResponseBody>(model1);
      }
    }
  }


  virtual ~GetWorkitemTimeTypeListResponse() = default;
};
class GetWorkspaceResponseBodyWorkspace : public Darabonba::Model {
public:
  shared_ptr<string> codeUrl{};
  shared_ptr<string> codeVersion{};
  shared_ptr<string> createTime{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> spec{};
  shared_ptr<string> status{};
  shared_ptr<string> template_{};
  shared_ptr<string> userId{};

  GetWorkspaceResponseBodyWorkspace() {}

  explicit GetWorkspaceResponseBodyWorkspace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codeUrl) {
      res["codeUrl"] = boost::any(*codeUrl);
    }
    if (codeVersion) {
      res["codeVersion"] = boost::any(*codeVersion);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (template_) {
      res["template"] = boost::any(*template_);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("codeUrl") != m.end() && !m["codeUrl"].empty()) {
      codeUrl = make_shared<string>(boost::any_cast<string>(m["codeUrl"]));
    }
    if (m.find("codeVersion") != m.end() && !m["codeVersion"].empty()) {
      codeVersion = make_shared<string>(boost::any_cast<string>(m["codeVersion"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("template") != m.end() && !m["template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["template"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
  }


  virtual ~GetWorkspaceResponseBodyWorkspace() = default;
};
class GetWorkspaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<GetWorkspaceResponseBodyWorkspace> workspace{};

  GetWorkspaceResponseBody() {}

  explicit GetWorkspaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (workspace) {
      res["workspace"] = workspace ? boost::any(workspace->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("workspace") != m.end() && !m["workspace"].empty()) {
      if (typeid(map<string, boost::any>) == m["workspace"].type()) {
        GetWorkspaceResponseBodyWorkspace model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["workspace"]));
        workspace = make_shared<GetWorkspaceResponseBodyWorkspace>(model1);
      }
    }
  }


  virtual ~GetWorkspaceResponseBody() = default;
};
class GetWorkspaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWorkspaceResponseBody> body{};

  GetWorkspaceResponse() {}

  explicit GetWorkspaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWorkspaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWorkspaceResponseBody>(model1);
      }
    }
  }


  virtual ~GetWorkspaceResponse() = default;
};
class JoinPipelineGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> pipelineIds{};

  JoinPipelineGroupRequest() {}

  explicit JoinPipelineGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["groupId"] = boost::any(*groupId);
    }
    if (pipelineIds) {
      res["pipelineIds"] = boost::any(*pipelineIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("groupId") != m.end() && !m["groupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["groupId"]));
    }
    if (m.find("pipelineIds") != m.end() && !m["pipelineIds"].empty()) {
      pipelineIds = make_shared<string>(boost::any_cast<string>(m["pipelineIds"]));
    }
  }


  virtual ~JoinPipelineGroupRequest() = default;
};
class JoinPipelineGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  JoinPipelineGroupResponseBody() {}

  explicit JoinPipelineGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~JoinPipelineGroupResponseBody() = default;
};
class JoinPipelineGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<JoinPipelineGroupResponseBody> body{};

  JoinPipelineGroupResponse() {}

  explicit JoinPipelineGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        JoinPipelineGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<JoinPipelineGroupResponseBody>(model1);
      }
    }
  }


  virtual ~JoinPipelineGroupResponse() = default;
};
class LinkMergeRequestLabelRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<vector<string>> labelIds{};
  shared_ptr<long> localId{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> repositoryIdentity{};

  LinkMergeRequestLabelRequest() {}

  explicit LinkMergeRequestLabelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (labelIds) {
      res["labelIds"] = boost::any(*labelIds);
    }
    if (localId) {
      res["localId"] = boost::any(*localId);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (repositoryIdentity) {
      res["repositoryIdentity"] = boost::any(*repositoryIdentity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("labelIds") != m.end() && !m["labelIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["labelIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["labelIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      labelIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("localId") != m.end() && !m["localId"].empty()) {
      localId = make_shared<long>(boost::any_cast<long>(m["localId"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("repositoryIdentity") != m.end() && !m["repositoryIdentity"].empty()) {
      repositoryIdentity = make_shared<string>(boost::any_cast<string>(m["repositoryIdentity"]));
    }
  }


  virtual ~LinkMergeRequestLabelRequest() = default;
};
class LinkMergeRequestLabelResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> result{};

  LinkMergeRequestLabelResponseBodyResult() {}

  explicit LinkMergeRequestLabelResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~LinkMergeRequestLabelResponseBodyResult() = default;
};
class LinkMergeRequestLabelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<LinkMergeRequestLabelResponseBodyResult> result{};
  shared_ptr<bool> success{};

  LinkMergeRequestLabelResponseBody() {}

  explicit LinkMergeRequestLabelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        LinkMergeRequestLabelResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<LinkMergeRequestLabelResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~LinkMergeRequestLabelResponseBody() = default;
};
class LinkMergeRequestLabelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<LinkMergeRequestLabelResponseBody> body{};

  LinkMergeRequestLabelResponse() {}

  explicit LinkMergeRequestLabelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        LinkMergeRequestLabelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<LinkMergeRequestLabelResponseBody>(model1);
      }
    }
  }


  virtual ~LinkMergeRequestLabelResponse() = default;
};
class ListAllReleaseWorkflowsRequest : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};

  ListAllReleaseWorkflowsRequest() {}

  explicit ListAllReleaseWorkflowsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~ListAllReleaseWorkflowsRequest() = default;
};
class ListAllReleaseWorkflowsResponseBodyReleaseStagesVariableGroups : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> displayName{};
  shared_ptr<string> type{};

  ListAllReleaseWorkflowsResponseBodyReleaseStagesVariableGroups() {}

  explicit ListAllReleaseWorkflowsResponseBodyReleaseStagesVariableGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (displayName) {
      res["displayName"] = boost::any(*displayName);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("displayName") != m.end() && !m["displayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["displayName"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ListAllReleaseWorkflowsResponseBodyReleaseStagesVariableGroups() = default;
};
class ListAllReleaseWorkflowsResponseBodyReleaseStages : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> name{};
  shared_ptr<string> sn{};
  shared_ptr<string> releaseWorkflowSn{};
  shared_ptr<string> order{};
  shared_ptr<vector<ListAllReleaseWorkflowsResponseBodyReleaseStagesVariableGroups>> variableGroups{};

  ListAllReleaseWorkflowsResponseBodyReleaseStages() {}

  explicit ListAllReleaseWorkflowsResponseBodyReleaseStages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["appName"] = boost::any(*appName);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sn) {
      res["sn"] = boost::any(*sn);
    }
    if (releaseWorkflowSn) {
      res["releaseWorkflowSn"] = boost::any(*releaseWorkflowSn);
    }
    if (order) {
      res["order"] = boost::any(*order);
    }
    if (variableGroups) {
      vector<boost::any> temp1;
      for(auto item1:*variableGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["variableGroups"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("appName") != m.end() && !m["appName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["appName"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sn") != m.end() && !m["sn"].empty()) {
      sn = make_shared<string>(boost::any_cast<string>(m["sn"]));
    }
    if (m.find("releaseWorkflowSn") != m.end() && !m["releaseWorkflowSn"].empty()) {
      releaseWorkflowSn = make_shared<string>(boost::any_cast<string>(m["releaseWorkflowSn"]));
    }
    if (m.find("order") != m.end() && !m["order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["order"]));
    }
    if (m.find("variableGroups") != m.end() && !m["variableGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["variableGroups"].type()) {
        vector<ListAllReleaseWorkflowsResponseBodyReleaseStagesVariableGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["variableGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAllReleaseWorkflowsResponseBodyReleaseStagesVariableGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variableGroups = make_shared<vector<ListAllReleaseWorkflowsResponseBodyReleaseStagesVariableGroups>>(expect1);
      }
    }
  }


  virtual ~ListAllReleaseWorkflowsResponseBodyReleaseStages() = default;
};
class ListAllReleaseWorkflowsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> sn{};
  shared_ptr<string> name{};
  shared_ptr<string> order{};
  shared_ptr<vector<ListAllReleaseWorkflowsResponseBodyReleaseStages>> releaseStages{};
  shared_ptr<string> note{};

  ListAllReleaseWorkflowsResponseBody() {}

  explicit ListAllReleaseWorkflowsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["appName"] = boost::any(*appName);
    }
    if (sn) {
      res["sn"] = boost::any(*sn);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (order) {
      res["order"] = boost::any(*order);
    }
    if (releaseStages) {
      vector<boost::any> temp1;
      for(auto item1:*releaseStages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["releaseStages"] = boost::any(temp1);
    }
    if (note) {
      res["note"] = boost::any(*note);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("appName") != m.end() && !m["appName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["appName"]));
    }
    if (m.find("sn") != m.end() && !m["sn"].empty()) {
      sn = make_shared<string>(boost::any_cast<string>(m["sn"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("order") != m.end() && !m["order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["order"]));
    }
    if (m.find("releaseStages") != m.end() && !m["releaseStages"].empty()) {
      if (typeid(vector<boost::any>) == m["releaseStages"].type()) {
        vector<ListAllReleaseWorkflowsResponseBodyReleaseStages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["releaseStages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAllReleaseWorkflowsResponseBodyReleaseStages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        releaseStages = make_shared<vector<ListAllReleaseWorkflowsResponseBodyReleaseStages>>(expect1);
      }
    }
    if (m.find("note") != m.end() && !m["note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["note"]));
    }
  }


  virtual ~ListAllReleaseWorkflowsResponseBody() = default;
};
class ListAllReleaseWorkflowsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<vector<ListAllReleaseWorkflowsResponseBody>> body{};

  ListAllReleaseWorkflowsResponse() {}

  explicit ListAllReleaseWorkflowsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      vector<boost::any> temp1;
      for(auto item1:*body){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["body"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(vector<boost::any>) == m["body"].type()) {
        vector<ListAllReleaseWorkflowsResponseBody> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["body"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAllReleaseWorkflowsResponseBody model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        body = make_shared<vector<ListAllReleaseWorkflowsResponseBody>>(expect1);
      }
    }
  }


  virtual ~ListAllReleaseWorkflowsResponse() = default;
};
class ListAppReleaseStageExecutionIntegratedMetadataRequest : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};

  ListAppReleaseStageExecutionIntegratedMetadataRequest() {}

  explicit ListAppReleaseStageExecutionIntegratedMetadataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~ListAppReleaseStageExecutionIntegratedMetadataRequest() = default;
};
class ListAppReleaseStageExecutionIntegratedMetadataResponseBodyChangeRequests : public Darabonba::Model {
public:
  shared_ptr<string> sn{};
  shared_ptr<string> name{};
  shared_ptr<string> branchName{};
  shared_ptr<string> commitId{};
  shared_ptr<string> ownerAccountId{};

  ListAppReleaseStageExecutionIntegratedMetadataResponseBodyChangeRequests() {}

  explicit ListAppReleaseStageExecutionIntegratedMetadataResponseBodyChangeRequests(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sn) {
      res["sn"] = boost::any(*sn);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (branchName) {
      res["branchName"] = boost::any(*branchName);
    }
    if (commitId) {
      res["commitId"] = boost::any(*commitId);
    }
    if (ownerAccountId) {
      res["ownerAccountId"] = boost::any(*ownerAccountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("sn") != m.end() && !m["sn"].empty()) {
      sn = make_shared<string>(boost::any_cast<string>(m["sn"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("branchName") != m.end() && !m["branchName"].empty()) {
      branchName = make_shared<string>(boost::any_cast<string>(m["branchName"]));
    }
    if (m.find("commitId") != m.end() && !m["commitId"].empty()) {
      commitId = make_shared<string>(boost::any_cast<string>(m["commitId"]));
    }
    if (m.find("ownerAccountId") != m.end() && !m["ownerAccountId"].empty()) {
      ownerAccountId = make_shared<string>(boost::any_cast<string>(m["ownerAccountId"]));
    }
  }


  virtual ~ListAppReleaseStageExecutionIntegratedMetadataResponseBodyChangeRequests() = default;
};
class ListAppReleaseStageExecutionIntegratedMetadataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> releaseBranch{};
  shared_ptr<string> releaseRevision{};
  shared_ptr<string> repoUrl{};
  shared_ptr<string> repoType{};
  shared_ptr<vector<ListAppReleaseStageExecutionIntegratedMetadataResponseBodyChangeRequests>> changeRequests{};

  ListAppReleaseStageExecutionIntegratedMetadataResponseBody() {}

  explicit ListAppReleaseStageExecutionIntegratedMetadataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (releaseBranch) {
      res["releaseBranch"] = boost::any(*releaseBranch);
    }
    if (releaseRevision) {
      res["releaseRevision"] = boost::any(*releaseRevision);
    }
    if (repoUrl) {
      res["repoUrl"] = boost::any(*repoUrl);
    }
    if (repoType) {
      res["repoType"] = boost::any(*repoType);
    }
    if (changeRequests) {
      vector<boost::any> temp1;
      for(auto item1:*changeRequests){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["changeRequests"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("releaseBranch") != m.end() && !m["releaseBranch"].empty()) {
      releaseBranch = make_shared<string>(boost::any_cast<string>(m["releaseBranch"]));
    }
    if (m.find("releaseRevision") != m.end() && !m["releaseRevision"].empty()) {
      releaseRevision = make_shared<string>(boost::any_cast<string>(m["releaseRevision"]));
    }
    if (m.find("repoUrl") != m.end() && !m["repoUrl"].empty()) {
      repoUrl = make_shared<string>(boost::any_cast<string>(m["repoUrl"]));
    }
    if (m.find("repoType") != m.end() && !m["repoType"].empty()) {
      repoType = make_shared<string>(boost::any_cast<string>(m["repoType"]));
    }
    if (m.find("changeRequests") != m.end() && !m["changeRequests"].empty()) {
      if (typeid(vector<boost::any>) == m["changeRequests"].type()) {
        vector<ListAppReleaseStageExecutionIntegratedMetadataResponseBodyChangeRequests> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["changeRequests"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAppReleaseStageExecutionIntegratedMetadataResponseBodyChangeRequests model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        changeRequests = make_shared<vector<ListAppReleaseStageExecutionIntegratedMetadataResponseBodyChangeRequests>>(expect1);
      }
    }
  }


  virtual ~ListAppReleaseStageExecutionIntegratedMetadataResponseBody() = default;
};
class ListAppReleaseStageExecutionIntegratedMetadataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<vector<ListAppReleaseStageExecutionIntegratedMetadataResponseBody>> body{};

  ListAppReleaseStageExecutionIntegratedMetadataResponse() {}

  explicit ListAppReleaseStageExecutionIntegratedMetadataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      vector<boost::any> temp1;
      for(auto item1:*body){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["body"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(vector<boost::any>) == m["body"].type()) {
        vector<ListAppReleaseStageExecutionIntegratedMetadataResponseBody> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["body"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAppReleaseStageExecutionIntegratedMetadataResponseBody model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        body = make_shared<vector<ListAppReleaseStageExecutionIntegratedMetadataResponseBody>>(expect1);
      }
    }
  }


  virtual ~ListAppReleaseStageExecutionIntegratedMetadataResponse() = default;
};
class ListAppReleaseStageExecutionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> organizationId{};
  shared_ptr<long> page{};
  shared_ptr<string> pagination{};
  shared_ptr<long> perPage{};
  shared_ptr<string> sort{};

  ListAppReleaseStageExecutionsRequest() {}

  explicit ListAppReleaseStageExecutionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (orderBy) {
      res["orderBy"] = boost::any(*orderBy);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pagination) {
      res["pagination"] = boost::any(*pagination);
    }
    if (perPage) {
      res["perPage"] = boost::any(*perPage);
    }
    if (sort) {
      res["sort"] = boost::any(*sort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("orderBy") != m.end() && !m["orderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["orderBy"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("pagination") != m.end() && !m["pagination"].empty()) {
      pagination = make_shared<string>(boost::any_cast<string>(m["pagination"]));
    }
    if (m.find("perPage") != m.end() && !m["perPage"].empty()) {
      perPage = make_shared<long>(boost::any_cast<long>(m["perPage"]));
    }
    if (m.find("sort") != m.end() && !m["sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["sort"]));
    }
  }


  virtual ~ListAppReleaseStageExecutionsRequest() = default;
};
class ListAppReleaseStageExecutionsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> number{};
  shared_ptr<string> startTime{};
  shared_ptr<string> state{};
  shared_ptr<string> triggerMode{};

  ListAppReleaseStageExecutionsResponseBodyData() {}

  explicit ListAppReleaseStageExecutionsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (number) {
      res["number"] = boost::any(*number);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (triggerMode) {
      res["triggerMode"] = boost::any(*triggerMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("number") != m.end() && !m["number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["number"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["startTime"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("triggerMode") != m.end() && !m["triggerMode"].empty()) {
      triggerMode = make_shared<string>(boost::any_cast<string>(m["triggerMode"]));
    }
  }


  virtual ~ListAppReleaseStageExecutionsResponseBodyData() = default;
};
class ListAppReleaseStageExecutionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> current{};
  shared_ptr<vector<ListAppReleaseStageExecutionsResponseBodyData>> data{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> pages{};
  shared_ptr<long> perPage{};
  shared_ptr<long> total{};

  ListAppReleaseStageExecutionsResponseBody() {}

  explicit ListAppReleaseStageExecutionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (current) {
      res["current"] = boost::any(*current);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (pages) {
      res["pages"] = boost::any(*pages);
    }
    if (perPage) {
      res["perPage"] = boost::any(*perPage);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("current") != m.end() && !m["current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["current"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListAppReleaseStageExecutionsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAppReleaseStageExecutionsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListAppReleaseStageExecutionsResponseBodyData>>(expect1);
      }
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("pages") != m.end() && !m["pages"].empty()) {
      pages = make_shared<long>(boost::any_cast<long>(m["pages"]));
    }
    if (m.find("perPage") != m.end() && !m["perPage"].empty()) {
      perPage = make_shared<long>(boost::any_cast<long>(m["perPage"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
  }


  virtual ~ListAppReleaseStageExecutionsResponseBody() = default;
};
class ListAppReleaseStageExecutionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAppReleaseStageExecutionsResponseBody> body{};

  ListAppReleaseStageExecutionsResponse() {}

  explicit ListAppReleaseStageExecutionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAppReleaseStageExecutionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAppReleaseStageExecutionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAppReleaseStageExecutionsResponse() = default;
};
class ListApplicationMembersRequest : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};

  ListApplicationMembersRequest() {}

  explicit ListApplicationMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~ListApplicationMembersRequest() = default;
};
class ListApplicationMembersResponseBodyRecordsRoleList : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> name{};

  ListApplicationMembersResponseBodyRecordsRoleList() {}

  explicit ListApplicationMembersResponseBodyRecordsRoleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["displayName"] = boost::any(*displayName);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("displayName") != m.end() && !m["displayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["displayName"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~ListApplicationMembersResponseBodyRecordsRoleList() = default;
};
class ListApplicationMembersResponseBodyRecords : public Darabonba::Model {
public:
  shared_ptr<string> avatar{};
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> id{};
  shared_ptr<vector<ListApplicationMembersResponseBodyRecordsRoleList>> roleList{};
  shared_ptr<string> type{};

  ListApplicationMembersResponseBodyRecords() {}

  explicit ListApplicationMembersResponseBodyRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatar) {
      res["avatar"] = boost::any(*avatar);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (displayName) {
      res["displayName"] = boost::any(*displayName);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (roleList) {
      vector<boost::any> temp1;
      for(auto item1:*roleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["roleList"] = boost::any(temp1);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatar") != m.end() && !m["avatar"].empty()) {
      avatar = make_shared<string>(boost::any_cast<string>(m["avatar"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("displayName") != m.end() && !m["displayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["displayName"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("roleList") != m.end() && !m["roleList"].empty()) {
      if (typeid(vector<boost::any>) == m["roleList"].type()) {
        vector<ListApplicationMembersResponseBodyRecordsRoleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["roleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationMembersResponseBodyRecordsRoleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        roleList = make_shared<vector<ListApplicationMembersResponseBodyRecordsRoleList>>(expect1);
      }
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ListApplicationMembersResponseBodyRecords() = default;
};
class ListApplicationMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> current{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pages{};
  shared_ptr<vector<ListApplicationMembersResponseBodyRecords>> records{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  ListApplicationMembersResponseBody() {}

  explicit ListApplicationMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (current) {
      res["current"] = boost::any(*current);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (pages) {
      res["pages"] = boost::any(*pages);
    }
    if (records) {
      vector<boost::any> temp1;
      for(auto item1:*records){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["records"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("current") != m.end() && !m["current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["current"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("pages") != m.end() && !m["pages"].empty()) {
      pages = make_shared<long>(boost::any_cast<long>(m["pages"]));
    }
    if (m.find("records") != m.end() && !m["records"].empty()) {
      if (typeid(vector<boost::any>) == m["records"].type()) {
        vector<ListApplicationMembersResponseBodyRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["records"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationMembersResponseBodyRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        records = make_shared<vector<ListApplicationMembersResponseBodyRecords>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
  }


  virtual ~ListApplicationMembersResponseBody() = default;
};
class ListApplicationMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListApplicationMembersResponseBody> body{};

  ListApplicationMembersResponse() {}

  explicit ListApplicationMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListApplicationMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListApplicationMembersResponseBody>(model1);
      }
    }
  }


  virtual ~ListApplicationMembersResponse() = default;
};
class ListApplicationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> pagination{};
  shared_ptr<long> perPage{};
  shared_ptr<string> sort{};

  ListApplicationsRequest() {}

  explicit ListApplicationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (orderBy) {
      res["orderBy"] = boost::any(*orderBy);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (pagination) {
      res["pagination"] = boost::any(*pagination);
    }
    if (perPage) {
      res["perPage"] = boost::any(*perPage);
    }
    if (sort) {
      res["sort"] = boost::any(*sort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("orderBy") != m.end() && !m["orderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["orderBy"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("pagination") != m.end() && !m["pagination"].empty()) {
      pagination = make_shared<string>(boost::any_cast<string>(m["pagination"]));
    }
    if (m.find("perPage") != m.end() && !m["perPage"].empty()) {
      perPage = make_shared<long>(boost::any_cast<long>(m["perPage"]));
    }
    if (m.find("sort") != m.end() && !m["sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["sort"]));
    }
  }


  virtual ~ListApplicationsRequest() = default;
};
class ListApplicationsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> creatorAccountId{};
  shared_ptr<string> description{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> name{};

  ListApplicationsResponseBodyData() {}

  explicit ListApplicationsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creatorAccountId) {
      res["creatorAccountId"] = boost::any(*creatorAccountId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("creatorAccountId") != m.end() && !m["creatorAccountId"].empty()) {
      creatorAccountId = make_shared<string>(boost::any_cast<string>(m["creatorAccountId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmtCreate"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~ListApplicationsResponseBodyData() = default;
};
class ListApplicationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListApplicationsResponseBodyData>> data{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  ListApplicationsResponseBody() {}

  explicit ListApplicationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListApplicationsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListApplicationsResponseBodyData>>(expect1);
      }
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ListApplicationsResponseBody() = default;
};
class ListApplicationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListApplicationsResponseBody> body{};

  ListApplicationsResponse() {}

  explicit ListApplicationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListApplicationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListApplicationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListApplicationsResponse() = default;
};
class ListChangeRequestWorkflowExecutionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> orderBy{};
  shared_ptr<string> organizationId{};
  shared_ptr<long> page{};
  shared_ptr<long> perPage{};
  shared_ptr<string> releaseStageSn{};
  shared_ptr<string> releaseWorkflowSn{};
  shared_ptr<string> sort{};

  ListChangeRequestWorkflowExecutionsRequest() {}

  explicit ListChangeRequestWorkflowExecutionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderBy) {
      res["orderBy"] = boost::any(*orderBy);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (perPage) {
      res["perPage"] = boost::any(*perPage);
    }
    if (releaseStageSn) {
      res["releaseStageSn"] = boost::any(*releaseStageSn);
    }
    if (releaseWorkflowSn) {
      res["releaseWorkflowSn"] = boost::any(*releaseWorkflowSn);
    }
    if (sort) {
      res["sort"] = boost::any(*sort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("orderBy") != m.end() && !m["orderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["orderBy"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("perPage") != m.end() && !m["perPage"].empty()) {
      perPage = make_shared<long>(boost::any_cast<long>(m["perPage"]));
    }
    if (m.find("releaseStageSn") != m.end() && !m["releaseStageSn"].empty()) {
      releaseStageSn = make_shared<string>(boost::any_cast<string>(m["releaseStageSn"]));
    }
    if (m.find("releaseWorkflowSn") != m.end() && !m["releaseWorkflowSn"].empty()) {
      releaseWorkflowSn = make_shared<string>(boost::any_cast<string>(m["releaseWorkflowSn"]));
    }
    if (m.find("sort") != m.end() && !m["sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["sort"]));
    }
  }


  virtual ~ListChangeRequestWorkflowExecutionsRequest() = default;
};
class ListChangeRequestWorkflowExecutionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> current{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pages{};
  shared_ptr<vector<boost::any>> records{};
  shared_ptr<long> total{};

  ListChangeRequestWorkflowExecutionsResponseBody() {}

  explicit ListChangeRequestWorkflowExecutionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (current) {
      res["current"] = boost::any(*current);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (pages) {
      res["pages"] = boost::any(*pages);
    }
    if (records) {
      res["records"] = boost::any(*records);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("current") != m.end() && !m["current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["current"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("pages") != m.end() && !m["pages"].empty()) {
      pages = make_shared<long>(boost::any_cast<long>(m["pages"]));
    }
    if (m.find("records") != m.end() && !m["records"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["records"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["records"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      records = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
  }


  virtual ~ListChangeRequestWorkflowExecutionsResponseBody() = default;
};
class ListChangeRequestWorkflowExecutionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListChangeRequestWorkflowExecutionsResponseBody> body{};

  ListChangeRequestWorkflowExecutionsResponse() {}

  explicit ListChangeRequestWorkflowExecutionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListChangeRequestWorkflowExecutionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListChangeRequestWorkflowExecutionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListChangeRequestWorkflowExecutionsResponse() = default;
};
class ListChangeRequestsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> appNameList{};
  shared_ptr<string> displayNameKeyword{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> organizationId{};
  shared_ptr<vector<string>> ownerIdList{};
  shared_ptr<long> page{};
  shared_ptr<string> pagination{};
  shared_ptr<long> perPage{};
  shared_ptr<string> sort{};
  shared_ptr<vector<string>> stateList{};

  ListChangeRequestsRequest() {}

  explicit ListChangeRequestsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appNameList) {
      res["appNameList"] = boost::any(*appNameList);
    }
    if (displayNameKeyword) {
      res["displayNameKeyword"] = boost::any(*displayNameKeyword);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (orderBy) {
      res["orderBy"] = boost::any(*orderBy);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (ownerIdList) {
      res["ownerIdList"] = boost::any(*ownerIdList);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pagination) {
      res["pagination"] = boost::any(*pagination);
    }
    if (perPage) {
      res["perPage"] = boost::any(*perPage);
    }
    if (sort) {
      res["sort"] = boost::any(*sort);
    }
    if (stateList) {
      res["stateList"] = boost::any(*stateList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("appNameList") != m.end() && !m["appNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["appNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["appNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      appNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("displayNameKeyword") != m.end() && !m["displayNameKeyword"].empty()) {
      displayNameKeyword = make_shared<string>(boost::any_cast<string>(m["displayNameKeyword"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("orderBy") != m.end() && !m["orderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["orderBy"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("ownerIdList") != m.end() && !m["ownerIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ownerIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ownerIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("pagination") != m.end() && !m["pagination"].empty()) {
      pagination = make_shared<string>(boost::any_cast<string>(m["pagination"]));
    }
    if (m.find("perPage") != m.end() && !m["perPage"].empty()) {
      perPage = make_shared<long>(boost::any_cast<long>(m["perPage"]));
    }
    if (m.find("sort") != m.end() && !m["sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["sort"]));
    }
    if (m.find("stateList") != m.end() && !m["stateList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["stateList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["stateList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      stateList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListChangeRequestsRequest() = default;
};
class ListChangeRequestsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appNameListShrink{};
  shared_ptr<string> displayNameKeyword{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> ownerIdListShrink{};
  shared_ptr<long> page{};
  shared_ptr<string> pagination{};
  shared_ptr<long> perPage{};
  shared_ptr<string> sort{};
  shared_ptr<string> stateListShrink{};

  ListChangeRequestsShrinkRequest() {}

  explicit ListChangeRequestsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appNameListShrink) {
      res["appNameList"] = boost::any(*appNameListShrink);
    }
    if (displayNameKeyword) {
      res["displayNameKeyword"] = boost::any(*displayNameKeyword);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (orderBy) {
      res["orderBy"] = boost::any(*orderBy);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (ownerIdListShrink) {
      res["ownerIdList"] = boost::any(*ownerIdListShrink);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pagination) {
      res["pagination"] = boost::any(*pagination);
    }
    if (perPage) {
      res["perPage"] = boost::any(*perPage);
    }
    if (sort) {
      res["sort"] = boost::any(*sort);
    }
    if (stateListShrink) {
      res["stateList"] = boost::any(*stateListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("appNameList") != m.end() && !m["appNameList"].empty()) {
      appNameListShrink = make_shared<string>(boost::any_cast<string>(m["appNameList"]));
    }
    if (m.find("displayNameKeyword") != m.end() && !m["displayNameKeyword"].empty()) {
      displayNameKeyword = make_shared<string>(boost::any_cast<string>(m["displayNameKeyword"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("orderBy") != m.end() && !m["orderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["orderBy"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("ownerIdList") != m.end() && !m["ownerIdList"].empty()) {
      ownerIdListShrink = make_shared<string>(boost::any_cast<string>(m["ownerIdList"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("pagination") != m.end() && !m["pagination"].empty()) {
      pagination = make_shared<string>(boost::any_cast<string>(m["pagination"]));
    }
    if (m.find("perPage") != m.end() && !m["perPage"].empty()) {
      perPage = make_shared<long>(boost::any_cast<long>(m["perPage"]));
    }
    if (m.find("sort") != m.end() && !m["sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["sort"]));
    }
    if (m.find("stateList") != m.end() && !m["stateList"].empty()) {
      stateListShrink = make_shared<string>(boost::any_cast<string>(m["stateList"]));
    }
  }


  virtual ~ListChangeRequestsShrinkRequest() = default;
};
class ListChangeRequestsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> current{};
  shared_ptr<vector<boost::any>> data{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> pages{};
  shared_ptr<long> perPage{};
  shared_ptr<long> total{};

  ListChangeRequestsResponseBody() {}

  explicit ListChangeRequestsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (current) {
      res["current"] = boost::any(*current);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (pages) {
      res["pages"] = boost::any(*pages);
    }
    if (perPage) {
      res["perPage"] = boost::any(*perPage);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("current") != m.end() && !m["current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["current"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      data = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("pages") != m.end() && !m["pages"].empty()) {
      pages = make_shared<long>(boost::any_cast<long>(m["pages"]));
    }
    if (m.find("perPage") != m.end() && !m["perPage"].empty()) {
      perPage = make_shared<long>(boost::any_cast<long>(m["perPage"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
  }


  virtual ~ListChangeRequestsResponseBody() = default;
};
class ListChangeRequestsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListChangeRequestsResponseBody> body{};

  ListChangeRequestsResponse() {}

  explicit ListChangeRequestsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListChangeRequestsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListChangeRequestsResponseBody>(model1);
      }
    }
  }


  virtual ~ListChangeRequestsResponse() = default;
};
class ListCheckRunsRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> organizationId{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> ref{};
  shared_ptr<string> repositoryIdentity{};

  ListCheckRunsRequest() {}

  explicit ListCheckRunsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (ref) {
      res["ref"] = boost::any(*ref);
    }
    if (repositoryIdentity) {
      res["repositoryIdentity"] = boost::any(*repositoryIdentity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("ref") != m.end() && !m["ref"].empty()) {
      ref = make_shared<string>(boost::any_cast<string>(m["ref"]));
    }
    if (m.find("repositoryIdentity") != m.end() && !m["repositoryIdentity"].empty()) {
      repositoryIdentity = make_shared<string>(boost::any_cast<string>(m["repositoryIdentity"]));
    }
  }


  virtual ~ListCheckRunsRequest() = default;
};
class ListCheckRunsResponseBodyResultAnnotations : public Darabonba::Model {
public:
  shared_ptr<string> annotationLevel{};
  shared_ptr<long> endColumn{};
  shared_ptr<long> endLine{};
  shared_ptr<long> id{};
  shared_ptr<string> message{};
  shared_ptr<string> path{};
  shared_ptr<string> rawDetails{};
  shared_ptr<long> startColumn{};
  shared_ptr<long> startLine{};
  shared_ptr<string> title{};

  ListCheckRunsResponseBodyResultAnnotations() {}

  explicit ListCheckRunsResponseBodyResultAnnotations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationLevel) {
      res["annotationLevel"] = boost::any(*annotationLevel);
    }
    if (endColumn) {
      res["endColumn"] = boost::any(*endColumn);
    }
    if (endLine) {
      res["endLine"] = boost::any(*endLine);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (rawDetails) {
      res["rawDetails"] = boost::any(*rawDetails);
    }
    if (startColumn) {
      res["startColumn"] = boost::any(*startColumn);
    }
    if (startLine) {
      res["startLine"] = boost::any(*startLine);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("annotationLevel") != m.end() && !m["annotationLevel"].empty()) {
      annotationLevel = make_shared<string>(boost::any_cast<string>(m["annotationLevel"]));
    }
    if (m.find("endColumn") != m.end() && !m["endColumn"].empty()) {
      endColumn = make_shared<long>(boost::any_cast<long>(m["endColumn"]));
    }
    if (m.find("endLine") != m.end() && !m["endLine"].empty()) {
      endLine = make_shared<long>(boost::any_cast<long>(m["endLine"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("rawDetails") != m.end() && !m["rawDetails"].empty()) {
      rawDetails = make_shared<string>(boost::any_cast<string>(m["rawDetails"]));
    }
    if (m.find("startColumn") != m.end() && !m["startColumn"].empty()) {
      startColumn = make_shared<long>(boost::any_cast<long>(m["startColumn"]));
    }
    if (m.find("startLine") != m.end() && !m["startLine"].empty()) {
      startLine = make_shared<long>(boost::any_cast<long>(m["startLine"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~ListCheckRunsResponseBodyResultAnnotations() = default;
};
class ListCheckRunsResponseBodyResultCheckSuite : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  ListCheckRunsResponseBodyResultCheckSuite() {}

  explicit ListCheckRunsResponseBodyResultCheckSuite(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
  }


  virtual ~ListCheckRunsResponseBodyResultCheckSuite() = default;
};
class ListCheckRunsResponseBodyResultOutputImages : public Darabonba::Model {
public:
  shared_ptr<string> alt{};
  shared_ptr<string> caption{};
  shared_ptr<string> imageUrl{};

  ListCheckRunsResponseBodyResultOutputImages() {}

  explicit ListCheckRunsResponseBodyResultOutputImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alt) {
      res["alt"] = boost::any(*alt);
    }
    if (caption) {
      res["caption"] = boost::any(*caption);
    }
    if (imageUrl) {
      res["imageUrl"] = boost::any(*imageUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alt") != m.end() && !m["alt"].empty()) {
      alt = make_shared<string>(boost::any_cast<string>(m["alt"]));
    }
    if (m.find("caption") != m.end() && !m["caption"].empty()) {
      caption = make_shared<string>(boost::any_cast<string>(m["caption"]));
    }
    if (m.find("imageUrl") != m.end() && !m["imageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["imageUrl"]));
    }
  }


  virtual ~ListCheckRunsResponseBodyResultOutputImages() = default;
};
class ListCheckRunsResponseBodyResultOutput : public Darabonba::Model {
public:
  shared_ptr<vector<ListCheckRunsResponseBodyResultOutputImages>> images{};
  shared_ptr<string> summary{};
  shared_ptr<string> text{};
  shared_ptr<string> title{};

  ListCheckRunsResponseBodyResultOutput() {}

  explicit ListCheckRunsResponseBodyResultOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (images) {
      vector<boost::any> temp1;
      for(auto item1:*images){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["images"] = boost::any(temp1);
    }
    if (summary) {
      res["summary"] = boost::any(*summary);
    }
    if (text) {
      res["text"] = boost::any(*text);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("images") != m.end() && !m["images"].empty()) {
      if (typeid(vector<boost::any>) == m["images"].type()) {
        vector<ListCheckRunsResponseBodyResultOutputImages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["images"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCheckRunsResponseBodyResultOutputImages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        images = make_shared<vector<ListCheckRunsResponseBodyResultOutputImages>>(expect1);
      }
    }
    if (m.find("summary") != m.end() && !m["summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["summary"]));
    }
    if (m.find("text") != m.end() && !m["text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["text"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~ListCheckRunsResponseBodyResultOutput() = default;
};
class ListCheckRunsResponseBodyResultWriter : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> logoUrl{};
  shared_ptr<string> name{};
  shared_ptr<string> slug{};
  shared_ptr<string> type{};

  ListCheckRunsResponseBodyResultWriter() {}

  explicit ListCheckRunsResponseBodyResultWriter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (logoUrl) {
      res["logoUrl"] = boost::any(*logoUrl);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (slug) {
      res["slug"] = boost::any(*slug);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("logoUrl") != m.end() && !m["logoUrl"].empty()) {
      logoUrl = make_shared<string>(boost::any_cast<string>(m["logoUrl"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("slug") != m.end() && !m["slug"].empty()) {
      slug = make_shared<string>(boost::any_cast<string>(m["slug"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ListCheckRunsResponseBodyResultWriter() = default;
};
class ListCheckRunsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListCheckRunsResponseBodyResultAnnotations>> annotations{};
  shared_ptr<ListCheckRunsResponseBodyResultCheckSuite> checkSuite{};
  shared_ptr<string> completedAt{};
  shared_ptr<string> conclusion{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> detailsUrl{};
  shared_ptr<string> externalId{};
  shared_ptr<string> headSha{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<ListCheckRunsResponseBodyResultOutput> output{};
  shared_ptr<string> startedAt{};
  shared_ptr<string> status{};
  shared_ptr<string> updatedAt{};
  shared_ptr<ListCheckRunsResponseBodyResultWriter> writer{};

  ListCheckRunsResponseBodyResult() {}

  explicit ListCheckRunsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotations) {
      vector<boost::any> temp1;
      for(auto item1:*annotations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["annotations"] = boost::any(temp1);
    }
    if (checkSuite) {
      res["checkSuite"] = checkSuite ? boost::any(checkSuite->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (completedAt) {
      res["completedAt"] = boost::any(*completedAt);
    }
    if (conclusion) {
      res["conclusion"] = boost::any(*conclusion);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (detailsUrl) {
      res["detailsUrl"] = boost::any(*detailsUrl);
    }
    if (externalId) {
      res["externalId"] = boost::any(*externalId);
    }
    if (headSha) {
      res["headSha"] = boost::any(*headSha);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (output) {
      res["output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startedAt) {
      res["startedAt"] = boost::any(*startedAt);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (updatedAt) {
      res["updatedAt"] = boost::any(*updatedAt);
    }
    if (writer) {
      res["writer"] = writer ? boost::any(writer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("annotations") != m.end() && !m["annotations"].empty()) {
      if (typeid(vector<boost::any>) == m["annotations"].type()) {
        vector<ListCheckRunsResponseBodyResultAnnotations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["annotations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCheckRunsResponseBodyResultAnnotations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotations = make_shared<vector<ListCheckRunsResponseBodyResultAnnotations>>(expect1);
      }
    }
    if (m.find("checkSuite") != m.end() && !m["checkSuite"].empty()) {
      if (typeid(map<string, boost::any>) == m["checkSuite"].type()) {
        ListCheckRunsResponseBodyResultCheckSuite model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["checkSuite"]));
        checkSuite = make_shared<ListCheckRunsResponseBodyResultCheckSuite>(model1);
      }
    }
    if (m.find("completedAt") != m.end() && !m["completedAt"].empty()) {
      completedAt = make_shared<string>(boost::any_cast<string>(m["completedAt"]));
    }
    if (m.find("conclusion") != m.end() && !m["conclusion"].empty()) {
      conclusion = make_shared<string>(boost::any_cast<string>(m["conclusion"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("detailsUrl") != m.end() && !m["detailsUrl"].empty()) {
      detailsUrl = make_shared<string>(boost::any_cast<string>(m["detailsUrl"]));
    }
    if (m.find("externalId") != m.end() && !m["externalId"].empty()) {
      externalId = make_shared<string>(boost::any_cast<string>(m["externalId"]));
    }
    if (m.find("headSha") != m.end() && !m["headSha"].empty()) {
      headSha = make_shared<string>(boost::any_cast<string>(m["headSha"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("output") != m.end() && !m["output"].empty()) {
      if (typeid(map<string, boost::any>) == m["output"].type()) {
        ListCheckRunsResponseBodyResultOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["output"]));
        output = make_shared<ListCheckRunsResponseBodyResultOutput>(model1);
      }
    }
    if (m.find("startedAt") != m.end() && !m["startedAt"].empty()) {
      startedAt = make_shared<string>(boost::any_cast<string>(m["startedAt"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("updatedAt") != m.end() && !m["updatedAt"].empty()) {
      updatedAt = make_shared<string>(boost::any_cast<string>(m["updatedAt"]));
    }
    if (m.find("writer") != m.end() && !m["writer"].empty()) {
      if (typeid(map<string, boost::any>) == m["writer"].type()) {
        ListCheckRunsResponseBodyResultWriter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["writer"]));
        writer = make_shared<ListCheckRunsResponseBodyResultWriter>(model1);
      }
    }
  }


  virtual ~ListCheckRunsResponseBodyResult() = default;
};
class ListCheckRunsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListCheckRunsResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  ListCheckRunsResponseBody() {}

  explicit ListCheckRunsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ListCheckRunsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCheckRunsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListCheckRunsResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ListCheckRunsResponseBody() = default;
};
class ListCheckRunsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCheckRunsResponseBody> body{};

  ListCheckRunsResponse() {}

  explicit ListCheckRunsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCheckRunsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCheckRunsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCheckRunsResponse() = default;
};
class ListCommitStatusesRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> organizationId{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> repositoryIdentity{};
  shared_ptr<string> sha{};

  ListCommitStatusesRequest() {}

  explicit ListCommitStatusesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (repositoryIdentity) {
      res["repositoryIdentity"] = boost::any(*repositoryIdentity);
    }
    if (sha) {
      res["sha"] = boost::any(*sha);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("repositoryIdentity") != m.end() && !m["repositoryIdentity"].empty()) {
      repositoryIdentity = make_shared<string>(boost::any_cast<string>(m["repositoryIdentity"]));
    }
    if (m.find("sha") != m.end() && !m["sha"].empty()) {
      sha = make_shared<string>(boost::any_cast<string>(m["sha"]));
    }
  }


  virtual ~ListCommitStatusesRequest() = default;
};
class ListCommitStatusesResponseBodyResultCreator : public Darabonba::Model {
public:
  shared_ptr<string> aliyunPk{};
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> login{};
  shared_ptr<string> type{};

  ListCommitStatusesResponseBodyResultCreator() {}

  explicit ListCommitStatusesResponseBodyResultCreator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunPk) {
      res["aliyunPk"] = boost::any(*aliyunPk);
    }
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (login) {
      res["login"] = boost::any(*login);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aliyunPk") != m.end() && !m["aliyunPk"].empty()) {
      aliyunPk = make_shared<string>(boost::any_cast<string>(m["aliyunPk"]));
    }
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("login") != m.end() && !m["login"].empty()) {
      login = make_shared<string>(boost::any_cast<string>(m["login"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ListCommitStatusesResponseBodyResultCreator() = default;
};
class ListCommitStatusesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> context{};
  shared_ptr<ListCommitStatusesResponseBodyResultCreator> creator{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> sha{};
  shared_ptr<string> state{};
  shared_ptr<string> targetUrl{};

  ListCommitStatusesResponseBodyResult() {}

  explicit ListCommitStatusesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (context) {
      res["context"] = boost::any(*context);
    }
    if (creator) {
      res["creator"] = creator ? boost::any(creator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (sha) {
      res["sha"] = boost::any(*sha);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (targetUrl) {
      res["targetUrl"] = boost::any(*targetUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("context") != m.end() && !m["context"].empty()) {
      context = make_shared<string>(boost::any_cast<string>(m["context"]));
    }
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      if (typeid(map<string, boost::any>) == m["creator"].type()) {
        ListCommitStatusesResponseBodyResultCreator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["creator"]));
        creator = make_shared<ListCommitStatusesResponseBodyResultCreator>(model1);
      }
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("sha") != m.end() && !m["sha"].empty()) {
      sha = make_shared<string>(boost::any_cast<string>(m["sha"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("targetUrl") != m.end() && !m["targetUrl"].empty()) {
      targetUrl = make_shared<string>(boost::any_cast<string>(m["targetUrl"]));
    }
  }


  virtual ~ListCommitStatusesResponseBodyResult() = default;
};
class ListCommitStatusesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListCommitStatusesResponseBodyResult>> result{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListCommitStatusesResponseBody() {}

  explicit ListCommitStatusesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ListCommitStatusesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCommitStatusesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListCommitStatusesResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
  }


  virtual ~ListCommitStatusesResponseBody() = default;
};
class ListCommitStatusesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCommitStatusesResponseBody> body{};

  ListCommitStatusesResponse() {}

  explicit ListCommitStatusesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCommitStatusesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCommitStatusesResponseBody>(model1);
      }
    }
  }


  virtual ~ListCommitStatusesResponse() = default;
};
class ListFlowTagGroupsResponseBodyFlowTagGroups : public Darabonba::Model {
public:
  shared_ptr<string> creatorAccountId{};
  shared_ptr<long> id{};
  shared_ptr<string> modiferAccountId{};
  shared_ptr<string> name{};

  ListFlowTagGroupsResponseBodyFlowTagGroups() {}

  explicit ListFlowTagGroupsResponseBodyFlowTagGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creatorAccountId) {
      res["creatorAccountId"] = boost::any(*creatorAccountId);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (modiferAccountId) {
      res["modiferAccountId"] = boost::any(*modiferAccountId);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("creatorAccountId") != m.end() && !m["creatorAccountId"].empty()) {
      creatorAccountId = make_shared<string>(boost::any_cast<string>(m["creatorAccountId"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("modiferAccountId") != m.end() && !m["modiferAccountId"].empty()) {
      modiferAccountId = make_shared<string>(boost::any_cast<string>(m["modiferAccountId"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~ListFlowTagGroupsResponseBodyFlowTagGroups() = default;
};
class ListFlowTagGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<ListFlowTagGroupsResponseBodyFlowTagGroups>> flowTagGroups{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListFlowTagGroupsResponseBody() {}

  explicit ListFlowTagGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (flowTagGroups) {
      vector<boost::any> temp1;
      for(auto item1:*flowTagGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flowTagGroups"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("flowTagGroups") != m.end() && !m["flowTagGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["flowTagGroups"].type()) {
        vector<ListFlowTagGroupsResponseBodyFlowTagGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flowTagGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowTagGroupsResponseBodyFlowTagGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flowTagGroups = make_shared<vector<ListFlowTagGroupsResponseBodyFlowTagGroups>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ListFlowTagGroupsResponseBody() = default;
};
class ListFlowTagGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFlowTagGroupsResponseBody> body{};

  ListFlowTagGroupsResponse() {}

  explicit ListFlowTagGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowTagGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowTagGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowTagGroupsResponse() = default;
};
class ListGroupMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> organizationId{};

  ListGroupMemberRequest() {}

  explicit ListGroupMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~ListGroupMemberRequest() = default;
};
class ListGroupMemberResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> accessLevel{};
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> memberType{};
  shared_ptr<string> name{};
  shared_ptr<long> sourceId{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};

  ListGroupMemberResponseBodyResult() {}

  explicit ListGroupMemberResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessLevel) {
      res["accessLevel"] = boost::any(*accessLevel);
    }
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (memberType) {
      res["memberType"] = boost::any(*memberType);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sourceId) {
      res["sourceId"] = boost::any(*sourceId);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessLevel") != m.end() && !m["accessLevel"].empty()) {
      accessLevel = make_shared<long>(boost::any_cast<long>(m["accessLevel"]));
    }
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("memberType") != m.end() && !m["memberType"].empty()) {
      memberType = make_shared<string>(boost::any_cast<string>(m["memberType"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sourceId") != m.end() && !m["sourceId"].empty()) {
      sourceId = make_shared<long>(boost::any_cast<long>(m["sourceId"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~ListGroupMemberResponseBodyResult() = default;
};
class ListGroupMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListGroupMemberResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  ListGroupMemberResponseBody() {}

  explicit ListGroupMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ListGroupMemberResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGroupMemberResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListGroupMemberResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ListGroupMemberResponseBody() = default;
};
class ListGroupMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListGroupMemberResponseBody> body{};

  ListGroupMemberResponse() {}

  explicit ListGroupMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListGroupMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListGroupMemberResponseBody>(model1);
      }
    }
  }


  virtual ~ListGroupMemberResponse() = default;
};
class ListGroupRepositoriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> organizationId{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> search{};

  ListGroupRepositoriesRequest() {}

  explicit ListGroupRepositoriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (search) {
      res["search"] = boost::any(*search);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("search") != m.end() && !m["search"].empty()) {
      search = make_shared<string>(boost::any_cast<string>(m["search"]));
    }
  }


  virtual ~ListGroupRepositoriesRequest() = default;
};
class ListGroupRepositoriesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> archived{};
  shared_ptr<long> commitCount{};
  shared_ptr<string> createdAt{};
  shared_ptr<long> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<string> httpUrl{};
  shared_ptr<long> id{};
  shared_ptr<string> importUrl{};
  shared_ptr<bool> isStared{};
  shared_ptr<bool> issuesEnabled{};
  shared_ptr<string> lastActivityAt{};
  shared_ptr<bool> mergeRequestsEnabled{};
  shared_ptr<string> name{};
  shared_ptr<string> nameWithNamespace{};
  shared_ptr<bool> namespaceId{};
  shared_ptr<string> path{};
  shared_ptr<string> pathWithNamespace{};
  shared_ptr<bool> privateFlag{};
  shared_ptr<bool> snippetsEnabled{};
  shared_ptr<string> sshUrl{};
  shared_ptr<long> starCount{};
  shared_ptr<string> updatedAt{};
  shared_ptr<long> visibilityLevel{};
  shared_ptr<string> webUrl{};
  shared_ptr<bool> wikiEnabled{};

  ListGroupRepositoriesResponseBodyResult() {}

  explicit ListGroupRepositoriesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (archived) {
      res["archived"] = boost::any(*archived);
    }
    if (commitCount) {
      res["commitCount"] = boost::any(*commitCount);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (creatorId) {
      res["creatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (httpUrl) {
      res["httpUrl"] = boost::any(*httpUrl);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (importUrl) {
      res["importUrl"] = boost::any(*importUrl);
    }
    if (isStared) {
      res["isStared"] = boost::any(*isStared);
    }
    if (issuesEnabled) {
      res["issuesEnabled"] = boost::any(*issuesEnabled);
    }
    if (lastActivityAt) {
      res["lastActivityAt"] = boost::any(*lastActivityAt);
    }
    if (mergeRequestsEnabled) {
      res["mergeRequestsEnabled"] = boost::any(*mergeRequestsEnabled);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nameWithNamespace) {
      res["nameWithNamespace"] = boost::any(*nameWithNamespace);
    }
    if (namespaceId) {
      res["namespaceId"] = boost::any(*namespaceId);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (pathWithNamespace) {
      res["pathWithNamespace"] = boost::any(*pathWithNamespace);
    }
    if (privateFlag) {
      res["privateFlag"] = boost::any(*privateFlag);
    }
    if (snippetsEnabled) {
      res["snippetsEnabled"] = boost::any(*snippetsEnabled);
    }
    if (sshUrl) {
      res["sshUrl"] = boost::any(*sshUrl);
    }
    if (starCount) {
      res["starCount"] = boost::any(*starCount);
    }
    if (updatedAt) {
      res["updatedAt"] = boost::any(*updatedAt);
    }
    if (visibilityLevel) {
      res["visibilityLevel"] = boost::any(*visibilityLevel);
    }
    if (webUrl) {
      res["webUrl"] = boost::any(*webUrl);
    }
    if (wikiEnabled) {
      res["wikiEnabled"] = boost::any(*wikiEnabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("archived") != m.end() && !m["archived"].empty()) {
      archived = make_shared<bool>(boost::any_cast<bool>(m["archived"]));
    }
    if (m.find("commitCount") != m.end() && !m["commitCount"].empty()) {
      commitCount = make_shared<long>(boost::any_cast<long>(m["commitCount"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("creatorId") != m.end() && !m["creatorId"].empty()) {
      creatorId = make_shared<long>(boost::any_cast<long>(m["creatorId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("httpUrl") != m.end() && !m["httpUrl"].empty()) {
      httpUrl = make_shared<string>(boost::any_cast<string>(m["httpUrl"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("importUrl") != m.end() && !m["importUrl"].empty()) {
      importUrl = make_shared<string>(boost::any_cast<string>(m["importUrl"]));
    }
    if (m.find("isStared") != m.end() && !m["isStared"].empty()) {
      isStared = make_shared<bool>(boost::any_cast<bool>(m["isStared"]));
    }
    if (m.find("issuesEnabled") != m.end() && !m["issuesEnabled"].empty()) {
      issuesEnabled = make_shared<bool>(boost::any_cast<bool>(m["issuesEnabled"]));
    }
    if (m.find("lastActivityAt") != m.end() && !m["lastActivityAt"].empty()) {
      lastActivityAt = make_shared<string>(boost::any_cast<string>(m["lastActivityAt"]));
    }
    if (m.find("mergeRequestsEnabled") != m.end() && !m["mergeRequestsEnabled"].empty()) {
      mergeRequestsEnabled = make_shared<bool>(boost::any_cast<bool>(m["mergeRequestsEnabled"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nameWithNamespace") != m.end() && !m["nameWithNamespace"].empty()) {
      nameWithNamespace = make_shared<string>(boost::any_cast<string>(m["nameWithNamespace"]));
    }
    if (m.find("namespaceId") != m.end() && !m["namespaceId"].empty()) {
      namespaceId = make_shared<bool>(boost::any_cast<bool>(m["namespaceId"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("pathWithNamespace") != m.end() && !m["pathWithNamespace"].empty()) {
      pathWithNamespace = make_shared<string>(boost::any_cast<string>(m["pathWithNamespace"]));
    }
    if (m.find("privateFlag") != m.end() && !m["privateFlag"].empty()) {
      privateFlag = make_shared<bool>(boost::any_cast<bool>(m["privateFlag"]));
    }
    if (m.find("snippetsEnabled") != m.end() && !m["snippetsEnabled"].empty()) {
      snippetsEnabled = make_shared<bool>(boost::any_cast<bool>(m["snippetsEnabled"]));
    }
    if (m.find("sshUrl") != m.end() && !m["sshUrl"].empty()) {
      sshUrl = make_shared<string>(boost::any_cast<string>(m["sshUrl"]));
    }
    if (m.find("starCount") != m.end() && !m["starCount"].empty()) {
      starCount = make_shared<long>(boost::any_cast<long>(m["starCount"]));
    }
    if (m.find("updatedAt") != m.end() && !m["updatedAt"].empty()) {
      updatedAt = make_shared<string>(boost::any_cast<string>(m["updatedAt"]));
    }
    if (m.find("visibilityLevel") != m.end() && !m["visibilityLevel"].empty()) {
      visibilityLevel = make_shared<long>(boost::any_cast<long>(m["visibilityLevel"]));
    }
    if (m.find("webUrl") != m.end() && !m["webUrl"].empty()) {
      webUrl = make_shared<string>(boost::any_cast<string>(m["webUrl"]));
    }
    if (m.find("wikiEnabled") != m.end() && !m["wikiEnabled"].empty()) {
      wikiEnabled = make_shared<bool>(boost::any_cast<bool>(m["wikiEnabled"]));
    }
  }


  virtual ~ListGroupRepositoriesResponseBodyResult() = default;
};
class ListGroupRepositoriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListGroupRepositoriesResponseBodyResult>> result{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListGroupRepositoriesResponseBody() {}

  explicit ListGroupRepositoriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ListGroupRepositoriesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGroupRepositoriesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListGroupRepositoriesResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
  }


  virtual ~ListGroupRepositoriesResponseBody() = default;
};
class ListGroupRepositoriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListGroupRepositoriesResponseBody> body{};

  ListGroupRepositoriesResponse() {}

  explicit ListGroupRepositoriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListGroupRepositoriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListGroupRepositoriesResponseBody>(model1);
      }
    }
  }


  virtual ~ListGroupRepositoriesResponse() = default;
};
class ListHostGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<long> createEndTime{};
  shared_ptr<long> createStartTime{};
  shared_ptr<string> creatorAccountIds{};
  shared_ptr<string> ids{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> name{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> pageOrder{};
  shared_ptr<string> pageSort{};

  ListHostGroupsRequest() {}

  explicit ListHostGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createEndTime) {
      res["createEndTime"] = boost::any(*createEndTime);
    }
    if (createStartTime) {
      res["createStartTime"] = boost::any(*createStartTime);
    }
    if (creatorAccountIds) {
      res["creatorAccountIds"] = boost::any(*creatorAccountIds);
    }
    if (ids) {
      res["ids"] = boost::any(*ids);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (pageOrder) {
      res["pageOrder"] = boost::any(*pageOrder);
    }
    if (pageSort) {
      res["pageSort"] = boost::any(*pageSort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createEndTime") != m.end() && !m["createEndTime"].empty()) {
      createEndTime = make_shared<long>(boost::any_cast<long>(m["createEndTime"]));
    }
    if (m.find("createStartTime") != m.end() && !m["createStartTime"].empty()) {
      createStartTime = make_shared<long>(boost::any_cast<long>(m["createStartTime"]));
    }
    if (m.find("creatorAccountIds") != m.end() && !m["creatorAccountIds"].empty()) {
      creatorAccountIds = make_shared<string>(boost::any_cast<string>(m["creatorAccountIds"]));
    }
    if (m.find("ids") != m.end() && !m["ids"].empty()) {
      ids = make_shared<string>(boost::any_cast<string>(m["ids"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("pageOrder") != m.end() && !m["pageOrder"].empty()) {
      pageOrder = make_shared<string>(boost::any_cast<string>(m["pageOrder"]));
    }
    if (m.find("pageSort") != m.end() && !m["pageSort"].empty()) {
      pageSort = make_shared<string>(boost::any_cast<string>(m["pageSort"]));
    }
  }


  virtual ~ListHostGroupsRequest() = default;
};
class ListHostGroupsResponseBodyHostGroups : public Darabonba::Model {
public:
  shared_ptr<string> aliyunRegion{};
  shared_ptr<long> createTime{};
  shared_ptr<string> creatorAccountId{};
  shared_ptr<string> description{};
  shared_ptr<string> ecsLabelKey{};
  shared_ptr<string> ecsLabelValue{};
  shared_ptr<string> ecsType{};
  shared_ptr<long> hostNum{};
  shared_ptr<long> id{};
  shared_ptr<string> modifierAccountId{};
  shared_ptr<string> name{};
  shared_ptr<long> serviceConnectionId{};
  shared_ptr<string> type{};
  shared_ptr<long> updateTime{};

  ListHostGroupsResponseBodyHostGroups() {}

  explicit ListHostGroupsResponseBodyHostGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunRegion) {
      res["aliyunRegion"] = boost::any(*aliyunRegion);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (creatorAccountId) {
      res["creatorAccountId"] = boost::any(*creatorAccountId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (ecsLabelKey) {
      res["ecsLabelKey"] = boost::any(*ecsLabelKey);
    }
    if (ecsLabelValue) {
      res["ecsLabelValue"] = boost::any(*ecsLabelValue);
    }
    if (ecsType) {
      res["ecsType"] = boost::any(*ecsType);
    }
    if (hostNum) {
      res["hostNum"] = boost::any(*hostNum);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (modifierAccountId) {
      res["modifierAccountId"] = boost::any(*modifierAccountId);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (serviceConnectionId) {
      res["serviceConnectionId"] = boost::any(*serviceConnectionId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aliyunRegion") != m.end() && !m["aliyunRegion"].empty()) {
      aliyunRegion = make_shared<string>(boost::any_cast<string>(m["aliyunRegion"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["createTime"]));
    }
    if (m.find("creatorAccountId") != m.end() && !m["creatorAccountId"].empty()) {
      creatorAccountId = make_shared<string>(boost::any_cast<string>(m["creatorAccountId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("ecsLabelKey") != m.end() && !m["ecsLabelKey"].empty()) {
      ecsLabelKey = make_shared<string>(boost::any_cast<string>(m["ecsLabelKey"]));
    }
    if (m.find("ecsLabelValue") != m.end() && !m["ecsLabelValue"].empty()) {
      ecsLabelValue = make_shared<string>(boost::any_cast<string>(m["ecsLabelValue"]));
    }
    if (m.find("ecsType") != m.end() && !m["ecsType"].empty()) {
      ecsType = make_shared<string>(boost::any_cast<string>(m["ecsType"]));
    }
    if (m.find("hostNum") != m.end() && !m["hostNum"].empty()) {
      hostNum = make_shared<long>(boost::any_cast<long>(m["hostNum"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("modifierAccountId") != m.end() && !m["modifierAccountId"].empty()) {
      modifierAccountId = make_shared<string>(boost::any_cast<string>(m["modifierAccountId"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("serviceConnectionId") != m.end() && !m["serviceConnectionId"].empty()) {
      serviceConnectionId = make_shared<long>(boost::any_cast<long>(m["serviceConnectionId"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["updateTime"]));
    }
  }


  virtual ~ListHostGroupsResponseBodyHostGroups() = default;
};
class ListHostGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<ListHostGroupsResponseBodyHostGroups>> hostGroups{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListHostGroupsResponseBody() {}

  explicit ListHostGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (hostGroups) {
      vector<boost::any> temp1;
      for(auto item1:*hostGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["hostGroups"] = boost::any(temp1);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("hostGroups") != m.end() && !m["hostGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["hostGroups"].type()) {
        vector<ListHostGroupsResponseBodyHostGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["hostGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHostGroupsResponseBodyHostGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostGroups = make_shared<vector<ListHostGroupsResponseBodyHostGroups>>(expect1);
      }
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ListHostGroupsResponseBody() = default;
};
class ListHostGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHostGroupsResponseBody> body{};

  ListHostGroupsResponse() {}

  explicit ListHostGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHostGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHostGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListHostGroupsResponse() = default;
};
class ListJoinedOrganizationsResponseBodyOrganizations : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<bool> isOrgAdmin{};
  shared_ptr<string> name{};

  ListJoinedOrganizationsResponseBodyOrganizations() {}

  explicit ListJoinedOrganizationsResponseBodyOrganizations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (isOrgAdmin) {
      res["isOrgAdmin"] = boost::any(*isOrgAdmin);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("isOrgAdmin") != m.end() && !m["isOrgAdmin"].empty()) {
      isOrgAdmin = make_shared<bool>(boost::any_cast<bool>(m["isOrgAdmin"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~ListJoinedOrganizationsResponseBodyOrganizations() = default;
};
class ListJoinedOrganizationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<ListJoinedOrganizationsResponseBodyOrganizations>> organizations{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListJoinedOrganizationsResponseBody() {}

  explicit ListJoinedOrganizationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (organizations) {
      vector<boost::any> temp1;
      for(auto item1:*organizations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["organizations"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("organizations") != m.end() && !m["organizations"].empty()) {
      if (typeid(vector<boost::any>) == m["organizations"].type()) {
        vector<ListJoinedOrganizationsResponseBodyOrganizations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["organizations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJoinedOrganizationsResponseBodyOrganizations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        organizations = make_shared<vector<ListJoinedOrganizationsResponseBodyOrganizations>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ListJoinedOrganizationsResponseBody() = default;
};
class ListJoinedOrganizationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListJoinedOrganizationsResponseBody> body{};

  ListJoinedOrganizationsResponse() {}

  explicit ListJoinedOrganizationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListJoinedOrganizationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListJoinedOrganizationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListJoinedOrganizationsResponse() = default;
};
class ListMergeRequestCommentsRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> commentType{};
  shared_ptr<string> filePath{};
  shared_ptr<vector<string>> patchSetBizIds{};
  shared_ptr<bool> resolved{};
  shared_ptr<string> state{};
  shared_ptr<long> localId{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> repositoryIdentity{};

  ListMergeRequestCommentsRequest() {}

  explicit ListMergeRequestCommentsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (commentType) {
      res["commentType"] = boost::any(*commentType);
    }
    if (filePath) {
      res["filePath"] = boost::any(*filePath);
    }
    if (patchSetBizIds) {
      res["patchSetBizIds"] = boost::any(*patchSetBizIds);
    }
    if (resolved) {
      res["resolved"] = boost::any(*resolved);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (localId) {
      res["localId"] = boost::any(*localId);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (repositoryIdentity) {
      res["repositoryIdentity"] = boost::any(*repositoryIdentity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("commentType") != m.end() && !m["commentType"].empty()) {
      commentType = make_shared<string>(boost::any_cast<string>(m["commentType"]));
    }
    if (m.find("filePath") != m.end() && !m["filePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["filePath"]));
    }
    if (m.find("patchSetBizIds") != m.end() && !m["patchSetBizIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["patchSetBizIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["patchSetBizIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      patchSetBizIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("resolved") != m.end() && !m["resolved"].empty()) {
      resolved = make_shared<bool>(boost::any_cast<bool>(m["resolved"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("localId") != m.end() && !m["localId"].empty()) {
      localId = make_shared<long>(boost::any_cast<long>(m["localId"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("repositoryIdentity") != m.end() && !m["repositoryIdentity"].empty()) {
      repositoryIdentity = make_shared<string>(boost::any_cast<string>(m["repositoryIdentity"]));
    }
  }


  virtual ~ListMergeRequestCommentsRequest() = default;
};
class ListMergeRequestCommentsResponseBodyResultAuthor : public Darabonba::Model {
public:
  shared_ptr<string> aliyunPk{};
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};

  ListMergeRequestCommentsResponseBodyResultAuthor() {}

  explicit ListMergeRequestCommentsResponseBodyResultAuthor(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunPk) {
      res["aliyunPk"] = boost::any(*aliyunPk);
    }
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aliyunPk") != m.end() && !m["aliyunPk"].empty()) {
      aliyunPk = make_shared<string>(boost::any_cast<string>(m["aliyunPk"]));
    }
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~ListMergeRequestCommentsResponseBodyResultAuthor() = default;
};
class ListMergeRequestCommentsResponseBodyResultChildCommentsAuthor : public Darabonba::Model {
public:
  shared_ptr<string> aliyunPk{};
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};

  ListMergeRequestCommentsResponseBodyResultChildCommentsAuthor() {}

  explicit ListMergeRequestCommentsResponseBodyResultChildCommentsAuthor(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunPk) {
      res["aliyunPk"] = boost::any(*aliyunPk);
    }
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aliyunPk") != m.end() && !m["aliyunPk"].empty()) {
      aliyunPk = make_shared<string>(boost::any_cast<string>(m["aliyunPk"]));
    }
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~ListMergeRequestCommentsResponseBodyResultChildCommentsAuthor() = default;
};
class ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsAuthor : public Darabonba::Model {
public:
  shared_ptr<string> aliyunPk{};
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};

  ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsAuthor() {}

  explicit ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsAuthor(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunPk) {
      res["aliyunPk"] = boost::any(*aliyunPk);
    }
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aliyunPk") != m.end() && !m["aliyunPk"].empty()) {
      aliyunPk = make_shared<string>(boost::any_cast<string>(m["aliyunPk"]));
    }
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsAuthor() = default;
};
class ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsRelatedPatchSet : public Darabonba::Model {
public:
  shared_ptr<string> commitId{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> patchSetBizId{};
  shared_ptr<string> patchSetName{};
  shared_ptr<string> patchSetNo{};
  shared_ptr<string> relatedMergeItemType{};
  shared_ptr<string> shortId{};

  ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsRelatedPatchSet() {}

  explicit ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsRelatedPatchSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commitId) {
      res["commitId"] = boost::any(*commitId);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (patchSetBizId) {
      res["patchSetBizId"] = boost::any(*patchSetBizId);
    }
    if (patchSetName) {
      res["patchSetName"] = boost::any(*patchSetName);
    }
    if (patchSetNo) {
      res["patchSetNo"] = boost::any(*patchSetNo);
    }
    if (relatedMergeItemType) {
      res["relatedMergeItemType"] = boost::any(*relatedMergeItemType);
    }
    if (shortId) {
      res["shortId"] = boost::any(*shortId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commitId") != m.end() && !m["commitId"].empty()) {
      commitId = make_shared<string>(boost::any_cast<string>(m["commitId"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("patchSetBizId") != m.end() && !m["patchSetBizId"].empty()) {
      patchSetBizId = make_shared<string>(boost::any_cast<string>(m["patchSetBizId"]));
    }
    if (m.find("patchSetName") != m.end() && !m["patchSetName"].empty()) {
      patchSetName = make_shared<string>(boost::any_cast<string>(m["patchSetName"]));
    }
    if (m.find("patchSetNo") != m.end() && !m["patchSetNo"].empty()) {
      patchSetNo = make_shared<string>(boost::any_cast<string>(m["patchSetNo"]));
    }
    if (m.find("relatedMergeItemType") != m.end() && !m["relatedMergeItemType"].empty()) {
      relatedMergeItemType = make_shared<string>(boost::any_cast<string>(m["relatedMergeItemType"]));
    }
    if (m.find("shortId") != m.end() && !m["shortId"].empty()) {
      shortId = make_shared<string>(boost::any_cast<string>(m["shortId"]));
    }
  }


  virtual ~ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsRelatedPatchSet() = default;
};
class ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildComments : public Darabonba::Model {
public:
  shared_ptr<ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsAuthor> author{};
  shared_ptr<string> commentBizId{};
  shared_ptr<string> commentTime{};
  shared_ptr<string> commentType{};
  shared_ptr<string> content{};
  shared_ptr<bool> deleted{};
  shared_ptr<string> filePath{};
  shared_ptr<string> lastEditTime{};
  shared_ptr<string> lineNumber{};
  shared_ptr<string> parentCommentBizId{};
  shared_ptr<ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsRelatedPatchSet> relatedPatchSet{};
  shared_ptr<bool> resolved{};
  shared_ptr<string> rootCommentBizId{};
  shared_ptr<string> state{};

  ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildComments() {}

  explicit ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildComments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (author) {
      res["author"] = author ? boost::any(author->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (commentBizId) {
      res["commentBizId"] = boost::any(*commentBizId);
    }
    if (commentTime) {
      res["commentTime"] = boost::any(*commentTime);
    }
    if (commentType) {
      res["commentType"] = boost::any(*commentType);
    }
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (deleted) {
      res["deleted"] = boost::any(*deleted);
    }
    if (filePath) {
      res["filePath"] = boost::any(*filePath);
    }
    if (lastEditTime) {
      res["lastEditTime"] = boost::any(*lastEditTime);
    }
    if (lineNumber) {
      res["lineNumber"] = boost::any(*lineNumber);
    }
    if (parentCommentBizId) {
      res["parentCommentBizId"] = boost::any(*parentCommentBizId);
    }
    if (relatedPatchSet) {
      res["relatedPatchSet"] = relatedPatchSet ? boost::any(relatedPatchSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resolved) {
      res["resolved"] = boost::any(*resolved);
    }
    if (rootCommentBizId) {
      res["rootCommentBizId"] = boost::any(*rootCommentBizId);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("author") != m.end() && !m["author"].empty()) {
      if (typeid(map<string, boost::any>) == m["author"].type()) {
        ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsAuthor model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["author"]));
        author = make_shared<ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsAuthor>(model1);
      }
    }
    if (m.find("commentBizId") != m.end() && !m["commentBizId"].empty()) {
      commentBizId = make_shared<string>(boost::any_cast<string>(m["commentBizId"]));
    }
    if (m.find("commentTime") != m.end() && !m["commentTime"].empty()) {
      commentTime = make_shared<string>(boost::any_cast<string>(m["commentTime"]));
    }
    if (m.find("commentType") != m.end() && !m["commentType"].empty()) {
      commentType = make_shared<string>(boost::any_cast<string>(m["commentType"]));
    }
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("deleted") != m.end() && !m["deleted"].empty()) {
      deleted = make_shared<bool>(boost::any_cast<bool>(m["deleted"]));
    }
    if (m.find("filePath") != m.end() && !m["filePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["filePath"]));
    }
    if (m.find("lastEditTime") != m.end() && !m["lastEditTime"].empty()) {
      lastEditTime = make_shared<string>(boost::any_cast<string>(m["lastEditTime"]));
    }
    if (m.find("lineNumber") != m.end() && !m["lineNumber"].empty()) {
      lineNumber = make_shared<string>(boost::any_cast<string>(m["lineNumber"]));
    }
    if (m.find("parentCommentBizId") != m.end() && !m["parentCommentBizId"].empty()) {
      parentCommentBizId = make_shared<string>(boost::any_cast<string>(m["parentCommentBizId"]));
    }
    if (m.find("relatedPatchSet") != m.end() && !m["relatedPatchSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["relatedPatchSet"].type()) {
        ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsRelatedPatchSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["relatedPatchSet"]));
        relatedPatchSet = make_shared<ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsRelatedPatchSet>(model1);
      }
    }
    if (m.find("resolved") != m.end() && !m["resolved"].empty()) {
      resolved = make_shared<bool>(boost::any_cast<bool>(m["resolved"]));
    }
    if (m.find("rootCommentBizId") != m.end() && !m["rootCommentBizId"].empty()) {
      rootCommentBizId = make_shared<string>(boost::any_cast<string>(m["rootCommentBizId"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
  }


  virtual ~ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildComments() = default;
};
class ListMergeRequestCommentsResponseBodyResultChildCommentsRelatedPatchSet : public Darabonba::Model {
public:
  shared_ptr<string> commitId{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> patchSetBizId{};
  shared_ptr<string> patchSetName{};
  shared_ptr<string> patchSetNo{};
  shared_ptr<string> relatedMergeItemType{};
  shared_ptr<string> shortId{};

  ListMergeRequestCommentsResponseBodyResultChildCommentsRelatedPatchSet() {}

  explicit ListMergeRequestCommentsResponseBodyResultChildCommentsRelatedPatchSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commitId) {
      res["commitId"] = boost::any(*commitId);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (patchSetBizId) {
      res["patchSetBizId"] = boost::any(*patchSetBizId);
    }
    if (patchSetName) {
      res["patchSetName"] = boost::any(*patchSetName);
    }
    if (patchSetNo) {
      res["patchSetNo"] = boost::any(*patchSetNo);
    }
    if (relatedMergeItemType) {
      res["relatedMergeItemType"] = boost::any(*relatedMergeItemType);
    }
    if (shortId) {
      res["shortId"] = boost::any(*shortId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commitId") != m.end() && !m["commitId"].empty()) {
      commitId = make_shared<string>(boost::any_cast<string>(m["commitId"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("patchSetBizId") != m.end() && !m["patchSetBizId"].empty()) {
      patchSetBizId = make_shared<string>(boost::any_cast<string>(m["patchSetBizId"]));
    }
    if (m.find("patchSetName") != m.end() && !m["patchSetName"].empty()) {
      patchSetName = make_shared<string>(boost::any_cast<string>(m["patchSetName"]));
    }
    if (m.find("patchSetNo") != m.end() && !m["patchSetNo"].empty()) {
      patchSetNo = make_shared<string>(boost::any_cast<string>(m["patchSetNo"]));
    }
    if (m.find("relatedMergeItemType") != m.end() && !m["relatedMergeItemType"].empty()) {
      relatedMergeItemType = make_shared<string>(boost::any_cast<string>(m["relatedMergeItemType"]));
    }
    if (m.find("shortId") != m.end() && !m["shortId"].empty()) {
      shortId = make_shared<string>(boost::any_cast<string>(m["shortId"]));
    }
  }


  virtual ~ListMergeRequestCommentsResponseBodyResultChildCommentsRelatedPatchSet() = default;
};
class ListMergeRequestCommentsResponseBodyResultChildComments : public Darabonba::Model {
public:
  shared_ptr<ListMergeRequestCommentsResponseBodyResultChildCommentsAuthor> author{};
  shared_ptr<string> commentBizId{};
  shared_ptr<string> commentTime{};
  shared_ptr<string> commentType{};
  shared_ptr<string> content{};
  shared_ptr<bool> deleted{};
  shared_ptr<string> filePath{};
  shared_ptr<vector<ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildComments>> finalChildComments{};
  shared_ptr<string> lastEditTime{};
  shared_ptr<string> lineNumber{};
  shared_ptr<string> parentCommentBizId{};
  shared_ptr<ListMergeRequestCommentsResponseBodyResultChildCommentsRelatedPatchSet> relatedPatchSet{};
  shared_ptr<bool> resolved{};
  shared_ptr<string> rootCommentBizId{};
  shared_ptr<string> state{};

  ListMergeRequestCommentsResponseBodyResultChildComments() {}

  explicit ListMergeRequestCommentsResponseBodyResultChildComments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (author) {
      res["author"] = author ? boost::any(author->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (commentBizId) {
      res["commentBizId"] = boost::any(*commentBizId);
    }
    if (commentTime) {
      res["commentTime"] = boost::any(*commentTime);
    }
    if (commentType) {
      res["commentType"] = boost::any(*commentType);
    }
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (deleted) {
      res["deleted"] = boost::any(*deleted);
    }
    if (filePath) {
      res["filePath"] = boost::any(*filePath);
    }
    if (finalChildComments) {
      vector<boost::any> temp1;
      for(auto item1:*finalChildComments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["finalChildComments"] = boost::any(temp1);
    }
    if (lastEditTime) {
      res["lastEditTime"] = boost::any(*lastEditTime);
    }
    if (lineNumber) {
      res["lineNumber"] = boost::any(*lineNumber);
    }
    if (parentCommentBizId) {
      res["parentCommentBizId"] = boost::any(*parentCommentBizId);
    }
    if (relatedPatchSet) {
      res["relatedPatchSet"] = relatedPatchSet ? boost::any(relatedPatchSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resolved) {
      res["resolved"] = boost::any(*resolved);
    }
    if (rootCommentBizId) {
      res["rootCommentBizId"] = boost::any(*rootCommentBizId);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("author") != m.end() && !m["author"].empty()) {
      if (typeid(map<string, boost::any>) == m["author"].type()) {
        ListMergeRequestCommentsResponseBodyResultChildCommentsAuthor model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["author"]));
        author = make_shared<ListMergeRequestCommentsResponseBodyResultChildCommentsAuthor>(model1);
      }
    }
    if (m.find("commentBizId") != m.end() && !m["commentBizId"].empty()) {
      commentBizId = make_shared<string>(boost::any_cast<string>(m["commentBizId"]));
    }
    if (m.find("commentTime") != m.end() && !m["commentTime"].empty()) {
      commentTime = make_shared<string>(boost::any_cast<string>(m["commentTime"]));
    }
    if (m.find("commentType") != m.end() && !m["commentType"].empty()) {
      commentType = make_shared<string>(boost::any_cast<string>(m["commentType"]));
    }
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("deleted") != m.end() && !m["deleted"].empty()) {
      deleted = make_shared<bool>(boost::any_cast<bool>(m["deleted"]));
    }
    if (m.find("filePath") != m.end() && !m["filePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["filePath"]));
    }
    if (m.find("finalChildComments") != m.end() && !m["finalChildComments"].empty()) {
      if (typeid(vector<boost::any>) == m["finalChildComments"].type()) {
        vector<ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildComments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["finalChildComments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildComments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        finalChildComments = make_shared<vector<ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildComments>>(expect1);
      }
    }
    if (m.find("lastEditTime") != m.end() && !m["lastEditTime"].empty()) {
      lastEditTime = make_shared<string>(boost::any_cast<string>(m["lastEditTime"]));
    }
    if (m.find("lineNumber") != m.end() && !m["lineNumber"].empty()) {
      lineNumber = make_shared<string>(boost::any_cast<string>(m["lineNumber"]));
    }
    if (m.find("parentCommentBizId") != m.end() && !m["parentCommentBizId"].empty()) {
      parentCommentBizId = make_shared<string>(boost::any_cast<string>(m["parentCommentBizId"]));
    }
    if (m.find("relatedPatchSet") != m.end() && !m["relatedPatchSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["relatedPatchSet"].type()) {
        ListMergeRequestCommentsResponseBodyResultChildCommentsRelatedPatchSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["relatedPatchSet"]));
        relatedPatchSet = make_shared<ListMergeRequestCommentsResponseBodyResultChildCommentsRelatedPatchSet>(model1);
      }
    }
    if (m.find("resolved") != m.end() && !m["resolved"].empty()) {
      resolved = make_shared<bool>(boost::any_cast<bool>(m["resolved"]));
    }
    if (m.find("rootCommentBizId") != m.end() && !m["rootCommentBizId"].empty()) {
      rootCommentBizId = make_shared<string>(boost::any_cast<string>(m["rootCommentBizId"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
  }


  virtual ~ListMergeRequestCommentsResponseBodyResultChildComments() = default;
};
class ListMergeRequestCommentsResponseBodyResultRelatedPatchSet : public Darabonba::Model {
public:
  shared_ptr<string> commitId{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> patchSetBizId{};
  shared_ptr<string> patchSetName{};
  shared_ptr<string> patchSetNo{};
  shared_ptr<string> relatedMergeItemType{};
  shared_ptr<string> shortId{};

  ListMergeRequestCommentsResponseBodyResultRelatedPatchSet() {}

  explicit ListMergeRequestCommentsResponseBodyResultRelatedPatchSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commitId) {
      res["commitId"] = boost::any(*commitId);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (patchSetBizId) {
      res["patchSetBizId"] = boost::any(*patchSetBizId);
    }
    if (patchSetName) {
      res["patchSetName"] = boost::any(*patchSetName);
    }
    if (patchSetNo) {
      res["patchSetNo"] = boost::any(*patchSetNo);
    }
    if (relatedMergeItemType) {
      res["relatedMergeItemType"] = boost::any(*relatedMergeItemType);
    }
    if (shortId) {
      res["shortId"] = boost::any(*shortId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commitId") != m.end() && !m["commitId"].empty()) {
      commitId = make_shared<string>(boost::any_cast<string>(m["commitId"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("patchSetBizId") != m.end() && !m["patchSetBizId"].empty()) {
      patchSetBizId = make_shared<string>(boost::any_cast<string>(m["patchSetBizId"]));
    }
    if (m.find("patchSetName") != m.end() && !m["patchSetName"].empty()) {
      patchSetName = make_shared<string>(boost::any_cast<string>(m["patchSetName"]));
    }
    if (m.find("patchSetNo") != m.end() && !m["patchSetNo"].empty()) {
      patchSetNo = make_shared<string>(boost::any_cast<string>(m["patchSetNo"]));
    }
    if (m.find("relatedMergeItemType") != m.end() && !m["relatedMergeItemType"].empty()) {
      relatedMergeItemType = make_shared<string>(boost::any_cast<string>(m["relatedMergeItemType"]));
    }
    if (m.find("shortId") != m.end() && !m["shortId"].empty()) {
      shortId = make_shared<string>(boost::any_cast<string>(m["shortId"]));
    }
  }


  virtual ~ListMergeRequestCommentsResponseBodyResultRelatedPatchSet() = default;
};
class ListMergeRequestCommentsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<ListMergeRequestCommentsResponseBodyResultAuthor> author{};
  shared_ptr<vector<ListMergeRequestCommentsResponseBodyResultChildComments>> childComments{};
  shared_ptr<string> commentBizId{};
  shared_ptr<string> commentTime{};
  shared_ptr<string> commentType{};
  shared_ptr<string> content{};
  shared_ptr<bool> deleted{};
  shared_ptr<string> filePath{};
  shared_ptr<string> lastEditTime{};
  shared_ptr<string> lineNumber{};
  shared_ptr<string> parentCommentBizId{};
  shared_ptr<ListMergeRequestCommentsResponseBodyResultRelatedPatchSet> relatedPatchSet{};
  shared_ptr<bool> resolved{};
  shared_ptr<string> rootCommentBizId{};
  shared_ptr<string> state{};

  ListMergeRequestCommentsResponseBodyResult() {}

  explicit ListMergeRequestCommentsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (author) {
      res["author"] = author ? boost::any(author->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (childComments) {
      vector<boost::any> temp1;
      for(auto item1:*childComments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["childComments"] = boost::any(temp1);
    }
    if (commentBizId) {
      res["commentBizId"] = boost::any(*commentBizId);
    }
    if (commentTime) {
      res["commentTime"] = boost::any(*commentTime);
    }
    if (commentType) {
      res["commentType"] = boost::any(*commentType);
    }
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (deleted) {
      res["deleted"] = boost::any(*deleted);
    }
    if (filePath) {
      res["filePath"] = boost::any(*filePath);
    }
    if (lastEditTime) {
      res["lastEditTime"] = boost::any(*lastEditTime);
    }
    if (lineNumber) {
      res["lineNumber"] = boost::any(*lineNumber);
    }
    if (parentCommentBizId) {
      res["parentCommentBizId"] = boost::any(*parentCommentBizId);
    }
    if (relatedPatchSet) {
      res["relatedPatchSet"] = relatedPatchSet ? boost::any(relatedPatchSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resolved) {
      res["resolved"] = boost::any(*resolved);
    }
    if (rootCommentBizId) {
      res["rootCommentBizId"] = boost::any(*rootCommentBizId);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("author") != m.end() && !m["author"].empty()) {
      if (typeid(map<string, boost::any>) == m["author"].type()) {
        ListMergeRequestCommentsResponseBodyResultAuthor model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["author"]));
        author = make_shared<ListMergeRequestCommentsResponseBodyResultAuthor>(model1);
      }
    }
    if (m.find("childComments") != m.end() && !m["childComments"].empty()) {
      if (typeid(vector<boost::any>) == m["childComments"].type()) {
        vector<ListMergeRequestCommentsResponseBodyResultChildComments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["childComments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMergeRequestCommentsResponseBodyResultChildComments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        childComments = make_shared<vector<ListMergeRequestCommentsResponseBodyResultChildComments>>(expect1);
      }
    }
    if (m.find("commentBizId") != m.end() && !m["commentBizId"].empty()) {
      commentBizId = make_shared<string>(boost::any_cast<string>(m["commentBizId"]));
    }
    if (m.find("commentTime") != m.end() && !m["commentTime"].empty()) {
      commentTime = make_shared<string>(boost::any_cast<string>(m["commentTime"]));
    }
    if (m.find("commentType") != m.end() && !m["commentType"].empty()) {
      commentType = make_shared<string>(boost::any_cast<string>(m["commentType"]));
    }
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("deleted") != m.end() && !m["deleted"].empty()) {
      deleted = make_shared<bool>(boost::any_cast<bool>(m["deleted"]));
    }
    if (m.find("filePath") != m.end() && !m["filePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["filePath"]));
    }
    if (m.find("lastEditTime") != m.end() && !m["lastEditTime"].empty()) {
      lastEditTime = make_shared<string>(boost::any_cast<string>(m["lastEditTime"]));
    }
    if (m.find("lineNumber") != m.end() && !m["lineNumber"].empty()) {
      lineNumber = make_shared<string>(boost::any_cast<string>(m["lineNumber"]));
    }
    if (m.find("parentCommentBizId") != m.end() && !m["parentCommentBizId"].empty()) {
      parentCommentBizId = make_shared<string>(boost::any_cast<string>(m["parentCommentBizId"]));
    }
    if (m.find("relatedPatchSet") != m.end() && !m["relatedPatchSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["relatedPatchSet"].type()) {
        ListMergeRequestCommentsResponseBodyResultRelatedPatchSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["relatedPatchSet"]));
        relatedPatchSet = make_shared<ListMergeRequestCommentsResponseBodyResultRelatedPatchSet>(model1);
      }
    }
    if (m.find("resolved") != m.end() && !m["resolved"].empty()) {
      resolved = make_shared<bool>(boost::any_cast<bool>(m["resolved"]));
    }
    if (m.find("rootCommentBizId") != m.end() && !m["rootCommentBizId"].empty()) {
      rootCommentBizId = make_shared<string>(boost::any_cast<string>(m["rootCommentBizId"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
  }


  virtual ~ListMergeRequestCommentsResponseBodyResult() = default;
};
class ListMergeRequestCommentsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListMergeRequestCommentsResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  ListMergeRequestCommentsResponseBody() {}

  explicit ListMergeRequestCommentsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ListMergeRequestCommentsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMergeRequestCommentsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListMergeRequestCommentsResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ListMergeRequestCommentsResponseBody() = default;
};
class ListMergeRequestCommentsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMergeRequestCommentsResponseBody> body{};

  ListMergeRequestCommentsResponse() {}

  explicit ListMergeRequestCommentsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMergeRequestCommentsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMergeRequestCommentsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMergeRequestCommentsResponse() = default;
};
class ListMergeRequestFilesReadsRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> fromPatchSetBizId{};
  shared_ptr<long> localId{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> repositoryIdentity{};
  shared_ptr<string> toPatchSetBizId{};

  ListMergeRequestFilesReadsRequest() {}

  explicit ListMergeRequestFilesReadsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (fromPatchSetBizId) {
      res["fromPatchSetBizId"] = boost::any(*fromPatchSetBizId);
    }
    if (localId) {
      res["localId"] = boost::any(*localId);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (repositoryIdentity) {
      res["repositoryIdentity"] = boost::any(*repositoryIdentity);
    }
    if (toPatchSetBizId) {
      res["toPatchSetBizId"] = boost::any(*toPatchSetBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("fromPatchSetBizId") != m.end() && !m["fromPatchSetBizId"].empty()) {
      fromPatchSetBizId = make_shared<string>(boost::any_cast<string>(m["fromPatchSetBizId"]));
    }
    if (m.find("localId") != m.end() && !m["localId"].empty()) {
      localId = make_shared<long>(boost::any_cast<long>(m["localId"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("repositoryIdentity") != m.end() && !m["repositoryIdentity"].empty()) {
      repositoryIdentity = make_shared<string>(boost::any_cast<string>(m["repositoryIdentity"]));
    }
    if (m.find("toPatchSetBizId") != m.end() && !m["toPatchSetBizId"].empty()) {
      toPatchSetBizId = make_shared<string>(boost::any_cast<string>(m["toPatchSetBizId"]));
    }
  }


  virtual ~ListMergeRequestFilesReadsRequest() = default;
};
class ListMergeRequestFilesReadsResponseBodyResultReadUsers : public Darabonba::Model {
public:
  shared_ptr<string> aliyunPk{};
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};

  ListMergeRequestFilesReadsResponseBodyResultReadUsers() {}

  explicit ListMergeRequestFilesReadsResponseBodyResultReadUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunPk) {
      res["aliyunPk"] = boost::any(*aliyunPk);
    }
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aliyunPk") != m.end() && !m["aliyunPk"].empty()) {
      aliyunPk = make_shared<string>(boost::any_cast<string>(m["aliyunPk"]));
    }
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~ListMergeRequestFilesReadsResponseBodyResultReadUsers() = default;
};
class ListMergeRequestFilesReadsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> deletedFile{};
  shared_ptr<bool> newFile{};
  shared_ptr<string> newFilePath{};
  shared_ptr<string> oldFilePath{};
  shared_ptr<vector<ListMergeRequestFilesReadsResponseBodyResultReadUsers>> readUsers{};
  shared_ptr<string> renamedFile{};

  ListMergeRequestFilesReadsResponseBodyResult() {}

  explicit ListMergeRequestFilesReadsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deletedFile) {
      res["deletedFile"] = boost::any(*deletedFile);
    }
    if (newFile) {
      res["newFile"] = boost::any(*newFile);
    }
    if (newFilePath) {
      res["newFilePath"] = boost::any(*newFilePath);
    }
    if (oldFilePath) {
      res["oldFilePath"] = boost::any(*oldFilePath);
    }
    if (readUsers) {
      vector<boost::any> temp1;
      for(auto item1:*readUsers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["readUsers"] = boost::any(temp1);
    }
    if (renamedFile) {
      res["renamedFile"] = boost::any(*renamedFile);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("deletedFile") != m.end() && !m["deletedFile"].empty()) {
      deletedFile = make_shared<string>(boost::any_cast<string>(m["deletedFile"]));
    }
    if (m.find("newFile") != m.end() && !m["newFile"].empty()) {
      newFile = make_shared<bool>(boost::any_cast<bool>(m["newFile"]));
    }
    if (m.find("newFilePath") != m.end() && !m["newFilePath"].empty()) {
      newFilePath = make_shared<string>(boost::any_cast<string>(m["newFilePath"]));
    }
    if (m.find("oldFilePath") != m.end() && !m["oldFilePath"].empty()) {
      oldFilePath = make_shared<string>(boost::any_cast<string>(m["oldFilePath"]));
    }
    if (m.find("readUsers") != m.end() && !m["readUsers"].empty()) {
      if (typeid(vector<boost::any>) == m["readUsers"].type()) {
        vector<ListMergeRequestFilesReadsResponseBodyResultReadUsers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["readUsers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMergeRequestFilesReadsResponseBodyResultReadUsers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        readUsers = make_shared<vector<ListMergeRequestFilesReadsResponseBodyResultReadUsers>>(expect1);
      }
    }
    if (m.find("renamedFile") != m.end() && !m["renamedFile"].empty()) {
      renamedFile = make_shared<string>(boost::any_cast<string>(m["renamedFile"]));
    }
  }


  virtual ~ListMergeRequestFilesReadsResponseBodyResult() = default;
};
class ListMergeRequestFilesReadsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListMergeRequestFilesReadsResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  ListMergeRequestFilesReadsResponseBody() {}

  explicit ListMergeRequestFilesReadsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ListMergeRequestFilesReadsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMergeRequestFilesReadsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListMergeRequestFilesReadsResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ListMergeRequestFilesReadsResponseBody() = default;
};
class ListMergeRequestFilesReadsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMergeRequestFilesReadsResponseBody> body{};

  ListMergeRequestFilesReadsResponse() {}

  explicit ListMergeRequestFilesReadsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMergeRequestFilesReadsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMergeRequestFilesReadsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMergeRequestFilesReadsResponse() = default;
};
class ListMergeRequestLabelsRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<long> localId{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> repositoryIdentity{};

  ListMergeRequestLabelsRequest() {}

  explicit ListMergeRequestLabelsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (localId) {
      res["localId"] = boost::any(*localId);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (repositoryIdentity) {
      res["repositoryIdentity"] = boost::any(*repositoryIdentity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("localId") != m.end() && !m["localId"].empty()) {
      localId = make_shared<long>(boost::any_cast<long>(m["localId"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("repositoryIdentity") != m.end() && !m["repositoryIdentity"].empty()) {
      repositoryIdentity = make_shared<string>(boost::any_cast<string>(m["repositoryIdentity"]));
    }
  }


  virtual ~ListMergeRequestLabelsRequest() = default;
};
class ListMergeRequestLabelsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> color{};
  shared_ptr<string> description{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  ListMergeRequestLabelsResponseBodyResult() {}

  explicit ListMergeRequestLabelsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (color) {
      res["color"] = boost::any(*color);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("color") != m.end() && !m["color"].empty()) {
      color = make_shared<string>(boost::any_cast<string>(m["color"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~ListMergeRequestLabelsResponseBodyResult() = default;
};
class ListMergeRequestLabelsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListMergeRequestLabelsResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  ListMergeRequestLabelsResponseBody() {}

  explicit ListMergeRequestLabelsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ListMergeRequestLabelsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMergeRequestLabelsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListMergeRequestLabelsResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ListMergeRequestLabelsResponseBody() = default;
};
class ListMergeRequestLabelsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMergeRequestLabelsResponseBody> body{};

  ListMergeRequestLabelsResponse() {}

  explicit ListMergeRequestLabelsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMergeRequestLabelsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMergeRequestLabelsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMergeRequestLabelsResponse() = default;
};
class ListMergeRequestPatchSetsRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<long> localId{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> repositoryIdentity{};

  ListMergeRequestPatchSetsRequest() {}

  explicit ListMergeRequestPatchSetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (localId) {
      res["localId"] = boost::any(*localId);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (repositoryIdentity) {
      res["repositoryIdentity"] = boost::any(*repositoryIdentity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("localId") != m.end() && !m["localId"].empty()) {
      localId = make_shared<long>(boost::any_cast<long>(m["localId"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("repositoryIdentity") != m.end() && !m["repositoryIdentity"].empty()) {
      repositoryIdentity = make_shared<string>(boost::any_cast<string>(m["repositoryIdentity"]));
    }
  }


  virtual ~ListMergeRequestPatchSetsRequest() = default;
};
class ListMergeRequestPatchSetsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> commitId{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> patchSetBizId{};
  shared_ptr<string> patchSetName{};
  shared_ptr<long> patchSetNo{};
  shared_ptr<string> relatedMergeItemType{};
  shared_ptr<string> shortCommitId{};

  ListMergeRequestPatchSetsResponseBodyResult() {}

  explicit ListMergeRequestPatchSetsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commitId) {
      res["commitId"] = boost::any(*commitId);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (patchSetBizId) {
      res["patchSetBizId"] = boost::any(*patchSetBizId);
    }
    if (patchSetName) {
      res["patchSetName"] = boost::any(*patchSetName);
    }
    if (patchSetNo) {
      res["patchSetNo"] = boost::any(*patchSetNo);
    }
    if (relatedMergeItemType) {
      res["relatedMergeItemType"] = boost::any(*relatedMergeItemType);
    }
    if (shortCommitId) {
      res["shortCommitId"] = boost::any(*shortCommitId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commitId") != m.end() && !m["commitId"].empty()) {
      commitId = make_shared<string>(boost::any_cast<string>(m["commitId"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("patchSetBizId") != m.end() && !m["patchSetBizId"].empty()) {
      patchSetBizId = make_shared<string>(boost::any_cast<string>(m["patchSetBizId"]));
    }
    if (m.find("patchSetName") != m.end() && !m["patchSetName"].empty()) {
      patchSetName = make_shared<string>(boost::any_cast<string>(m["patchSetName"]));
    }
    if (m.find("patchSetNo") != m.end() && !m["patchSetNo"].empty()) {
      patchSetNo = make_shared<long>(boost::any_cast<long>(m["patchSetNo"]));
    }
    if (m.find("relatedMergeItemType") != m.end() && !m["relatedMergeItemType"].empty()) {
      relatedMergeItemType = make_shared<string>(boost::any_cast<string>(m["relatedMergeItemType"]));
    }
    if (m.find("shortCommitId") != m.end() && !m["shortCommitId"].empty()) {
      shortCommitId = make_shared<string>(boost::any_cast<string>(m["shortCommitId"]));
    }
  }


  virtual ~ListMergeRequestPatchSetsResponseBodyResult() = default;
};
class ListMergeRequestPatchSetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListMergeRequestPatchSetsResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  ListMergeRequestPatchSetsResponseBody() {}

  explicit ListMergeRequestPatchSetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ListMergeRequestPatchSetsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMergeRequestPatchSetsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListMergeRequestPatchSetsResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ListMergeRequestPatchSetsResponseBody() = default;
};
class ListMergeRequestPatchSetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMergeRequestPatchSetsResponseBody> body{};

  ListMergeRequestPatchSetsResponse() {}

  explicit ListMergeRequestPatchSetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMergeRequestPatchSetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMergeRequestPatchSetsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMergeRequestPatchSetsResponse() = default;
};
class ListMergeRequestsRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> authorIds{};
  shared_ptr<string> createdAfter{};
  shared_ptr<string> createdBefore{};
  shared_ptr<string> filter{};
  shared_ptr<string> groupIds{};
  shared_ptr<string> labelIds{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> organizationId{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectIds{};
  shared_ptr<string> reviewerIds{};
  shared_ptr<string> search{};
  shared_ptr<string> sort{};
  shared_ptr<string> state{};

  ListMergeRequestsRequest() {}

  explicit ListMergeRequestsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (authorIds) {
      res["authorIds"] = boost::any(*authorIds);
    }
    if (createdAfter) {
      res["createdAfter"] = boost::any(*createdAfter);
    }
    if (createdBefore) {
      res["createdBefore"] = boost::any(*createdBefore);
    }
    if (filter) {
      res["filter"] = boost::any(*filter);
    }
    if (groupIds) {
      res["groupIds"] = boost::any(*groupIds);
    }
    if (labelIds) {
      res["labelIds"] = boost::any(*labelIds);
    }
    if (orderBy) {
      res["orderBy"] = boost::any(*orderBy);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (projectIds) {
      res["projectIds"] = boost::any(*projectIds);
    }
    if (reviewerIds) {
      res["reviewerIds"] = boost::any(*reviewerIds);
    }
    if (search) {
      res["search"] = boost::any(*search);
    }
    if (sort) {
      res["sort"] = boost::any(*sort);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("authorIds") != m.end() && !m["authorIds"].empty()) {
      authorIds = make_shared<string>(boost::any_cast<string>(m["authorIds"]));
    }
    if (m.find("createdAfter") != m.end() && !m["createdAfter"].empty()) {
      createdAfter = make_shared<string>(boost::any_cast<string>(m["createdAfter"]));
    }
    if (m.find("createdBefore") != m.end() && !m["createdBefore"].empty()) {
      createdBefore = make_shared<string>(boost::any_cast<string>(m["createdBefore"]));
    }
    if (m.find("filter") != m.end() && !m["filter"].empty()) {
      filter = make_shared<string>(boost::any_cast<string>(m["filter"]));
    }
    if (m.find("groupIds") != m.end() && !m["groupIds"].empty()) {
      groupIds = make_shared<string>(boost::any_cast<string>(m["groupIds"]));
    }
    if (m.find("labelIds") != m.end() && !m["labelIds"].empty()) {
      labelIds = make_shared<string>(boost::any_cast<string>(m["labelIds"]));
    }
    if (m.find("orderBy") != m.end() && !m["orderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["orderBy"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("projectIds") != m.end() && !m["projectIds"].empty()) {
      projectIds = make_shared<string>(boost::any_cast<string>(m["projectIds"]));
    }
    if (m.find("reviewerIds") != m.end() && !m["reviewerIds"].empty()) {
      reviewerIds = make_shared<string>(boost::any_cast<string>(m["reviewerIds"]));
    }
    if (m.find("search") != m.end() && !m["search"].empty()) {
      search = make_shared<string>(boost::any_cast<string>(m["search"]));
    }
    if (m.find("sort") != m.end() && !m["sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["sort"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
  }


  virtual ~ListMergeRequestsRequest() = default;
};
class ListMergeRequestsResponseBodyResultAuthor : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};

  ListMergeRequestsResponseBodyResultAuthor() {}

  explicit ListMergeRequestsResponseBodyResultAuthor(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~ListMergeRequestsResponseBodyResultAuthor() = default;
};
class ListMergeRequestsResponseBodyResultLabels : public Darabonba::Model {
public:
  shared_ptr<string> color{};
  shared_ptr<string> description{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  ListMergeRequestsResponseBodyResultLabels() {}

  explicit ListMergeRequestsResponseBodyResultLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (color) {
      res["color"] = boost::any(*color);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("color") != m.end() && !m["color"].empty()) {
      color = make_shared<string>(boost::any_cast<string>(m["color"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~ListMergeRequestsResponseBodyResultLabels() = default;
};
class ListMergeRequestsResponseBodyResultReviewers : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<bool> hasCommented{};
  shared_ptr<bool> hasReviewed{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> reviewOpinionStatus{};
  shared_ptr<string> reviewTime{};
  shared_ptr<string> state{};
  shared_ptr<string> status{};
  shared_ptr<string> username{};

  ListMergeRequestsResponseBodyResultReviewers() {}

  explicit ListMergeRequestsResponseBodyResultReviewers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (hasCommented) {
      res["hasCommented"] = boost::any(*hasCommented);
    }
    if (hasReviewed) {
      res["hasReviewed"] = boost::any(*hasReviewed);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (reviewOpinionStatus) {
      res["reviewOpinionStatus"] = boost::any(*reviewOpinionStatus);
    }
    if (reviewTime) {
      res["reviewTime"] = boost::any(*reviewTime);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("hasCommented") != m.end() && !m["hasCommented"].empty()) {
      hasCommented = make_shared<bool>(boost::any_cast<bool>(m["hasCommented"]));
    }
    if (m.find("hasReviewed") != m.end() && !m["hasReviewed"].empty()) {
      hasReviewed = make_shared<bool>(boost::any_cast<bool>(m["hasReviewed"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("reviewOpinionStatus") != m.end() && !m["reviewOpinionStatus"].empty()) {
      reviewOpinionStatus = make_shared<string>(boost::any_cast<string>(m["reviewOpinionStatus"]));
    }
    if (m.find("reviewTime") != m.end() && !m["reviewTime"].empty()) {
      reviewTime = make_shared<string>(boost::any_cast<string>(m["reviewTime"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~ListMergeRequestsResponseBodyResultReviewers() = default;
};
class ListMergeRequestsResponseBodyResultSubscribers : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};

  ListMergeRequestsResponseBodyResultSubscribers() {}

  explicit ListMergeRequestsResponseBodyResultSubscribers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~ListMergeRequestsResponseBodyResultSubscribers() = default;
};
class ListMergeRequestsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<ListMergeRequestsResponseBodyResultAuthor> author{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> creationMethod{};
  shared_ptr<string> description{};
  shared_ptr<string> detailUrl{};
  shared_ptr<long> id{};
  shared_ptr<long> iid{};
  shared_ptr<vector<ListMergeRequestsResponseBodyResultLabels>> labels{};
  shared_ptr<long> localId{};
  shared_ptr<string> mergedRevision{};
  shared_ptr<string> mrBizId{};
  shared_ptr<string> nameWithNamespace{};
  shared_ptr<bool> newMergeRequestIdentifier{};
  shared_ptr<string> newVersionState{};
  shared_ptr<long> projectId{};
  shared_ptr<vector<ListMergeRequestsResponseBodyResultReviewers>> reviewers{};
  shared_ptr<string> sourceBranch{};
  shared_ptr<long> sourceProjectId{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> sshUrl{};
  shared_ptr<string> state{};
  shared_ptr<vector<ListMergeRequestsResponseBodyResultSubscribers>> subscribers{};
  shared_ptr<bool> supportMergeFFOnly{};
  shared_ptr<string> targetBranch{};
  shared_ptr<long> targetProjectId{};
  shared_ptr<string> targetType{};
  shared_ptr<string> title{};
  shared_ptr<string> updatedAt{};
  shared_ptr<string> webUrl{};
  shared_ptr<bool> workInProgress{};

  ListMergeRequestsResponseBodyResult() {}

  explicit ListMergeRequestsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (author) {
      res["author"] = author ? boost::any(author->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (creationMethod) {
      res["creationMethod"] = boost::any(*creationMethod);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (detailUrl) {
      res["detailUrl"] = boost::any(*detailUrl);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (iid) {
      res["iid"] = boost::any(*iid);
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["labels"] = boost::any(temp1);
    }
    if (localId) {
      res["localId"] = boost::any(*localId);
    }
    if (mergedRevision) {
      res["mergedRevision"] = boost::any(*mergedRevision);
    }
    if (mrBizId) {
      res["mrBizId"] = boost::any(*mrBizId);
    }
    if (nameWithNamespace) {
      res["nameWithNamespace"] = boost::any(*nameWithNamespace);
    }
    if (newMergeRequestIdentifier) {
      res["newMergeRequestIdentifier"] = boost::any(*newMergeRequestIdentifier);
    }
    if (newVersionState) {
      res["newVersionState"] = boost::any(*newVersionState);
    }
    if (projectId) {
      res["projectId"] = boost::any(*projectId);
    }
    if (reviewers) {
      vector<boost::any> temp1;
      for(auto item1:*reviewers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["reviewers"] = boost::any(temp1);
    }
    if (sourceBranch) {
      res["sourceBranch"] = boost::any(*sourceBranch);
    }
    if (sourceProjectId) {
      res["sourceProjectId"] = boost::any(*sourceProjectId);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (sshUrl) {
      res["sshUrl"] = boost::any(*sshUrl);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (subscribers) {
      vector<boost::any> temp1;
      for(auto item1:*subscribers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["subscribers"] = boost::any(temp1);
    }
    if (supportMergeFFOnly) {
      res["supportMergeFFOnly"] = boost::any(*supportMergeFFOnly);
    }
    if (targetBranch) {
      res["targetBranch"] = boost::any(*targetBranch);
    }
    if (targetProjectId) {
      res["targetProjectId"] = boost::any(*targetProjectId);
    }
    if (targetType) {
      res["targetType"] = boost::any(*targetType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (updatedAt) {
      res["updatedAt"] = boost::any(*updatedAt);
    }
    if (webUrl) {
      res["webUrl"] = boost::any(*webUrl);
    }
    if (workInProgress) {
      res["workInProgress"] = boost::any(*workInProgress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("author") != m.end() && !m["author"].empty()) {
      if (typeid(map<string, boost::any>) == m["author"].type()) {
        ListMergeRequestsResponseBodyResultAuthor model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["author"]));
        author = make_shared<ListMergeRequestsResponseBodyResultAuthor>(model1);
      }
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("creationMethod") != m.end() && !m["creationMethod"].empty()) {
      creationMethod = make_shared<string>(boost::any_cast<string>(m["creationMethod"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("detailUrl") != m.end() && !m["detailUrl"].empty()) {
      detailUrl = make_shared<string>(boost::any_cast<string>(m["detailUrl"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("iid") != m.end() && !m["iid"].empty()) {
      iid = make_shared<long>(boost::any_cast<long>(m["iid"]));
    }
    if (m.find("labels") != m.end() && !m["labels"].empty()) {
      if (typeid(vector<boost::any>) == m["labels"].type()) {
        vector<ListMergeRequestsResponseBodyResultLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMergeRequestsResponseBodyResultLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<ListMergeRequestsResponseBodyResultLabels>>(expect1);
      }
    }
    if (m.find("localId") != m.end() && !m["localId"].empty()) {
      localId = make_shared<long>(boost::any_cast<long>(m["localId"]));
    }
    if (m.find("mergedRevision") != m.end() && !m["mergedRevision"].empty()) {
      mergedRevision = make_shared<string>(boost::any_cast<string>(m["mergedRevision"]));
    }
    if (m.find("mrBizId") != m.end() && !m["mrBizId"].empty()) {
      mrBizId = make_shared<string>(boost::any_cast<string>(m["mrBizId"]));
    }
    if (m.find("nameWithNamespace") != m.end() && !m["nameWithNamespace"].empty()) {
      nameWithNamespace = make_shared<string>(boost::any_cast<string>(m["nameWithNamespace"]));
    }
    if (m.find("newMergeRequestIdentifier") != m.end() && !m["newMergeRequestIdentifier"].empty()) {
      newMergeRequestIdentifier = make_shared<bool>(boost::any_cast<bool>(m["newMergeRequestIdentifier"]));
    }
    if (m.find("newVersionState") != m.end() && !m["newVersionState"].empty()) {
      newVersionState = make_shared<string>(boost::any_cast<string>(m["newVersionState"]));
    }
    if (m.find("projectId") != m.end() && !m["projectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["projectId"]));
    }
    if (m.find("reviewers") != m.end() && !m["reviewers"].empty()) {
      if (typeid(vector<boost::any>) == m["reviewers"].type()) {
        vector<ListMergeRequestsResponseBodyResultReviewers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["reviewers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMergeRequestsResponseBodyResultReviewers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reviewers = make_shared<vector<ListMergeRequestsResponseBodyResultReviewers>>(expect1);
      }
    }
    if (m.find("sourceBranch") != m.end() && !m["sourceBranch"].empty()) {
      sourceBranch = make_shared<string>(boost::any_cast<string>(m["sourceBranch"]));
    }
    if (m.find("sourceProjectId") != m.end() && !m["sourceProjectId"].empty()) {
      sourceProjectId = make_shared<long>(boost::any_cast<long>(m["sourceProjectId"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("sshUrl") != m.end() && !m["sshUrl"].empty()) {
      sshUrl = make_shared<string>(boost::any_cast<string>(m["sshUrl"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("subscribers") != m.end() && !m["subscribers"].empty()) {
      if (typeid(vector<boost::any>) == m["subscribers"].type()) {
        vector<ListMergeRequestsResponseBodyResultSubscribers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["subscribers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMergeRequestsResponseBodyResultSubscribers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subscribers = make_shared<vector<ListMergeRequestsResponseBodyResultSubscribers>>(expect1);
      }
    }
    if (m.find("supportMergeFFOnly") != m.end() && !m["supportMergeFFOnly"].empty()) {
      supportMergeFFOnly = make_shared<bool>(boost::any_cast<bool>(m["supportMergeFFOnly"]));
    }
    if (m.find("targetBranch") != m.end() && !m["targetBranch"].empty()) {
      targetBranch = make_shared<string>(boost::any_cast<string>(m["targetBranch"]));
    }
    if (m.find("targetProjectId") != m.end() && !m["targetProjectId"].empty()) {
      targetProjectId = make_shared<long>(boost::any_cast<long>(m["targetProjectId"]));
    }
    if (m.find("targetType") != m.end() && !m["targetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["targetType"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("updatedAt") != m.end() && !m["updatedAt"].empty()) {
      updatedAt = make_shared<string>(boost::any_cast<string>(m["updatedAt"]));
    }
    if (m.find("webUrl") != m.end() && !m["webUrl"].empty()) {
      webUrl = make_shared<string>(boost::any_cast<string>(m["webUrl"]));
    }
    if (m.find("workInProgress") != m.end() && !m["workInProgress"].empty()) {
      workInProgress = make_shared<bool>(boost::any_cast<bool>(m["workInProgress"]));
    }
  }


  virtual ~ListMergeRequestsResponseBodyResult() = default;
};
class ListMergeRequestsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListMergeRequestsResponseBodyResult>> result{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListMergeRequestsResponseBody() {}

  explicit ListMergeRequestsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ListMergeRequestsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMergeRequestsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListMergeRequestsResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
  }


  virtual ~ListMergeRequestsResponseBody() = default;
};
class ListMergeRequestsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMergeRequestsResponseBody> body{};

  ListMergeRequestsResponse() {}

  explicit ListMergeRequestsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMergeRequestsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMergeRequestsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMergeRequestsResponse() = default;
};
class ListOrganizationMembersRequest : public Darabonba::Model {
public:
  shared_ptr<bool> containsExternInfo{};
  shared_ptr<string> externUid{};
  shared_ptr<long> joinTimeFrom{};
  shared_ptr<long> joinTimeTo{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> organizationMemberName{};
  shared_ptr<string> provider{};
  shared_ptr<string> state{};

  ListOrganizationMembersRequest() {}

  explicit ListOrganizationMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containsExternInfo) {
      res["containsExternInfo"] = boost::any(*containsExternInfo);
    }
    if (externUid) {
      res["externUid"] = boost::any(*externUid);
    }
    if (joinTimeFrom) {
      res["joinTimeFrom"] = boost::any(*joinTimeFrom);
    }
    if (joinTimeTo) {
      res["joinTimeTo"] = boost::any(*joinTimeTo);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (organizationMemberName) {
      res["organizationMemberName"] = boost::any(*organizationMemberName);
    }
    if (provider) {
      res["provider"] = boost::any(*provider);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("containsExternInfo") != m.end() && !m["containsExternInfo"].empty()) {
      containsExternInfo = make_shared<bool>(boost::any_cast<bool>(m["containsExternInfo"]));
    }
    if (m.find("externUid") != m.end() && !m["externUid"].empty()) {
      externUid = make_shared<string>(boost::any_cast<string>(m["externUid"]));
    }
    if (m.find("joinTimeFrom") != m.end() && !m["joinTimeFrom"].empty()) {
      joinTimeFrom = make_shared<long>(boost::any_cast<long>(m["joinTimeFrom"]));
    }
    if (m.find("joinTimeTo") != m.end() && !m["joinTimeTo"].empty()) {
      joinTimeTo = make_shared<long>(boost::any_cast<long>(m["joinTimeTo"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("organizationMemberName") != m.end() && !m["organizationMemberName"].empty()) {
      organizationMemberName = make_shared<string>(boost::any_cast<string>(m["organizationMemberName"]));
    }
    if (m.find("provider") != m.end() && !m["provider"].empty()) {
      provider = make_shared<string>(boost::any_cast<string>(m["provider"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
  }


  virtual ~ListOrganizationMembersRequest() = default;
};
class ListOrganizationMembersResponseBodyMembersIdentities : public Darabonba::Model {
public:
  shared_ptr<string> externUid{};
  shared_ptr<string> provider{};

  ListOrganizationMembersResponseBodyMembersIdentities() {}

  explicit ListOrganizationMembersResponseBodyMembersIdentities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (externUid) {
      res["externUid"] = boost::any(*externUid);
    }
    if (provider) {
      res["provider"] = boost::any(*provider);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("externUid") != m.end() && !m["externUid"].empty()) {
      externUid = make_shared<string>(boost::any_cast<string>(m["externUid"]));
    }
    if (m.find("provider") != m.end() && !m["provider"].empty()) {
      provider = make_shared<string>(boost::any_cast<string>(m["provider"]));
    }
  }


  virtual ~ListOrganizationMembersResponseBodyMembersIdentities() = default;
};
class ListOrganizationMembersResponseBodyMembers : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<long> birthday{};
  shared_ptr<vector<string>> deptLists{};
  shared_ptr<string> email{};
  shared_ptr<long> hiredDate{};
  shared_ptr<ListOrganizationMembersResponseBodyMembersIdentities> identities{};
  shared_ptr<string> jobNumber{};
  shared_ptr<long> joinTime{};
  shared_ptr<long> lastVisitTime{};
  shared_ptr<string> mobile{};
  shared_ptr<string> organizationMemberName{};
  shared_ptr<string> organizationRoleId{};
  shared_ptr<string> organizationRoleName{};
  shared_ptr<string> state{};

  ListOrganizationMembersResponseBodyMembers() {}

  explicit ListOrganizationMembersResponseBodyMembers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    if (birthday) {
      res["birthday"] = boost::any(*birthday);
    }
    if (deptLists) {
      res["deptLists"] = boost::any(*deptLists);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (hiredDate) {
      res["hiredDate"] = boost::any(*hiredDate);
    }
    if (identities) {
      res["identities"] = identities ? boost::any(identities->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobNumber) {
      res["jobNumber"] = boost::any(*jobNumber);
    }
    if (joinTime) {
      res["joinTime"] = boost::any(*joinTime);
    }
    if (lastVisitTime) {
      res["lastVisitTime"] = boost::any(*lastVisitTime);
    }
    if (mobile) {
      res["mobile"] = boost::any(*mobile);
    }
    if (organizationMemberName) {
      res["organizationMemberName"] = boost::any(*organizationMemberName);
    }
    if (organizationRoleId) {
      res["organizationRoleId"] = boost::any(*organizationRoleId);
    }
    if (organizationRoleName) {
      res["organizationRoleName"] = boost::any(*organizationRoleName);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
    if (m.find("birthday") != m.end() && !m["birthday"].empty()) {
      birthday = make_shared<long>(boost::any_cast<long>(m["birthday"]));
    }
    if (m.find("deptLists") != m.end() && !m["deptLists"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["deptLists"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["deptLists"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deptLists = make_shared<vector<string>>(toVec1);
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("hiredDate") != m.end() && !m["hiredDate"].empty()) {
      hiredDate = make_shared<long>(boost::any_cast<long>(m["hiredDate"]));
    }
    if (m.find("identities") != m.end() && !m["identities"].empty()) {
      if (typeid(map<string, boost::any>) == m["identities"].type()) {
        ListOrganizationMembersResponseBodyMembersIdentities model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["identities"]));
        identities = make_shared<ListOrganizationMembersResponseBodyMembersIdentities>(model1);
      }
    }
    if (m.find("jobNumber") != m.end() && !m["jobNumber"].empty()) {
      jobNumber = make_shared<string>(boost::any_cast<string>(m["jobNumber"]));
    }
    if (m.find("joinTime") != m.end() && !m["joinTime"].empty()) {
      joinTime = make_shared<long>(boost::any_cast<long>(m["joinTime"]));
    }
    if (m.find("lastVisitTime") != m.end() && !m["lastVisitTime"].empty()) {
      lastVisitTime = make_shared<long>(boost::any_cast<long>(m["lastVisitTime"]));
    }
    if (m.find("mobile") != m.end() && !m["mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["mobile"]));
    }
    if (m.find("organizationMemberName") != m.end() && !m["organizationMemberName"].empty()) {
      organizationMemberName = make_shared<string>(boost::any_cast<string>(m["organizationMemberName"]));
    }
    if (m.find("organizationRoleId") != m.end() && !m["organizationRoleId"].empty()) {
      organizationRoleId = make_shared<string>(boost::any_cast<string>(m["organizationRoleId"]));
    }
    if (m.find("organizationRoleName") != m.end() && !m["organizationRoleName"].empty()) {
      organizationRoleName = make_shared<string>(boost::any_cast<string>(m["organizationRoleName"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
  }


  virtual ~ListOrganizationMembersResponseBodyMembers() = default;
};
class ListOrganizationMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<ListOrganizationMembersResponseBodyMembers>> members{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListOrganizationMembersResponseBody() {}

  explicit ListOrganizationMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (members) {
      vector<boost::any> temp1;
      for(auto item1:*members){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["members"] = boost::any(temp1);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("members") != m.end() && !m["members"].empty()) {
      if (typeid(vector<boost::any>) == m["members"].type()) {
        vector<ListOrganizationMembersResponseBodyMembers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["members"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOrganizationMembersResponseBodyMembers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        members = make_shared<vector<ListOrganizationMembersResponseBodyMembers>>(expect1);
      }
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ListOrganizationMembersResponseBody() = default;
};
class ListOrganizationMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListOrganizationMembersResponseBody> body{};

  ListOrganizationMembersResponse() {}

  explicit ListOrganizationMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOrganizationMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOrganizationMembersResponseBody>(model1);
      }
    }
  }


  virtual ~ListOrganizationMembersResponse() = default;
};
class ListOrganizationsRequest : public Darabonba::Model {
public:
  shared_ptr<long> accessLevel{};
  shared_ptr<string> accessToken{};
  shared_ptr<long> minAccessLevel{};

  ListOrganizationsRequest() {}

  explicit ListOrganizationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessLevel) {
      res["accessLevel"] = boost::any(*accessLevel);
    }
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (minAccessLevel) {
      res["minAccessLevel"] = boost::any(*minAccessLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessLevel") != m.end() && !m["accessLevel"].empty()) {
      accessLevel = make_shared<long>(boost::any_cast<long>(m["accessLevel"]));
    }
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("minAccessLevel") != m.end() && !m["minAccessLevel"].empty()) {
      minAccessLevel = make_shared<long>(boost::any_cast<long>(m["minAccessLevel"]));
    }
  }


  virtual ~ListOrganizationsRequest() = default;
};
class ListOrganizationsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> accessLevel{};
  shared_ptr<long> id{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> organizationAlias{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> organizationName{};
  shared_ptr<string> organizationRole{};

  ListOrganizationsResponseBodyResult() {}

  explicit ListOrganizationsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessLevel) {
      res["accessLevel"] = boost::any(*accessLevel);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (namespaceId) {
      res["namespaceId"] = boost::any(*namespaceId);
    }
    if (organizationAlias) {
      res["organizationAlias"] = boost::any(*organizationAlias);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (organizationName) {
      res["organizationName"] = boost::any(*organizationName);
    }
    if (organizationRole) {
      res["organizationRole"] = boost::any(*organizationRole);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessLevel") != m.end() && !m["accessLevel"].empty()) {
      accessLevel = make_shared<long>(boost::any_cast<long>(m["accessLevel"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("namespaceId") != m.end() && !m["namespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["namespaceId"]));
    }
    if (m.find("organizationAlias") != m.end() && !m["organizationAlias"].empty()) {
      organizationAlias = make_shared<string>(boost::any_cast<string>(m["organizationAlias"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("organizationName") != m.end() && !m["organizationName"].empty()) {
      organizationName = make_shared<string>(boost::any_cast<string>(m["organizationName"]));
    }
    if (m.find("organizationRole") != m.end() && !m["organizationRole"].empty()) {
      organizationRole = make_shared<string>(boost::any_cast<string>(m["organizationRole"]));
    }
  }


  virtual ~ListOrganizationsResponseBodyResult() = default;
};
class ListOrganizationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListOrganizationsResponseBodyResult>> result{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListOrganizationsResponseBody() {}

  explicit ListOrganizationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ListOrganizationsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOrganizationsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListOrganizationsResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
  }


  virtual ~ListOrganizationsResponseBody() = default;
};
class ListOrganizationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListOrganizationsResponseBody> body{};

  ListOrganizationsResponse() {}

  explicit ListOrganizationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOrganizationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOrganizationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListOrganizationsResponse() = default;
};
class ListPipelineGroupPipelinesRequest : public Darabonba::Model {
public:
  shared_ptr<long> createEndTime{};
  shared_ptr<long> createStartTime{};
  shared_ptr<long> executeEndTime{};
  shared_ptr<long> executeStartTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> pipelineName{};
  shared_ptr<string> resultStatusList{};

  ListPipelineGroupPipelinesRequest() {}

  explicit ListPipelineGroupPipelinesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createEndTime) {
      res["createEndTime"] = boost::any(*createEndTime);
    }
    if (createStartTime) {
      res["createStartTime"] = boost::any(*createStartTime);
    }
    if (executeEndTime) {
      res["executeEndTime"] = boost::any(*executeEndTime);
    }
    if (executeStartTime) {
      res["executeStartTime"] = boost::any(*executeStartTime);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (pipelineName) {
      res["pipelineName"] = boost::any(*pipelineName);
    }
    if (resultStatusList) {
      res["resultStatusList"] = boost::any(*resultStatusList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createEndTime") != m.end() && !m["createEndTime"].empty()) {
      createEndTime = make_shared<long>(boost::any_cast<long>(m["createEndTime"]));
    }
    if (m.find("createStartTime") != m.end() && !m["createStartTime"].empty()) {
      createStartTime = make_shared<long>(boost::any_cast<long>(m["createStartTime"]));
    }
    if (m.find("executeEndTime") != m.end() && !m["executeEndTime"].empty()) {
      executeEndTime = make_shared<long>(boost::any_cast<long>(m["executeEndTime"]));
    }
    if (m.find("executeStartTime") != m.end() && !m["executeStartTime"].empty()) {
      executeStartTime = make_shared<long>(boost::any_cast<long>(m["executeStartTime"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("pipelineName") != m.end() && !m["pipelineName"].empty()) {
      pipelineName = make_shared<string>(boost::any_cast<string>(m["pipelineName"]));
    }
    if (m.find("resultStatusList") != m.end() && !m["resultStatusList"].empty()) {
      resultStatusList = make_shared<string>(boost::any_cast<string>(m["resultStatusList"]));
    }
  }


  virtual ~ListPipelineGroupPipelinesRequest() = default;
};
class ListPipelineGroupPipelinesResponseBodyPipelines : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> pipelineId{};
  shared_ptr<string> pipelineName{};

  ListPipelineGroupPipelinesResponseBodyPipelines() {}

  explicit ListPipelineGroupPipelinesResponseBodyPipelines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (pipelineId) {
      res["pipelineId"] = boost::any(*pipelineId);
    }
    if (pipelineName) {
      res["pipelineName"] = boost::any(*pipelineName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["createTime"]));
    }
    if (m.find("pipelineId") != m.end() && !m["pipelineId"].empty()) {
      pipelineId = make_shared<long>(boost::any_cast<long>(m["pipelineId"]));
    }
    if (m.find("pipelineName") != m.end() && !m["pipelineName"].empty()) {
      pipelineName = make_shared<string>(boost::any_cast<string>(m["pipelineName"]));
    }
  }


  virtual ~ListPipelineGroupPipelinesResponseBodyPipelines() = default;
};
class ListPipelineGroupPipelinesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ListPipelineGroupPipelinesResponseBodyPipelines>> pipelines{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListPipelineGroupPipelinesResponseBody() {}

  explicit ListPipelineGroupPipelinesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (pipelines) {
      vector<boost::any> temp1;
      for(auto item1:*pipelines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["pipelines"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("pipelines") != m.end() && !m["pipelines"].empty()) {
      if (typeid(vector<boost::any>) == m["pipelines"].type()) {
        vector<ListPipelineGroupPipelinesResponseBodyPipelines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["pipelines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPipelineGroupPipelinesResponseBodyPipelines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pipelines = make_shared<vector<ListPipelineGroupPipelinesResponseBodyPipelines>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ListPipelineGroupPipelinesResponseBody() = default;
};
class ListPipelineGroupPipelinesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPipelineGroupPipelinesResponseBody> body{};

  ListPipelineGroupPipelinesResponse() {}

  explicit ListPipelineGroupPipelinesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPipelineGroupPipelinesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPipelineGroupPipelinesResponseBody>(model1);
      }
    }
  }


  virtual ~ListPipelineGroupPipelinesResponse() = default;
};
class ListPipelineGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  ListPipelineGroupsRequest() {}

  explicit ListPipelineGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
  }


  virtual ~ListPipelineGroupsRequest() = default;
};
class ListPipelineGroupsResponseBodyPipelineGroups : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  ListPipelineGroupsResponseBodyPipelineGroups() {}

  explicit ListPipelineGroupsResponseBodyPipelineGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["createTime"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~ListPipelineGroupsResponseBodyPipelineGroups() = default;
};
class ListPipelineGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ListPipelineGroupsResponseBodyPipelineGroups>> pipelineGroups{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListPipelineGroupsResponseBody() {}

  explicit ListPipelineGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (pipelineGroups) {
      vector<boost::any> temp1;
      for(auto item1:*pipelineGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["pipelineGroups"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("pipelineGroups") != m.end() && !m["pipelineGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["pipelineGroups"].type()) {
        vector<ListPipelineGroupsResponseBodyPipelineGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["pipelineGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPipelineGroupsResponseBodyPipelineGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pipelineGroups = make_shared<vector<ListPipelineGroupsResponseBodyPipelineGroups>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ListPipelineGroupsResponseBody() = default;
};
class ListPipelineGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPipelineGroupsResponseBody> body{};

  ListPipelineGroupsResponse() {}

  explicit ListPipelineGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPipelineGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPipelineGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListPipelineGroupsResponse() = default;
};
class ListPipelineJobHistorysRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> identifier{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  ListPipelineJobHistorysRequest() {}

  explicit ListPipelineJobHistorysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["category"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
  }


  virtual ~ListPipelineJobHistorysRequest() = default;
};
class ListPipelineJobHistorysResponseBodyJobs : public Darabonba::Model {
public:
  shared_ptr<long> executeNumber{};
  shared_ptr<string> identifier{};
  shared_ptr<long> jobId{};
  shared_ptr<string> jobName{};
  shared_ptr<string> operatorAccountId{};
  shared_ptr<long> pipelineId{};
  shared_ptr<long> pipelineRunId{};
  shared_ptr<string> sources{};
  shared_ptr<string> status{};

  ListPipelineJobHistorysResponseBodyJobs() {}

  explicit ListPipelineJobHistorysResponseBodyJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (executeNumber) {
      res["executeNumber"] = boost::any(*executeNumber);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (jobId) {
      res["jobId"] = boost::any(*jobId);
    }
    if (jobName) {
      res["jobName"] = boost::any(*jobName);
    }
    if (operatorAccountId) {
      res["operatorAccountId"] = boost::any(*operatorAccountId);
    }
    if (pipelineId) {
      res["pipelineId"] = boost::any(*pipelineId);
    }
    if (pipelineRunId) {
      res["pipelineRunId"] = boost::any(*pipelineRunId);
    }
    if (sources) {
      res["sources"] = boost::any(*sources);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("executeNumber") != m.end() && !m["executeNumber"].empty()) {
      executeNumber = make_shared<long>(boost::any_cast<long>(m["executeNumber"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("jobId") != m.end() && !m["jobId"].empty()) {
      jobId = make_shared<long>(boost::any_cast<long>(m["jobId"]));
    }
    if (m.find("jobName") != m.end() && !m["jobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["jobName"]));
    }
    if (m.find("operatorAccountId") != m.end() && !m["operatorAccountId"].empty()) {
      operatorAccountId = make_shared<string>(boost::any_cast<string>(m["operatorAccountId"]));
    }
    if (m.find("pipelineId") != m.end() && !m["pipelineId"].empty()) {
      pipelineId = make_shared<long>(boost::any_cast<long>(m["pipelineId"]));
    }
    if (m.find("pipelineRunId") != m.end() && !m["pipelineRunId"].empty()) {
      pipelineRunId = make_shared<long>(boost::any_cast<long>(m["pipelineRunId"]));
    }
    if (m.find("sources") != m.end() && !m["sources"].empty()) {
      sources = make_shared<string>(boost::any_cast<string>(m["sources"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~ListPipelineJobHistorysResponseBodyJobs() = default;
};
class ListPipelineJobHistorysResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<ListPipelineJobHistorysResponseBodyJobs>> jobs{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListPipelineJobHistorysResponseBody() {}

  explicit ListPipelineJobHistorysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (jobs) {
      vector<boost::any> temp1;
      for(auto item1:*jobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["jobs"] = boost::any(temp1);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("jobs") != m.end() && !m["jobs"].empty()) {
      if (typeid(vector<boost::any>) == m["jobs"].type()) {
        vector<ListPipelineJobHistorysResponseBodyJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["jobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPipelineJobHistorysResponseBodyJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobs = make_shared<vector<ListPipelineJobHistorysResponseBodyJobs>>(expect1);
      }
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ListPipelineJobHistorysResponseBody() = default;
};
class ListPipelineJobHistorysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPipelineJobHistorysResponseBody> body{};

  ListPipelineJobHistorysResponse() {}

  explicit ListPipelineJobHistorysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPipelineJobHistorysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPipelineJobHistorysResponseBody>(model1);
      }
    }
  }


  virtual ~ListPipelineJobHistorysResponse() = default;
};
class ListPipelineJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};

  ListPipelineJobsRequest() {}

  explicit ListPipelineJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["category"] = boost::any(*category);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["category"]));
    }
  }


  virtual ~ListPipelineJobsRequest() = default;
};
class ListPipelineJobsResponseBodyJobs : public Darabonba::Model {
public:
  shared_ptr<string> identifier{};
  shared_ptr<string> jobName{};
  shared_ptr<long> lastJobId{};
  shared_ptr<string> lastJobParams{};

  ListPipelineJobsResponseBodyJobs() {}

  explicit ListPipelineJobsResponseBodyJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (jobName) {
      res["jobName"] = boost::any(*jobName);
    }
    if (lastJobId) {
      res["lastJobId"] = boost::any(*lastJobId);
    }
    if (lastJobParams) {
      res["lastJobParams"] = boost::any(*lastJobParams);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("jobName") != m.end() && !m["jobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["jobName"]));
    }
    if (m.find("lastJobId") != m.end() && !m["lastJobId"].empty()) {
      lastJobId = make_shared<long>(boost::any_cast<long>(m["lastJobId"]));
    }
    if (m.find("lastJobParams") != m.end() && !m["lastJobParams"].empty()) {
      lastJobParams = make_shared<string>(boost::any_cast<string>(m["lastJobParams"]));
    }
  }


  virtual ~ListPipelineJobsResponseBodyJobs() = default;
};
class ListPipelineJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<ListPipelineJobsResponseBodyJobs>> jobs{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListPipelineJobsResponseBody() {}

  explicit ListPipelineJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (jobs) {
      vector<boost::any> temp1;
      for(auto item1:*jobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["jobs"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("jobs") != m.end() && !m["jobs"].empty()) {
      if (typeid(vector<boost::any>) == m["jobs"].type()) {
        vector<ListPipelineJobsResponseBodyJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["jobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPipelineJobsResponseBodyJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobs = make_shared<vector<ListPipelineJobsResponseBodyJobs>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ListPipelineJobsResponseBody() = default;
};
class ListPipelineJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPipelineJobsResponseBody> body{};

  ListPipelineJobsResponse() {}

  explicit ListPipelineJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPipelineJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPipelineJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListPipelineJobsResponse() = default;
};
class ListPipelineRelationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> relObjectType{};

  ListPipelineRelationsRequest() {}

  explicit ListPipelineRelationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (relObjectType) {
      res["relObjectType"] = boost::any(*relObjectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("relObjectType") != m.end() && !m["relObjectType"].empty()) {
      relObjectType = make_shared<string>(boost::any_cast<string>(m["relObjectType"]));
    }
  }


  virtual ~ListPipelineRelationsRequest() = default;
};
class ListPipelineRelationsResponseBodyPipelineRelations : public Darabonba::Model {
public:
  shared_ptr<long> refObjectId{};

  ListPipelineRelationsResponseBodyPipelineRelations() {}

  explicit ListPipelineRelationsResponseBodyPipelineRelations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (refObjectId) {
      res["refObjectId"] = boost::any(*refObjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("refObjectId") != m.end() && !m["refObjectId"].empty()) {
      refObjectId = make_shared<long>(boost::any_cast<long>(m["refObjectId"]));
    }
  }


  virtual ~ListPipelineRelationsResponseBodyPipelineRelations() = default;
};
class ListPipelineRelationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<ListPipelineRelationsResponseBodyPipelineRelations>> pipelineRelations{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListPipelineRelationsResponseBody() {}

  explicit ListPipelineRelationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (pipelineRelations) {
      vector<boost::any> temp1;
      for(auto item1:*pipelineRelations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["pipelineRelations"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("pipelineRelations") != m.end() && !m["pipelineRelations"].empty()) {
      if (typeid(vector<boost::any>) == m["pipelineRelations"].type()) {
        vector<ListPipelineRelationsResponseBodyPipelineRelations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["pipelineRelations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPipelineRelationsResponseBodyPipelineRelations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pipelineRelations = make_shared<vector<ListPipelineRelationsResponseBodyPipelineRelations>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ListPipelineRelationsResponseBody() = default;
};
class ListPipelineRelationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPipelineRelationsResponseBody> body{};

  ListPipelineRelationsResponse() {}

  explicit ListPipelineRelationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPipelineRelationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPipelineRelationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListPipelineRelationsResponse() = default;
};
class ListPipelineRunsRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};
  shared_ptr<long> triggerMode{};

  ListPipelineRunsRequest() {}

  explicit ListPipelineRunsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (triggerMode) {
      res["triggerMode"] = boost::any(*triggerMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("triggerMode") != m.end() && !m["triggerMode"].empty()) {
      triggerMode = make_shared<long>(boost::any_cast<long>(m["triggerMode"]));
    }
  }


  virtual ~ListPipelineRunsRequest() = default;
};
class ListPipelineRunsResponseBodyPipelineRuns : public Darabonba::Model {
public:
  shared_ptr<string> creatorAccountId{};
  shared_ptr<long> endTime{};
  shared_ptr<long> pipelineId{};
  shared_ptr<long> pipelineRunId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};
  shared_ptr<long> triggerMode{};

  ListPipelineRunsResponseBodyPipelineRuns() {}

  explicit ListPipelineRunsResponseBodyPipelineRuns(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creatorAccountId) {
      res["creatorAccountId"] = boost::any(*creatorAccountId);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (pipelineId) {
      res["pipelineId"] = boost::any(*pipelineId);
    }
    if (pipelineRunId) {
      res["pipelineRunId"] = boost::any(*pipelineRunId);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (triggerMode) {
      res["triggerMode"] = boost::any(*triggerMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("creatorAccountId") != m.end() && !m["creatorAccountId"].empty()) {
      creatorAccountId = make_shared<string>(boost::any_cast<string>(m["creatorAccountId"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("pipelineId") != m.end() && !m["pipelineId"].empty()) {
      pipelineId = make_shared<long>(boost::any_cast<long>(m["pipelineId"]));
    }
    if (m.find("pipelineRunId") != m.end() && !m["pipelineRunId"].empty()) {
      pipelineRunId = make_shared<long>(boost::any_cast<long>(m["pipelineRunId"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("triggerMode") != m.end() && !m["triggerMode"].empty()) {
      triggerMode = make_shared<long>(boost::any_cast<long>(m["triggerMode"]));
    }
  }


  virtual ~ListPipelineRunsResponseBodyPipelineRuns() = default;
};
class ListPipelineRunsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ListPipelineRunsResponseBodyPipelineRuns>> pipelineRuns{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListPipelineRunsResponseBody() {}

  explicit ListPipelineRunsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (pipelineRuns) {
      vector<boost::any> temp1;
      for(auto item1:*pipelineRuns){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["pipelineRuns"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("pipelineRuns") != m.end() && !m["pipelineRuns"].empty()) {
      if (typeid(vector<boost::any>) == m["pipelineRuns"].type()) {
        vector<ListPipelineRunsResponseBodyPipelineRuns> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["pipelineRuns"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPipelineRunsResponseBodyPipelineRuns model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pipelineRuns = make_shared<vector<ListPipelineRunsResponseBodyPipelineRuns>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ListPipelineRunsResponseBody() = default;
};
class ListPipelineRunsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPipelineRunsResponseBody> body{};

  ListPipelineRunsResponse() {}

  explicit ListPipelineRunsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPipelineRunsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPipelineRunsResponseBody>(model1);
      }
    }
  }


  virtual ~ListPipelineRunsResponse() = default;
};
class ListPipelinesRequest : public Darabonba::Model {
public:
  shared_ptr<long> createEndTime{};
  shared_ptr<long> createStartTime{};
  shared_ptr<string> creatorAccountIds{};
  shared_ptr<string> executeAccountIds{};
  shared_ptr<long> executeEndTime{};
  shared_ptr<long> executeStartTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> pipelineName{};
  shared_ptr<string> statusList{};

  ListPipelinesRequest() {}

  explicit ListPipelinesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createEndTime) {
      res["createEndTime"] = boost::any(*createEndTime);
    }
    if (createStartTime) {
      res["createStartTime"] = boost::any(*createStartTime);
    }
    if (creatorAccountIds) {
      res["creatorAccountIds"] = boost::any(*creatorAccountIds);
    }
    if (executeAccountIds) {
      res["executeAccountIds"] = boost::any(*executeAccountIds);
    }
    if (executeEndTime) {
      res["executeEndTime"] = boost::any(*executeEndTime);
    }
    if (executeStartTime) {
      res["executeStartTime"] = boost::any(*executeStartTime);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (pipelineName) {
      res["pipelineName"] = boost::any(*pipelineName);
    }
    if (statusList) {
      res["statusList"] = boost::any(*statusList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createEndTime") != m.end() && !m["createEndTime"].empty()) {
      createEndTime = make_shared<long>(boost::any_cast<long>(m["createEndTime"]));
    }
    if (m.find("createStartTime") != m.end() && !m["createStartTime"].empty()) {
      createStartTime = make_shared<long>(boost::any_cast<long>(m["createStartTime"]));
    }
    if (m.find("creatorAccountIds") != m.end() && !m["creatorAccountIds"].empty()) {
      creatorAccountIds = make_shared<string>(boost::any_cast<string>(m["creatorAccountIds"]));
    }
    if (m.find("executeAccountIds") != m.end() && !m["executeAccountIds"].empty()) {
      executeAccountIds = make_shared<string>(boost::any_cast<string>(m["executeAccountIds"]));
    }
    if (m.find("executeEndTime") != m.end() && !m["executeEndTime"].empty()) {
      executeEndTime = make_shared<long>(boost::any_cast<long>(m["executeEndTime"]));
    }
    if (m.find("executeStartTime") != m.end() && !m["executeStartTime"].empty()) {
      executeStartTime = make_shared<long>(boost::any_cast<long>(m["executeStartTime"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("pipelineName") != m.end() && !m["pipelineName"].empty()) {
      pipelineName = make_shared<string>(boost::any_cast<string>(m["pipelineName"]));
    }
    if (m.find("statusList") != m.end() && !m["statusList"].empty()) {
      statusList = make_shared<string>(boost::any_cast<string>(m["statusList"]));
    }
  }


  virtual ~ListPipelinesRequest() = default;
};
class ListPipelinesResponseBodyPipelines : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> creatorAccountId{};
  shared_ptr<long> groupId{};
  shared_ptr<long> pipelineId{};
  shared_ptr<string> pipelineName{};

  ListPipelinesResponseBodyPipelines() {}

  explicit ListPipelinesResponseBodyPipelines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (creatorAccountId) {
      res["creatorAccountId"] = boost::any(*creatorAccountId);
    }
    if (groupId) {
      res["groupId"] = boost::any(*groupId);
    }
    if (pipelineId) {
      res["pipelineId"] = boost::any(*pipelineId);
    }
    if (pipelineName) {
      res["pipelineName"] = boost::any(*pipelineName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["createTime"]));
    }
    if (m.find("creatorAccountId") != m.end() && !m["creatorAccountId"].empty()) {
      creatorAccountId = make_shared<string>(boost::any_cast<string>(m["creatorAccountId"]));
    }
    if (m.find("groupId") != m.end() && !m["groupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["groupId"]));
    }
    if (m.find("pipelineId") != m.end() && !m["pipelineId"].empty()) {
      pipelineId = make_shared<long>(boost::any_cast<long>(m["pipelineId"]));
    }
    if (m.find("pipelineName") != m.end() && !m["pipelineName"].empty()) {
      pipelineName = make_shared<string>(boost::any_cast<string>(m["pipelineName"]));
    }
  }


  virtual ~ListPipelinesResponseBodyPipelines() = default;
};
class ListPipelinesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ListPipelinesResponseBodyPipelines>> pipelines{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListPipelinesResponseBody() {}

  explicit ListPipelinesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (pipelines) {
      vector<boost::any> temp1;
      for(auto item1:*pipelines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["pipelines"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("pipelines") != m.end() && !m["pipelines"].empty()) {
      if (typeid(vector<boost::any>) == m["pipelines"].type()) {
        vector<ListPipelinesResponseBodyPipelines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["pipelines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPipelinesResponseBodyPipelines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pipelines = make_shared<vector<ListPipelinesResponseBodyPipelines>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ListPipelinesResponseBody() = default;
};
class ListPipelinesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPipelinesResponseBody> body{};

  ListPipelinesResponse() {}

  explicit ListPipelinesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPipelinesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPipelinesResponseBody>(model1);
      }
    }
  }


  virtual ~ListPipelinesResponse() = default;
};
class ListProjectLabelsRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> organizationId{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> repositoryIdentity{};
  shared_ptr<string> search{};
  shared_ptr<string> sort{};
  shared_ptr<bool> withCounts{};

  ListProjectLabelsRequest() {}

  explicit ListProjectLabelsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (orderBy) {
      res["orderBy"] = boost::any(*orderBy);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (repositoryIdentity) {
      res["repositoryIdentity"] = boost::any(*repositoryIdentity);
    }
    if (search) {
      res["search"] = boost::any(*search);
    }
    if (sort) {
      res["sort"] = boost::any(*sort);
    }
    if (withCounts) {
      res["withCounts"] = boost::any(*withCounts);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("orderBy") != m.end() && !m["orderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["orderBy"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("repositoryIdentity") != m.end() && !m["repositoryIdentity"].empty()) {
      repositoryIdentity = make_shared<string>(boost::any_cast<string>(m["repositoryIdentity"]));
    }
    if (m.find("search") != m.end() && !m["search"].empty()) {
      search = make_shared<string>(boost::any_cast<string>(m["search"]));
    }
    if (m.find("sort") != m.end() && !m["sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["sort"]));
    }
    if (m.find("withCounts") != m.end() && !m["withCounts"].empty()) {
      withCounts = make_shared<bool>(boost::any_cast<bool>(m["withCounts"]));
    }
  }


  virtual ~ListProjectLabelsRequest() = default;
};
class ListProjectLabelsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> color{};
  shared_ptr<string> description{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<long> openMergeRequestsCount{};

  ListProjectLabelsResponseBodyResult() {}

  explicit ListProjectLabelsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (color) {
      res["color"] = boost::any(*color);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (openMergeRequestsCount) {
      res["openMergeRequestsCount"] = boost::any(*openMergeRequestsCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("color") != m.end() && !m["color"].empty()) {
      color = make_shared<string>(boost::any_cast<string>(m["color"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("openMergeRequestsCount") != m.end() && !m["openMergeRequestsCount"].empty()) {
      openMergeRequestsCount = make_shared<long>(boost::any_cast<long>(m["openMergeRequestsCount"]));
    }
  }


  virtual ~ListProjectLabelsResponseBodyResult() = default;
};
class ListProjectLabelsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListProjectLabelsResponseBodyResult>> result{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListProjectLabelsResponseBody() {}

  explicit ListProjectLabelsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ListProjectLabelsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectLabelsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListProjectLabelsResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
  }


  virtual ~ListProjectLabelsResponseBody() = default;
};
class ListProjectLabelsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListProjectLabelsResponseBody> body{};

  ListProjectLabelsResponse() {}

  explicit ListProjectLabelsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProjectLabelsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProjectLabelsResponseBody>(model1);
      }
    }
  }


  virtual ~ListProjectLabelsResponse() = default;
};
class ListProjectMembersRequest : public Darabonba::Model {
public:
  shared_ptr<string> targetType{};

  ListProjectMembersRequest() {}

  explicit ListProjectMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetType) {
      res["targetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("targetType") != m.end() && !m["targetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["targetType"]));
    }
  }


  virtual ~ListProjectMembersRequest() = default;
};
class ListProjectMembersResponseBodyMembersDivision : public Darabonba::Model {
public:
  shared_ptr<string> identifier{};

  ListProjectMembersResponseBodyMembersDivision() {}

  explicit ListProjectMembersResponseBodyMembersDivision(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
  }


  virtual ~ListProjectMembersResponseBodyMembersDivision() = default;
};
class ListProjectMembersResponseBodyMembersOrganizationUserInfo : public Darabonba::Model {
public:
  shared_ptr<string> organizationIdentifier{};

  ListProjectMembersResponseBodyMembersOrganizationUserInfo() {}

  explicit ListProjectMembersResponseBodyMembersOrganizationUserInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationIdentifier) {
      res["organizationIdentifier"] = boost::any(*organizationIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("organizationIdentifier") != m.end() && !m["organizationIdentifier"].empty()) {
      organizationIdentifier = make_shared<string>(boost::any_cast<string>(m["organizationIdentifier"]));
    }
  }


  virtual ~ListProjectMembersResponseBodyMembersOrganizationUserInfo() = default;
};
class ListProjectMembersResponseBodyMembers : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> avatar{};
  shared_ptr<string> dingTalkId{};
  shared_ptr<string> displayName{};
  shared_ptr<string> displayNickName{};
  shared_ptr<string> displayRealName{};
  shared_ptr<ListProjectMembersResponseBodyMembersDivision> division{};
  shared_ptr<string> email{};
  shared_ptr<string> gender{};
  shared_ptr<string> identifier{};
  shared_ptr<string> mobile{};
  shared_ptr<string> nameEn{};
  shared_ptr<string> nickName{};
  shared_ptr<string> nickNamePinyin{};
  shared_ptr<ListProjectMembersResponseBodyMembersOrganizationUserInfo> organizationUserInfo{};
  shared_ptr<string> realName{};
  shared_ptr<string> realNamePinyin{};
  shared_ptr<string> roleName{};
  shared_ptr<string> stamp{};
  shared_ptr<string> tbRoleId{};

  ListProjectMembersResponseBodyMembers() {}

  explicit ListProjectMembersResponseBodyMembers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["account"] = boost::any(*account);
    }
    if (avatar) {
      res["avatar"] = boost::any(*avatar);
    }
    if (dingTalkId) {
      res["dingTalkId"] = boost::any(*dingTalkId);
    }
    if (displayName) {
      res["displayName"] = boost::any(*displayName);
    }
    if (displayNickName) {
      res["displayNickName"] = boost::any(*displayNickName);
    }
    if (displayRealName) {
      res["displayRealName"] = boost::any(*displayRealName);
    }
    if (division) {
      res["division"] = division ? boost::any(division->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (gender) {
      res["gender"] = boost::any(*gender);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (mobile) {
      res["mobile"] = boost::any(*mobile);
    }
    if (nameEn) {
      res["nameEn"] = boost::any(*nameEn);
    }
    if (nickName) {
      res["nickName"] = boost::any(*nickName);
    }
    if (nickNamePinyin) {
      res["nickNamePinyin"] = boost::any(*nickNamePinyin);
    }
    if (organizationUserInfo) {
      res["organizationUserInfo"] = organizationUserInfo ? boost::any(organizationUserInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (realName) {
      res["realName"] = boost::any(*realName);
    }
    if (realNamePinyin) {
      res["realNamePinyin"] = boost::any(*realNamePinyin);
    }
    if (roleName) {
      res["roleName"] = boost::any(*roleName);
    }
    if (stamp) {
      res["stamp"] = boost::any(*stamp);
    }
    if (tbRoleId) {
      res["tbRoleId"] = boost::any(*tbRoleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("account") != m.end() && !m["account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["account"]));
    }
    if (m.find("avatar") != m.end() && !m["avatar"].empty()) {
      avatar = make_shared<string>(boost::any_cast<string>(m["avatar"]));
    }
    if (m.find("dingTalkId") != m.end() && !m["dingTalkId"].empty()) {
      dingTalkId = make_shared<string>(boost::any_cast<string>(m["dingTalkId"]));
    }
    if (m.find("displayName") != m.end() && !m["displayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["displayName"]));
    }
    if (m.find("displayNickName") != m.end() && !m["displayNickName"].empty()) {
      displayNickName = make_shared<string>(boost::any_cast<string>(m["displayNickName"]));
    }
    if (m.find("displayRealName") != m.end() && !m["displayRealName"].empty()) {
      displayRealName = make_shared<string>(boost::any_cast<string>(m["displayRealName"]));
    }
    if (m.find("division") != m.end() && !m["division"].empty()) {
      if (typeid(map<string, boost::any>) == m["division"].type()) {
        ListProjectMembersResponseBodyMembersDivision model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["division"]));
        division = make_shared<ListProjectMembersResponseBodyMembersDivision>(model1);
      }
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("gender") != m.end() && !m["gender"].empty()) {
      gender = make_shared<string>(boost::any_cast<string>(m["gender"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("mobile") != m.end() && !m["mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["mobile"]));
    }
    if (m.find("nameEn") != m.end() && !m["nameEn"].empty()) {
      nameEn = make_shared<string>(boost::any_cast<string>(m["nameEn"]));
    }
    if (m.find("nickName") != m.end() && !m["nickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["nickName"]));
    }
    if (m.find("nickNamePinyin") != m.end() && !m["nickNamePinyin"].empty()) {
      nickNamePinyin = make_shared<string>(boost::any_cast<string>(m["nickNamePinyin"]));
    }
    if (m.find("organizationUserInfo") != m.end() && !m["organizationUserInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["organizationUserInfo"].type()) {
        ListProjectMembersResponseBodyMembersOrganizationUserInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["organizationUserInfo"]));
        organizationUserInfo = make_shared<ListProjectMembersResponseBodyMembersOrganizationUserInfo>(model1);
      }
    }
    if (m.find("realName") != m.end() && !m["realName"].empty()) {
      realName = make_shared<string>(boost::any_cast<string>(m["realName"]));
    }
    if (m.find("realNamePinyin") != m.end() && !m["realNamePinyin"].empty()) {
      realNamePinyin = make_shared<string>(boost::any_cast<string>(m["realNamePinyin"]));
    }
    if (m.find("roleName") != m.end() && !m["roleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["roleName"]));
    }
    if (m.find("stamp") != m.end() && !m["stamp"].empty()) {
      stamp = make_shared<string>(boost::any_cast<string>(m["stamp"]));
    }
    if (m.find("tbRoleId") != m.end() && !m["tbRoleId"].empty()) {
      tbRoleId = make_shared<string>(boost::any_cast<string>(m["tbRoleId"]));
    }
  }


  virtual ~ListProjectMembersResponseBodyMembers() = default;
};
class ListProjectMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<vector<ListProjectMembersResponseBodyMembers>> members{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListProjectMembersResponseBody() {}

  explicit ListProjectMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (members) {
      vector<boost::any> temp1;
      for(auto item1:*members){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["members"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("members") != m.end() && !m["members"].empty()) {
      if (typeid(vector<boost::any>) == m["members"].type()) {
        vector<ListProjectMembersResponseBodyMembers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["members"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectMembersResponseBodyMembers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        members = make_shared<vector<ListProjectMembersResponseBodyMembers>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ListProjectMembersResponseBody() = default;
};
class ListProjectMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListProjectMembersResponseBody> body{};

  ListProjectMembersResponse() {}

  explicit ListProjectMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProjectMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProjectMembersResponseBody>(model1);
      }
    }
  }


  virtual ~ListProjectMembersResponse() = default;
};
class ListProjectTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};

  ListProjectTemplatesRequest() {}

  explicit ListProjectTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["category"] = boost::any(*category);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["category"]));
    }
  }


  virtual ~ListProjectTemplatesRequest() = default;
};
class ListProjectTemplatesResponseBodyTemplates : public Darabonba::Model {
public:
  shared_ptr<string> copyFrom{};
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> icon{};
  shared_ptr<string> identifier{};
  shared_ptr<string> modifier{};
  shared_ptr<string> name{};
  shared_ptr<string> nameEn{};
  shared_ptr<string> resourceCategory{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> spaceIdentifier{};
  shared_ptr<string> spaceType{};
  shared_ptr<long> type{};

  ListProjectTemplatesResponseBodyTemplates() {}

  explicit ListProjectTemplatesResponseBodyTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (copyFrom) {
      res["copyFrom"] = boost::any(*copyFrom);
    }
    if (creator) {
      res["creator"] = boost::any(*creator);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (icon) {
      res["icon"] = boost::any(*icon);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (modifier) {
      res["modifier"] = boost::any(*modifier);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nameEn) {
      res["nameEn"] = boost::any(*nameEn);
    }
    if (resourceCategory) {
      res["resourceCategory"] = boost::any(*resourceCategory);
    }
    if (resourceType) {
      res["resourceType"] = boost::any(*resourceType);
    }
    if (spaceIdentifier) {
      res["spaceIdentifier"] = boost::any(*spaceIdentifier);
    }
    if (spaceType) {
      res["spaceType"] = boost::any(*spaceType);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("copyFrom") != m.end() && !m["copyFrom"].empty()) {
      copyFrom = make_shared<string>(boost::any_cast<string>(m["copyFrom"]));
    }
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["creator"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("icon") != m.end() && !m["icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["icon"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("modifier") != m.end() && !m["modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["modifier"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nameEn") != m.end() && !m["nameEn"].empty()) {
      nameEn = make_shared<string>(boost::any_cast<string>(m["nameEn"]));
    }
    if (m.find("resourceCategory") != m.end() && !m["resourceCategory"].empty()) {
      resourceCategory = make_shared<string>(boost::any_cast<string>(m["resourceCategory"]));
    }
    if (m.find("resourceType") != m.end() && !m["resourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["resourceType"]));
    }
    if (m.find("spaceIdentifier") != m.end() && !m["spaceIdentifier"].empty()) {
      spaceIdentifier = make_shared<string>(boost::any_cast<string>(m["spaceIdentifier"]));
    }
    if (m.find("spaceType") != m.end() && !m["spaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["spaceType"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~ListProjectTemplatesResponseBodyTemplates() = default;
};
class ListProjectTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<vector<ListProjectTemplatesResponseBodyTemplates>> templates{};

  ListProjectTemplatesResponseBody() {}

  explicit ListProjectTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (templates) {
      vector<boost::any> temp1;
      for(auto item1:*templates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["templates"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("templates") != m.end() && !m["templates"].empty()) {
      if (typeid(vector<boost::any>) == m["templates"].type()) {
        vector<ListProjectTemplatesResponseBodyTemplates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["templates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectTemplatesResponseBodyTemplates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        templates = make_shared<vector<ListProjectTemplatesResponseBodyTemplates>>(expect1);
      }
    }
  }


  virtual ~ListProjectTemplatesResponseBody() = default;
};
class ListProjectTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListProjectTemplatesResponseBody> body{};

  ListProjectTemplatesResponse() {}

  explicit ListProjectTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProjectTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProjectTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListProjectTemplatesResponse() = default;
};
class ListProjectWorkitemTypesRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> spaceType{};

  ListProjectWorkitemTypesRequest() {}

  explicit ListProjectWorkitemTypesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (spaceType) {
      res["spaceType"] = boost::any(*spaceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["category"]));
    }
    if (m.find("spaceType") != m.end() && !m["spaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["spaceType"]));
    }
  }


  virtual ~ListProjectWorkitemTypesRequest() = default;
};
class ListProjectWorkitemTypesResponseBodyWorkitemTypes : public Darabonba::Model {
public:
  shared_ptr<string> addUser{};
  shared_ptr<string> categoryIdentifier{};
  shared_ptr<string> creator{};
  shared_ptr<bool> defaultType{};
  shared_ptr<string> description{};
  shared_ptr<bool> enable{};
  shared_ptr<long> gmtAdd{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> identifier{};
  shared_ptr<string> name{};
  shared_ptr<string> nameEn{};
  shared_ptr<bool> systemDefault{};

  ListProjectWorkitemTypesResponseBodyWorkitemTypes() {}

  explicit ListProjectWorkitemTypesResponseBodyWorkitemTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addUser) {
      res["addUser"] = boost::any(*addUser);
    }
    if (categoryIdentifier) {
      res["categoryIdentifier"] = boost::any(*categoryIdentifier);
    }
    if (creator) {
      res["creator"] = boost::any(*creator);
    }
    if (defaultType) {
      res["defaultType"] = boost::any(*defaultType);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (enable) {
      res["enable"] = boost::any(*enable);
    }
    if (gmtAdd) {
      res["gmtAdd"] = boost::any(*gmtAdd);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nameEn) {
      res["nameEn"] = boost::any(*nameEn);
    }
    if (systemDefault) {
      res["systemDefault"] = boost::any(*systemDefault);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("addUser") != m.end() && !m["addUser"].empty()) {
      addUser = make_shared<string>(boost::any_cast<string>(m["addUser"]));
    }
    if (m.find("categoryIdentifier") != m.end() && !m["categoryIdentifier"].empty()) {
      categoryIdentifier = make_shared<string>(boost::any_cast<string>(m["categoryIdentifier"]));
    }
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["creator"]));
    }
    if (m.find("defaultType") != m.end() && !m["defaultType"].empty()) {
      defaultType = make_shared<bool>(boost::any_cast<bool>(m["defaultType"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("enable") != m.end() && !m["enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["enable"]));
    }
    if (m.find("gmtAdd") != m.end() && !m["gmtAdd"].empty()) {
      gmtAdd = make_shared<long>(boost::any_cast<long>(m["gmtAdd"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nameEn") != m.end() && !m["nameEn"].empty()) {
      nameEn = make_shared<string>(boost::any_cast<string>(m["nameEn"]));
    }
    if (m.find("systemDefault") != m.end() && !m["systemDefault"].empty()) {
      systemDefault = make_shared<bool>(boost::any_cast<bool>(m["systemDefault"]));
    }
  }


  virtual ~ListProjectWorkitemTypesResponseBodyWorkitemTypes() = default;
};
class ListProjectWorkitemTypesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<vector<ListProjectWorkitemTypesResponseBodyWorkitemTypes>> workitemTypes{};

  ListProjectWorkitemTypesResponseBody() {}

  explicit ListProjectWorkitemTypesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (workitemTypes) {
      vector<boost::any> temp1;
      for(auto item1:*workitemTypes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["workitemTypes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("workitemTypes") != m.end() && !m["workitemTypes"].empty()) {
      if (typeid(vector<boost::any>) == m["workitemTypes"].type()) {
        vector<ListProjectWorkitemTypesResponseBodyWorkitemTypes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["workitemTypes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectWorkitemTypesResponseBodyWorkitemTypes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workitemTypes = make_shared<vector<ListProjectWorkitemTypesResponseBodyWorkitemTypes>>(expect1);
      }
    }
  }


  virtual ~ListProjectWorkitemTypesResponseBody() = default;
};
class ListProjectWorkitemTypesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListProjectWorkitemTypesResponseBody> body{};

  ListProjectWorkitemTypesResponse() {}

  explicit ListProjectWorkitemTypesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProjectWorkitemTypesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProjectWorkitemTypesResponseBody>(model1);
      }
    }
  }


  virtual ~ListProjectWorkitemTypesResponse() = default;
};
class ListProjectsRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> conditions{};
  shared_ptr<string> extraConditions{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> scope{};

  ListProjectsRequest() {}

  explicit ListProjectsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (conditions) {
      res["conditions"] = boost::any(*conditions);
    }
    if (extraConditions) {
      res["extraConditions"] = boost::any(*extraConditions);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["category"]));
    }
    if (m.find("conditions") != m.end() && !m["conditions"].empty()) {
      conditions = make_shared<string>(boost::any_cast<string>(m["conditions"]));
    }
    if (m.find("extraConditions") != m.end() && !m["extraConditions"].empty()) {
      extraConditions = make_shared<string>(boost::any_cast<string>(m["extraConditions"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["scope"]));
    }
  }


  virtual ~ListProjectsRequest() = default;
};
class ListProjectsResponseBodyProjects : public Darabonba::Model {
public:
  shared_ptr<string> categoryIdentifier{};
  shared_ptr<string> creator{};
  shared_ptr<string> customCode{};
  shared_ptr<long> deleteTime{};
  shared_ptr<string> description{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> icon{};
  shared_ptr<string> identifier{};
  shared_ptr<string> logicalStatus{};
  shared_ptr<string> name{};
  shared_ptr<string> scope{};
  shared_ptr<string> statusStageIdentifier{};
  shared_ptr<string> typeIdentifier{};

  ListProjectsResponseBodyProjects() {}

  explicit ListProjectsResponseBodyProjects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryIdentifier) {
      res["categoryIdentifier"] = boost::any(*categoryIdentifier);
    }
    if (creator) {
      res["creator"] = boost::any(*creator);
    }
    if (customCode) {
      res["customCode"] = boost::any(*customCode);
    }
    if (deleteTime) {
      res["deleteTime"] = boost::any(*deleteTime);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (icon) {
      res["icon"] = boost::any(*icon);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (logicalStatus) {
      res["logicalStatus"] = boost::any(*logicalStatus);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (statusStageIdentifier) {
      res["statusStageIdentifier"] = boost::any(*statusStageIdentifier);
    }
    if (typeIdentifier) {
      res["typeIdentifier"] = boost::any(*typeIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("categoryIdentifier") != m.end() && !m["categoryIdentifier"].empty()) {
      categoryIdentifier = make_shared<string>(boost::any_cast<string>(m["categoryIdentifier"]));
    }
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["creator"]));
    }
    if (m.find("customCode") != m.end() && !m["customCode"].empty()) {
      customCode = make_shared<string>(boost::any_cast<string>(m["customCode"]));
    }
    if (m.find("deleteTime") != m.end() && !m["deleteTime"].empty()) {
      deleteTime = make_shared<long>(boost::any_cast<long>(m["deleteTime"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("icon") != m.end() && !m["icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["icon"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("logicalStatus") != m.end() && !m["logicalStatus"].empty()) {
      logicalStatus = make_shared<string>(boost::any_cast<string>(m["logicalStatus"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["scope"]));
    }
    if (m.find("statusStageIdentifier") != m.end() && !m["statusStageIdentifier"].empty()) {
      statusStageIdentifier = make_shared<string>(boost::any_cast<string>(m["statusStageIdentifier"]));
    }
    if (m.find("typeIdentifier") != m.end() && !m["typeIdentifier"].empty()) {
      typeIdentifier = make_shared<string>(boost::any_cast<string>(m["typeIdentifier"]));
    }
  }


  virtual ~ListProjectsResponseBodyProjects() = default;
};
class ListProjectsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ListProjectsResponseBodyProjects>> projects{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListProjectsResponseBody() {}

  explicit ListProjectsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (projects) {
      vector<boost::any> temp1;
      for(auto item1:*projects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["projects"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("projects") != m.end() && !m["projects"].empty()) {
      if (typeid(vector<boost::any>) == m["projects"].type()) {
        vector<ListProjectsResponseBodyProjects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["projects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectsResponseBodyProjects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        projects = make_shared<vector<ListProjectsResponseBodyProjects>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ListProjectsResponseBody() = default;
};
class ListProjectsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListProjectsResponseBody> body{};

  ListProjectsResponse() {}

  explicit ListProjectsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProjectsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProjectsResponseBody>(model1);
      }
    }
  }


  virtual ~ListProjectsResponse() = default;
};
class ListProtectedBranchesRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> organizationId{};

  ListProtectedBranchesRequest() {}

  explicit ListProtectedBranchesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~ListProtectedBranchesRequest() = default;
};
class ListProtectedBranchesResponseBodyResultAllowMergeUsers : public Darabonba::Model {
public:
  shared_ptr<string> avatar{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> username{};

  ListProtectedBranchesResponseBodyResultAllowMergeUsers() {}

  explicit ListProtectedBranchesResponseBodyResultAllowMergeUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatar) {
      res["avatar"] = boost::any(*avatar);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatar") != m.end() && !m["avatar"].empty()) {
      avatar = make_shared<string>(boost::any_cast<string>(m["avatar"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~ListProtectedBranchesResponseBodyResultAllowMergeUsers() = default;
};
class ListProtectedBranchesResponseBodyResultAllowPushUsers : public Darabonba::Model {
public:
  shared_ptr<string> avatar{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> username{};

  ListProtectedBranchesResponseBodyResultAllowPushUsers() {}

  explicit ListProtectedBranchesResponseBodyResultAllowPushUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatar) {
      res["avatar"] = boost::any(*avatar);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatar") != m.end() && !m["avatar"].empty()) {
      avatar = make_shared<string>(boost::any_cast<string>(m["avatar"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~ListProtectedBranchesResponseBodyResultAllowPushUsers() = default;
};
class ListProtectedBranchesResponseBodyResultMergeRequestSettingDefaultAssignees : public Darabonba::Model {
public:
  shared_ptr<string> avatar{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> username{};

  ListProtectedBranchesResponseBodyResultMergeRequestSettingDefaultAssignees() {}

  explicit ListProtectedBranchesResponseBodyResultMergeRequestSettingDefaultAssignees(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatar) {
      res["avatar"] = boost::any(*avatar);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatar") != m.end() && !m["avatar"].empty()) {
      avatar = make_shared<string>(boost::any_cast<string>(m["avatar"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~ListProtectedBranchesResponseBodyResultMergeRequestSettingDefaultAssignees() = default;
};
class ListProtectedBranchesResponseBodyResultMergeRequestSetting : public Darabonba::Model {
public:
  shared_ptr<vector<long>> allowMergeRequestRoles{};
  shared_ptr<vector<ListProtectedBranchesResponseBodyResultMergeRequestSettingDefaultAssignees>> defaultAssignees{};
  shared_ptr<bool> isAllowSelfApproval{};
  shared_ptr<bool> isRequireDiscussionProcessed{};
  shared_ptr<bool> isRequired{};
  shared_ptr<bool> isResetApprovalWhenNewPush{};
  shared_ptr<long> minimumApproval{};
  shared_ptr<string> mrMode{};
  shared_ptr<string> whiteList{};

  ListProtectedBranchesResponseBodyResultMergeRequestSetting() {}

  explicit ListProtectedBranchesResponseBodyResultMergeRequestSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowMergeRequestRoles) {
      res["allowMergeRequestRoles"] = boost::any(*allowMergeRequestRoles);
    }
    if (defaultAssignees) {
      vector<boost::any> temp1;
      for(auto item1:*defaultAssignees){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["defaultAssignees"] = boost::any(temp1);
    }
    if (isAllowSelfApproval) {
      res["isAllowSelfApproval"] = boost::any(*isAllowSelfApproval);
    }
    if (isRequireDiscussionProcessed) {
      res["isRequireDiscussionProcessed"] = boost::any(*isRequireDiscussionProcessed);
    }
    if (isRequired) {
      res["isRequired"] = boost::any(*isRequired);
    }
    if (isResetApprovalWhenNewPush) {
      res["isResetApprovalWhenNewPush"] = boost::any(*isResetApprovalWhenNewPush);
    }
    if (minimumApproval) {
      res["minimumApproval"] = boost::any(*minimumApproval);
    }
    if (mrMode) {
      res["mrMode"] = boost::any(*mrMode);
    }
    if (whiteList) {
      res["whiteList"] = boost::any(*whiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("allowMergeRequestRoles") != m.end() && !m["allowMergeRequestRoles"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["allowMergeRequestRoles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["allowMergeRequestRoles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      allowMergeRequestRoles = make_shared<vector<long>>(toVec1);
    }
    if (m.find("defaultAssignees") != m.end() && !m["defaultAssignees"].empty()) {
      if (typeid(vector<boost::any>) == m["defaultAssignees"].type()) {
        vector<ListProtectedBranchesResponseBodyResultMergeRequestSettingDefaultAssignees> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["defaultAssignees"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProtectedBranchesResponseBodyResultMergeRequestSettingDefaultAssignees model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        defaultAssignees = make_shared<vector<ListProtectedBranchesResponseBodyResultMergeRequestSettingDefaultAssignees>>(expect1);
      }
    }
    if (m.find("isAllowSelfApproval") != m.end() && !m["isAllowSelfApproval"].empty()) {
      isAllowSelfApproval = make_shared<bool>(boost::any_cast<bool>(m["isAllowSelfApproval"]));
    }
    if (m.find("isRequireDiscussionProcessed") != m.end() && !m["isRequireDiscussionProcessed"].empty()) {
      isRequireDiscussionProcessed = make_shared<bool>(boost::any_cast<bool>(m["isRequireDiscussionProcessed"]));
    }
    if (m.find("isRequired") != m.end() && !m["isRequired"].empty()) {
      isRequired = make_shared<bool>(boost::any_cast<bool>(m["isRequired"]));
    }
    if (m.find("isResetApprovalWhenNewPush") != m.end() && !m["isResetApprovalWhenNewPush"].empty()) {
      isResetApprovalWhenNewPush = make_shared<bool>(boost::any_cast<bool>(m["isResetApprovalWhenNewPush"]));
    }
    if (m.find("minimumApproval") != m.end() && !m["minimumApproval"].empty()) {
      minimumApproval = make_shared<long>(boost::any_cast<long>(m["minimumApproval"]));
    }
    if (m.find("mrMode") != m.end() && !m["mrMode"].empty()) {
      mrMode = make_shared<string>(boost::any_cast<string>(m["mrMode"]));
    }
    if (m.find("whiteList") != m.end() && !m["whiteList"].empty()) {
      whiteList = make_shared<string>(boost::any_cast<string>(m["whiteList"]));
    }
  }


  virtual ~ListProtectedBranchesResponseBodyResultMergeRequestSetting() = default;
};
class ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems : public Darabonba::Model {
public:
  shared_ptr<bool> isRequired{};
  shared_ptr<string> name{};

  ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems() {}

  explicit ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isRequired) {
      res["isRequired"] = boost::any(*isRequired);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("isRequired") != m.end() && !m["isRequired"].empty()) {
      isRequired = make_shared<bool>(boost::any_cast<bool>(m["isRequired"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems() = default;
};
class ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig : public Darabonba::Model {
public:
  shared_ptr<vector<ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems>> checkItems{};

  ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig() {}

  explicit ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkItems) {
      vector<boost::any> temp1;
      for(auto item1:*checkItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["checkItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("checkItems") != m.end() && !m["checkItems"].empty()) {
      if (typeid(vector<boost::any>) == m["checkItems"].type()) {
        vector<ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["checkItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        checkItems = make_shared<vector<ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems>>(expect1);
      }
    }
  }


  virtual ~ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig() = default;
};
class ListProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig : public Darabonba::Model {
public:
  shared_ptr<string> bizNo{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> message{};
  shared_ptr<string> taskName{};

  ListProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig() {}

  explicit ListProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizNo) {
      res["bizNo"] = boost::any(*bizNo);
    }
    if (enabled) {
      res["enabled"] = boost::any(*enabled);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (taskName) {
      res["taskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bizNo") != m.end() && !m["bizNo"].empty()) {
      bizNo = make_shared<string>(boost::any_cast<string>(m["bizNo"]));
    }
    if (m.find("enabled") != m.end() && !m["enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["enabled"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("taskName") != m.end() && !m["taskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["taskName"]));
    }
  }


  virtual ~ListProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig() = default;
};
class ListProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<string> message{};

  ListProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection() {}

  explicit ListProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["enabled"] = boost::any(*enabled);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enabled") != m.end() && !m["enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["enabled"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
  }


  virtual ~ListProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection() = default;
};
class ListProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<string> message{};

  ListProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection() {}

  explicit ListProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["enabled"] = boost::any(*enabled);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enabled") != m.end() && !m["enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["enabled"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
  }


  virtual ~ListProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection() = default;
};
class ListProtectedBranchesResponseBodyResultTestSettingDTO : public Darabonba::Model {
public:
  shared_ptr<ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig> checkConfig{};
  shared_ptr<ListProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig> checkTaskQualityConfig{};
  shared_ptr<ListProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection> codeGuidelinesDetection{};
  shared_ptr<bool> isRequired{};
  shared_ptr<ListProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection> sensitiveInfoDetection{};

  ListProtectedBranchesResponseBodyResultTestSettingDTO() {}

  explicit ListProtectedBranchesResponseBodyResultTestSettingDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkConfig) {
      res["checkConfig"] = checkConfig ? boost::any(checkConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (checkTaskQualityConfig) {
      res["checkTaskQualityConfig"] = checkTaskQualityConfig ? boost::any(checkTaskQualityConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (codeGuidelinesDetection) {
      res["codeGuidelinesDetection"] = codeGuidelinesDetection ? boost::any(codeGuidelinesDetection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isRequired) {
      res["isRequired"] = boost::any(*isRequired);
    }
    if (sensitiveInfoDetection) {
      res["sensitiveInfoDetection"] = sensitiveInfoDetection ? boost::any(sensitiveInfoDetection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("checkConfig") != m.end() && !m["checkConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["checkConfig"].type()) {
        ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["checkConfig"]));
        checkConfig = make_shared<ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig>(model1);
      }
    }
    if (m.find("checkTaskQualityConfig") != m.end() && !m["checkTaskQualityConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["checkTaskQualityConfig"].type()) {
        ListProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["checkTaskQualityConfig"]));
        checkTaskQualityConfig = make_shared<ListProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig>(model1);
      }
    }
    if (m.find("codeGuidelinesDetection") != m.end() && !m["codeGuidelinesDetection"].empty()) {
      if (typeid(map<string, boost::any>) == m["codeGuidelinesDetection"].type()) {
        ListProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["codeGuidelinesDetection"]));
        codeGuidelinesDetection = make_shared<ListProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection>(model1);
      }
    }
    if (m.find("isRequired") != m.end() && !m["isRequired"].empty()) {
      isRequired = make_shared<bool>(boost::any_cast<bool>(m["isRequired"]));
    }
    if (m.find("sensitiveInfoDetection") != m.end() && !m["sensitiveInfoDetection"].empty()) {
      if (typeid(map<string, boost::any>) == m["sensitiveInfoDetection"].type()) {
        ListProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["sensitiveInfoDetection"]));
        sensitiveInfoDetection = make_shared<ListProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection>(model1);
      }
    }
  }


  virtual ~ListProtectedBranchesResponseBodyResultTestSettingDTO() = default;
};
class ListProtectedBranchesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<long>> allowMergeRoles{};
  shared_ptr<vector<long>> allowMergeUserIds{};
  shared_ptr<vector<ListProtectedBranchesResponseBodyResultAllowMergeUsers>> allowMergeUsers{};
  shared_ptr<vector<long>> allowPushRoles{};
  shared_ptr<vector<long>> allowPushUserIds{};
  shared_ptr<vector<ListProtectedBranchesResponseBodyResultAllowPushUsers>> allowPushUsers{};
  shared_ptr<string> branch{};
  shared_ptr<string> createdAt{};
  shared_ptr<long> id{};
  shared_ptr<vector<string>> matches{};
  shared_ptr<ListProtectedBranchesResponseBodyResultMergeRequestSetting> mergeRequestSetting{};
  shared_ptr<ListProtectedBranchesResponseBodyResultTestSettingDTO> testSettingDTO{};
  shared_ptr<string> updatedAt{};

  ListProtectedBranchesResponseBodyResult() {}

  explicit ListProtectedBranchesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowMergeRoles) {
      res["allowMergeRoles"] = boost::any(*allowMergeRoles);
    }
    if (allowMergeUserIds) {
      res["allowMergeUserIds"] = boost::any(*allowMergeUserIds);
    }
    if (allowMergeUsers) {
      vector<boost::any> temp1;
      for(auto item1:*allowMergeUsers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["allowMergeUsers"] = boost::any(temp1);
    }
    if (allowPushRoles) {
      res["allowPushRoles"] = boost::any(*allowPushRoles);
    }
    if (allowPushUserIds) {
      res["allowPushUserIds"] = boost::any(*allowPushUserIds);
    }
    if (allowPushUsers) {
      vector<boost::any> temp1;
      for(auto item1:*allowPushUsers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["allowPushUsers"] = boost::any(temp1);
    }
    if (branch) {
      res["branch"] = boost::any(*branch);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (matches) {
      res["matches"] = boost::any(*matches);
    }
    if (mergeRequestSetting) {
      res["mergeRequestSetting"] = mergeRequestSetting ? boost::any(mergeRequestSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (testSettingDTO) {
      res["testSettingDTO"] = testSettingDTO ? boost::any(testSettingDTO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updatedAt) {
      res["updatedAt"] = boost::any(*updatedAt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("allowMergeRoles") != m.end() && !m["allowMergeRoles"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["allowMergeRoles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["allowMergeRoles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      allowMergeRoles = make_shared<vector<long>>(toVec1);
    }
    if (m.find("allowMergeUserIds") != m.end() && !m["allowMergeUserIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["allowMergeUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["allowMergeUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      allowMergeUserIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("allowMergeUsers") != m.end() && !m["allowMergeUsers"].empty()) {
      if (typeid(vector<boost::any>) == m["allowMergeUsers"].type()) {
        vector<ListProtectedBranchesResponseBodyResultAllowMergeUsers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["allowMergeUsers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProtectedBranchesResponseBodyResultAllowMergeUsers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        allowMergeUsers = make_shared<vector<ListProtectedBranchesResponseBodyResultAllowMergeUsers>>(expect1);
      }
    }
    if (m.find("allowPushRoles") != m.end() && !m["allowPushRoles"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["allowPushRoles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["allowPushRoles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      allowPushRoles = make_shared<vector<long>>(toVec1);
    }
    if (m.find("allowPushUserIds") != m.end() && !m["allowPushUserIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["allowPushUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["allowPushUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      allowPushUserIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("allowPushUsers") != m.end() && !m["allowPushUsers"].empty()) {
      if (typeid(vector<boost::any>) == m["allowPushUsers"].type()) {
        vector<ListProtectedBranchesResponseBodyResultAllowPushUsers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["allowPushUsers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProtectedBranchesResponseBodyResultAllowPushUsers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        allowPushUsers = make_shared<vector<ListProtectedBranchesResponseBodyResultAllowPushUsers>>(expect1);
      }
    }
    if (m.find("branch") != m.end() && !m["branch"].empty()) {
      branch = make_shared<string>(boost::any_cast<string>(m["branch"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("matches") != m.end() && !m["matches"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["matches"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["matches"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      matches = make_shared<vector<string>>(toVec1);
    }
    if (m.find("mergeRequestSetting") != m.end() && !m["mergeRequestSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["mergeRequestSetting"].type()) {
        ListProtectedBranchesResponseBodyResultMergeRequestSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["mergeRequestSetting"]));
        mergeRequestSetting = make_shared<ListProtectedBranchesResponseBodyResultMergeRequestSetting>(model1);
      }
    }
    if (m.find("testSettingDTO") != m.end() && !m["testSettingDTO"].empty()) {
      if (typeid(map<string, boost::any>) == m["testSettingDTO"].type()) {
        ListProtectedBranchesResponseBodyResultTestSettingDTO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["testSettingDTO"]));
        testSettingDTO = make_shared<ListProtectedBranchesResponseBodyResultTestSettingDTO>(model1);
      }
    }
    if (m.find("updatedAt") != m.end() && !m["updatedAt"].empty()) {
      updatedAt = make_shared<string>(boost::any_cast<string>(m["updatedAt"]));
    }
  }


  virtual ~ListProtectedBranchesResponseBodyResult() = default;
};
class ListProtectedBranchesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListProtectedBranchesResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  ListProtectedBranchesResponseBody() {}

  explicit ListProtectedBranchesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ListProtectedBranchesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProtectedBranchesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListProtectedBranchesResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ListProtectedBranchesResponseBody() = default;
};
class ListProtectedBranchesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListProtectedBranchesResponseBody> body{};

  ListProtectedBranchesResponse() {}

  explicit ListProtectedBranchesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProtectedBranchesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProtectedBranchesResponseBody>(model1);
      }
    }
  }


  virtual ~ListProtectedBranchesResponse() = default;
};
class ListPushRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> organizationId{};

  ListPushRulesRequest() {}

  explicit ListPushRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~ListPushRulesRequest() = default;
};
class ListPushRulesResponseBodyResultRuleInfos : public Darabonba::Model {
public:
  shared_ptr<string> checkerName{};
  shared_ptr<string> checkerType{};
  shared_ptr<string> extraMessage{};
  shared_ptr<vector<string>> fileRuleRegexes{};

  ListPushRulesResponseBodyResultRuleInfos() {}

  explicit ListPushRulesResponseBodyResultRuleInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkerName) {
      res["checkerName"] = boost::any(*checkerName);
    }
    if (checkerType) {
      res["checkerType"] = boost::any(*checkerType);
    }
    if (extraMessage) {
      res["extraMessage"] = boost::any(*extraMessage);
    }
    if (fileRuleRegexes) {
      res["fileRuleRegexes"] = boost::any(*fileRuleRegexes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("checkerName") != m.end() && !m["checkerName"].empty()) {
      checkerName = make_shared<string>(boost::any_cast<string>(m["checkerName"]));
    }
    if (m.find("checkerType") != m.end() && !m["checkerType"].empty()) {
      checkerType = make_shared<string>(boost::any_cast<string>(m["checkerType"]));
    }
    if (m.find("extraMessage") != m.end() && !m["extraMessage"].empty()) {
      extraMessage = make_shared<string>(boost::any_cast<string>(m["extraMessage"]));
    }
    if (m.find("fileRuleRegexes") != m.end() && !m["fileRuleRegexes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["fileRuleRegexes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["fileRuleRegexes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fileRuleRegexes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListPushRulesResponseBodyResultRuleInfos() = default;
};
class ListPushRulesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<vector<ListPushRulesResponseBodyResultRuleInfos>> ruleInfos{};

  ListPushRulesResponseBodyResult() {}

  explicit ListPushRulesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (ruleInfos) {
      vector<boost::any> temp1;
      for(auto item1:*ruleInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ruleInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("ruleInfos") != m.end() && !m["ruleInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["ruleInfos"].type()) {
        vector<ListPushRulesResponseBodyResultRuleInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ruleInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPushRulesResponseBodyResultRuleInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleInfos = make_shared<vector<ListPushRulesResponseBodyResultRuleInfos>>(expect1);
      }
    }
  }


  virtual ~ListPushRulesResponseBodyResult() = default;
};
class ListPushRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListPushRulesResponseBodyResult>> result{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListPushRulesResponseBody() {}

  explicit ListPushRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ListPushRulesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPushRulesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListPushRulesResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
  }


  virtual ~ListPushRulesResponseBody() = default;
};
class ListPushRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPushRulesResponseBody> body{};

  ListPushRulesResponse() {}

  explicit ListPushRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPushRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPushRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListPushRulesResponse() = default;
};
class ListRepositoriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<bool> archived{};
  shared_ptr<long> minAccessLevel{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> organizationId{};
  shared_ptr<long> page{};
  shared_ptr<long> perPage{};
  shared_ptr<string> search{};
  shared_ptr<string> sort{};

  ListRepositoriesRequest() {}

  explicit ListRepositoriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (archived) {
      res["archived"] = boost::any(*archived);
    }
    if (minAccessLevel) {
      res["minAccessLevel"] = boost::any(*minAccessLevel);
    }
    if (orderBy) {
      res["orderBy"] = boost::any(*orderBy);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (perPage) {
      res["perPage"] = boost::any(*perPage);
    }
    if (search) {
      res["search"] = boost::any(*search);
    }
    if (sort) {
      res["sort"] = boost::any(*sort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("archived") != m.end() && !m["archived"].empty()) {
      archived = make_shared<bool>(boost::any_cast<bool>(m["archived"]));
    }
    if (m.find("minAccessLevel") != m.end() && !m["minAccessLevel"].empty()) {
      minAccessLevel = make_shared<long>(boost::any_cast<long>(m["minAccessLevel"]));
    }
    if (m.find("orderBy") != m.end() && !m["orderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["orderBy"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("perPage") != m.end() && !m["perPage"].empty()) {
      perPage = make_shared<long>(boost::any_cast<long>(m["perPage"]));
    }
    if (m.find("search") != m.end() && !m["search"].empty()) {
      search = make_shared<string>(boost::any_cast<string>(m["search"]));
    }
    if (m.find("sort") != m.end() && !m["sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["sort"]));
    }
  }


  virtual ~ListRepositoriesRequest() = default;
};
class ListRepositoriesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> accessLevel{};
  shared_ptr<bool> archive{};
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> description{};
  shared_ptr<string> importStatus{};
  shared_ptr<string> lastActivityAt{};
  shared_ptr<string> name{};
  shared_ptr<string> nameWithNamespace{};
  shared_ptr<long> namespaceId{};
  shared_ptr<string> path{};
  shared_ptr<string> pathWithNamespace{};
  shared_ptr<bool> star{};
  shared_ptr<long> starCount{};
  shared_ptr<string> updatedAt{};
  shared_ptr<string> visibilityLevel{};
  shared_ptr<string> webUrl{};

  ListRepositoriesResponseBodyResult() {}

  explicit ListRepositoriesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (accessLevel) {
      res["accessLevel"] = boost::any(*accessLevel);
    }
    if (archive) {
      res["archive"] = boost::any(*archive);
    }
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (importStatus) {
      res["importStatus"] = boost::any(*importStatus);
    }
    if (lastActivityAt) {
      res["lastActivityAt"] = boost::any(*lastActivityAt);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nameWithNamespace) {
      res["nameWithNamespace"] = boost::any(*nameWithNamespace);
    }
    if (namespaceId) {
      res["namespaceId"] = boost::any(*namespaceId);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (pathWithNamespace) {
      res["pathWithNamespace"] = boost::any(*pathWithNamespace);
    }
    if (star) {
      res["star"] = boost::any(*star);
    }
    if (starCount) {
      res["starCount"] = boost::any(*starCount);
    }
    if (updatedAt) {
      res["updatedAt"] = boost::any(*updatedAt);
    }
    if (visibilityLevel) {
      res["visibilityLevel"] = boost::any(*visibilityLevel);
    }
    if (webUrl) {
      res["webUrl"] = boost::any(*webUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("accessLevel") != m.end() && !m["accessLevel"].empty()) {
      accessLevel = make_shared<long>(boost::any_cast<long>(m["accessLevel"]));
    }
    if (m.find("archive") != m.end() && !m["archive"].empty()) {
      archive = make_shared<bool>(boost::any_cast<bool>(m["archive"]));
    }
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("importStatus") != m.end() && !m["importStatus"].empty()) {
      importStatus = make_shared<string>(boost::any_cast<string>(m["importStatus"]));
    }
    if (m.find("lastActivityAt") != m.end() && !m["lastActivityAt"].empty()) {
      lastActivityAt = make_shared<string>(boost::any_cast<string>(m["lastActivityAt"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nameWithNamespace") != m.end() && !m["nameWithNamespace"].empty()) {
      nameWithNamespace = make_shared<string>(boost::any_cast<string>(m["nameWithNamespace"]));
    }
    if (m.find("namespaceId") != m.end() && !m["namespaceId"].empty()) {
      namespaceId = make_shared<long>(boost::any_cast<long>(m["namespaceId"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("pathWithNamespace") != m.end() && !m["pathWithNamespace"].empty()) {
      pathWithNamespace = make_shared<string>(boost::any_cast<string>(m["pathWithNamespace"]));
    }
    if (m.find("star") != m.end() && !m["star"].empty()) {
      star = make_shared<bool>(boost::any_cast<bool>(m["star"]));
    }
    if (m.find("starCount") != m.end() && !m["starCount"].empty()) {
      starCount = make_shared<long>(boost::any_cast<long>(m["starCount"]));
    }
    if (m.find("updatedAt") != m.end() && !m["updatedAt"].empty()) {
      updatedAt = make_shared<string>(boost::any_cast<string>(m["updatedAt"]));
    }
    if (m.find("visibilityLevel") != m.end() && !m["visibilityLevel"].empty()) {
      visibilityLevel = make_shared<string>(boost::any_cast<string>(m["visibilityLevel"]));
    }
    if (m.find("webUrl") != m.end() && !m["webUrl"].empty()) {
      webUrl = make_shared<string>(boost::any_cast<string>(m["webUrl"]));
    }
  }


  virtual ~ListRepositoriesResponseBodyResult() = default;
};
class ListRepositoriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListRepositoriesResponseBodyResult>> result{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListRepositoriesResponseBody() {}

  explicit ListRepositoriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ListRepositoriesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRepositoriesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListRepositoriesResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
  }


  virtual ~ListRepositoriesResponseBody() = default;
};
class ListRepositoriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRepositoriesResponseBody> body{};

  ListRepositoriesResponse() {}

  explicit ListRepositoriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRepositoriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRepositoriesResponseBody>(model1);
      }
    }
  }


  virtual ~ListRepositoriesResponse() = default;
};
class ListRepositoryBranchesRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> organizationId{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> search{};
  shared_ptr<string> sort{};

  ListRepositoryBranchesRequest() {}

  explicit ListRepositoryBranchesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (search) {
      res["search"] = boost::any(*search);
    }
    if (sort) {
      res["sort"] = boost::any(*sort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("search") != m.end() && !m["search"].empty()) {
      search = make_shared<string>(boost::any_cast<string>(m["search"]));
    }
    if (m.find("sort") != m.end() && !m["sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["sort"]));
    }
  }


  virtual ~ListRepositoryBranchesRequest() = default;
};
class ListRepositoryBranchesResponseBodyResultCommit : public Darabonba::Model {
public:
  shared_ptr<string> authorEmail{};
  shared_ptr<string> authorName{};
  shared_ptr<string> authoredDate{};
  shared_ptr<string> committedDate{};
  shared_ptr<string> committerEmail{};
  shared_ptr<string> committerName{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> id{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> parentIds{};
  shared_ptr<string> shortId{};
  shared_ptr<string> title{};

  ListRepositoryBranchesResponseBodyResultCommit() {}

  explicit ListRepositoryBranchesResponseBodyResultCommit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorEmail) {
      res["authorEmail"] = boost::any(*authorEmail);
    }
    if (authorName) {
      res["authorName"] = boost::any(*authorName);
    }
    if (authoredDate) {
      res["authoredDate"] = boost::any(*authoredDate);
    }
    if (committedDate) {
      res["committedDate"] = boost::any(*committedDate);
    }
    if (committerEmail) {
      res["committerEmail"] = boost::any(*committerEmail);
    }
    if (committerName) {
      res["committerName"] = boost::any(*committerName);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (parentIds) {
      res["parentIds"] = boost::any(*parentIds);
    }
    if (shortId) {
      res["shortId"] = boost::any(*shortId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("authorEmail") != m.end() && !m["authorEmail"].empty()) {
      authorEmail = make_shared<string>(boost::any_cast<string>(m["authorEmail"]));
    }
    if (m.find("authorName") != m.end() && !m["authorName"].empty()) {
      authorName = make_shared<string>(boost::any_cast<string>(m["authorName"]));
    }
    if (m.find("authoredDate") != m.end() && !m["authoredDate"].empty()) {
      authoredDate = make_shared<string>(boost::any_cast<string>(m["authoredDate"]));
    }
    if (m.find("committedDate") != m.end() && !m["committedDate"].empty()) {
      committedDate = make_shared<string>(boost::any_cast<string>(m["committedDate"]));
    }
    if (m.find("committerEmail") != m.end() && !m["committerEmail"].empty()) {
      committerEmail = make_shared<string>(boost::any_cast<string>(m["committerEmail"]));
    }
    if (m.find("committerName") != m.end() && !m["committerName"].empty()) {
      committerName = make_shared<string>(boost::any_cast<string>(m["committerName"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("parentIds") != m.end() && !m["parentIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["parentIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["parentIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      parentIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("shortId") != m.end() && !m["shortId"].empty()) {
      shortId = make_shared<string>(boost::any_cast<string>(m["shortId"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~ListRepositoryBranchesResponseBodyResultCommit() = default;
};
class ListRepositoryBranchesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<ListRepositoryBranchesResponseBodyResultCommit> commit{};
  shared_ptr<string> name{};
  shared_ptr<string> protected_{};

  ListRepositoryBranchesResponseBodyResult() {}

  explicit ListRepositoryBranchesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commit) {
      res["commit"] = commit ? boost::any(commit->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (protected_) {
      res["protected"] = boost::any(*protected_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commit") != m.end() && !m["commit"].empty()) {
      if (typeid(map<string, boost::any>) == m["commit"].type()) {
        ListRepositoryBranchesResponseBodyResultCommit model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["commit"]));
        commit = make_shared<ListRepositoryBranchesResponseBodyResultCommit>(model1);
      }
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("protected") != m.end() && !m["protected"].empty()) {
      protected_ = make_shared<string>(boost::any_cast<string>(m["protected"]));
    }
  }


  virtual ~ListRepositoryBranchesResponseBodyResult() = default;
};
class ListRepositoryBranchesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListRepositoryBranchesResponseBodyResult>> result{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListRepositoryBranchesResponseBody() {}

  explicit ListRepositoryBranchesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ListRepositoryBranchesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRepositoryBranchesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListRepositoryBranchesResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
  }


  virtual ~ListRepositoryBranchesResponseBody() = default;
};
class ListRepositoryBranchesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRepositoryBranchesResponseBody> body{};

  ListRepositoryBranchesResponse() {}

  explicit ListRepositoryBranchesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRepositoryBranchesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRepositoryBranchesResponseBody>(model1);
      }
    }
  }


  virtual ~ListRepositoryBranchesResponse() = default;
};
class ListRepositoryCommitDiffRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<long> contextLine{};
  shared_ptr<string> organizationId{};

  ListRepositoryCommitDiffRequest() {}

  explicit ListRepositoryCommitDiffRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (contextLine) {
      res["contextLine"] = boost::any(*contextLine);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("contextLine") != m.end() && !m["contextLine"].empty()) {
      contextLine = make_shared<long>(boost::any_cast<long>(m["contextLine"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~ListRepositoryCommitDiffRequest() = default;
};
class ListRepositoryCommitDiffResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> aMode{};
  shared_ptr<string> bMode{};
  shared_ptr<bool> deletedFile{};
  shared_ptr<string> diff{};
  shared_ptr<bool> isBinary{};
  shared_ptr<bool> isNewLfs{};
  shared_ptr<bool> isOldLfs{};
  shared_ptr<bool> newFile{};
  shared_ptr<string> newId{};
  shared_ptr<string> newPath{};
  shared_ptr<string> oldId{};
  shared_ptr<string> oldPath{};
  shared_ptr<bool> renamedFile{};

  ListRepositoryCommitDiffResponseBodyResult() {}

  explicit ListRepositoryCommitDiffResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aMode) {
      res["aMode"] = boost::any(*aMode);
    }
    if (bMode) {
      res["bMode"] = boost::any(*bMode);
    }
    if (deletedFile) {
      res["deletedFile"] = boost::any(*deletedFile);
    }
    if (diff) {
      res["diff"] = boost::any(*diff);
    }
    if (isBinary) {
      res["isBinary"] = boost::any(*isBinary);
    }
    if (isNewLfs) {
      res["isNewLfs"] = boost::any(*isNewLfs);
    }
    if (isOldLfs) {
      res["isOldLfs"] = boost::any(*isOldLfs);
    }
    if (newFile) {
      res["newFile"] = boost::any(*newFile);
    }
    if (newId) {
      res["newId"] = boost::any(*newId);
    }
    if (newPath) {
      res["newPath"] = boost::any(*newPath);
    }
    if (oldId) {
      res["oldId"] = boost::any(*oldId);
    }
    if (oldPath) {
      res["oldPath"] = boost::any(*oldPath);
    }
    if (renamedFile) {
      res["renamedFile"] = boost::any(*renamedFile);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aMode") != m.end() && !m["aMode"].empty()) {
      aMode = make_shared<string>(boost::any_cast<string>(m["aMode"]));
    }
    if (m.find("bMode") != m.end() && !m["bMode"].empty()) {
      bMode = make_shared<string>(boost::any_cast<string>(m["bMode"]));
    }
    if (m.find("deletedFile") != m.end() && !m["deletedFile"].empty()) {
      deletedFile = make_shared<bool>(boost::any_cast<bool>(m["deletedFile"]));
    }
    if (m.find("diff") != m.end() && !m["diff"].empty()) {
      diff = make_shared<string>(boost::any_cast<string>(m["diff"]));
    }
    if (m.find("isBinary") != m.end() && !m["isBinary"].empty()) {
      isBinary = make_shared<bool>(boost::any_cast<bool>(m["isBinary"]));
    }
    if (m.find("isNewLfs") != m.end() && !m["isNewLfs"].empty()) {
      isNewLfs = make_shared<bool>(boost::any_cast<bool>(m["isNewLfs"]));
    }
    if (m.find("isOldLfs") != m.end() && !m["isOldLfs"].empty()) {
      isOldLfs = make_shared<bool>(boost::any_cast<bool>(m["isOldLfs"]));
    }
    if (m.find("newFile") != m.end() && !m["newFile"].empty()) {
      newFile = make_shared<bool>(boost::any_cast<bool>(m["newFile"]));
    }
    if (m.find("newId") != m.end() && !m["newId"].empty()) {
      newId = make_shared<string>(boost::any_cast<string>(m["newId"]));
    }
    if (m.find("newPath") != m.end() && !m["newPath"].empty()) {
      newPath = make_shared<string>(boost::any_cast<string>(m["newPath"]));
    }
    if (m.find("oldId") != m.end() && !m["oldId"].empty()) {
      oldId = make_shared<string>(boost::any_cast<string>(m["oldId"]));
    }
    if (m.find("oldPath") != m.end() && !m["oldPath"].empty()) {
      oldPath = make_shared<string>(boost::any_cast<string>(m["oldPath"]));
    }
    if (m.find("renamedFile") != m.end() && !m["renamedFile"].empty()) {
      renamedFile = make_shared<bool>(boost::any_cast<bool>(m["renamedFile"]));
    }
  }


  virtual ~ListRepositoryCommitDiffResponseBodyResult() = default;
};
class ListRepositoryCommitDiffResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListRepositoryCommitDiffResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  ListRepositoryCommitDiffResponseBody() {}

  explicit ListRepositoryCommitDiffResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ListRepositoryCommitDiffResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRepositoryCommitDiffResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListRepositoryCommitDiffResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ListRepositoryCommitDiffResponseBody() = default;
};
class ListRepositoryCommitDiffResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRepositoryCommitDiffResponseBody> body{};

  ListRepositoryCommitDiffResponse() {}

  explicit ListRepositoryCommitDiffResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRepositoryCommitDiffResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRepositoryCommitDiffResponseBody>(model1);
      }
    }
  }


  virtual ~ListRepositoryCommitDiffResponse() = default;
};
class ListRepositoryCommitsRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> end{};
  shared_ptr<string> organizationId{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> path{};
  shared_ptr<string> refName{};
  shared_ptr<string> search{};
  shared_ptr<bool> showCommentsCount{};
  shared_ptr<bool> showSignature{};
  shared_ptr<string> start{};

  ListRepositoryCommitsRequest() {}

  explicit ListRepositoryCommitsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (end) {
      res["end"] = boost::any(*end);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (refName) {
      res["refName"] = boost::any(*refName);
    }
    if (search) {
      res["search"] = boost::any(*search);
    }
    if (showCommentsCount) {
      res["showCommentsCount"] = boost::any(*showCommentsCount);
    }
    if (showSignature) {
      res["showSignature"] = boost::any(*showSignature);
    }
    if (start) {
      res["start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("end") != m.end() && !m["end"].empty()) {
      end = make_shared<string>(boost::any_cast<string>(m["end"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("refName") != m.end() && !m["refName"].empty()) {
      refName = make_shared<string>(boost::any_cast<string>(m["refName"]));
    }
    if (m.find("search") != m.end() && !m["search"].empty()) {
      search = make_shared<string>(boost::any_cast<string>(m["search"]));
    }
    if (m.find("showCommentsCount") != m.end() && !m["showCommentsCount"].empty()) {
      showCommentsCount = make_shared<bool>(boost::any_cast<bool>(m["showCommentsCount"]));
    }
    if (m.find("showSignature") != m.end() && !m["showSignature"].empty()) {
      showSignature = make_shared<bool>(boost::any_cast<bool>(m["showSignature"]));
    }
    if (m.find("start") != m.end() && !m["start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["start"]));
    }
  }


  virtual ~ListRepositoryCommitsRequest() = default;
};
class ListRepositoryCommitsResponseBodyResultAuthor : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};
  shared_ptr<string> websiteUrl{};

  ListRepositoryCommitsResponseBodyResultAuthor() {}

  explicit ListRepositoryCommitsResponseBodyResultAuthor(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    if (websiteUrl) {
      res["websiteUrl"] = boost::any(*websiteUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
    if (m.find("websiteUrl") != m.end() && !m["websiteUrl"].empty()) {
      websiteUrl = make_shared<string>(boost::any_cast<string>(m["websiteUrl"]));
    }
  }


  virtual ~ListRepositoryCommitsResponseBodyResultAuthor() = default;
};
class ListRepositoryCommitsResponseBodyResultCommitter : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};
  shared_ptr<string> websiteUrl{};

  ListRepositoryCommitsResponseBodyResultCommitter() {}

  explicit ListRepositoryCommitsResponseBodyResultCommitter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    if (websiteUrl) {
      res["websiteUrl"] = boost::any(*websiteUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
    if (m.find("websiteUrl") != m.end() && !m["websiteUrl"].empty()) {
      websiteUrl = make_shared<string>(boost::any_cast<string>(m["websiteUrl"]));
    }
  }


  virtual ~ListRepositoryCommitsResponseBodyResultCommitter() = default;
};
class ListRepositoryCommitsResponseBodyResultSignature : public Darabonba::Model {
public:
  shared_ptr<string> gpgKeyId{};
  shared_ptr<string> verificationStatus{};

  ListRepositoryCommitsResponseBodyResultSignature() {}

  explicit ListRepositoryCommitsResponseBodyResultSignature(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gpgKeyId) {
      res["gpgKeyId"] = boost::any(*gpgKeyId);
    }
    if (verificationStatus) {
      res["verificationStatus"] = boost::any(*verificationStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gpgKeyId") != m.end() && !m["gpgKeyId"].empty()) {
      gpgKeyId = make_shared<string>(boost::any_cast<string>(m["gpgKeyId"]));
    }
    if (m.find("verificationStatus") != m.end() && !m["verificationStatus"].empty()) {
      verificationStatus = make_shared<string>(boost::any_cast<string>(m["verificationStatus"]));
    }
  }


  virtual ~ListRepositoryCommitsResponseBodyResultSignature() = default;
};
class ListRepositoryCommitsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<ListRepositoryCommitsResponseBodyResultAuthor> author{};
  shared_ptr<string> authorEmail{};
  shared_ptr<string> authorName{};
  shared_ptr<string> authoredDate{};
  shared_ptr<long> commentsCount{};
  shared_ptr<string> committedDate{};
  shared_ptr<ListRepositoryCommitsResponseBodyResultCommitter> committer{};
  shared_ptr<string> committerEmail{};
  shared_ptr<string> committerName{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> id{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> parentIds{};
  shared_ptr<string> shortId{};
  shared_ptr<ListRepositoryCommitsResponseBodyResultSignature> signature{};
  shared_ptr<string> title{};

  ListRepositoryCommitsResponseBodyResult() {}

  explicit ListRepositoryCommitsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (author) {
      res["author"] = author ? boost::any(author->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (authorEmail) {
      res["authorEmail"] = boost::any(*authorEmail);
    }
    if (authorName) {
      res["authorName"] = boost::any(*authorName);
    }
    if (authoredDate) {
      res["authoredDate"] = boost::any(*authoredDate);
    }
    if (commentsCount) {
      res["commentsCount"] = boost::any(*commentsCount);
    }
    if (committedDate) {
      res["committedDate"] = boost::any(*committedDate);
    }
    if (committer) {
      res["committer"] = committer ? boost::any(committer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (committerEmail) {
      res["committerEmail"] = boost::any(*committerEmail);
    }
    if (committerName) {
      res["committerName"] = boost::any(*committerName);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (parentIds) {
      res["parentIds"] = boost::any(*parentIds);
    }
    if (shortId) {
      res["shortId"] = boost::any(*shortId);
    }
    if (signature) {
      res["signature"] = signature ? boost::any(signature->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("author") != m.end() && !m["author"].empty()) {
      if (typeid(map<string, boost::any>) == m["author"].type()) {
        ListRepositoryCommitsResponseBodyResultAuthor model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["author"]));
        author = make_shared<ListRepositoryCommitsResponseBodyResultAuthor>(model1);
      }
    }
    if (m.find("authorEmail") != m.end() && !m["authorEmail"].empty()) {
      authorEmail = make_shared<string>(boost::any_cast<string>(m["authorEmail"]));
    }
    if (m.find("authorName") != m.end() && !m["authorName"].empty()) {
      authorName = make_shared<string>(boost::any_cast<string>(m["authorName"]));
    }
    if (m.find("authoredDate") != m.end() && !m["authoredDate"].empty()) {
      authoredDate = make_shared<string>(boost::any_cast<string>(m["authoredDate"]));
    }
    if (m.find("commentsCount") != m.end() && !m["commentsCount"].empty()) {
      commentsCount = make_shared<long>(boost::any_cast<long>(m["commentsCount"]));
    }
    if (m.find("committedDate") != m.end() && !m["committedDate"].empty()) {
      committedDate = make_shared<string>(boost::any_cast<string>(m["committedDate"]));
    }
    if (m.find("committer") != m.end() && !m["committer"].empty()) {
      if (typeid(map<string, boost::any>) == m["committer"].type()) {
        ListRepositoryCommitsResponseBodyResultCommitter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["committer"]));
        committer = make_shared<ListRepositoryCommitsResponseBodyResultCommitter>(model1);
      }
    }
    if (m.find("committerEmail") != m.end() && !m["committerEmail"].empty()) {
      committerEmail = make_shared<string>(boost::any_cast<string>(m["committerEmail"]));
    }
    if (m.find("committerName") != m.end() && !m["committerName"].empty()) {
      committerName = make_shared<string>(boost::any_cast<string>(m["committerName"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("parentIds") != m.end() && !m["parentIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["parentIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["parentIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      parentIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("shortId") != m.end() && !m["shortId"].empty()) {
      shortId = make_shared<string>(boost::any_cast<string>(m["shortId"]));
    }
    if (m.find("signature") != m.end() && !m["signature"].empty()) {
      if (typeid(map<string, boost::any>) == m["signature"].type()) {
        ListRepositoryCommitsResponseBodyResultSignature model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["signature"]));
        signature = make_shared<ListRepositoryCommitsResponseBodyResultSignature>(model1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~ListRepositoryCommitsResponseBodyResult() = default;
};
class ListRepositoryCommitsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListRepositoryCommitsResponseBodyResult>> result{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListRepositoryCommitsResponseBody() {}

  explicit ListRepositoryCommitsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ListRepositoryCommitsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRepositoryCommitsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListRepositoryCommitsResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
  }


  virtual ~ListRepositoryCommitsResponseBody() = default;
};
class ListRepositoryCommitsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRepositoryCommitsResponseBody> body{};

  ListRepositoryCommitsResponse() {}

  explicit ListRepositoryCommitsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRepositoryCommitsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRepositoryCommitsResponseBody>(model1);
      }
    }
  }


  virtual ~ListRepositoryCommitsResponse() = default;
};
class ListRepositoryGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<bool> includePersonal{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> organizationId{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> parentId{};
  shared_ptr<string> search{};
  shared_ptr<string> sort{};

  ListRepositoryGroupsRequest() {}

  explicit ListRepositoryGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (includePersonal) {
      res["includePersonal"] = boost::any(*includePersonal);
    }
    if (orderBy) {
      res["orderBy"] = boost::any(*orderBy);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (parentId) {
      res["parentId"] = boost::any(*parentId);
    }
    if (search) {
      res["search"] = boost::any(*search);
    }
    if (sort) {
      res["sort"] = boost::any(*sort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("includePersonal") != m.end() && !m["includePersonal"].empty()) {
      includePersonal = make_shared<bool>(boost::any_cast<bool>(m["includePersonal"]));
    }
    if (m.find("orderBy") != m.end() && !m["orderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["orderBy"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("parentId") != m.end() && !m["parentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["parentId"]));
    }
    if (m.find("search") != m.end() && !m["search"].empty()) {
      search = make_shared<string>(boost::any_cast<string>(m["search"]));
    }
    if (m.find("sort") != m.end() && !m["sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["sort"]));
    }
  }


  virtual ~ListRepositoryGroupsRequest() = default;
};
class ListRepositoryGroupsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> accessLevel{};
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> description{};
  shared_ptr<long> groupCount{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> nameWithNamespace{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> parentId{};
  shared_ptr<string> path{};
  shared_ptr<string> pathWithNamespace{};
  shared_ptr<long> projectCount{};
  shared_ptr<string> type{};
  shared_ptr<string> updatedAt{};
  shared_ptr<long> visibilityLevel{};
  shared_ptr<string> webUrl{};

  ListRepositoryGroupsResponseBodyResult() {}

  explicit ListRepositoryGroupsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessLevel) {
      res["accessLevel"] = boost::any(*accessLevel);
    }
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (groupCount) {
      res["groupCount"] = boost::any(*groupCount);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nameWithNamespace) {
      res["nameWithNamespace"] = boost::any(*nameWithNamespace);
    }
    if (ownerId) {
      res["ownerId"] = boost::any(*ownerId);
    }
    if (parentId) {
      res["parentId"] = boost::any(*parentId);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (pathWithNamespace) {
      res["pathWithNamespace"] = boost::any(*pathWithNamespace);
    }
    if (projectCount) {
      res["projectCount"] = boost::any(*projectCount);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (updatedAt) {
      res["updatedAt"] = boost::any(*updatedAt);
    }
    if (visibilityLevel) {
      res["visibilityLevel"] = boost::any(*visibilityLevel);
    }
    if (webUrl) {
      res["webUrl"] = boost::any(*webUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessLevel") != m.end() && !m["accessLevel"].empty()) {
      accessLevel = make_shared<long>(boost::any_cast<long>(m["accessLevel"]));
    }
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("groupCount") != m.end() && !m["groupCount"].empty()) {
      groupCount = make_shared<long>(boost::any_cast<long>(m["groupCount"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nameWithNamespace") != m.end() && !m["nameWithNamespace"].empty()) {
      nameWithNamespace = make_shared<string>(boost::any_cast<string>(m["nameWithNamespace"]));
    }
    if (m.find("ownerId") != m.end() && !m["ownerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["ownerId"]));
    }
    if (m.find("parentId") != m.end() && !m["parentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["parentId"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("pathWithNamespace") != m.end() && !m["pathWithNamespace"].empty()) {
      pathWithNamespace = make_shared<string>(boost::any_cast<string>(m["pathWithNamespace"]));
    }
    if (m.find("projectCount") != m.end() && !m["projectCount"].empty()) {
      projectCount = make_shared<long>(boost::any_cast<long>(m["projectCount"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("updatedAt") != m.end() && !m["updatedAt"].empty()) {
      updatedAt = make_shared<string>(boost::any_cast<string>(m["updatedAt"]));
    }
    if (m.find("visibilityLevel") != m.end() && !m["visibilityLevel"].empty()) {
      visibilityLevel = make_shared<long>(boost::any_cast<long>(m["visibilityLevel"]));
    }
    if (m.find("webUrl") != m.end() && !m["webUrl"].empty()) {
      webUrl = make_shared<string>(boost::any_cast<string>(m["webUrl"]));
    }
  }


  virtual ~ListRepositoryGroupsResponseBodyResult() = default;
};
class ListRepositoryGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListRepositoryGroupsResponseBodyResult>> result{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListRepositoryGroupsResponseBody() {}

  explicit ListRepositoryGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ListRepositoryGroupsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRepositoryGroupsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListRepositoryGroupsResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
  }


  virtual ~ListRepositoryGroupsResponseBody() = default;
};
class ListRepositoryGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRepositoryGroupsResponseBody> body{};

  ListRepositoryGroupsResponse() {}

  explicit ListRepositoryGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRepositoryGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRepositoryGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListRepositoryGroupsResponse() = default;
};
class ListRepositoryMemberWithInheritedRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> organizationId{};

  ListRepositoryMemberWithInheritedRequest() {}

  explicit ListRepositoryMemberWithInheritedRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~ListRepositoryMemberWithInheritedRequest() = default;
};
class ListRepositoryMemberWithInheritedResponseBodyResultInherited : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> nameWithNamespace{};
  shared_ptr<string> path{};
  shared_ptr<string> pathWithNamespace{};
  shared_ptr<string> type{};
  shared_ptr<string> visibilityLevel{};

  ListRepositoryMemberWithInheritedResponseBodyResultInherited() {}

  explicit ListRepositoryMemberWithInheritedResponseBodyResultInherited(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nameWithNamespace) {
      res["nameWithNamespace"] = boost::any(*nameWithNamespace);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (pathWithNamespace) {
      res["pathWithNamespace"] = boost::any(*pathWithNamespace);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (visibilityLevel) {
      res["visibilityLevel"] = boost::any(*visibilityLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nameWithNamespace") != m.end() && !m["nameWithNamespace"].empty()) {
      nameWithNamespace = make_shared<string>(boost::any_cast<string>(m["nameWithNamespace"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("pathWithNamespace") != m.end() && !m["pathWithNamespace"].empty()) {
      pathWithNamespace = make_shared<string>(boost::any_cast<string>(m["pathWithNamespace"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("visibilityLevel") != m.end() && !m["visibilityLevel"].empty()) {
      visibilityLevel = make_shared<string>(boost::any_cast<string>(m["visibilityLevel"]));
    }
  }


  virtual ~ListRepositoryMemberWithInheritedResponseBodyResultInherited() = default;
};
class ListRepositoryMemberWithInheritedResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> accessLevel{};
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<ListRepositoryMemberWithInheritedResponseBodyResultInherited> inherited{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};

  ListRepositoryMemberWithInheritedResponseBodyResult() {}

  explicit ListRepositoryMemberWithInheritedResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessLevel) {
      res["accessLevel"] = boost::any(*accessLevel);
    }
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (inherited) {
      res["inherited"] = inherited ? boost::any(inherited->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessLevel") != m.end() && !m["accessLevel"].empty()) {
      accessLevel = make_shared<long>(boost::any_cast<long>(m["accessLevel"]));
    }
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("inherited") != m.end() && !m["inherited"].empty()) {
      if (typeid(map<string, boost::any>) == m["inherited"].type()) {
        ListRepositoryMemberWithInheritedResponseBodyResultInherited model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["inherited"]));
        inherited = make_shared<ListRepositoryMemberWithInheritedResponseBodyResultInherited>(model1);
      }
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~ListRepositoryMemberWithInheritedResponseBodyResult() = default;
};
class ListRepositoryMemberWithInheritedResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListRepositoryMemberWithInheritedResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  ListRepositoryMemberWithInheritedResponseBody() {}

  explicit ListRepositoryMemberWithInheritedResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ListRepositoryMemberWithInheritedResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRepositoryMemberWithInheritedResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListRepositoryMemberWithInheritedResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ListRepositoryMemberWithInheritedResponseBody() = default;
};
class ListRepositoryMemberWithInheritedResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRepositoryMemberWithInheritedResponseBody> body{};

  ListRepositoryMemberWithInheritedResponse() {}

  explicit ListRepositoryMemberWithInheritedResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRepositoryMemberWithInheritedResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRepositoryMemberWithInheritedResponseBody>(model1);
      }
    }
  }


  virtual ~ListRepositoryMemberWithInheritedResponse() = default;
};
class ListRepositoryTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> organizationId{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> search{};
  shared_ptr<string> sort{};

  ListRepositoryTagsRequest() {}

  explicit ListRepositoryTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (search) {
      res["search"] = boost::any(*search);
    }
    if (sort) {
      res["sort"] = boost::any(*sort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("search") != m.end() && !m["search"].empty()) {
      search = make_shared<string>(boost::any_cast<string>(m["search"]));
    }
    if (m.find("sort") != m.end() && !m["sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["sort"]));
    }
  }


  virtual ~ListRepositoryTagsRequest() = default;
};
class ListRepositoryTagsResponseBodyResultCommitSignature : public Darabonba::Model {
public:
  shared_ptr<string> gpgKeyId{};
  shared_ptr<string> verificationStatus{};

  ListRepositoryTagsResponseBodyResultCommitSignature() {}

  explicit ListRepositoryTagsResponseBodyResultCommitSignature(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gpgKeyId) {
      res["gpgKeyId"] = boost::any(*gpgKeyId);
    }
    if (verificationStatus) {
      res["verificationStatus"] = boost::any(*verificationStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gpgKeyId") != m.end() && !m["gpgKeyId"].empty()) {
      gpgKeyId = make_shared<string>(boost::any_cast<string>(m["gpgKeyId"]));
    }
    if (m.find("verificationStatus") != m.end() && !m["verificationStatus"].empty()) {
      verificationStatus = make_shared<string>(boost::any_cast<string>(m["verificationStatus"]));
    }
  }


  virtual ~ListRepositoryTagsResponseBodyResultCommitSignature() = default;
};
class ListRepositoryTagsResponseBodyResultCommit : public Darabonba::Model {
public:
  shared_ptr<string> authorEmail{};
  shared_ptr<string> authorName{};
  shared_ptr<string> authoredDate{};
  shared_ptr<string> committedDate{};
  shared_ptr<string> committerEmail{};
  shared_ptr<string> committerName{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> id{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> parentIds{};
  shared_ptr<string> shortId{};
  shared_ptr<ListRepositoryTagsResponseBodyResultCommitSignature> signature{};
  shared_ptr<string> title{};

  ListRepositoryTagsResponseBodyResultCommit() {}

  explicit ListRepositoryTagsResponseBodyResultCommit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorEmail) {
      res["authorEmail"] = boost::any(*authorEmail);
    }
    if (authorName) {
      res["authorName"] = boost::any(*authorName);
    }
    if (authoredDate) {
      res["authoredDate"] = boost::any(*authoredDate);
    }
    if (committedDate) {
      res["committedDate"] = boost::any(*committedDate);
    }
    if (committerEmail) {
      res["committerEmail"] = boost::any(*committerEmail);
    }
    if (committerName) {
      res["committerName"] = boost::any(*committerName);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (parentIds) {
      res["parentIds"] = boost::any(*parentIds);
    }
    if (shortId) {
      res["shortId"] = boost::any(*shortId);
    }
    if (signature) {
      res["signature"] = signature ? boost::any(signature->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("authorEmail") != m.end() && !m["authorEmail"].empty()) {
      authorEmail = make_shared<string>(boost::any_cast<string>(m["authorEmail"]));
    }
    if (m.find("authorName") != m.end() && !m["authorName"].empty()) {
      authorName = make_shared<string>(boost::any_cast<string>(m["authorName"]));
    }
    if (m.find("authoredDate") != m.end() && !m["authoredDate"].empty()) {
      authoredDate = make_shared<string>(boost::any_cast<string>(m["authoredDate"]));
    }
    if (m.find("committedDate") != m.end() && !m["committedDate"].empty()) {
      committedDate = make_shared<string>(boost::any_cast<string>(m["committedDate"]));
    }
    if (m.find("committerEmail") != m.end() && !m["committerEmail"].empty()) {
      committerEmail = make_shared<string>(boost::any_cast<string>(m["committerEmail"]));
    }
    if (m.find("committerName") != m.end() && !m["committerName"].empty()) {
      committerName = make_shared<string>(boost::any_cast<string>(m["committerName"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("parentIds") != m.end() && !m["parentIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["parentIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["parentIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      parentIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("shortId") != m.end() && !m["shortId"].empty()) {
      shortId = make_shared<string>(boost::any_cast<string>(m["shortId"]));
    }
    if (m.find("signature") != m.end() && !m["signature"].empty()) {
      if (typeid(map<string, boost::any>) == m["signature"].type()) {
        ListRepositoryTagsResponseBodyResultCommitSignature model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["signature"]));
        signature = make_shared<ListRepositoryTagsResponseBodyResultCommitSignature>(model1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~ListRepositoryTagsResponseBodyResultCommit() = default;
};
class ListRepositoryTagsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<ListRepositoryTagsResponseBodyResultCommit> commit{};
  shared_ptr<string> id{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};

  ListRepositoryTagsResponseBodyResult() {}

  explicit ListRepositoryTagsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commit) {
      res["commit"] = commit ? boost::any(commit->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commit") != m.end() && !m["commit"].empty()) {
      if (typeid(map<string, boost::any>) == m["commit"].type()) {
        ListRepositoryTagsResponseBodyResultCommit model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["commit"]));
        commit = make_shared<ListRepositoryTagsResponseBodyResultCommit>(model1);
      }
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~ListRepositoryTagsResponseBodyResult() = default;
};
class ListRepositoryTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListRepositoryTagsResponseBodyResult>> result{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListRepositoryTagsResponseBody() {}

  explicit ListRepositoryTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ListRepositoryTagsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRepositoryTagsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListRepositoryTagsResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
  }


  virtual ~ListRepositoryTagsResponseBody() = default;
};
class ListRepositoryTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRepositoryTagsResponseBody> body{};

  ListRepositoryTagsResponse() {}

  explicit ListRepositoryTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRepositoryTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRepositoryTagsResponseBody>(model1);
      }
    }
  }


  virtual ~ListRepositoryTagsResponse() = default;
};
class ListRepositoryTreeRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> path{};
  shared_ptr<string> refName{};
  shared_ptr<string> type{};

  ListRepositoryTreeRequest() {}

  explicit ListRepositoryTreeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (refName) {
      res["refName"] = boost::any(*refName);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("refName") != m.end() && !m["refName"].empty()) {
      refName = make_shared<string>(boost::any_cast<string>(m["refName"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ListRepositoryTreeRequest() = default;
};
class ListRepositoryTreeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<bool> isLFS{};
  shared_ptr<string> mode{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<string> type{};

  ListRepositoryTreeResponseBodyResult() {}

  explicit ListRepositoryTreeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (isLFS) {
      res["isLFS"] = boost::any(*isLFS);
    }
    if (mode) {
      res["mode"] = boost::any(*mode);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("isLFS") != m.end() && !m["isLFS"].empty()) {
      isLFS = make_shared<bool>(boost::any_cast<bool>(m["isLFS"]));
    }
    if (m.find("mode") != m.end() && !m["mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["mode"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ListRepositoryTreeResponseBodyResult() = default;
};
class ListRepositoryTreeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListRepositoryTreeResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  ListRepositoryTreeResponseBody() {}

  explicit ListRepositoryTreeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ListRepositoryTreeResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRepositoryTreeResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListRepositoryTreeResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ListRepositoryTreeResponseBody() = default;
};
class ListRepositoryTreeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRepositoryTreeResponseBody> body{};

  ListRepositoryTreeResponse() {}

  explicit ListRepositoryTreeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRepositoryTreeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRepositoryTreeResponseBody>(model1);
      }
    }
  }


  virtual ~ListRepositoryTreeResponse() = default;
};
class ListRepositoryWebhookRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> organizationId{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};

  ListRepositoryWebhookRequest() {}

  explicit ListRepositoryWebhookRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
  }


  virtual ~ListRepositoryWebhookRequest() = default;
};
class ListRepositoryWebhookResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> createdAt{};
  shared_ptr<string> description{};
  shared_ptr<bool> enableSslVerification{};
  shared_ptr<long> id{};
  shared_ptr<string> lastTestResult{};
  shared_ptr<bool> mergeRequestsEvents{};
  shared_ptr<bool> noteEvents{};
  shared_ptr<long> projectId{};
  shared_ptr<bool> pushEvents{};
  shared_ptr<string> secretToken{};
  shared_ptr<bool> tagPushEvents{};
  shared_ptr<string> url{};

  ListRepositoryWebhookResponseBodyResult() {}

  explicit ListRepositoryWebhookResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (enableSslVerification) {
      res["enableSslVerification"] = boost::any(*enableSslVerification);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (lastTestResult) {
      res["lastTestResult"] = boost::any(*lastTestResult);
    }
    if (mergeRequestsEvents) {
      res["mergeRequestsEvents"] = boost::any(*mergeRequestsEvents);
    }
    if (noteEvents) {
      res["noteEvents"] = boost::any(*noteEvents);
    }
    if (projectId) {
      res["projectId"] = boost::any(*projectId);
    }
    if (pushEvents) {
      res["pushEvents"] = boost::any(*pushEvents);
    }
    if (secretToken) {
      res["secretToken"] = boost::any(*secretToken);
    }
    if (tagPushEvents) {
      res["tagPushEvents"] = boost::any(*tagPushEvents);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("enableSslVerification") != m.end() && !m["enableSslVerification"].empty()) {
      enableSslVerification = make_shared<bool>(boost::any_cast<bool>(m["enableSslVerification"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("lastTestResult") != m.end() && !m["lastTestResult"].empty()) {
      lastTestResult = make_shared<string>(boost::any_cast<string>(m["lastTestResult"]));
    }
    if (m.find("mergeRequestsEvents") != m.end() && !m["mergeRequestsEvents"].empty()) {
      mergeRequestsEvents = make_shared<bool>(boost::any_cast<bool>(m["mergeRequestsEvents"]));
    }
    if (m.find("noteEvents") != m.end() && !m["noteEvents"].empty()) {
      noteEvents = make_shared<bool>(boost::any_cast<bool>(m["noteEvents"]));
    }
    if (m.find("projectId") != m.end() && !m["projectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["projectId"]));
    }
    if (m.find("pushEvents") != m.end() && !m["pushEvents"].empty()) {
      pushEvents = make_shared<bool>(boost::any_cast<bool>(m["pushEvents"]));
    }
    if (m.find("secretToken") != m.end() && !m["secretToken"].empty()) {
      secretToken = make_shared<string>(boost::any_cast<string>(m["secretToken"]));
    }
    if (m.find("tagPushEvents") != m.end() && !m["tagPushEvents"].empty()) {
      tagPushEvents = make_shared<bool>(boost::any_cast<bool>(m["tagPushEvents"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~ListRepositoryWebhookResponseBodyResult() = default;
};
class ListRepositoryWebhookResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListRepositoryWebhookResponseBodyResult>> result{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListRepositoryWebhookResponseBody() {}

  explicit ListRepositoryWebhookResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ListRepositoryWebhookResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRepositoryWebhookResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListRepositoryWebhookResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
  }


  virtual ~ListRepositoryWebhookResponseBody() = default;
};
class ListRepositoryWebhookResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRepositoryWebhookResponseBody> body{};

  ListRepositoryWebhookResponse() {}

  explicit ListRepositoryWebhookResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRepositoryWebhookResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRepositoryWebhookResponseBody>(model1);
      }
    }
  }


  virtual ~ListRepositoryWebhookResponse() = default;
};
class ListResourceMembersResponseBodyResourceMembers : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> roleName{};
  shared_ptr<string> username{};

  ListResourceMembersResponseBodyResourceMembers() {}

  explicit ListResourceMembersResponseBodyResourceMembers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    if (roleName) {
      res["roleName"] = boost::any(*roleName);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
    if (m.find("roleName") != m.end() && !m["roleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["roleName"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~ListResourceMembersResponseBodyResourceMembers() = default;
};
class ListResourceMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListResourceMembersResponseBodyResourceMembers>> resourceMembers{};
  shared_ptr<bool> success{};

  ListResourceMembersResponseBody() {}

  explicit ListResourceMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (resourceMembers) {
      vector<boost::any> temp1;
      for(auto item1:*resourceMembers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["resourceMembers"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("resourceMembers") != m.end() && !m["resourceMembers"].empty()) {
      if (typeid(vector<boost::any>) == m["resourceMembers"].type()) {
        vector<ListResourceMembersResponseBodyResourceMembers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["resourceMembers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourceMembersResponseBodyResourceMembers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceMembers = make_shared<vector<ListResourceMembersResponseBodyResourceMembers>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ListResourceMembersResponseBody() = default;
};
class ListResourceMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListResourceMembersResponseBody> body{};

  ListResourceMembersResponse() {}

  explicit ListResourceMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListResourceMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListResourceMembersResponseBody>(model1);
      }
    }
  }


  virtual ~ListResourceMembersResponse() = default;
};
class ListSearchCommitRequestRepoPath : public Darabonba::Model {
public:
  shared_ptr<string> matchType{};
  shared_ptr<string> operatorType{};
  shared_ptr<string> value{};

  ListSearchCommitRequestRepoPath() {}

  explicit ListSearchCommitRequestRepoPath(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (matchType) {
      res["matchType"] = boost::any(*matchType);
    }
    if (operatorType) {
      res["operatorType"] = boost::any(*operatorType);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("matchType") != m.end() && !m["matchType"].empty()) {
      matchType = make_shared<string>(boost::any_cast<string>(m["matchType"]));
    }
    if (m.find("operatorType") != m.end() && !m["operatorType"].empty()) {
      operatorType = make_shared<string>(boost::any_cast<string>(m["operatorType"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~ListSearchCommitRequestRepoPath() = default;
};
class ListSearchCommitRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<string> order{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<ListSearchCommitRequestRepoPath> repoPath{};
  shared_ptr<string> scope{};
  shared_ptr<string> sort{};
  shared_ptr<string> organizationId{};

  ListSearchCommitRequest() {}

  explicit ListSearchCommitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["keyword"] = boost::any(*keyword);
    }
    if (order) {
      res["order"] = boost::any(*order);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (repoPath) {
      res["repoPath"] = repoPath ? boost::any(repoPath->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (sort) {
      res["sort"] = boost::any(*sort);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("keyword") != m.end() && !m["keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["keyword"]));
    }
    if (m.find("order") != m.end() && !m["order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["order"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("repoPath") != m.end() && !m["repoPath"].empty()) {
      if (typeid(map<string, boost::any>) == m["repoPath"].type()) {
        ListSearchCommitRequestRepoPath model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["repoPath"]));
        repoPath = make_shared<ListSearchCommitRequestRepoPath>(model1);
      }
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["scope"]));
    }
    if (m.find("sort") != m.end() && !m["sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["sort"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~ListSearchCommitRequest() = default;
};
class ListSearchCommitResponseBodyResultHighlightTextMap : public Darabonba::Model {
public:
  shared_ptr<string> commitId{};
  shared_ptr<string> commitMessage{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> title{};

  ListSearchCommitResponseBodyResultHighlightTextMap() {}

  explicit ListSearchCommitResponseBodyResultHighlightTextMap(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commitId) {
      res["commitId"] = boost::any(*commitId);
    }
    if (commitMessage) {
      res["commitMessage"] = boost::any(*commitMessage);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commitId") != m.end() && !m["commitId"].empty()) {
      commitId = make_shared<string>(boost::any_cast<string>(m["commitId"]));
    }
    if (m.find("commitMessage") != m.end() && !m["commitMessage"].empty()) {
      commitMessage = make_shared<string>(boost::any_cast<string>(m["commitMessage"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~ListSearchCommitResponseBodyResultHighlightTextMap() = default;
};
class ListSearchCommitResponseBodyResultSourceAuthor : public Darabonba::Model {
public:
  shared_ptr<string> email{};
  shared_ptr<string> name{};

  ListSearchCommitResponseBodyResultSourceAuthor() {}

  explicit ListSearchCommitResponseBodyResultSourceAuthor(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~ListSearchCommitResponseBodyResultSourceAuthor() = default;
};
class ListSearchCommitResponseBodyResultSource : public Darabonba::Model {
public:
  shared_ptr<ListSearchCommitResponseBodyResultSourceAuthor> author{};
  shared_ptr<string> authorTime{};
  shared_ptr<string> commitId{};
  shared_ptr<string> commitMessage{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> repoPath{};
  shared_ptr<string> title{};

  ListSearchCommitResponseBodyResultSource() {}

  explicit ListSearchCommitResponseBodyResultSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (author) {
      res["author"] = author ? boost::any(author->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (authorTime) {
      res["authorTime"] = boost::any(*authorTime);
    }
    if (commitId) {
      res["commitId"] = boost::any(*commitId);
    }
    if (commitMessage) {
      res["commitMessage"] = boost::any(*commitMessage);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (repoPath) {
      res["repoPath"] = boost::any(*repoPath);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("author") != m.end() && !m["author"].empty()) {
      if (typeid(map<string, boost::any>) == m["author"].type()) {
        ListSearchCommitResponseBodyResultSourceAuthor model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["author"]));
        author = make_shared<ListSearchCommitResponseBodyResultSourceAuthor>(model1);
      }
    }
    if (m.find("authorTime") != m.end() && !m["authorTime"].empty()) {
      authorTime = make_shared<string>(boost::any_cast<string>(m["authorTime"]));
    }
    if (m.find("commitId") != m.end() && !m["commitId"].empty()) {
      commitId = make_shared<string>(boost::any_cast<string>(m["commitId"]));
    }
    if (m.find("commitMessage") != m.end() && !m["commitMessage"].empty()) {
      commitMessage = make_shared<string>(boost::any_cast<string>(m["commitMessage"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("repoPath") != m.end() && !m["repoPath"].empty()) {
      repoPath = make_shared<string>(boost::any_cast<string>(m["repoPath"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~ListSearchCommitResponseBodyResultSource() = default;
};
class ListSearchCommitResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> docId{};
  shared_ptr<ListSearchCommitResponseBodyResultHighlightTextMap> highlightTextMap{};
  shared_ptr<ListSearchCommitResponseBodyResultSource> source{};

  ListSearchCommitResponseBodyResult() {}

  explicit ListSearchCommitResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docId) {
      res["docId"] = boost::any(*docId);
    }
    if (highlightTextMap) {
      res["highlightTextMap"] = highlightTextMap ? boost::any(highlightTextMap->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (source) {
      res["source"] = source ? boost::any(source->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("docId") != m.end() && !m["docId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["docId"]));
    }
    if (m.find("highlightTextMap") != m.end() && !m["highlightTextMap"].empty()) {
      if (typeid(map<string, boost::any>) == m["highlightTextMap"].type()) {
        ListSearchCommitResponseBodyResultHighlightTextMap model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["highlightTextMap"]));
        highlightTextMap = make_shared<ListSearchCommitResponseBodyResultHighlightTextMap>(model1);
      }
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      if (typeid(map<string, boost::any>) == m["source"].type()) {
        ListSearchCommitResponseBodyResultSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["source"]));
        source = make_shared<ListSearchCommitResponseBodyResultSource>(model1);
      }
    }
  }


  virtual ~ListSearchCommitResponseBodyResult() = default;
};
class ListSearchCommitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSearchCommitResponseBodyResult>> result{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListSearchCommitResponseBody() {}

  explicit ListSearchCommitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ListSearchCommitResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSearchCommitResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListSearchCommitResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
  }


  virtual ~ListSearchCommitResponseBody() = default;
};
class ListSearchCommitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSearchCommitResponseBody> body{};

  ListSearchCommitResponse() {}

  explicit ListSearchCommitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSearchCommitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSearchCommitResponseBody>(model1);
      }
    }
  }


  virtual ~ListSearchCommitResponse() = default;
};
class ListSearchRepositoryRequestRepoPath : public Darabonba::Model {
public:
  shared_ptr<string> matchType{};
  shared_ptr<string> operatorType{};
  shared_ptr<string> value{};

  ListSearchRepositoryRequestRepoPath() {}

  explicit ListSearchRepositoryRequestRepoPath(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (matchType) {
      res["matchType"] = boost::any(*matchType);
    }
    if (operatorType) {
      res["operatorType"] = boost::any(*operatorType);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("matchType") != m.end() && !m["matchType"].empty()) {
      matchType = make_shared<string>(boost::any_cast<string>(m["matchType"]));
    }
    if (m.find("operatorType") != m.end() && !m["operatorType"].empty()) {
      operatorType = make_shared<string>(boost::any_cast<string>(m["operatorType"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~ListSearchRepositoryRequestRepoPath() = default;
};
class ListSearchRepositoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunPk{};
  shared_ptr<string> keyword{};
  shared_ptr<string> order{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<ListSearchRepositoryRequestRepoPath> repoPath{};
  shared_ptr<string> scope{};
  shared_ptr<string> sort{};
  shared_ptr<long> visibilityLevel{};
  shared_ptr<string> organizationId{};

  ListSearchRepositoryRequest() {}

  explicit ListSearchRepositoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunPk) {
      res["aliyunPk"] = boost::any(*aliyunPk);
    }
    if (keyword) {
      res["keyword"] = boost::any(*keyword);
    }
    if (order) {
      res["order"] = boost::any(*order);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (repoPath) {
      res["repoPath"] = repoPath ? boost::any(repoPath->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (sort) {
      res["sort"] = boost::any(*sort);
    }
    if (visibilityLevel) {
      res["visibilityLevel"] = boost::any(*visibilityLevel);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aliyunPk") != m.end() && !m["aliyunPk"].empty()) {
      aliyunPk = make_shared<string>(boost::any_cast<string>(m["aliyunPk"]));
    }
    if (m.find("keyword") != m.end() && !m["keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["keyword"]));
    }
    if (m.find("order") != m.end() && !m["order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["order"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("repoPath") != m.end() && !m["repoPath"].empty()) {
      if (typeid(map<string, boost::any>) == m["repoPath"].type()) {
        ListSearchRepositoryRequestRepoPath model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["repoPath"]));
        repoPath = make_shared<ListSearchRepositoryRequestRepoPath>(model1);
      }
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["scope"]));
    }
    if (m.find("sort") != m.end() && !m["sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["sort"]));
    }
    if (m.find("visibilityLevel") != m.end() && !m["visibilityLevel"].empty()) {
      visibilityLevel = make_shared<long>(boost::any_cast<long>(m["visibilityLevel"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~ListSearchRepositoryRequest() = default;
};
class ListSearchRepositoryResponseBodyResultHighlightTextMap : public Darabonba::Model {
public:
  shared_ptr<string> creatorUserId{};
  shared_ptr<string> description{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> readMe{};
  shared_ptr<string> repoNameWithNamespace{};
  shared_ptr<string> repoPath{};

  ListSearchRepositoryResponseBodyResultHighlightTextMap() {}

  explicit ListSearchRepositoryResponseBodyResultHighlightTextMap(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creatorUserId) {
      res["creatorUserId"] = boost::any(*creatorUserId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (readMe) {
      res["readMe"] = boost::any(*readMe);
    }
    if (repoNameWithNamespace) {
      res["repoNameWithNamespace"] = boost::any(*repoNameWithNamespace);
    }
    if (repoPath) {
      res["repoPath"] = boost::any(*repoPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("creatorUserId") != m.end() && !m["creatorUserId"].empty()) {
      creatorUserId = make_shared<string>(boost::any_cast<string>(m["creatorUserId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("readMe") != m.end() && !m["readMe"].empty()) {
      readMe = make_shared<string>(boost::any_cast<string>(m["readMe"]));
    }
    if (m.find("repoNameWithNamespace") != m.end() && !m["repoNameWithNamespace"].empty()) {
      repoNameWithNamespace = make_shared<string>(boost::any_cast<string>(m["repoNameWithNamespace"]));
    }
    if (m.find("repoPath") != m.end() && !m["repoPath"].empty()) {
      repoPath = make_shared<string>(boost::any_cast<string>(m["repoPath"]));
    }
  }


  virtual ~ListSearchRepositoryResponseBodyResultHighlightTextMap() = default;
};
class ListSearchRepositoryResponseBodyResultSource : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> lastActivityTime{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> readMe{};
  shared_ptr<string> repoName{};
  shared_ptr<string> repoPath{};
  shared_ptr<long> visibilityLevel{};

  ListSearchRepositoryResponseBodyResultSource() {}

  explicit ListSearchRepositoryResponseBodyResultSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (lastActivityTime) {
      res["lastActivityTime"] = boost::any(*lastActivityTime);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (readMe) {
      res["readMe"] = boost::any(*readMe);
    }
    if (repoName) {
      res["repoName"] = boost::any(*repoName);
    }
    if (repoPath) {
      res["repoPath"] = boost::any(*repoPath);
    }
    if (visibilityLevel) {
      res["visibilityLevel"] = boost::any(*visibilityLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("lastActivityTime") != m.end() && !m["lastActivityTime"].empty()) {
      lastActivityTime = make_shared<string>(boost::any_cast<string>(m["lastActivityTime"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("readMe") != m.end() && !m["readMe"].empty()) {
      readMe = make_shared<string>(boost::any_cast<string>(m["readMe"]));
    }
    if (m.find("repoName") != m.end() && !m["repoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["repoName"]));
    }
    if (m.find("repoPath") != m.end() && !m["repoPath"].empty()) {
      repoPath = make_shared<string>(boost::any_cast<string>(m["repoPath"]));
    }
    if (m.find("visibilityLevel") != m.end() && !m["visibilityLevel"].empty()) {
      visibilityLevel = make_shared<long>(boost::any_cast<long>(m["visibilityLevel"]));
    }
  }


  virtual ~ListSearchRepositoryResponseBodyResultSource() = default;
};
class ListSearchRepositoryResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> docId{};
  shared_ptr<ListSearchRepositoryResponseBodyResultHighlightTextMap> highlightTextMap{};
  shared_ptr<ListSearchRepositoryResponseBodyResultSource> source{};

  ListSearchRepositoryResponseBodyResult() {}

  explicit ListSearchRepositoryResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docId) {
      res["docId"] = boost::any(*docId);
    }
    if (highlightTextMap) {
      res["highlightTextMap"] = highlightTextMap ? boost::any(highlightTextMap->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (source) {
      res["source"] = source ? boost::any(source->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("docId") != m.end() && !m["docId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["docId"]));
    }
    if (m.find("highlightTextMap") != m.end() && !m["highlightTextMap"].empty()) {
      if (typeid(map<string, boost::any>) == m["highlightTextMap"].type()) {
        ListSearchRepositoryResponseBodyResultHighlightTextMap model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["highlightTextMap"]));
        highlightTextMap = make_shared<ListSearchRepositoryResponseBodyResultHighlightTextMap>(model1);
      }
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      if (typeid(map<string, boost::any>) == m["source"].type()) {
        ListSearchRepositoryResponseBodyResultSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["source"]));
        source = make_shared<ListSearchRepositoryResponseBodyResultSource>(model1);
      }
    }
  }


  virtual ~ListSearchRepositoryResponseBodyResult() = default;
};
class ListSearchRepositoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSearchRepositoryResponseBodyResult>> result{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListSearchRepositoryResponseBody() {}

  explicit ListSearchRepositoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ListSearchRepositoryResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSearchRepositoryResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListSearchRepositoryResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
  }


  virtual ~ListSearchRepositoryResponseBody() = default;
};
class ListSearchRepositoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSearchRepositoryResponseBody> body{};

  ListSearchRepositoryResponse() {}

  explicit ListSearchRepositoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSearchRepositoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSearchRepositoryResponseBody>(model1);
      }
    }
  }


  virtual ~ListSearchRepositoryResponse() = default;
};
class ListSearchSourceCodeRequestFilePath : public Darabonba::Model {
public:
  shared_ptr<string> matchType{};
  shared_ptr<string> operatorType{};
  shared_ptr<string> value{};

  ListSearchSourceCodeRequestFilePath() {}

  explicit ListSearchSourceCodeRequestFilePath(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (matchType) {
      res["matchType"] = boost::any(*matchType);
    }
    if (operatorType) {
      res["operatorType"] = boost::any(*operatorType);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("matchType") != m.end() && !m["matchType"].empty()) {
      matchType = make_shared<string>(boost::any_cast<string>(m["matchType"]));
    }
    if (m.find("operatorType") != m.end() && !m["operatorType"].empty()) {
      operatorType = make_shared<string>(boost::any_cast<string>(m["operatorType"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~ListSearchSourceCodeRequestFilePath() = default;
};
class ListSearchSourceCodeRequestRepoPath : public Darabonba::Model {
public:
  shared_ptr<string> matchType{};
  shared_ptr<string> operatorType{};
  shared_ptr<string> value{};

  ListSearchSourceCodeRequestRepoPath() {}

  explicit ListSearchSourceCodeRequestRepoPath(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (matchType) {
      res["matchType"] = boost::any(*matchType);
    }
    if (operatorType) {
      res["operatorType"] = boost::any(*operatorType);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("matchType") != m.end() && !m["matchType"].empty()) {
      matchType = make_shared<string>(boost::any_cast<string>(m["matchType"]));
    }
    if (m.find("operatorType") != m.end() && !m["operatorType"].empty()) {
      operatorType = make_shared<string>(boost::any_cast<string>(m["operatorType"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~ListSearchSourceCodeRequestRepoPath() = default;
};
class ListSearchSourceCodeRequest : public Darabonba::Model {
public:
  shared_ptr<ListSearchSourceCodeRequestFilePath> filePath{};
  shared_ptr<bool> isCodeBlock{};
  shared_ptr<string> keyword{};
  shared_ptr<string> language{};
  shared_ptr<string> order{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<ListSearchSourceCodeRequestRepoPath> repoPath{};
  shared_ptr<string> scope{};
  shared_ptr<string> sort{};
  shared_ptr<string> organizationId{};

  ListSearchSourceCodeRequest() {}

  explicit ListSearchSourceCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filePath) {
      res["filePath"] = filePath ? boost::any(filePath->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isCodeBlock) {
      res["isCodeBlock"] = boost::any(*isCodeBlock);
    }
    if (keyword) {
      res["keyword"] = boost::any(*keyword);
    }
    if (language) {
      res["language"] = boost::any(*language);
    }
    if (order) {
      res["order"] = boost::any(*order);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (repoPath) {
      res["repoPath"] = repoPath ? boost::any(repoPath->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (sort) {
      res["sort"] = boost::any(*sort);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("filePath") != m.end() && !m["filePath"].empty()) {
      if (typeid(map<string, boost::any>) == m["filePath"].type()) {
        ListSearchSourceCodeRequestFilePath model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["filePath"]));
        filePath = make_shared<ListSearchSourceCodeRequestFilePath>(model1);
      }
    }
    if (m.find("isCodeBlock") != m.end() && !m["isCodeBlock"].empty()) {
      isCodeBlock = make_shared<bool>(boost::any_cast<bool>(m["isCodeBlock"]));
    }
    if (m.find("keyword") != m.end() && !m["keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["keyword"]));
    }
    if (m.find("language") != m.end() && !m["language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["language"]));
    }
    if (m.find("order") != m.end() && !m["order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["order"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("repoPath") != m.end() && !m["repoPath"].empty()) {
      if (typeid(map<string, boost::any>) == m["repoPath"].type()) {
        ListSearchSourceCodeRequestRepoPath model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["repoPath"]));
        repoPath = make_shared<ListSearchSourceCodeRequestRepoPath>(model1);
      }
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["scope"]));
    }
    if (m.find("sort") != m.end() && !m["sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["sort"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~ListSearchSourceCodeRequest() = default;
};
class ListSearchSourceCodeResponseBodyResultHighlightTextMap : public Darabonba::Model {
public:
  shared_ptr<string> clob{};
  shared_ptr<string> fileName{};
  shared_ptr<string> language{};
  shared_ptr<string> organizationId{};

  ListSearchSourceCodeResponseBodyResultHighlightTextMap() {}

  explicit ListSearchSourceCodeResponseBodyResultHighlightTextMap(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clob) {
      res["clob"] = boost::any(*clob);
    }
    if (fileName) {
      res["fileName"] = boost::any(*fileName);
    }
    if (language) {
      res["language"] = boost::any(*language);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clob") != m.end() && !m["clob"].empty()) {
      clob = make_shared<string>(boost::any_cast<string>(m["clob"]));
    }
    if (m.find("fileName") != m.end() && !m["fileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["fileName"]));
    }
    if (m.find("language") != m.end() && !m["language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["language"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~ListSearchSourceCodeResponseBodyResultHighlightTextMap() = default;
};
class ListSearchSourceCodeResponseBodyResultSource : public Darabonba::Model {
public:
  shared_ptr<string> branch{};
  shared_ptr<string> checkinDate{};
  shared_ptr<string> fileName{};
  shared_ptr<string> filePath{};
  shared_ptr<string> language{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> repoPath{};

  ListSearchSourceCodeResponseBodyResultSource() {}

  explicit ListSearchSourceCodeResponseBodyResultSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (branch) {
      res["branch"] = boost::any(*branch);
    }
    if (checkinDate) {
      res["checkinDate"] = boost::any(*checkinDate);
    }
    if (fileName) {
      res["fileName"] = boost::any(*fileName);
    }
    if (filePath) {
      res["filePath"] = boost::any(*filePath);
    }
    if (language) {
      res["language"] = boost::any(*language);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (repoPath) {
      res["repoPath"] = boost::any(*repoPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("branch") != m.end() && !m["branch"].empty()) {
      branch = make_shared<string>(boost::any_cast<string>(m["branch"]));
    }
    if (m.find("checkinDate") != m.end() && !m["checkinDate"].empty()) {
      checkinDate = make_shared<string>(boost::any_cast<string>(m["checkinDate"]));
    }
    if (m.find("fileName") != m.end() && !m["fileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["fileName"]));
    }
    if (m.find("filePath") != m.end() && !m["filePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["filePath"]));
    }
    if (m.find("language") != m.end() && !m["language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["language"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("repoPath") != m.end() && !m["repoPath"].empty()) {
      repoPath = make_shared<string>(boost::any_cast<string>(m["repoPath"]));
    }
  }


  virtual ~ListSearchSourceCodeResponseBodyResultSource() = default;
};
class ListSearchSourceCodeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> docId{};
  shared_ptr<ListSearchSourceCodeResponseBodyResultHighlightTextMap> highlightTextMap{};
  shared_ptr<ListSearchSourceCodeResponseBodyResultSource> source{};

  ListSearchSourceCodeResponseBodyResult() {}

  explicit ListSearchSourceCodeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docId) {
      res["docId"] = boost::any(*docId);
    }
    if (highlightTextMap) {
      res["highlightTextMap"] = highlightTextMap ? boost::any(highlightTextMap->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (source) {
      res["source"] = source ? boost::any(source->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("docId") != m.end() && !m["docId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["docId"]));
    }
    if (m.find("highlightTextMap") != m.end() && !m["highlightTextMap"].empty()) {
      if (typeid(map<string, boost::any>) == m["highlightTextMap"].type()) {
        ListSearchSourceCodeResponseBodyResultHighlightTextMap model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["highlightTextMap"]));
        highlightTextMap = make_shared<ListSearchSourceCodeResponseBodyResultHighlightTextMap>(model1);
      }
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      if (typeid(map<string, boost::any>) == m["source"].type()) {
        ListSearchSourceCodeResponseBodyResultSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["source"]));
        source = make_shared<ListSearchSourceCodeResponseBodyResultSource>(model1);
      }
    }
  }


  virtual ~ListSearchSourceCodeResponseBodyResult() = default;
};
class ListSearchSourceCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSearchSourceCodeResponseBodyResult>> result{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListSearchSourceCodeResponseBody() {}

  explicit ListSearchSourceCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ListSearchSourceCodeResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSearchSourceCodeResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListSearchSourceCodeResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
  }


  virtual ~ListSearchSourceCodeResponseBody() = default;
};
class ListSearchSourceCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSearchSourceCodeResponseBody> body{};

  ListSearchSourceCodeResponse() {}

  explicit ListSearchSourceCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSearchSourceCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSearchSourceCodeResponseBody>(model1);
      }
    }
  }


  virtual ~ListSearchSourceCodeResponse() = default;
};
class ListServiceAuthsRequest : public Darabonba::Model {
public:
  shared_ptr<string> serviceAuthType{};

  ListServiceAuthsRequest() {}

  explicit ListServiceAuthsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceAuthType) {
      res["serviceAuthType"] = boost::any(*serviceAuthType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("serviceAuthType") != m.end() && !m["serviceAuthType"].empty()) {
      serviceAuthType = make_shared<string>(boost::any_cast<string>(m["serviceAuthType"]));
    }
  }


  virtual ~ListServiceAuthsRequest() = default;
};
class ListServiceAuthsResponseBodyServiceAuths : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> ownerStaffId{};
  shared_ptr<string> type{};

  ListServiceAuthsResponseBodyServiceAuths() {}

  explicit ListServiceAuthsResponseBodyServiceAuths(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (ownerName) {
      res["ownerName"] = boost::any(*ownerName);
    }
    if (ownerStaffId) {
      res["ownerStaffId"] = boost::any(*ownerStaffId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("ownerName") != m.end() && !m["ownerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["ownerName"]));
    }
    if (m.find("ownerStaffId") != m.end() && !m["ownerStaffId"].empty()) {
      ownerStaffId = make_shared<string>(boost::any_cast<string>(m["ownerStaffId"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ListServiceAuthsResponseBodyServiceAuths() = default;
};
class ListServiceAuthsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListServiceAuthsResponseBodyServiceAuths>> serviceAuths{};
  shared_ptr<bool> success{};

  ListServiceAuthsResponseBody() {}

  explicit ListServiceAuthsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (serviceAuths) {
      vector<boost::any> temp1;
      for(auto item1:*serviceAuths){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["serviceAuths"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("serviceAuths") != m.end() && !m["serviceAuths"].empty()) {
      if (typeid(vector<boost::any>) == m["serviceAuths"].type()) {
        vector<ListServiceAuthsResponseBodyServiceAuths> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["serviceAuths"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListServiceAuthsResponseBodyServiceAuths model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceAuths = make_shared<vector<ListServiceAuthsResponseBodyServiceAuths>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ListServiceAuthsResponseBody() = default;
};
class ListServiceAuthsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListServiceAuthsResponseBody> body{};

  ListServiceAuthsResponse() {}

  explicit ListServiceAuthsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListServiceAuthsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListServiceAuthsResponseBody>(model1);
      }
    }
  }


  virtual ~ListServiceAuthsResponse() = default;
};
class ListServiceConnectionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> sericeConnectionType{};

  ListServiceConnectionsRequest() {}

  explicit ListServiceConnectionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sericeConnectionType) {
      res["sericeConnectionType"] = boost::any(*sericeConnectionType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("sericeConnectionType") != m.end() && !m["sericeConnectionType"].empty()) {
      sericeConnectionType = make_shared<string>(boost::any_cast<string>(m["sericeConnectionType"]));
    }
  }


  virtual ~ListServiceConnectionsRequest() = default;
};
class ListServiceConnectionsResponseBodyServiceConnections : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerAccountId{};
  shared_ptr<string> type{};
  shared_ptr<string> uuid{};

  ListServiceConnectionsResponseBodyServiceConnections() {}

  explicit ListServiceConnectionsResponseBodyServiceConnections(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (ownerAccountId) {
      res["ownerAccountId"] = boost::any(*ownerAccountId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (uuid) {
      res["uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["createTime"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("ownerAccountId") != m.end() && !m["ownerAccountId"].empty()) {
      ownerAccountId = make_shared<long>(boost::any_cast<long>(m["ownerAccountId"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("uuid") != m.end() && !m["uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["uuid"]));
    }
  }


  virtual ~ListServiceConnectionsResponseBodyServiceConnections() = default;
};
class ListServiceConnectionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListServiceConnectionsResponseBodyServiceConnections>> serviceConnections{};
  shared_ptr<bool> success{};

  ListServiceConnectionsResponseBody() {}

  explicit ListServiceConnectionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (serviceConnections) {
      vector<boost::any> temp1;
      for(auto item1:*serviceConnections){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["serviceConnections"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("serviceConnections") != m.end() && !m["serviceConnections"].empty()) {
      if (typeid(vector<boost::any>) == m["serviceConnections"].type()) {
        vector<ListServiceConnectionsResponseBodyServiceConnections> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["serviceConnections"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListServiceConnectionsResponseBodyServiceConnections model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceConnections = make_shared<vector<ListServiceConnectionsResponseBodyServiceConnections>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ListServiceConnectionsResponseBody() = default;
};
class ListServiceConnectionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListServiceConnectionsResponseBody> body{};

  ListServiceConnectionsResponse() {}

  explicit ListServiceConnectionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListServiceConnectionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListServiceConnectionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListServiceConnectionsResponse() = default;
};
class ListServiceCredentialsRequest : public Darabonba::Model {
public:
  shared_ptr<string> serviceCredentialType{};

  ListServiceCredentialsRequest() {}

  explicit ListServiceCredentialsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceCredentialType) {
      res["serviceCredentialType"] = boost::any(*serviceCredentialType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("serviceCredentialType") != m.end() && !m["serviceCredentialType"].empty()) {
      serviceCredentialType = make_shared<string>(boost::any_cast<string>(m["serviceCredentialType"]));
    }
  }


  virtual ~ListServiceCredentialsRequest() = default;
};
class ListServiceCredentialsResponseBodyServiceCredentials : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> ownerStaffId{};
  shared_ptr<string> type{};

  ListServiceCredentialsResponseBodyServiceCredentials() {}

  explicit ListServiceCredentialsResponseBodyServiceCredentials(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (ownerName) {
      res["ownerName"] = boost::any(*ownerName);
    }
    if (ownerStaffId) {
      res["ownerStaffId"] = boost::any(*ownerStaffId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("ownerName") != m.end() && !m["ownerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["ownerName"]));
    }
    if (m.find("ownerStaffId") != m.end() && !m["ownerStaffId"].empty()) {
      ownerStaffId = make_shared<string>(boost::any_cast<string>(m["ownerStaffId"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ListServiceCredentialsResponseBodyServiceCredentials() = default;
};
class ListServiceCredentialsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListServiceCredentialsResponseBodyServiceCredentials>> serviceCredentials{};
  shared_ptr<bool> success{};

  ListServiceCredentialsResponseBody() {}

  explicit ListServiceCredentialsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (serviceCredentials) {
      vector<boost::any> temp1;
      for(auto item1:*serviceCredentials){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["serviceCredentials"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("serviceCredentials") != m.end() && !m["serviceCredentials"].empty()) {
      if (typeid(vector<boost::any>) == m["serviceCredentials"].type()) {
        vector<ListServiceCredentialsResponseBodyServiceCredentials> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["serviceCredentials"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListServiceCredentialsResponseBodyServiceCredentials model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceCredentials = make_shared<vector<ListServiceCredentialsResponseBodyServiceCredentials>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ListServiceCredentialsResponseBody() = default;
};
class ListServiceCredentialsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListServiceCredentialsResponseBody> body{};

  ListServiceCredentialsResponse() {}

  explicit ListServiceCredentialsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListServiceCredentialsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListServiceCredentialsResponseBody>(model1);
      }
    }
  }


  virtual ~ListServiceCredentialsResponse() = default;
};
class ListSprintsRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> spaceIdentifier{};
  shared_ptr<string> spaceType{};

  ListSprintsRequest() {}

  explicit ListSprintsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (spaceIdentifier) {
      res["spaceIdentifier"] = boost::any(*spaceIdentifier);
    }
    if (spaceType) {
      res["spaceType"] = boost::any(*spaceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("spaceIdentifier") != m.end() && !m["spaceIdentifier"].empty()) {
      spaceIdentifier = make_shared<string>(boost::any_cast<string>(m["spaceIdentifier"]));
    }
    if (m.find("spaceType") != m.end() && !m["spaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["spaceType"]));
    }
  }


  virtual ~ListSprintsRequest() = default;
};
class ListSprintsResponseBodySprints : public Darabonba::Model {
public:
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<long> endDate{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> identifier{};
  shared_ptr<string> modifier{};
  shared_ptr<string> name{};
  shared_ptr<string> scope{};
  shared_ptr<string> spaceIdentifier{};
  shared_ptr<long> startDate{};
  shared_ptr<string> status{};

  ListSprintsResponseBodySprints() {}

  explicit ListSprintsResponseBodySprints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creator) {
      res["creator"] = boost::any(*creator);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (endDate) {
      res["endDate"] = boost::any(*endDate);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (modifier) {
      res["modifier"] = boost::any(*modifier);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (spaceIdentifier) {
      res["spaceIdentifier"] = boost::any(*spaceIdentifier);
    }
    if (startDate) {
      res["startDate"] = boost::any(*startDate);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["creator"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("endDate") != m.end() && !m["endDate"].empty()) {
      endDate = make_shared<long>(boost::any_cast<long>(m["endDate"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("modifier") != m.end() && !m["modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["modifier"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["scope"]));
    }
    if (m.find("spaceIdentifier") != m.end() && !m["spaceIdentifier"].empty()) {
      spaceIdentifier = make_shared<string>(boost::any_cast<string>(m["spaceIdentifier"]));
    }
    if (m.find("startDate") != m.end() && !m["startDate"].empty()) {
      startDate = make_shared<long>(boost::any_cast<long>(m["startDate"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~ListSprintsResponseBodySprints() = default;
};
class ListSprintsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSprintsResponseBodySprints>> sprints{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListSprintsResponseBody() {}

  explicit ListSprintsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (sprints) {
      vector<boost::any> temp1;
      for(auto item1:*sprints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["sprints"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("sprints") != m.end() && !m["sprints"].empty()) {
      if (typeid(vector<boost::any>) == m["sprints"].type()) {
        vector<ListSprintsResponseBodySprints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["sprints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSprintsResponseBodySprints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sprints = make_shared<vector<ListSprintsResponseBodySprints>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ListSprintsResponseBody() = default;
};
class ListSprintsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSprintsResponseBody> body{};

  ListSprintsResponse() {}

  explicit ListSprintsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSprintsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSprintsResponseBody>(model1);
      }
    }
  }


  virtual ~ListSprintsResponse() = default;
};
class ListTestCaseFieldsRequest : public Darabonba::Model {
public:
  shared_ptr<string> spaceIdentifier{};

  ListTestCaseFieldsRequest() {}

  explicit ListTestCaseFieldsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (spaceIdentifier) {
      res["spaceIdentifier"] = boost::any(*spaceIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("spaceIdentifier") != m.end() && !m["spaceIdentifier"].empty()) {
      spaceIdentifier = make_shared<string>(boost::any_cast<string>(m["spaceIdentifier"]));
    }
  }


  virtual ~ListTestCaseFieldsRequest() = default;
};
class ListTestCaseFieldsResponseBodyFieldsOptions : public Darabonba::Model {
public:
  shared_ptr<string> displayValue{};
  shared_ptr<string> fieldIdentifier{};
  shared_ptr<string> identifier{};
  shared_ptr<long> level{};
  shared_ptr<long> position{};
  shared_ptr<string> value{};
  shared_ptr<string> valueEn{};

  ListTestCaseFieldsResponseBodyFieldsOptions() {}

  explicit ListTestCaseFieldsResponseBodyFieldsOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayValue) {
      res["displayValue"] = boost::any(*displayValue);
    }
    if (fieldIdentifier) {
      res["fieldIdentifier"] = boost::any(*fieldIdentifier);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (level) {
      res["level"] = boost::any(*level);
    }
    if (position) {
      res["position"] = boost::any(*position);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    if (valueEn) {
      res["valueEn"] = boost::any(*valueEn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("displayValue") != m.end() && !m["displayValue"].empty()) {
      displayValue = make_shared<string>(boost::any_cast<string>(m["displayValue"]));
    }
    if (m.find("fieldIdentifier") != m.end() && !m["fieldIdentifier"].empty()) {
      fieldIdentifier = make_shared<string>(boost::any_cast<string>(m["fieldIdentifier"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("level") != m.end() && !m["level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["level"]));
    }
    if (m.find("position") != m.end() && !m["position"].empty()) {
      position = make_shared<long>(boost::any_cast<long>(m["position"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
    if (m.find("valueEn") != m.end() && !m["valueEn"].empty()) {
      valueEn = make_shared<string>(boost::any_cast<string>(m["valueEn"]));
    }
  }


  virtual ~ListTestCaseFieldsResponseBodyFieldsOptions() = default;
};
class ListTestCaseFieldsResponseBodyFields : public Darabonba::Model {
public:
  shared_ptr<string> className{};
  shared_ptr<string> creator{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> description{};
  shared_ptr<string> format{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> identifier{};
  shared_ptr<bool> isRequired{};
  shared_ptr<bool> isShowWhenCreate{};
  shared_ptr<bool> isSystemRequired{};
  shared_ptr<string> linkWithService{};
  shared_ptr<string> modifier{};
  shared_ptr<string> name{};
  shared_ptr<vector<ListTestCaseFieldsResponseBodyFieldsOptions>> options{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> type{};

  ListTestCaseFieldsResponseBodyFields() {}

  explicit ListTestCaseFieldsResponseBodyFields(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (className) {
      res["className"] = boost::any(*className);
    }
    if (creator) {
      res["creator"] = boost::any(*creator);
    }
    if (defaultValue) {
      res["defaultValue"] = boost::any(*defaultValue);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (format) {
      res["format"] = boost::any(*format);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (isRequired) {
      res["isRequired"] = boost::any(*isRequired);
    }
    if (isShowWhenCreate) {
      res["isShowWhenCreate"] = boost::any(*isShowWhenCreate);
    }
    if (isSystemRequired) {
      res["isSystemRequired"] = boost::any(*isSystemRequired);
    }
    if (linkWithService) {
      res["linkWithService"] = boost::any(*linkWithService);
    }
    if (modifier) {
      res["modifier"] = boost::any(*modifier);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (options) {
      vector<boost::any> temp1;
      for(auto item1:*options){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["options"] = boost::any(temp1);
    }
    if (resourceType) {
      res["resourceType"] = boost::any(*resourceType);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("className") != m.end() && !m["className"].empty()) {
      className = make_shared<string>(boost::any_cast<string>(m["className"]));
    }
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["creator"]));
    }
    if (m.find("defaultValue") != m.end() && !m["defaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["defaultValue"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("format") != m.end() && !m["format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["format"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("isRequired") != m.end() && !m["isRequired"].empty()) {
      isRequired = make_shared<bool>(boost::any_cast<bool>(m["isRequired"]));
    }
    if (m.find("isShowWhenCreate") != m.end() && !m["isShowWhenCreate"].empty()) {
      isShowWhenCreate = make_shared<bool>(boost::any_cast<bool>(m["isShowWhenCreate"]));
    }
    if (m.find("isSystemRequired") != m.end() && !m["isSystemRequired"].empty()) {
      isSystemRequired = make_shared<bool>(boost::any_cast<bool>(m["isSystemRequired"]));
    }
    if (m.find("linkWithService") != m.end() && !m["linkWithService"].empty()) {
      linkWithService = make_shared<string>(boost::any_cast<string>(m["linkWithService"]));
    }
    if (m.find("modifier") != m.end() && !m["modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["modifier"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("options") != m.end() && !m["options"].empty()) {
      if (typeid(vector<boost::any>) == m["options"].type()) {
        vector<ListTestCaseFieldsResponseBodyFieldsOptions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["options"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTestCaseFieldsResponseBodyFieldsOptions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        options = make_shared<vector<ListTestCaseFieldsResponseBodyFieldsOptions>>(expect1);
      }
    }
    if (m.find("resourceType") != m.end() && !m["resourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["resourceType"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ListTestCaseFieldsResponseBodyFields() = default;
};
class ListTestCaseFieldsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<vector<ListTestCaseFieldsResponseBodyFields>> fields{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListTestCaseFieldsResponseBody() {}

  explicit ListTestCaseFieldsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (fields) {
      vector<boost::any> temp1;
      for(auto item1:*fields){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["fields"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("fields") != m.end() && !m["fields"].empty()) {
      if (typeid(vector<boost::any>) == m["fields"].type()) {
        vector<ListTestCaseFieldsResponseBodyFields> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["fields"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTestCaseFieldsResponseBodyFields model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fields = make_shared<vector<ListTestCaseFieldsResponseBodyFields>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ListTestCaseFieldsResponseBody() = default;
};
class ListTestCaseFieldsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTestCaseFieldsResponseBody> body{};

  ListTestCaseFieldsResponse() {}

  explicit ListTestCaseFieldsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTestCaseFieldsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTestCaseFieldsResponseBody>(model1);
      }
    }
  }


  virtual ~ListTestCaseFieldsResponse() = default;
};
class ListUserDrawRecordByPkRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunPk{};
  shared_ptr<string> drawGroup{};
  shared_ptr<string> drawPoolName{};

  ListUserDrawRecordByPkRequest() {}

  explicit ListUserDrawRecordByPkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunPk) {
      res["aliyunPk"] = boost::any(*aliyunPk);
    }
    if (drawGroup) {
      res["drawGroup"] = boost::any(*drawGroup);
    }
    if (drawPoolName) {
      res["drawPoolName"] = boost::any(*drawPoolName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aliyunPk") != m.end() && !m["aliyunPk"].empty()) {
      aliyunPk = make_shared<string>(boost::any_cast<string>(m["aliyunPk"]));
    }
    if (m.find("drawGroup") != m.end() && !m["drawGroup"].empty()) {
      drawGroup = make_shared<string>(boost::any_cast<string>(m["drawGroup"]));
    }
    if (m.find("drawPoolName") != m.end() && !m["drawPoolName"].empty()) {
      drawPoolName = make_shared<string>(boost::any_cast<string>(m["drawPoolName"]));
    }
  }


  virtual ~ListUserDrawRecordByPkRequest() = default;
};
class ListUserDrawRecordByPkResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> aliyunPk{};
  shared_ptr<string> drawGroup{};
  shared_ptr<string> drawPoolName{};
  shared_ptr<string> drawResult{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> taskGroupId{};
  shared_ptr<string> uccId{};

  ListUserDrawRecordByPkResponseBodyData() {}

  explicit ListUserDrawRecordByPkResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunPk) {
      res["aliyunPk"] = boost::any(*aliyunPk);
    }
    if (drawGroup) {
      res["drawGroup"] = boost::any(*drawGroup);
    }
    if (drawPoolName) {
      res["drawPoolName"] = boost::any(*drawPoolName);
    }
    if (drawResult) {
      res["drawResult"] = boost::any(*drawResult);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (taskGroupId) {
      res["taskGroupId"] = boost::any(*taskGroupId);
    }
    if (uccId) {
      res["uccId"] = boost::any(*uccId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aliyunPk") != m.end() && !m["aliyunPk"].empty()) {
      aliyunPk = make_shared<string>(boost::any_cast<string>(m["aliyunPk"]));
    }
    if (m.find("drawGroup") != m.end() && !m["drawGroup"].empty()) {
      drawGroup = make_shared<string>(boost::any_cast<string>(m["drawGroup"]));
    }
    if (m.find("drawPoolName") != m.end() && !m["drawPoolName"].empty()) {
      drawPoolName = make_shared<string>(boost::any_cast<string>(m["drawPoolName"]));
    }
    if (m.find("drawResult") != m.end() && !m["drawResult"].empty()) {
      drawResult = make_shared<string>(boost::any_cast<string>(m["drawResult"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmtCreate"]));
    }
    if (m.find("taskGroupId") != m.end() && !m["taskGroupId"].empty()) {
      taskGroupId = make_shared<string>(boost::any_cast<string>(m["taskGroupId"]));
    }
    if (m.find("uccId") != m.end() && !m["uccId"].empty()) {
      uccId = make_shared<string>(boost::any_cast<string>(m["uccId"]));
    }
  }


  virtual ~ListUserDrawRecordByPkResponseBodyData() = default;
};
class ListUserDrawRecordByPkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListUserDrawRecordByPkResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListUserDrawRecordByPkResponseBody() {}

  explicit ListUserDrawRecordByPkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListUserDrawRecordByPkResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUserDrawRecordByPkResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListUserDrawRecordByPkResponseBodyData>>(expect1);
      }
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ListUserDrawRecordByPkResponseBody() = default;
};
class ListUserDrawRecordByPkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUserDrawRecordByPkResponseBody> body{};

  ListUserDrawRecordByPkResponse() {}

  explicit ListUserDrawRecordByPkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUserDrawRecordByPkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUserDrawRecordByPkResponseBody>(model1);
      }
    }
  }


  virtual ~ListUserDrawRecordByPkResponse() = default;
};
class ListUserKeysRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> organizationId{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sort{};

  ListUserKeysRequest() {}

  explicit ListUserKeysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (orderBy) {
      res["orderBy"] = boost::any(*orderBy);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (sort) {
      res["sort"] = boost::any(*sort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("orderBy") != m.end() && !m["orderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["orderBy"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("sort") != m.end() && !m["sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["sort"]));
    }
  }


  virtual ~ListUserKeysRequest() = default;
};
class ListUserKeysResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> createdAt{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> fingerPrint{};
  shared_ptr<long> id{};
  shared_ptr<string> keyScope{};
  shared_ptr<string> lastUsedTime{};
  shared_ptr<string> publicKey{};
  shared_ptr<string> title{};

  ListUserKeysResponseBodyResult() {}

  explicit ListUserKeysResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (expireTime) {
      res["expireTime"] = boost::any(*expireTime);
    }
    if (fingerPrint) {
      res["fingerPrint"] = boost::any(*fingerPrint);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (keyScope) {
      res["keyScope"] = boost::any(*keyScope);
    }
    if (lastUsedTime) {
      res["lastUsedTime"] = boost::any(*lastUsedTime);
    }
    if (publicKey) {
      res["publicKey"] = boost::any(*publicKey);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("expireTime") != m.end() && !m["expireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["expireTime"]));
    }
    if (m.find("fingerPrint") != m.end() && !m["fingerPrint"].empty()) {
      fingerPrint = make_shared<string>(boost::any_cast<string>(m["fingerPrint"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("keyScope") != m.end() && !m["keyScope"].empty()) {
      keyScope = make_shared<string>(boost::any_cast<string>(m["keyScope"]));
    }
    if (m.find("lastUsedTime") != m.end() && !m["lastUsedTime"].empty()) {
      lastUsedTime = make_shared<string>(boost::any_cast<string>(m["lastUsedTime"]));
    }
    if (m.find("publicKey") != m.end() && !m["publicKey"].empty()) {
      publicKey = make_shared<string>(boost::any_cast<string>(m["publicKey"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~ListUserKeysResponseBodyResult() = default;
};
class ListUserKeysResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListUserKeysResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  ListUserKeysResponseBody() {}

  explicit ListUserKeysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ListUserKeysResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUserKeysResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListUserKeysResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ListUserKeysResponseBody() = default;
};
class ListUserKeysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUserKeysResponseBody> body{};

  ListUserKeysResponse() {}

  explicit ListUserKeysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUserKeysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUserKeysResponseBody>(model1);
      }
    }
  }


  virtual ~ListUserKeysResponse() = default;
};
class ListUserResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> organizationId{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> userIds{};

  ListUserResourcesRequest() {}

  explicit ListUserResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (userIds) {
      res["userIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("userIds") != m.end() && !m["userIds"].empty()) {
      userIds = make_shared<string>(boost::any_cast<string>(m["userIds"]));
    }
  }


  virtual ~ListUserResourcesRequest() = default;
};
class ListUserResourcesResponseBodyResultGroupInfosGroupInfo : public Darabonba::Model {
public:
  shared_ptr<string> createdAt{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> nameWithNamespace{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> parentId{};
  shared_ptr<string> path{};
  shared_ptr<string> pathWithNamespace{};
  shared_ptr<string> updatedAt{};
  shared_ptr<long> visibilityLevel{};

  ListUserResourcesResponseBodyResultGroupInfosGroupInfo() {}

  explicit ListUserResourcesResponseBodyResultGroupInfosGroupInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nameWithNamespace) {
      res["nameWithNamespace"] = boost::any(*nameWithNamespace);
    }
    if (ownerId) {
      res["ownerId"] = boost::any(*ownerId);
    }
    if (parentId) {
      res["parentId"] = boost::any(*parentId);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (pathWithNamespace) {
      res["pathWithNamespace"] = boost::any(*pathWithNamespace);
    }
    if (updatedAt) {
      res["updatedAt"] = boost::any(*updatedAt);
    }
    if (visibilityLevel) {
      res["visibilityLevel"] = boost::any(*visibilityLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nameWithNamespace") != m.end() && !m["nameWithNamespace"].empty()) {
      nameWithNamespace = make_shared<string>(boost::any_cast<string>(m["nameWithNamespace"]));
    }
    if (m.find("ownerId") != m.end() && !m["ownerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["ownerId"]));
    }
    if (m.find("parentId") != m.end() && !m["parentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["parentId"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("pathWithNamespace") != m.end() && !m["pathWithNamespace"].empty()) {
      pathWithNamespace = make_shared<string>(boost::any_cast<string>(m["pathWithNamespace"]));
    }
    if (m.find("updatedAt") != m.end() && !m["updatedAt"].empty()) {
      updatedAt = make_shared<string>(boost::any_cast<string>(m["updatedAt"]));
    }
    if (m.find("visibilityLevel") != m.end() && !m["visibilityLevel"].empty()) {
      visibilityLevel = make_shared<long>(boost::any_cast<long>(m["visibilityLevel"]));
    }
  }


  virtual ~ListUserResourcesResponseBodyResultGroupInfosGroupInfo() = default;
};
class ListUserResourcesResponseBodyResultGroupInfosGroupRole : public Darabonba::Model {
public:
  shared_ptr<long> accessLevel{};
  shared_ptr<string> cnRoleName{};
  shared_ptr<string> enRoleName{};
  shared_ptr<long> sourceId{};
  shared_ptr<string> sourceType{};

  ListUserResourcesResponseBodyResultGroupInfosGroupRole() {}

  explicit ListUserResourcesResponseBodyResultGroupInfosGroupRole(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessLevel) {
      res["accessLevel"] = boost::any(*accessLevel);
    }
    if (cnRoleName) {
      res["cnRoleName"] = boost::any(*cnRoleName);
    }
    if (enRoleName) {
      res["enRoleName"] = boost::any(*enRoleName);
    }
    if (sourceId) {
      res["sourceId"] = boost::any(*sourceId);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessLevel") != m.end() && !m["accessLevel"].empty()) {
      accessLevel = make_shared<long>(boost::any_cast<long>(m["accessLevel"]));
    }
    if (m.find("cnRoleName") != m.end() && !m["cnRoleName"].empty()) {
      cnRoleName = make_shared<string>(boost::any_cast<string>(m["cnRoleName"]));
    }
    if (m.find("enRoleName") != m.end() && !m["enRoleName"].empty()) {
      enRoleName = make_shared<string>(boost::any_cast<string>(m["enRoleName"]));
    }
    if (m.find("sourceId") != m.end() && !m["sourceId"].empty()) {
      sourceId = make_shared<long>(boost::any_cast<long>(m["sourceId"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
  }


  virtual ~ListUserResourcesResponseBodyResultGroupInfosGroupRole() = default;
};
class ListUserResourcesResponseBodyResultGroupInfos : public Darabonba::Model {
public:
  shared_ptr<ListUserResourcesResponseBodyResultGroupInfosGroupInfo> groupInfo{};
  shared_ptr<ListUserResourcesResponseBodyResultGroupInfosGroupRole> groupRole{};

  ListUserResourcesResponseBodyResultGroupInfos() {}

  explicit ListUserResourcesResponseBodyResultGroupInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupInfo) {
      res["groupInfo"] = groupInfo ? boost::any(groupInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (groupRole) {
      res["groupRole"] = groupRole ? boost::any(groupRole->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("groupInfo") != m.end() && !m["groupInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["groupInfo"].type()) {
        ListUserResourcesResponseBodyResultGroupInfosGroupInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["groupInfo"]));
        groupInfo = make_shared<ListUserResourcesResponseBodyResultGroupInfosGroupInfo>(model1);
      }
    }
    if (m.find("groupRole") != m.end() && !m["groupRole"].empty()) {
      if (typeid(map<string, boost::any>) == m["groupRole"].type()) {
        ListUserResourcesResponseBodyResultGroupInfosGroupRole model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["groupRole"]));
        groupRole = make_shared<ListUserResourcesResponseBodyResultGroupInfosGroupRole>(model1);
      }
    }
  }


  virtual ~ListUserResourcesResponseBodyResultGroupInfos() = default;
};
class ListUserResourcesResponseBodyResultRepositoryInfosRepositoryInfo : public Darabonba::Model {
public:
  shared_ptr<long> accessLevel{};
  shared_ptr<bool> archived{};
  shared_ptr<string> createdAt{};
  shared_ptr<long> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<bool> encrypted{};
  shared_ptr<long> id{};
  shared_ptr<string> lastActivityAt{};
  shared_ptr<string> name{};
  shared_ptr<string> nameWithNamespace{};
  shared_ptr<long> namespaceId{};
  shared_ptr<string> path{};
  shared_ptr<string> pathWithNamespace{};
  shared_ptr<string> updatedAt{};
  shared_ptr<long> visibilityLevel{};

  ListUserResourcesResponseBodyResultRepositoryInfosRepositoryInfo() {}

  explicit ListUserResourcesResponseBodyResultRepositoryInfosRepositoryInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessLevel) {
      res["accessLevel"] = boost::any(*accessLevel);
    }
    if (archived) {
      res["archived"] = boost::any(*archived);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (creatorId) {
      res["creatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (encrypted) {
      res["encrypted"] = boost::any(*encrypted);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (lastActivityAt) {
      res["lastActivityAt"] = boost::any(*lastActivityAt);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nameWithNamespace) {
      res["nameWithNamespace"] = boost::any(*nameWithNamespace);
    }
    if (namespaceId) {
      res["namespaceId"] = boost::any(*namespaceId);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (pathWithNamespace) {
      res["pathWithNamespace"] = boost::any(*pathWithNamespace);
    }
    if (updatedAt) {
      res["updatedAt"] = boost::any(*updatedAt);
    }
    if (visibilityLevel) {
      res["visibilityLevel"] = boost::any(*visibilityLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessLevel") != m.end() && !m["accessLevel"].empty()) {
      accessLevel = make_shared<long>(boost::any_cast<long>(m["accessLevel"]));
    }
    if (m.find("archived") != m.end() && !m["archived"].empty()) {
      archived = make_shared<bool>(boost::any_cast<bool>(m["archived"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("creatorId") != m.end() && !m["creatorId"].empty()) {
      creatorId = make_shared<long>(boost::any_cast<long>(m["creatorId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("encrypted") != m.end() && !m["encrypted"].empty()) {
      encrypted = make_shared<bool>(boost::any_cast<bool>(m["encrypted"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("lastActivityAt") != m.end() && !m["lastActivityAt"].empty()) {
      lastActivityAt = make_shared<string>(boost::any_cast<string>(m["lastActivityAt"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nameWithNamespace") != m.end() && !m["nameWithNamespace"].empty()) {
      nameWithNamespace = make_shared<string>(boost::any_cast<string>(m["nameWithNamespace"]));
    }
    if (m.find("namespaceId") != m.end() && !m["namespaceId"].empty()) {
      namespaceId = make_shared<long>(boost::any_cast<long>(m["namespaceId"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("pathWithNamespace") != m.end() && !m["pathWithNamespace"].empty()) {
      pathWithNamespace = make_shared<string>(boost::any_cast<string>(m["pathWithNamespace"]));
    }
    if (m.find("updatedAt") != m.end() && !m["updatedAt"].empty()) {
      updatedAt = make_shared<string>(boost::any_cast<string>(m["updatedAt"]));
    }
    if (m.find("visibilityLevel") != m.end() && !m["visibilityLevel"].empty()) {
      visibilityLevel = make_shared<long>(boost::any_cast<long>(m["visibilityLevel"]));
    }
  }


  virtual ~ListUserResourcesResponseBodyResultRepositoryInfosRepositoryInfo() = default;
};
class ListUserResourcesResponseBodyResultRepositoryInfosRepositoryRole : public Darabonba::Model {
public:
  shared_ptr<long> accessLevel{};
  shared_ptr<string> cnRoleName{};
  shared_ptr<string> enRoleName{};
  shared_ptr<long> sourceId{};
  shared_ptr<string> sourceType{};

  ListUserResourcesResponseBodyResultRepositoryInfosRepositoryRole() {}

  explicit ListUserResourcesResponseBodyResultRepositoryInfosRepositoryRole(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessLevel) {
      res["accessLevel"] = boost::any(*accessLevel);
    }
    if (cnRoleName) {
      res["cnRoleName"] = boost::any(*cnRoleName);
    }
    if (enRoleName) {
      res["enRoleName"] = boost::any(*enRoleName);
    }
    if (sourceId) {
      res["sourceId"] = boost::any(*sourceId);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessLevel") != m.end() && !m["accessLevel"].empty()) {
      accessLevel = make_shared<long>(boost::any_cast<long>(m["accessLevel"]));
    }
    if (m.find("cnRoleName") != m.end() && !m["cnRoleName"].empty()) {
      cnRoleName = make_shared<string>(boost::any_cast<string>(m["cnRoleName"]));
    }
    if (m.find("enRoleName") != m.end() && !m["enRoleName"].empty()) {
      enRoleName = make_shared<string>(boost::any_cast<string>(m["enRoleName"]));
    }
    if (m.find("sourceId") != m.end() && !m["sourceId"].empty()) {
      sourceId = make_shared<long>(boost::any_cast<long>(m["sourceId"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
  }


  virtual ~ListUserResourcesResponseBodyResultRepositoryInfosRepositoryRole() = default;
};
class ListUserResourcesResponseBodyResultRepositoryInfos : public Darabonba::Model {
public:
  shared_ptr<ListUserResourcesResponseBodyResultRepositoryInfosRepositoryInfo> repositoryInfo{};
  shared_ptr<ListUserResourcesResponseBodyResultRepositoryInfosRepositoryRole> repositoryRole{};

  ListUserResourcesResponseBodyResultRepositoryInfos() {}

  explicit ListUserResourcesResponseBodyResultRepositoryInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (repositoryInfo) {
      res["repositoryInfo"] = repositoryInfo ? boost::any(repositoryInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (repositoryRole) {
      res["repositoryRole"] = repositoryRole ? boost::any(repositoryRole->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("repositoryInfo") != m.end() && !m["repositoryInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["repositoryInfo"].type()) {
        ListUserResourcesResponseBodyResultRepositoryInfosRepositoryInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["repositoryInfo"]));
        repositoryInfo = make_shared<ListUserResourcesResponseBodyResultRepositoryInfosRepositoryInfo>(model1);
      }
    }
    if (m.find("repositoryRole") != m.end() && !m["repositoryRole"].empty()) {
      if (typeid(map<string, boost::any>) == m["repositoryRole"].type()) {
        ListUserResourcesResponseBodyResultRepositoryInfosRepositoryRole model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["repositoryRole"]));
        repositoryRole = make_shared<ListUserResourcesResponseBodyResultRepositoryInfosRepositoryRole>(model1);
      }
    }
  }


  virtual ~ListUserResourcesResponseBodyResultRepositoryInfos() = default;
};
class ListUserResourcesResponseBodyResultUserInfo : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};

  ListUserResourcesResponseBodyResultUserInfo() {}

  explicit ListUserResourcesResponseBodyResultUserInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~ListUserResourcesResponseBodyResultUserInfo() = default;
};
class ListUserResourcesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListUserResourcesResponseBodyResultGroupInfos>> groupInfos{};
  shared_ptr<vector<ListUserResourcesResponseBodyResultRepositoryInfos>> repositoryInfos{};
  shared_ptr<ListUserResourcesResponseBodyResultUserInfo> userInfo{};

  ListUserResourcesResponseBodyResult() {}

  explicit ListUserResourcesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupInfos) {
      vector<boost::any> temp1;
      for(auto item1:*groupInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["groupInfos"] = boost::any(temp1);
    }
    if (repositoryInfos) {
      vector<boost::any> temp1;
      for(auto item1:*repositoryInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["repositoryInfos"] = boost::any(temp1);
    }
    if (userInfo) {
      res["userInfo"] = userInfo ? boost::any(userInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("groupInfos") != m.end() && !m["groupInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["groupInfos"].type()) {
        vector<ListUserResourcesResponseBodyResultGroupInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["groupInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUserResourcesResponseBodyResultGroupInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupInfos = make_shared<vector<ListUserResourcesResponseBodyResultGroupInfos>>(expect1);
      }
    }
    if (m.find("repositoryInfos") != m.end() && !m["repositoryInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["repositoryInfos"].type()) {
        vector<ListUserResourcesResponseBodyResultRepositoryInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["repositoryInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUserResourcesResponseBodyResultRepositoryInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        repositoryInfos = make_shared<vector<ListUserResourcesResponseBodyResultRepositoryInfos>>(expect1);
      }
    }
    if (m.find("userInfo") != m.end() && !m["userInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["userInfo"].type()) {
        ListUserResourcesResponseBodyResultUserInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["userInfo"]));
        userInfo = make_shared<ListUserResourcesResponseBodyResultUserInfo>(model1);
      }
    }
  }


  virtual ~ListUserResourcesResponseBodyResult() = default;
};
class ListUserResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListUserResourcesResponseBodyResult>> result{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListUserResourcesResponseBody() {}

  explicit ListUserResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ListUserResourcesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUserResourcesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListUserResourcesResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
  }


  virtual ~ListUserResourcesResponseBody() = default;
};
class ListUserResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUserResourcesResponseBody> body{};

  ListUserResourcesResponse() {}

  explicit ListUserResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUserResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUserResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListUserResourcesResponse() = default;
};
class ListVariableGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> pageOrder{};
  shared_ptr<string> pageSort{};

  ListVariableGroupsRequest() {}

  explicit ListVariableGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (pageOrder) {
      res["pageOrder"] = boost::any(*pageOrder);
    }
    if (pageSort) {
      res["pageSort"] = boost::any(*pageSort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("pageOrder") != m.end() && !m["pageOrder"].empty()) {
      pageOrder = make_shared<string>(boost::any_cast<string>(m["pageOrder"]));
    }
    if (m.find("pageSort") != m.end() && !m["pageSort"].empty()) {
      pageSort = make_shared<string>(boost::any_cast<string>(m["pageSort"]));
    }
  }


  virtual ~ListVariableGroupsRequest() = default;
};
class ListVariableGroupsResponseBodyVariableGroupsRelatedPipelines : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  ListVariableGroupsResponseBodyVariableGroupsRelatedPipelines() {}

  explicit ListVariableGroupsResponseBodyVariableGroupsRelatedPipelines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~ListVariableGroupsResponseBodyVariableGroupsRelatedPipelines() = default;
};
class ListVariableGroupsResponseBodyVariableGroupsVariables : public Darabonba::Model {
public:
  shared_ptr<bool> isEncrypted{};
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  ListVariableGroupsResponseBodyVariableGroupsVariables() {}

  explicit ListVariableGroupsResponseBodyVariableGroupsVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isEncrypted) {
      res["isEncrypted"] = boost::any(*isEncrypted);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("isEncrypted") != m.end() && !m["isEncrypted"].empty()) {
      isEncrypted = make_shared<bool>(boost::any_cast<bool>(m["isEncrypted"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~ListVariableGroupsResponseBodyVariableGroupsVariables() = default;
};
class ListVariableGroupsResponseBodyVariableGroups : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> creatorAccountId{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> modifierAccountId{};
  shared_ptr<string> name{};
  shared_ptr<vector<ListVariableGroupsResponseBodyVariableGroupsRelatedPipelines>> relatedPipelines{};
  shared_ptr<long> updateTime{};
  shared_ptr<vector<ListVariableGroupsResponseBodyVariableGroupsVariables>> variables{};

  ListVariableGroupsResponseBodyVariableGroups() {}

  explicit ListVariableGroupsResponseBodyVariableGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (creatorAccountId) {
      res["creatorAccountId"] = boost::any(*creatorAccountId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (modifierAccountId) {
      res["modifierAccountId"] = boost::any(*modifierAccountId);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (relatedPipelines) {
      vector<boost::any> temp1;
      for(auto item1:*relatedPipelines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["relatedPipelines"] = boost::any(temp1);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["createTime"]));
    }
    if (m.find("creatorAccountId") != m.end() && !m["creatorAccountId"].empty()) {
      creatorAccountId = make_shared<string>(boost::any_cast<string>(m["creatorAccountId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("modifierAccountId") != m.end() && !m["modifierAccountId"].empty()) {
      modifierAccountId = make_shared<string>(boost::any_cast<string>(m["modifierAccountId"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("relatedPipelines") != m.end() && !m["relatedPipelines"].empty()) {
      if (typeid(vector<boost::any>) == m["relatedPipelines"].type()) {
        vector<ListVariableGroupsResponseBodyVariableGroupsRelatedPipelines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["relatedPipelines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListVariableGroupsResponseBodyVariableGroupsRelatedPipelines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        relatedPipelines = make_shared<vector<ListVariableGroupsResponseBodyVariableGroupsRelatedPipelines>>(expect1);
      }
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["updateTime"]));
    }
    if (m.find("variables") != m.end() && !m["variables"].empty()) {
      if (typeid(vector<boost::any>) == m["variables"].type()) {
        vector<ListVariableGroupsResponseBodyVariableGroupsVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListVariableGroupsResponseBodyVariableGroupsVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<ListVariableGroupsResponseBodyVariableGroupsVariables>>(expect1);
      }
    }
  }


  virtual ~ListVariableGroupsResponseBodyVariableGroups() = default;
};
class ListVariableGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListVariableGroupsResponseBodyVariableGroups>> variableGroups{};

  ListVariableGroupsResponseBody() {}

  explicit ListVariableGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    if (variableGroups) {
      vector<boost::any> temp1;
      for(auto item1:*variableGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["variableGroups"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
    if (m.find("variableGroups") != m.end() && !m["variableGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["variableGroups"].type()) {
        vector<ListVariableGroupsResponseBodyVariableGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["variableGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListVariableGroupsResponseBodyVariableGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variableGroups = make_shared<vector<ListVariableGroupsResponseBodyVariableGroups>>(expect1);
      }
    }
  }


  virtual ~ListVariableGroupsResponseBody() = default;
};
class ListVariableGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListVariableGroupsResponseBody> body{};

  ListVariableGroupsResponse() {}

  explicit ListVariableGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListVariableGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListVariableGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListVariableGroupsResponse() = default;
};
class ListWorkItemAllFieldsRequest : public Darabonba::Model {
public:
  shared_ptr<string> spaceIdentifier{};
  shared_ptr<string> spaceType{};
  shared_ptr<string> workitemTypeIdentifier{};

  ListWorkItemAllFieldsRequest() {}

  explicit ListWorkItemAllFieldsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (spaceIdentifier) {
      res["spaceIdentifier"] = boost::any(*spaceIdentifier);
    }
    if (spaceType) {
      res["spaceType"] = boost::any(*spaceType);
    }
    if (workitemTypeIdentifier) {
      res["workitemTypeIdentifier"] = boost::any(*workitemTypeIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("spaceIdentifier") != m.end() && !m["spaceIdentifier"].empty()) {
      spaceIdentifier = make_shared<string>(boost::any_cast<string>(m["spaceIdentifier"]));
    }
    if (m.find("spaceType") != m.end() && !m["spaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["spaceType"]));
    }
    if (m.find("workitemTypeIdentifier") != m.end() && !m["workitemTypeIdentifier"].empty()) {
      workitemTypeIdentifier = make_shared<string>(boost::any_cast<string>(m["workitemTypeIdentifier"]));
    }
  }


  virtual ~ListWorkItemAllFieldsRequest() = default;
};
class ListWorkItemAllFieldsResponseBodyFieldsOptions : public Darabonba::Model {
public:
  shared_ptr<string> displayValue{};
  shared_ptr<string> fieldIdentifier{};
  shared_ptr<string> identifier{};
  shared_ptr<long> level{};
  shared_ptr<long> position{};
  shared_ptr<string> value{};
  shared_ptr<string> valueEn{};

  ListWorkItemAllFieldsResponseBodyFieldsOptions() {}

  explicit ListWorkItemAllFieldsResponseBodyFieldsOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayValue) {
      res["displayValue"] = boost::any(*displayValue);
    }
    if (fieldIdentifier) {
      res["fieldIdentifier"] = boost::any(*fieldIdentifier);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (level) {
      res["level"] = boost::any(*level);
    }
    if (position) {
      res["position"] = boost::any(*position);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    if (valueEn) {
      res["valueEn"] = boost::any(*valueEn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("displayValue") != m.end() && !m["displayValue"].empty()) {
      displayValue = make_shared<string>(boost::any_cast<string>(m["displayValue"]));
    }
    if (m.find("fieldIdentifier") != m.end() && !m["fieldIdentifier"].empty()) {
      fieldIdentifier = make_shared<string>(boost::any_cast<string>(m["fieldIdentifier"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("level") != m.end() && !m["level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["level"]));
    }
    if (m.find("position") != m.end() && !m["position"].empty()) {
      position = make_shared<long>(boost::any_cast<long>(m["position"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
    if (m.find("valueEn") != m.end() && !m["valueEn"].empty()) {
      valueEn = make_shared<string>(boost::any_cast<string>(m["valueEn"]));
    }
  }


  virtual ~ListWorkItemAllFieldsResponseBodyFieldsOptions() = default;
};
class ListWorkItemAllFieldsResponseBodyFields : public Darabonba::Model {
public:
  shared_ptr<string> className{};
  shared_ptr<string> creator{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> description{};
  shared_ptr<string> format{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> identifier{};
  shared_ptr<bool> isRequired{};
  shared_ptr<bool> isShowWhenCreate{};
  shared_ptr<bool> isSystemRequired{};
  shared_ptr<string> linkWithService{};
  shared_ptr<string> modifier{};
  shared_ptr<string> name{};
  shared_ptr<vector<ListWorkItemAllFieldsResponseBodyFieldsOptions>> options{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> type{};

  ListWorkItemAllFieldsResponseBodyFields() {}

  explicit ListWorkItemAllFieldsResponseBodyFields(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (className) {
      res["className"] = boost::any(*className);
    }
    if (creator) {
      res["creator"] = boost::any(*creator);
    }
    if (defaultValue) {
      res["defaultValue"] = boost::any(*defaultValue);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (format) {
      res["format"] = boost::any(*format);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (isRequired) {
      res["isRequired"] = boost::any(*isRequired);
    }
    if (isShowWhenCreate) {
      res["isShowWhenCreate"] = boost::any(*isShowWhenCreate);
    }
    if (isSystemRequired) {
      res["isSystemRequired"] = boost::any(*isSystemRequired);
    }
    if (linkWithService) {
      res["linkWithService"] = boost::any(*linkWithService);
    }
    if (modifier) {
      res["modifier"] = boost::any(*modifier);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (options) {
      vector<boost::any> temp1;
      for(auto item1:*options){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["options"] = boost::any(temp1);
    }
    if (resourceType) {
      res["resourceType"] = boost::any(*resourceType);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("className") != m.end() && !m["className"].empty()) {
      className = make_shared<string>(boost::any_cast<string>(m["className"]));
    }
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["creator"]));
    }
    if (m.find("defaultValue") != m.end() && !m["defaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["defaultValue"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("format") != m.end() && !m["format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["format"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("isRequired") != m.end() && !m["isRequired"].empty()) {
      isRequired = make_shared<bool>(boost::any_cast<bool>(m["isRequired"]));
    }
    if (m.find("isShowWhenCreate") != m.end() && !m["isShowWhenCreate"].empty()) {
      isShowWhenCreate = make_shared<bool>(boost::any_cast<bool>(m["isShowWhenCreate"]));
    }
    if (m.find("isSystemRequired") != m.end() && !m["isSystemRequired"].empty()) {
      isSystemRequired = make_shared<bool>(boost::any_cast<bool>(m["isSystemRequired"]));
    }
    if (m.find("linkWithService") != m.end() && !m["linkWithService"].empty()) {
      linkWithService = make_shared<string>(boost::any_cast<string>(m["linkWithService"]));
    }
    if (m.find("modifier") != m.end() && !m["modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["modifier"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("options") != m.end() && !m["options"].empty()) {
      if (typeid(vector<boost::any>) == m["options"].type()) {
        vector<ListWorkItemAllFieldsResponseBodyFieldsOptions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["options"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWorkItemAllFieldsResponseBodyFieldsOptions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        options = make_shared<vector<ListWorkItemAllFieldsResponseBodyFieldsOptions>>(expect1);
      }
    }
    if (m.find("resourceType") != m.end() && !m["resourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["resourceType"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ListWorkItemAllFieldsResponseBodyFields() = default;
};
class ListWorkItemAllFieldsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<vector<ListWorkItemAllFieldsResponseBodyFields>> fields{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListWorkItemAllFieldsResponseBody() {}

  explicit ListWorkItemAllFieldsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (fields) {
      vector<boost::any> temp1;
      for(auto item1:*fields){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["fields"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("fields") != m.end() && !m["fields"].empty()) {
      if (typeid(vector<boost::any>) == m["fields"].type()) {
        vector<ListWorkItemAllFieldsResponseBodyFields> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["fields"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWorkItemAllFieldsResponseBodyFields model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fields = make_shared<vector<ListWorkItemAllFieldsResponseBodyFields>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ListWorkItemAllFieldsResponseBody() = default;
};
class ListWorkItemAllFieldsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWorkItemAllFieldsResponseBody> body{};

  ListWorkItemAllFieldsResponse() {}

  explicit ListWorkItemAllFieldsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWorkItemAllFieldsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWorkItemAllFieldsResponseBody>(model1);
      }
    }
  }


  virtual ~ListWorkItemAllFieldsResponse() = default;
};
class ListWorkItemWorkFlowStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> spaceIdentifier{};
  shared_ptr<string> spaceType{};
  shared_ptr<string> workitemCategoryIdentifier{};
  shared_ptr<string> workitemTypeIdentifier{};

  ListWorkItemWorkFlowStatusRequest() {}

  explicit ListWorkItemWorkFlowStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (spaceIdentifier) {
      res["spaceIdentifier"] = boost::any(*spaceIdentifier);
    }
    if (spaceType) {
      res["spaceType"] = boost::any(*spaceType);
    }
    if (workitemCategoryIdentifier) {
      res["workitemCategoryIdentifier"] = boost::any(*workitemCategoryIdentifier);
    }
    if (workitemTypeIdentifier) {
      res["workitemTypeIdentifier"] = boost::any(*workitemTypeIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("spaceIdentifier") != m.end() && !m["spaceIdentifier"].empty()) {
      spaceIdentifier = make_shared<string>(boost::any_cast<string>(m["spaceIdentifier"]));
    }
    if (m.find("spaceType") != m.end() && !m["spaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["spaceType"]));
    }
    if (m.find("workitemCategoryIdentifier") != m.end() && !m["workitemCategoryIdentifier"].empty()) {
      workitemCategoryIdentifier = make_shared<string>(boost::any_cast<string>(m["workitemCategoryIdentifier"]));
    }
    if (m.find("workitemTypeIdentifier") != m.end() && !m["workitemTypeIdentifier"].empty()) {
      workitemTypeIdentifier = make_shared<string>(boost::any_cast<string>(m["workitemTypeIdentifier"]));
    }
  }


  virtual ~ListWorkItemWorkFlowStatusRequest() = default;
};
class ListWorkItemWorkFlowStatusResponseBodyStatuses : public Darabonba::Model {
public:
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> identifier{};
  shared_ptr<string> modifier{};
  shared_ptr<string> name{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> source{};
  shared_ptr<string> workflowStageIdentifier{};
  shared_ptr<string> workflowStageName{};

  ListWorkItemWorkFlowStatusResponseBodyStatuses() {}

  explicit ListWorkItemWorkFlowStatusResponseBodyStatuses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creator) {
      res["creator"] = boost::any(*creator);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (modifier) {
      res["modifier"] = boost::any(*modifier);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (resourceType) {
      res["resourceType"] = boost::any(*resourceType);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (workflowStageIdentifier) {
      res["workflowStageIdentifier"] = boost::any(*workflowStageIdentifier);
    }
    if (workflowStageName) {
      res["workflowStageName"] = boost::any(*workflowStageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["creator"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("modifier") != m.end() && !m["modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["modifier"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("resourceType") != m.end() && !m["resourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["resourceType"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("workflowStageIdentifier") != m.end() && !m["workflowStageIdentifier"].empty()) {
      workflowStageIdentifier = make_shared<string>(boost::any_cast<string>(m["workflowStageIdentifier"]));
    }
    if (m.find("workflowStageName") != m.end() && !m["workflowStageName"].empty()) {
      workflowStageName = make_shared<string>(boost::any_cast<string>(m["workflowStageName"]));
    }
  }


  virtual ~ListWorkItemWorkFlowStatusResponseBodyStatuses() = default;
};
class ListWorkItemWorkFlowStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListWorkItemWorkFlowStatusResponseBodyStatuses>> statuses{};
  shared_ptr<bool> success{};

  ListWorkItemWorkFlowStatusResponseBody() {}

  explicit ListWorkItemWorkFlowStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (statuses) {
      vector<boost::any> temp1;
      for(auto item1:*statuses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["statuses"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("statuses") != m.end() && !m["statuses"].empty()) {
      if (typeid(vector<boost::any>) == m["statuses"].type()) {
        vector<ListWorkItemWorkFlowStatusResponseBodyStatuses> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["statuses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWorkItemWorkFlowStatusResponseBodyStatuses model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statuses = make_shared<vector<ListWorkItemWorkFlowStatusResponseBodyStatuses>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ListWorkItemWorkFlowStatusResponseBody() = default;
};
class ListWorkItemWorkFlowStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWorkItemWorkFlowStatusResponseBody> body{};

  ListWorkItemWorkFlowStatusResponse() {}

  explicit ListWorkItemWorkFlowStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWorkItemWorkFlowStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWorkItemWorkFlowStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ListWorkItemWorkFlowStatusResponse() = default;
};
class ListWorkitemAttachmentsResponseBodyAttachments : public Darabonba::Model {
public:
  shared_ptr<string> creator{};
  shared_ptr<string> fileIdentifier{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSuffix{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> size{};
  shared_ptr<string> url{};

  ListWorkitemAttachmentsResponseBodyAttachments() {}

  explicit ListWorkitemAttachmentsResponseBodyAttachments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creator) {
      res["creator"] = boost::any(*creator);
    }
    if (fileIdentifier) {
      res["fileIdentifier"] = boost::any(*fileIdentifier);
    }
    if (fileName) {
      res["fileName"] = boost::any(*fileName);
    }
    if (fileSuffix) {
      res["fileSuffix"] = boost::any(*fileSuffix);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["creator"]));
    }
    if (m.find("fileIdentifier") != m.end() && !m["fileIdentifier"].empty()) {
      fileIdentifier = make_shared<string>(boost::any_cast<string>(m["fileIdentifier"]));
    }
    if (m.find("fileName") != m.end() && !m["fileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["fileName"]));
    }
    if (m.find("fileSuffix") != m.end() && !m["fileSuffix"].empty()) {
      fileSuffix = make_shared<string>(boost::any_cast<string>(m["fileSuffix"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["size"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~ListWorkitemAttachmentsResponseBodyAttachments() = default;
};
class ListWorkitemAttachmentsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListWorkitemAttachmentsResponseBodyAttachments>> attachments{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListWorkitemAttachmentsResponseBody() {}

  explicit ListWorkitemAttachmentsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachments) {
      vector<boost::any> temp1;
      for(auto item1:*attachments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["attachments"] = boost::any(temp1);
    }
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("attachments") != m.end() && !m["attachments"].empty()) {
      if (typeid(vector<boost::any>) == m["attachments"].type()) {
        vector<ListWorkitemAttachmentsResponseBodyAttachments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["attachments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWorkitemAttachmentsResponseBodyAttachments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attachments = make_shared<vector<ListWorkitemAttachmentsResponseBodyAttachments>>(expect1);
      }
    }
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ListWorkitemAttachmentsResponseBody() = default;
};
class ListWorkitemAttachmentsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWorkitemAttachmentsResponseBody> body{};

  ListWorkitemAttachmentsResponse() {}

  explicit ListWorkitemAttachmentsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWorkitemAttachmentsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWorkitemAttachmentsResponseBody>(model1);
      }
    }
  }


  virtual ~ListWorkitemAttachmentsResponse() = default;
};
class ListWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser : public Darabonba::Model {
public:
  shared_ptr<string> identifier{};
  shared_ptr<string> name{};

  ListWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser() {}

  explicit ListWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~ListWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser() = default;
};
class ListWorkitemEstimateResponseBodyWorkitemTimeEstimate : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtEnd{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> gmtStart{};
  shared_ptr<string> identifier{};
  shared_ptr<ListWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser> recordUser{};
  shared_ptr<double> spentTime{};
  shared_ptr<string> type{};
  shared_ptr<string> workitemIdentifier{};

  ListWorkitemEstimateResponseBodyWorkitemTimeEstimate() {}

  explicit ListWorkitemEstimateResponseBodyWorkitemTimeEstimate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtEnd) {
      res["gmtEnd"] = boost::any(*gmtEnd);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (gmtStart) {
      res["gmtStart"] = boost::any(*gmtStart);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (recordUser) {
      res["recordUser"] = recordUser ? boost::any(recordUser->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spentTime) {
      res["spentTime"] = boost::any(*spentTime);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (workitemIdentifier) {
      res["workitemIdentifier"] = boost::any(*workitemIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtEnd") != m.end() && !m["gmtEnd"].empty()) {
      gmtEnd = make_shared<long>(boost::any_cast<long>(m["gmtEnd"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("gmtStart") != m.end() && !m["gmtStart"].empty()) {
      gmtStart = make_shared<long>(boost::any_cast<long>(m["gmtStart"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("recordUser") != m.end() && !m["recordUser"].empty()) {
      if (typeid(map<string, boost::any>) == m["recordUser"].type()) {
        ListWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["recordUser"]));
        recordUser = make_shared<ListWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser>(model1);
      }
    }
    if (m.find("spentTime") != m.end() && !m["spentTime"].empty()) {
      spentTime = make_shared<double>(boost::any_cast<double>(m["spentTime"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("workitemIdentifier") != m.end() && !m["workitemIdentifier"].empty()) {
      workitemIdentifier = make_shared<string>(boost::any_cast<string>(m["workitemIdentifier"]));
    }
  }


  virtual ~ListWorkitemEstimateResponseBodyWorkitemTimeEstimate() = default;
};
class ListWorkitemEstimateResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<vector<ListWorkitemEstimateResponseBodyWorkitemTimeEstimate>> workitemTimeEstimate{};

  ListWorkitemEstimateResponseBody() {}

  explicit ListWorkitemEstimateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (workitemTimeEstimate) {
      vector<boost::any> temp1;
      for(auto item1:*workitemTimeEstimate){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["workitemTimeEstimate"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["code"]));
    }
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("workitemTimeEstimate") != m.end() && !m["workitemTimeEstimate"].empty()) {
      if (typeid(vector<boost::any>) == m["workitemTimeEstimate"].type()) {
        vector<ListWorkitemEstimateResponseBodyWorkitemTimeEstimate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["workitemTimeEstimate"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWorkitemEstimateResponseBodyWorkitemTimeEstimate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workitemTimeEstimate = make_shared<vector<ListWorkitemEstimateResponseBodyWorkitemTimeEstimate>>(expect1);
      }
    }
  }


  virtual ~ListWorkitemEstimateResponseBody() = default;
};
class ListWorkitemEstimateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWorkitemEstimateResponseBody> body{};

  ListWorkitemEstimateResponse() {}

  explicit ListWorkitemEstimateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWorkitemEstimateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWorkitemEstimateResponseBody>(model1);
      }
    }
  }


  virtual ~ListWorkitemEstimateResponse() = default;
};
class ListWorkitemTimeResponseBodyWorkitemTime : public Darabonba::Model {
public:
  shared_ptr<double> actualTime{};
  shared_ptr<string> description{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtEnd{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> gmtStart{};
  shared_ptr<string> identifier{};
  shared_ptr<string> recordUser{};
  shared_ptr<string> type{};
  shared_ptr<string> workitemIdentifier{};

  ListWorkitemTimeResponseBodyWorkitemTime() {}

  explicit ListWorkitemTimeResponseBodyWorkitemTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualTime) {
      res["actualTime"] = boost::any(*actualTime);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtEnd) {
      res["gmtEnd"] = boost::any(*gmtEnd);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (gmtStart) {
      res["gmtStart"] = boost::any(*gmtStart);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (recordUser) {
      res["recordUser"] = boost::any(*recordUser);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (workitemIdentifier) {
      res["workitemIdentifier"] = boost::any(*workitemIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("actualTime") != m.end() && !m["actualTime"].empty()) {
      actualTime = make_shared<double>(boost::any_cast<double>(m["actualTime"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtEnd") != m.end() && !m["gmtEnd"].empty()) {
      gmtEnd = make_shared<long>(boost::any_cast<long>(m["gmtEnd"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("gmtStart") != m.end() && !m["gmtStart"].empty()) {
      gmtStart = make_shared<long>(boost::any_cast<long>(m["gmtStart"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("recordUser") != m.end() && !m["recordUser"].empty()) {
      recordUser = make_shared<string>(boost::any_cast<string>(m["recordUser"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("workitemIdentifier") != m.end() && !m["workitemIdentifier"].empty()) {
      workitemIdentifier = make_shared<string>(boost::any_cast<string>(m["workitemIdentifier"]));
    }
  }


  virtual ~ListWorkitemTimeResponseBodyWorkitemTime() = default;
};
class ListWorkitemTimeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<vector<ListWorkitemTimeResponseBodyWorkitemTime>> workitemTime{};

  ListWorkitemTimeResponseBody() {}

  explicit ListWorkitemTimeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (workitemTime) {
      vector<boost::any> temp1;
      for(auto item1:*workitemTime){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["workitemTime"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["code"]));
    }
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("workitemTime") != m.end() && !m["workitemTime"].empty()) {
      if (typeid(vector<boost::any>) == m["workitemTime"].type()) {
        vector<ListWorkitemTimeResponseBodyWorkitemTime> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["workitemTime"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWorkitemTimeResponseBodyWorkitemTime model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workitemTime = make_shared<vector<ListWorkitemTimeResponseBodyWorkitemTime>>(expect1);
      }
    }
  }


  virtual ~ListWorkitemTimeResponseBody() = default;
};
class ListWorkitemTimeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWorkitemTimeResponseBody> body{};

  ListWorkitemTimeResponse() {}

  explicit ListWorkitemTimeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWorkitemTimeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWorkitemTimeResponseBody>(model1);
      }
    }
  }


  virtual ~ListWorkitemTimeResponse() = default;
};
class ListWorkitemsRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> conditions{};
  shared_ptr<string> extraConditions{};
  shared_ptr<string> groupCondition{};
  shared_ptr<string> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> searchType{};
  shared_ptr<string> spaceIdentifier{};
  shared_ptr<string> spaceType{};

  ListWorkitemsRequest() {}

  explicit ListWorkitemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (conditions) {
      res["conditions"] = boost::any(*conditions);
    }
    if (extraConditions) {
      res["extraConditions"] = boost::any(*extraConditions);
    }
    if (groupCondition) {
      res["groupCondition"] = boost::any(*groupCondition);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (orderBy) {
      res["orderBy"] = boost::any(*orderBy);
    }
    if (searchType) {
      res["searchType"] = boost::any(*searchType);
    }
    if (spaceIdentifier) {
      res["spaceIdentifier"] = boost::any(*spaceIdentifier);
    }
    if (spaceType) {
      res["spaceType"] = boost::any(*spaceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["category"]));
    }
    if (m.find("conditions") != m.end() && !m["conditions"].empty()) {
      conditions = make_shared<string>(boost::any_cast<string>(m["conditions"]));
    }
    if (m.find("extraConditions") != m.end() && !m["extraConditions"].empty()) {
      extraConditions = make_shared<string>(boost::any_cast<string>(m["extraConditions"]));
    }
    if (m.find("groupCondition") != m.end() && !m["groupCondition"].empty()) {
      groupCondition = make_shared<string>(boost::any_cast<string>(m["groupCondition"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<string>(boost::any_cast<string>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("orderBy") != m.end() && !m["orderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["orderBy"]));
    }
    if (m.find("searchType") != m.end() && !m["searchType"].empty()) {
      searchType = make_shared<string>(boost::any_cast<string>(m["searchType"]));
    }
    if (m.find("spaceIdentifier") != m.end() && !m["spaceIdentifier"].empty()) {
      spaceIdentifier = make_shared<string>(boost::any_cast<string>(m["spaceIdentifier"]));
    }
    if (m.find("spaceType") != m.end() && !m["spaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["spaceType"]));
    }
  }


  virtual ~ListWorkitemsRequest() = default;
};
class ListWorkitemsResponseBodyWorkitems : public Darabonba::Model {
public:
  shared_ptr<string> assignedTo{};
  shared_ptr<string> categoryIdentifier{};
  shared_ptr<string> creator{};
  shared_ptr<string> document{};
  shared_ptr<long> finishTime{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> identifier{};
  shared_ptr<string> logicalStatus{};
  shared_ptr<string> modifier{};
  shared_ptr<string> parentIdentifier{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> spaceIdentifier{};
  shared_ptr<string> spaceName{};
  shared_ptr<string> spaceType{};
  shared_ptr<string> sprintIdentifier{};
  shared_ptr<string> status{};
  shared_ptr<string> statusIdentifier{};
  shared_ptr<string> statusStageIdentifier{};
  shared_ptr<string> subject{};
  shared_ptr<long> updateStatusAt{};
  shared_ptr<string> workitemTypeIdentifier{};

  ListWorkitemsResponseBodyWorkitems() {}

  explicit ListWorkitemsResponseBodyWorkitems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignedTo) {
      res["assignedTo"] = boost::any(*assignedTo);
    }
    if (categoryIdentifier) {
      res["categoryIdentifier"] = boost::any(*categoryIdentifier);
    }
    if (creator) {
      res["creator"] = boost::any(*creator);
    }
    if (document) {
      res["document"] = boost::any(*document);
    }
    if (finishTime) {
      res["finishTime"] = boost::any(*finishTime);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (logicalStatus) {
      res["logicalStatus"] = boost::any(*logicalStatus);
    }
    if (modifier) {
      res["modifier"] = boost::any(*modifier);
    }
    if (parentIdentifier) {
      res["parentIdentifier"] = boost::any(*parentIdentifier);
    }
    if (serialNumber) {
      res["serialNumber"] = boost::any(*serialNumber);
    }
    if (spaceIdentifier) {
      res["spaceIdentifier"] = boost::any(*spaceIdentifier);
    }
    if (spaceName) {
      res["spaceName"] = boost::any(*spaceName);
    }
    if (spaceType) {
      res["spaceType"] = boost::any(*spaceType);
    }
    if (sprintIdentifier) {
      res["sprintIdentifier"] = boost::any(*sprintIdentifier);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (statusIdentifier) {
      res["statusIdentifier"] = boost::any(*statusIdentifier);
    }
    if (statusStageIdentifier) {
      res["statusStageIdentifier"] = boost::any(*statusStageIdentifier);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    if (updateStatusAt) {
      res["updateStatusAt"] = boost::any(*updateStatusAt);
    }
    if (workitemTypeIdentifier) {
      res["workitemTypeIdentifier"] = boost::any(*workitemTypeIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignedTo") != m.end() && !m["assignedTo"].empty()) {
      assignedTo = make_shared<string>(boost::any_cast<string>(m["assignedTo"]));
    }
    if (m.find("categoryIdentifier") != m.end() && !m["categoryIdentifier"].empty()) {
      categoryIdentifier = make_shared<string>(boost::any_cast<string>(m["categoryIdentifier"]));
    }
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["creator"]));
    }
    if (m.find("document") != m.end() && !m["document"].empty()) {
      document = make_shared<string>(boost::any_cast<string>(m["document"]));
    }
    if (m.find("finishTime") != m.end() && !m["finishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["finishTime"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("logicalStatus") != m.end() && !m["logicalStatus"].empty()) {
      logicalStatus = make_shared<string>(boost::any_cast<string>(m["logicalStatus"]));
    }
    if (m.find("modifier") != m.end() && !m["modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["modifier"]));
    }
    if (m.find("parentIdentifier") != m.end() && !m["parentIdentifier"].empty()) {
      parentIdentifier = make_shared<string>(boost::any_cast<string>(m["parentIdentifier"]));
    }
    if (m.find("serialNumber") != m.end() && !m["serialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["serialNumber"]));
    }
    if (m.find("spaceIdentifier") != m.end() && !m["spaceIdentifier"].empty()) {
      spaceIdentifier = make_shared<string>(boost::any_cast<string>(m["spaceIdentifier"]));
    }
    if (m.find("spaceName") != m.end() && !m["spaceName"].empty()) {
      spaceName = make_shared<string>(boost::any_cast<string>(m["spaceName"]));
    }
    if (m.find("spaceType") != m.end() && !m["spaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["spaceType"]));
    }
    if (m.find("sprintIdentifier") != m.end() && !m["sprintIdentifier"].empty()) {
      sprintIdentifier = make_shared<string>(boost::any_cast<string>(m["sprintIdentifier"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("statusIdentifier") != m.end() && !m["statusIdentifier"].empty()) {
      statusIdentifier = make_shared<string>(boost::any_cast<string>(m["statusIdentifier"]));
    }
    if (m.find("statusStageIdentifier") != m.end() && !m["statusStageIdentifier"].empty()) {
      statusStageIdentifier = make_shared<string>(boost::any_cast<string>(m["statusStageIdentifier"]));
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
    if (m.find("updateStatusAt") != m.end() && !m["updateStatusAt"].empty()) {
      updateStatusAt = make_shared<long>(boost::any_cast<long>(m["updateStatusAt"]));
    }
    if (m.find("workitemTypeIdentifier") != m.end() && !m["workitemTypeIdentifier"].empty()) {
      workitemTypeIdentifier = make_shared<string>(boost::any_cast<string>(m["workitemTypeIdentifier"]));
    }
  }


  virtual ~ListWorkitemsResponseBodyWorkitems() = default;
};
class ListWorkitemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListWorkitemsResponseBodyWorkitems>> workitems{};

  ListWorkitemsResponseBody() {}

  explicit ListWorkitemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    if (workitems) {
      vector<boost::any> temp1;
      for(auto item1:*workitems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["workitems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
    if (m.find("workitems") != m.end() && !m["workitems"].empty()) {
      if (typeid(vector<boost::any>) == m["workitems"].type()) {
        vector<ListWorkitemsResponseBodyWorkitems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["workitems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWorkitemsResponseBodyWorkitems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workitems = make_shared<vector<ListWorkitemsResponseBodyWorkitems>>(expect1);
      }
    }
  }


  virtual ~ListWorkitemsResponseBody() = default;
};
class ListWorkitemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWorkitemsResponseBody> body{};

  ListWorkitemsResponse() {}

  explicit ListWorkitemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWorkitemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWorkitemsResponseBody>(model1);
      }
    }
  }


  virtual ~ListWorkitemsResponse() = default;
};
class ListWorkspacesRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<string>> statusList{};
  shared_ptr<vector<string>> workspaceTemplateList{};

  ListWorkspacesRequest() {}

  explicit ListWorkspacesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (statusList) {
      res["statusList"] = boost::any(*statusList);
    }
    if (workspaceTemplateList) {
      res["workspaceTemplateList"] = boost::any(*workspaceTemplateList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("statusList") != m.end() && !m["statusList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["statusList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["statusList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      statusList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("workspaceTemplateList") != m.end() && !m["workspaceTemplateList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["workspaceTemplateList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["workspaceTemplateList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      workspaceTemplateList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListWorkspacesRequest() = default;
};
class ListWorkspacesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> statusListShrink{};
  shared_ptr<string> workspaceTemplateListShrink{};

  ListWorkspacesShrinkRequest() {}

  explicit ListWorkspacesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (statusListShrink) {
      res["statusList"] = boost::any(*statusListShrink);
    }
    if (workspaceTemplateListShrink) {
      res["workspaceTemplateList"] = boost::any(*workspaceTemplateListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("statusList") != m.end() && !m["statusList"].empty()) {
      statusListShrink = make_shared<string>(boost::any_cast<string>(m["statusList"]));
    }
    if (m.find("workspaceTemplateList") != m.end() && !m["workspaceTemplateList"].empty()) {
      workspaceTemplateListShrink = make_shared<string>(boost::any_cast<string>(m["workspaceTemplateList"]));
    }
  }


  virtual ~ListWorkspacesShrinkRequest() = default;
};
class ListWorkspacesResponseBodyWorkspaces : public Darabonba::Model {
public:
  shared_ptr<string> codeUrl{};
  shared_ptr<string> codeVersion{};
  shared_ptr<string> createTime{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> spec{};
  shared_ptr<string> status{};
  shared_ptr<string> template_{};
  shared_ptr<string> userId{};

  ListWorkspacesResponseBodyWorkspaces() {}

  explicit ListWorkspacesResponseBodyWorkspaces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codeUrl) {
      res["codeUrl"] = boost::any(*codeUrl);
    }
    if (codeVersion) {
      res["codeVersion"] = boost::any(*codeVersion);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (template_) {
      res["template"] = boost::any(*template_);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("codeUrl") != m.end() && !m["codeUrl"].empty()) {
      codeUrl = make_shared<string>(boost::any_cast<string>(m["codeUrl"]));
    }
    if (m.find("codeVersion") != m.end() && !m["codeVersion"].empty()) {
      codeVersion = make_shared<string>(boost::any_cast<string>(m["codeVersion"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("template") != m.end() && !m["template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["template"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
  }


  virtual ~ListWorkspacesResponseBodyWorkspaces() = default;
};
class ListWorkspacesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListWorkspacesResponseBodyWorkspaces>> workspaces{};

  ListWorkspacesResponseBody() {}

  explicit ListWorkspacesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    if (workspaces) {
      vector<boost::any> temp1;
      for(auto item1:*workspaces){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["workspaces"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
    if (m.find("workspaces") != m.end() && !m["workspaces"].empty()) {
      if (typeid(vector<boost::any>) == m["workspaces"].type()) {
        vector<ListWorkspacesResponseBodyWorkspaces> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["workspaces"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWorkspacesResponseBodyWorkspaces model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workspaces = make_shared<vector<ListWorkspacesResponseBodyWorkspaces>>(expect1);
      }
    }
  }


  virtual ~ListWorkspacesResponseBody() = default;
};
class ListWorkspacesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWorkspacesResponseBody> body{};

  ListWorkspacesResponse() {}

  explicit ListWorkspacesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWorkspacesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWorkspacesResponseBody>(model1);
      }
    }
  }


  virtual ~ListWorkspacesResponse() = default;
};
class LogPipelineJobRunResponseBodyLog : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<bool> more{};

  LogPipelineJobRunResponseBodyLog() {}

  explicit LogPipelineJobRunResponseBodyLog(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (more) {
      res["more"] = boost::any(*more);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("more") != m.end() && !m["more"].empty()) {
      more = make_shared<bool>(boost::any_cast<bool>(m["more"]));
    }
  }


  virtual ~LogPipelineJobRunResponseBodyLog() = default;
};
class LogPipelineJobRunResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<LogPipelineJobRunResponseBodyLog> log{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  LogPipelineJobRunResponseBody() {}

  explicit LogPipelineJobRunResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (log) {
      res["log"] = log ? boost::any(log->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("log") != m.end() && !m["log"].empty()) {
      if (typeid(map<string, boost::any>) == m["log"].type()) {
        LogPipelineJobRunResponseBodyLog model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["log"]));
        log = make_shared<LogPipelineJobRunResponseBodyLog>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~LogPipelineJobRunResponseBody() = default;
};
class LogPipelineJobRunResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<LogPipelineJobRunResponseBody> body{};

  LogPipelineJobRunResponse() {}

  explicit LogPipelineJobRunResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        LogPipelineJobRunResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<LogPipelineJobRunResponseBody>(model1);
      }
    }
  }


  virtual ~LogPipelineJobRunResponse() = default;
};
class LogVMDeployMachineResponseBodyDeployMachineLog : public Darabonba::Model {
public:
  shared_ptr<string> aliyunRegion{};
  shared_ptr<long> deployBeginTime{};
  shared_ptr<long> deployEndTime{};
  shared_ptr<string> deployLog{};
  shared_ptr<string> deployLogPath{};

  LogVMDeployMachineResponseBodyDeployMachineLog() {}

  explicit LogVMDeployMachineResponseBodyDeployMachineLog(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunRegion) {
      res["aliyunRegion"] = boost::any(*aliyunRegion);
    }
    if (deployBeginTime) {
      res["deployBeginTime"] = boost::any(*deployBeginTime);
    }
    if (deployEndTime) {
      res["deployEndTime"] = boost::any(*deployEndTime);
    }
    if (deployLog) {
      res["deployLog"] = boost::any(*deployLog);
    }
    if (deployLogPath) {
      res["deployLogPath"] = boost::any(*deployLogPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aliyunRegion") != m.end() && !m["aliyunRegion"].empty()) {
      aliyunRegion = make_shared<string>(boost::any_cast<string>(m["aliyunRegion"]));
    }
    if (m.find("deployBeginTime") != m.end() && !m["deployBeginTime"].empty()) {
      deployBeginTime = make_shared<long>(boost::any_cast<long>(m["deployBeginTime"]));
    }
    if (m.find("deployEndTime") != m.end() && !m["deployEndTime"].empty()) {
      deployEndTime = make_shared<long>(boost::any_cast<long>(m["deployEndTime"]));
    }
    if (m.find("deployLog") != m.end() && !m["deployLog"].empty()) {
      deployLog = make_shared<string>(boost::any_cast<string>(m["deployLog"]));
    }
    if (m.find("deployLogPath") != m.end() && !m["deployLogPath"].empty()) {
      deployLogPath = make_shared<string>(boost::any_cast<string>(m["deployLogPath"]));
    }
  }


  virtual ~LogVMDeployMachineResponseBodyDeployMachineLog() = default;
};
class LogVMDeployMachineResponseBody : public Darabonba::Model {
public:
  shared_ptr<LogVMDeployMachineResponseBodyDeployMachineLog> deployMachineLog{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  LogVMDeployMachineResponseBody() {}

  explicit LogVMDeployMachineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployMachineLog) {
      res["deployMachineLog"] = deployMachineLog ? boost::any(deployMachineLog->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("deployMachineLog") != m.end() && !m["deployMachineLog"].empty()) {
      if (typeid(map<string, boost::any>) == m["deployMachineLog"].type()) {
        LogVMDeployMachineResponseBodyDeployMachineLog model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["deployMachineLog"]));
        deployMachineLog = make_shared<LogVMDeployMachineResponseBodyDeployMachineLog>(model1);
      }
    }
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~LogVMDeployMachineResponseBody() = default;
};
class LogVMDeployMachineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<LogVMDeployMachineResponseBody> body{};

  LogVMDeployMachineResponse() {}

  explicit LogVMDeployMachineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        LogVMDeployMachineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<LogVMDeployMachineResponseBody>(model1);
      }
    }
  }


  virtual ~LogVMDeployMachineResponse() = default;
};
class MergeMergeRequestRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> mergeMessage{};
  shared_ptr<string> mergeType{};
  shared_ptr<bool> removeSourceBranch{};
  shared_ptr<string> organizationId{};

  MergeMergeRequestRequest() {}

  explicit MergeMergeRequestRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (mergeMessage) {
      res["mergeMessage"] = boost::any(*mergeMessage);
    }
    if (mergeType) {
      res["mergeType"] = boost::any(*mergeType);
    }
    if (removeSourceBranch) {
      res["removeSourceBranch"] = boost::any(*removeSourceBranch);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("mergeMessage") != m.end() && !m["mergeMessage"].empty()) {
      mergeMessage = make_shared<string>(boost::any_cast<string>(m["mergeMessage"]));
    }
    if (m.find("mergeType") != m.end() && !m["mergeType"].empty()) {
      mergeType = make_shared<string>(boost::any_cast<string>(m["mergeType"]));
    }
    if (m.find("removeSourceBranch") != m.end() && !m["removeSourceBranch"].empty()) {
      removeSourceBranch = make_shared<bool>(boost::any_cast<bool>(m["removeSourceBranch"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~MergeMergeRequestRequest() = default;
};
class MergeMergeRequestResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> localId{};
  shared_ptr<string> mergedRevision{};
  shared_ptr<long> projectId{};
  shared_ptr<bool> result{};

  MergeMergeRequestResponseBodyResult() {}

  explicit MergeMergeRequestResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["bizId"] = boost::any(*bizId);
    }
    if (localId) {
      res["localId"] = boost::any(*localId);
    }
    if (mergedRevision) {
      res["mergedRevision"] = boost::any(*mergedRevision);
    }
    if (projectId) {
      res["projectId"] = boost::any(*projectId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bizId") != m.end() && !m["bizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["bizId"]));
    }
    if (m.find("localId") != m.end() && !m["localId"].empty()) {
      localId = make_shared<long>(boost::any_cast<long>(m["localId"]));
    }
    if (m.find("mergedRevision") != m.end() && !m["mergedRevision"].empty()) {
      mergedRevision = make_shared<string>(boost::any_cast<string>(m["mergedRevision"]));
    }
    if (m.find("projectId") != m.end() && !m["projectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["projectId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~MergeMergeRequestResponseBodyResult() = default;
};
class MergeMergeRequestResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<MergeMergeRequestResponseBodyResult> result{};
  shared_ptr<bool> success{};

  MergeMergeRequestResponseBody() {}

  explicit MergeMergeRequestResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        MergeMergeRequestResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<MergeMergeRequestResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~MergeMergeRequestResponseBody() = default;
};
class MergeMergeRequestResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MergeMergeRequestResponseBody> body{};

  MergeMergeRequestResponse() {}

  explicit MergeMergeRequestResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MergeMergeRequestResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MergeMergeRequestResponseBody>(model1);
      }
    }
  }


  virtual ~MergeMergeRequestResponse() = default;
};
class PassPipelineValidateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PassPipelineValidateResponseBody() {}

  explicit PassPipelineValidateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~PassPipelineValidateResponseBody() = default;
};
class PassPipelineValidateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PassPipelineValidateResponseBody> body{};

  PassPipelineValidateResponse() {}

  explicit PassPipelineValidateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PassPipelineValidateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PassPipelineValidateResponseBody>(model1);
      }
    }
  }


  virtual ~PassPipelineValidateResponse() = default;
};
class PassReleaseStagePipelineValidateRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> organizationId{};

  PassReleaseStagePipelineValidateRequest() {}

  explicit PassReleaseStagePipelineValidateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["jobId"] = boost::any(*jobId);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("jobId") != m.end() && !m["jobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["jobId"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~PassReleaseStagePipelineValidateRequest() = default;
};
class PassReleaseStagePipelineValidateResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> success{};

  PassReleaseStagePipelineValidateResponseBody() {}

  explicit PassReleaseStagePipelineValidateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~PassReleaseStagePipelineValidateResponseBody() = default;
};
class PassReleaseStagePipelineValidateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PassReleaseStagePipelineValidateResponseBody> body{};

  PassReleaseStagePipelineValidateResponse() {}

  explicit PassReleaseStagePipelineValidateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PassReleaseStagePipelineValidateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PassReleaseStagePipelineValidateResponseBody>(model1);
      }
    }
  }


  virtual ~PassReleaseStagePipelineValidateResponse() = default;
};
class RefusePipelineValidateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RefusePipelineValidateResponseBody() {}

  explicit RefusePipelineValidateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~RefusePipelineValidateResponseBody() = default;
};
class RefusePipelineValidateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RefusePipelineValidateResponseBody> body{};

  RefusePipelineValidateResponse() {}

  explicit RefusePipelineValidateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefusePipelineValidateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefusePipelineValidateResponseBody>(model1);
      }
    }
  }


  virtual ~RefusePipelineValidateResponse() = default;
};
class RefuseReleaseStagePipelineValidateRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> organizationId{};

  RefuseReleaseStagePipelineValidateRequest() {}

  explicit RefuseReleaseStagePipelineValidateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["jobId"] = boost::any(*jobId);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("jobId") != m.end() && !m["jobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["jobId"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~RefuseReleaseStagePipelineValidateRequest() = default;
};
class RefuseReleaseStagePipelineValidateResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> success{};

  RefuseReleaseStagePipelineValidateResponseBody() {}

  explicit RefuseReleaseStagePipelineValidateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~RefuseReleaseStagePipelineValidateResponseBody() = default;
};
class RefuseReleaseStagePipelineValidateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RefuseReleaseStagePipelineValidateResponseBody> body{};

  RefuseReleaseStagePipelineValidateResponse() {}

  explicit RefuseReleaseStagePipelineValidateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefuseReleaseStagePipelineValidateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefuseReleaseStagePipelineValidateResponseBody>(model1);
      }
    }
  }


  virtual ~RefuseReleaseStagePipelineValidateResponse() = default;
};
class ReleaseWorkspaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ReleaseWorkspaceResponseBody() {}

  explicit ReleaseWorkspaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ReleaseWorkspaceResponseBody() = default;
};
class ReleaseWorkspaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReleaseWorkspaceResponseBody> body{};

  ReleaseWorkspaceResponse() {}

  explicit ReleaseWorkspaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseWorkspaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseWorkspaceResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseWorkspaceResponse() = default;
};
class ReopenMergeRequestRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> organizationId{};

  ReopenMergeRequestRequest() {}

  explicit ReopenMergeRequestRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~ReopenMergeRequestRequest() = default;
};
class ReopenMergeRequestResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> result{};

  ReopenMergeRequestResponseBodyResult() {}

  explicit ReopenMergeRequestResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~ReopenMergeRequestResponseBodyResult() = default;
};
class ReopenMergeRequestResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<ReopenMergeRequestResponseBodyResult> result{};
  shared_ptr<bool> success{};

  ReopenMergeRequestResponseBody() {}

  explicit ReopenMergeRequestResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        ReopenMergeRequestResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<ReopenMergeRequestResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ReopenMergeRequestResponseBody() = default;
};
class ReopenMergeRequestResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReopenMergeRequestResponseBody> body{};

  ReopenMergeRequestResponse() {}

  explicit ReopenMergeRequestResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReopenMergeRequestResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReopenMergeRequestResponseBody>(model1);
      }
    }
  }


  virtual ~ReopenMergeRequestResponse() = default;
};
class ResetSshKeyResponseBodySshKey : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> publicKey{};

  ResetSshKeyResponseBodySshKey() {}

  explicit ResetSshKeyResponseBodySshKey(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (publicKey) {
      res["publicKey"] = boost::any(*publicKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("publicKey") != m.end() && !m["publicKey"].empty()) {
      publicKey = make_shared<string>(boost::any_cast<string>(m["publicKey"]));
    }
  }


  virtual ~ResetSshKeyResponseBodySshKey() = default;
};
class ResetSshKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<ResetSshKeyResponseBodySshKey> sshKey{};
  shared_ptr<bool> success{};

  ResetSshKeyResponseBody() {}

  explicit ResetSshKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (sshKey) {
      res["sshKey"] = sshKey ? boost::any(sshKey->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("sshKey") != m.end() && !m["sshKey"].empty()) {
      if (typeid(map<string, boost::any>) == m["sshKey"].type()) {
        ResetSshKeyResponseBodySshKey model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["sshKey"]));
        sshKey = make_shared<ResetSshKeyResponseBodySshKey>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ResetSshKeyResponseBody() = default;
};
class ResetSshKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetSshKeyResponseBody> body{};

  ResetSshKeyResponse() {}

  explicit ResetSshKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetSshKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetSshKeyResponseBody>(model1);
      }
    }
  }


  virtual ~ResetSshKeyResponse() = default;
};
class ResumeVMDeployOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ResumeVMDeployOrderResponseBody() {}

  explicit ResumeVMDeployOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ResumeVMDeployOrderResponseBody() = default;
};
class ResumeVMDeployOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResumeVMDeployOrderResponseBody> body{};

  ResumeVMDeployOrderResponse() {}

  explicit ResumeVMDeployOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResumeVMDeployOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResumeVMDeployOrderResponseBody>(model1);
      }
    }
  }


  virtual ~ResumeVMDeployOrderResponse() = default;
};
class RetryPipelineJobRunResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RetryPipelineJobRunResponseBody() {}

  explicit RetryPipelineJobRunResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~RetryPipelineJobRunResponseBody() = default;
};
class RetryPipelineJobRunResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RetryPipelineJobRunResponseBody> body{};

  RetryPipelineJobRunResponse() {}

  explicit RetryPipelineJobRunResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RetryPipelineJobRunResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RetryPipelineJobRunResponseBody>(model1);
      }
    }
  }


  virtual ~RetryPipelineJobRunResponse() = default;
};
class RetryVMDeployMachineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RetryVMDeployMachineResponseBody() {}

  explicit RetryVMDeployMachineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~RetryVMDeployMachineResponseBody() = default;
};
class RetryVMDeployMachineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RetryVMDeployMachineResponseBody> body{};

  RetryVMDeployMachineResponse() {}

  explicit RetryVMDeployMachineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RetryVMDeployMachineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RetryVMDeployMachineResponseBody>(model1);
      }
    }
  }


  virtual ~RetryVMDeployMachineResponse() = default;
};
class ReviewMergeRequestRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<vector<string>> draftCommentIds{};
  shared_ptr<string> reviewComment{};
  shared_ptr<string> reviewOpinion{};
  shared_ptr<string> organizationId{};

  ReviewMergeRequestRequest() {}

  explicit ReviewMergeRequestRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (draftCommentIds) {
      res["draftCommentIds"] = boost::any(*draftCommentIds);
    }
    if (reviewComment) {
      res["reviewComment"] = boost::any(*reviewComment);
    }
    if (reviewOpinion) {
      res["reviewOpinion"] = boost::any(*reviewOpinion);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("draftCommentIds") != m.end() && !m["draftCommentIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["draftCommentIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["draftCommentIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      draftCommentIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("reviewComment") != m.end() && !m["reviewComment"].empty()) {
      reviewComment = make_shared<string>(boost::any_cast<string>(m["reviewComment"]));
    }
    if (m.find("reviewOpinion") != m.end() && !m["reviewOpinion"].empty()) {
      reviewOpinion = make_shared<string>(boost::any_cast<string>(m["reviewOpinion"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~ReviewMergeRequestRequest() = default;
};
class ReviewMergeRequestResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> result{};

  ReviewMergeRequestResponseBodyResult() {}

  explicit ReviewMergeRequestResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~ReviewMergeRequestResponseBodyResult() = default;
};
class ReviewMergeRequestResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<ReviewMergeRequestResponseBodyResult> result{};
  shared_ptr<bool> success{};

  ReviewMergeRequestResponseBody() {}

  explicit ReviewMergeRequestResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        ReviewMergeRequestResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<ReviewMergeRequestResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~ReviewMergeRequestResponseBody() = default;
};
class ReviewMergeRequestResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReviewMergeRequestResponseBody> body{};

  ReviewMergeRequestResponse() {}

  explicit ReviewMergeRequestResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReviewMergeRequestResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReviewMergeRequestResponseBody>(model1);
      }
    }
  }


  virtual ~ReviewMergeRequestResponse() = default;
};
class SkipPipelineJobRunResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SkipPipelineJobRunResponseBody() {}

  explicit SkipPipelineJobRunResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~SkipPipelineJobRunResponseBody() = default;
};
class SkipPipelineJobRunResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SkipPipelineJobRunResponseBody> body{};

  SkipPipelineJobRunResponse() {}

  explicit SkipPipelineJobRunResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SkipPipelineJobRunResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SkipPipelineJobRunResponseBody>(model1);
      }
    }
  }


  virtual ~SkipPipelineJobRunResponse() = default;
};
class SkipVMDeployMachineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SkipVMDeployMachineResponseBody() {}

  explicit SkipVMDeployMachineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~SkipVMDeployMachineResponseBody() = default;
};
class SkipVMDeployMachineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SkipVMDeployMachineResponseBody> body{};

  SkipVMDeployMachineResponse() {}

  explicit SkipVMDeployMachineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SkipVMDeployMachineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SkipVMDeployMachineResponseBody>(model1);
      }
    }
  }


  virtual ~SkipVMDeployMachineResponse() = default;
};
class StartPipelineRunRequest : public Darabonba::Model {
public:
  shared_ptr<string> params{};

  StartPipelineRunRequest() {}

  explicit StartPipelineRunRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (params) {
      res["params"] = boost::any(*params);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("params") != m.end() && !m["params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["params"]));
    }
  }


  virtual ~StartPipelineRunRequest() = default;
};
class StartPipelineRunResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> pipelineRunId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  StartPipelineRunResponseBody() {}

  explicit StartPipelineRunResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (pipelineRunId) {
      res["pipelineRunId"] = boost::any(*pipelineRunId);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("pipelineRunId") != m.end() && !m["pipelineRunId"].empty()) {
      pipelineRunId = make_shared<long>(boost::any_cast<long>(m["pipelineRunId"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~StartPipelineRunResponseBody() = default;
};
class StartPipelineRunResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartPipelineRunResponseBody> body{};

  StartPipelineRunResponse() {}

  explicit StartPipelineRunResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartPipelineRunResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartPipelineRunResponseBody>(model1);
      }
    }
  }


  virtual ~StartPipelineRunResponse() = default;
};
class StopPipelineJobRunResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  StopPipelineJobRunResponseBody() {}

  explicit StopPipelineJobRunResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~StopPipelineJobRunResponseBody() = default;
};
class StopPipelineJobRunResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopPipelineJobRunResponseBody> body{};

  StopPipelineJobRunResponse() {}

  explicit StopPipelineJobRunResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopPipelineJobRunResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopPipelineJobRunResponseBody>(model1);
      }
    }
  }


  virtual ~StopPipelineJobRunResponse() = default;
};
class StopPipelineRunResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  StopPipelineRunResponseBody() {}

  explicit StopPipelineRunResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~StopPipelineRunResponseBody() = default;
};
class StopPipelineRunResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopPipelineRunResponseBody> body{};

  StopPipelineRunResponse() {}

  explicit StopPipelineRunResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopPipelineRunResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopPipelineRunResponseBody>(model1);
      }
    }
  }


  virtual ~StopPipelineRunResponse() = default;
};
class StopVMDeployOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  StopVMDeployOrderResponseBody() {}

  explicit StopVMDeployOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~StopVMDeployOrderResponseBody() = default;
};
class StopVMDeployOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopVMDeployOrderResponseBody> body{};

  StopVMDeployOrderResponse() {}

  explicit StopVMDeployOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopVMDeployOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopVMDeployOrderResponseBody>(model1);
      }
    }
  }


  virtual ~StopVMDeployOrderResponse() = default;
};
class TransferRepositoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> groupId{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> repositoryId{};

  TransferRepositoryRequest() {}

  explicit TransferRepositoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (groupId) {
      res["groupId"] = boost::any(*groupId);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (repositoryId) {
      res["repositoryId"] = boost::any(*repositoryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("groupId") != m.end() && !m["groupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["groupId"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("repositoryId") != m.end() && !m["repositoryId"].empty()) {
      repositoryId = make_shared<string>(boost::any_cast<string>(m["repositoryId"]));
    }
  }


  virtual ~TransferRepositoryRequest() = default;
};
class TransferRepositoryResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> accessLevel{};
  shared_ptr<bool> archived{};
  shared_ptr<string> createdAt{};
  shared_ptr<long> creatorId{};
  shared_ptr<bool> demoProject{};
  shared_ptr<string> description{};
  shared_ptr<bool> encrypted{};
  shared_ptr<long> id{};
  shared_ptr<string> lastActivityAt{};
  shared_ptr<string> name{};
  shared_ptr<string> nameWithNamespace{};
  shared_ptr<long> namespaceId{};
  shared_ptr<string> path{};
  shared_ptr<string> pathWithNamespace{};
  shared_ptr<long> starCount{};
  shared_ptr<bool> starred{};
  shared_ptr<string> updatedAt{};
  shared_ptr<long> visibilityLevel{};
  shared_ptr<string> webUrl{};

  TransferRepositoryResponseBodyResult() {}

  explicit TransferRepositoryResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessLevel) {
      res["accessLevel"] = boost::any(*accessLevel);
    }
    if (archived) {
      res["archived"] = boost::any(*archived);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (creatorId) {
      res["creatorId"] = boost::any(*creatorId);
    }
    if (demoProject) {
      res["demoProject"] = boost::any(*demoProject);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (encrypted) {
      res["encrypted"] = boost::any(*encrypted);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (lastActivityAt) {
      res["lastActivityAt"] = boost::any(*lastActivityAt);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nameWithNamespace) {
      res["nameWithNamespace"] = boost::any(*nameWithNamespace);
    }
    if (namespaceId) {
      res["namespaceId"] = boost::any(*namespaceId);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (pathWithNamespace) {
      res["pathWithNamespace"] = boost::any(*pathWithNamespace);
    }
    if (starCount) {
      res["starCount"] = boost::any(*starCount);
    }
    if (starred) {
      res["starred"] = boost::any(*starred);
    }
    if (updatedAt) {
      res["updatedAt"] = boost::any(*updatedAt);
    }
    if (visibilityLevel) {
      res["visibilityLevel"] = boost::any(*visibilityLevel);
    }
    if (webUrl) {
      res["webUrl"] = boost::any(*webUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessLevel") != m.end() && !m["accessLevel"].empty()) {
      accessLevel = make_shared<long>(boost::any_cast<long>(m["accessLevel"]));
    }
    if (m.find("archived") != m.end() && !m["archived"].empty()) {
      archived = make_shared<bool>(boost::any_cast<bool>(m["archived"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("creatorId") != m.end() && !m["creatorId"].empty()) {
      creatorId = make_shared<long>(boost::any_cast<long>(m["creatorId"]));
    }
    if (m.find("demoProject") != m.end() && !m["demoProject"].empty()) {
      demoProject = make_shared<bool>(boost::any_cast<bool>(m["demoProject"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("encrypted") != m.end() && !m["encrypted"].empty()) {
      encrypted = make_shared<bool>(boost::any_cast<bool>(m["encrypted"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("lastActivityAt") != m.end() && !m["lastActivityAt"].empty()) {
      lastActivityAt = make_shared<string>(boost::any_cast<string>(m["lastActivityAt"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nameWithNamespace") != m.end() && !m["nameWithNamespace"].empty()) {
      nameWithNamespace = make_shared<string>(boost::any_cast<string>(m["nameWithNamespace"]));
    }
    if (m.find("namespaceId") != m.end() && !m["namespaceId"].empty()) {
      namespaceId = make_shared<long>(boost::any_cast<long>(m["namespaceId"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("pathWithNamespace") != m.end() && !m["pathWithNamespace"].empty()) {
      pathWithNamespace = make_shared<string>(boost::any_cast<string>(m["pathWithNamespace"]));
    }
    if (m.find("starCount") != m.end() && !m["starCount"].empty()) {
      starCount = make_shared<long>(boost::any_cast<long>(m["starCount"]));
    }
    if (m.find("starred") != m.end() && !m["starred"].empty()) {
      starred = make_shared<bool>(boost::any_cast<bool>(m["starred"]));
    }
    if (m.find("updatedAt") != m.end() && !m["updatedAt"].empty()) {
      updatedAt = make_shared<string>(boost::any_cast<string>(m["updatedAt"]));
    }
    if (m.find("visibilityLevel") != m.end() && !m["visibilityLevel"].empty()) {
      visibilityLevel = make_shared<long>(boost::any_cast<long>(m["visibilityLevel"]));
    }
    if (m.find("webUrl") != m.end() && !m["webUrl"].empty()) {
      webUrl = make_shared<string>(boost::any_cast<string>(m["webUrl"]));
    }
  }


  virtual ~TransferRepositoryResponseBodyResult() = default;
};
class TransferRepositoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<TransferRepositoryResponseBodyResult> result{};
  shared_ptr<bool> success{};

  TransferRepositoryResponseBody() {}

  explicit TransferRepositoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        TransferRepositoryResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<TransferRepositoryResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~TransferRepositoryResponseBody() = default;
};
class TransferRepositoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TransferRepositoryResponseBody> body{};

  TransferRepositoryResponse() {}

  explicit TransferRepositoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TransferRepositoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TransferRepositoryResponseBody>(model1);
      }
    }
  }


  virtual ~TransferRepositoryResponse() = default;
};
class TriggerRepositoryMirrorSyncRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> account{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> token{};

  TriggerRepositoryMirrorSyncRequest() {}

  explicit TriggerRepositoryMirrorSyncRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (account) {
      res["account"] = boost::any(*account);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (token) {
      res["token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("account") != m.end() && !m["account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["account"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("token") != m.end() && !m["token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["token"]));
    }
  }


  virtual ~TriggerRepositoryMirrorSyncRequest() = default;
};
class TriggerRepositoryMirrorSyncResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> result{};

  TriggerRepositoryMirrorSyncResponseBodyResult() {}

  explicit TriggerRepositoryMirrorSyncResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~TriggerRepositoryMirrorSyncResponseBodyResult() = default;
};
class TriggerRepositoryMirrorSyncResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<TriggerRepositoryMirrorSyncResponseBodyResult> result{};
  shared_ptr<bool> success{};

  TriggerRepositoryMirrorSyncResponseBody() {}

  explicit TriggerRepositoryMirrorSyncResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        TriggerRepositoryMirrorSyncResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<TriggerRepositoryMirrorSyncResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~TriggerRepositoryMirrorSyncResponseBody() = default;
};
class TriggerRepositoryMirrorSyncResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TriggerRepositoryMirrorSyncResponseBody> body{};

  TriggerRepositoryMirrorSyncResponse() {}

  explicit TriggerRepositoryMirrorSyncResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TriggerRepositoryMirrorSyncResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TriggerRepositoryMirrorSyncResponseBody>(model1);
      }
    }
  }


  virtual ~TriggerRepositoryMirrorSyncResponse() = default;
};
class UpdateAppMemberRequestPlayer : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> type{};

  UpdateAppMemberRequestPlayer() {}

  explicit UpdateAppMemberRequestPlayer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~UpdateAppMemberRequestPlayer() = default;
};
class UpdateAppMemberRequest : public Darabonba::Model {
public:
  shared_ptr<UpdateAppMemberRequestPlayer> player{};
  shared_ptr<vector<string>> roleNames{};
  shared_ptr<string> organizationId{};

  UpdateAppMemberRequest() {}

  explicit UpdateAppMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (player) {
      res["player"] = player ? boost::any(player->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (roleNames) {
      res["roleNames"] = boost::any(*roleNames);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("player") != m.end() && !m["player"].empty()) {
      if (typeid(map<string, boost::any>) == m["player"].type()) {
        UpdateAppMemberRequestPlayer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["player"]));
        player = make_shared<UpdateAppMemberRequestPlayer>(model1);
      }
    }
    if (m.find("roleNames") != m.end() && !m["roleNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["roleNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["roleNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      roleNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~UpdateAppMemberRequest() = default;
};
class UpdateAppMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<string> body{};

  UpdateAppMemberResponse() {}

  explicit UpdateAppMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~UpdateAppMemberResponse() = default;
};
class UpdateApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccountId{};
  shared_ptr<string> organizationId{};

  UpdateApplicationRequest() {}

  explicit UpdateApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccountId) {
      res["ownerAccountId"] = boost::any(*ownerAccountId);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ownerAccountId") != m.end() && !m["ownerAccountId"].empty()) {
      ownerAccountId = make_shared<string>(boost::any_cast<string>(m["ownerAccountId"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~UpdateApplicationRequest() = default;
};
class UpdateApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> creatorAccountId{};
  shared_ptr<string> description{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};

  UpdateApplicationResponseBody() {}

  explicit UpdateApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creatorAccountId) {
      res["creatorAccountId"] = boost::any(*creatorAccountId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("creatorAccountId") != m.end() && !m["creatorAccountId"].empty()) {
      creatorAccountId = make_shared<string>(boost::any_cast<string>(m["creatorAccountId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmtCreate"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UpdateApplicationResponseBody() = default;
};
class UpdateApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateApplicationResponseBody> body{};

  UpdateApplicationResponse() {}

  explicit UpdateApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateApplicationResponse() = default;
};
class UpdateCheckRunRequestAnnotations : public Darabonba::Model {
public:
  shared_ptr<string> annotationLevel{};
  shared_ptr<long> endColumn{};
  shared_ptr<long> endLine{};
  shared_ptr<string> message{};
  shared_ptr<string> path{};
  shared_ptr<string> rawDetails{};
  shared_ptr<long> startColumn{};
  shared_ptr<long> startLine{};
  shared_ptr<string> title{};

  UpdateCheckRunRequestAnnotations() {}

  explicit UpdateCheckRunRequestAnnotations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationLevel) {
      res["annotationLevel"] = boost::any(*annotationLevel);
    }
    if (endColumn) {
      res["endColumn"] = boost::any(*endColumn);
    }
    if (endLine) {
      res["endLine"] = boost::any(*endLine);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (rawDetails) {
      res["rawDetails"] = boost::any(*rawDetails);
    }
    if (startColumn) {
      res["startColumn"] = boost::any(*startColumn);
    }
    if (startLine) {
      res["startLine"] = boost::any(*startLine);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("annotationLevel") != m.end() && !m["annotationLevel"].empty()) {
      annotationLevel = make_shared<string>(boost::any_cast<string>(m["annotationLevel"]));
    }
    if (m.find("endColumn") != m.end() && !m["endColumn"].empty()) {
      endColumn = make_shared<long>(boost::any_cast<long>(m["endColumn"]));
    }
    if (m.find("endLine") != m.end() && !m["endLine"].empty()) {
      endLine = make_shared<long>(boost::any_cast<long>(m["endLine"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("rawDetails") != m.end() && !m["rawDetails"].empty()) {
      rawDetails = make_shared<string>(boost::any_cast<string>(m["rawDetails"]));
    }
    if (m.find("startColumn") != m.end() && !m["startColumn"].empty()) {
      startColumn = make_shared<long>(boost::any_cast<long>(m["startColumn"]));
    }
    if (m.find("startLine") != m.end() && !m["startLine"].empty()) {
      startLine = make_shared<long>(boost::any_cast<long>(m["startLine"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~UpdateCheckRunRequestAnnotations() = default;
};
class UpdateCheckRunRequestOutputImages : public Darabonba::Model {
public:
  shared_ptr<string> alt{};
  shared_ptr<string> caption{};
  shared_ptr<string> imageUrl{};

  UpdateCheckRunRequestOutputImages() {}

  explicit UpdateCheckRunRequestOutputImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alt) {
      res["alt"] = boost::any(*alt);
    }
    if (caption) {
      res["caption"] = boost::any(*caption);
    }
    if (imageUrl) {
      res["imageUrl"] = boost::any(*imageUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alt") != m.end() && !m["alt"].empty()) {
      alt = make_shared<string>(boost::any_cast<string>(m["alt"]));
    }
    if (m.find("caption") != m.end() && !m["caption"].empty()) {
      caption = make_shared<string>(boost::any_cast<string>(m["caption"]));
    }
    if (m.find("imageUrl") != m.end() && !m["imageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["imageUrl"]));
    }
  }


  virtual ~UpdateCheckRunRequestOutputImages() = default;
};
class UpdateCheckRunRequestOutput : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateCheckRunRequestOutputImages>> images{};
  shared_ptr<string> summary{};
  shared_ptr<string> text{};
  shared_ptr<string> title{};

  UpdateCheckRunRequestOutput() {}

  explicit UpdateCheckRunRequestOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (images) {
      vector<boost::any> temp1;
      for(auto item1:*images){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["images"] = boost::any(temp1);
    }
    if (summary) {
      res["summary"] = boost::any(*summary);
    }
    if (text) {
      res["text"] = boost::any(*text);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("images") != m.end() && !m["images"].empty()) {
      if (typeid(vector<boost::any>) == m["images"].type()) {
        vector<UpdateCheckRunRequestOutputImages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["images"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateCheckRunRequestOutputImages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        images = make_shared<vector<UpdateCheckRunRequestOutputImages>>(expect1);
      }
    }
    if (m.find("summary") != m.end() && !m["summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["summary"]));
    }
    if (m.find("text") != m.end() && !m["text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["text"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~UpdateCheckRunRequestOutput() = default;
};
class UpdateCheckRunRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<vector<UpdateCheckRunRequestAnnotations>> annotations{};
  shared_ptr<string> completedAt{};
  shared_ptr<string> conclusion{};
  shared_ptr<string> detailsUrl{};
  shared_ptr<string> externalId{};
  shared_ptr<string> name{};
  shared_ptr<UpdateCheckRunRequestOutput> output{};
  shared_ptr<string> startedAt{};
  shared_ptr<string> status{};
  shared_ptr<long> checkRunId{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> repositoryIdentity{};

  UpdateCheckRunRequest() {}

  explicit UpdateCheckRunRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (annotations) {
      vector<boost::any> temp1;
      for(auto item1:*annotations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["annotations"] = boost::any(temp1);
    }
    if (completedAt) {
      res["completedAt"] = boost::any(*completedAt);
    }
    if (conclusion) {
      res["conclusion"] = boost::any(*conclusion);
    }
    if (detailsUrl) {
      res["detailsUrl"] = boost::any(*detailsUrl);
    }
    if (externalId) {
      res["externalId"] = boost::any(*externalId);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (output) {
      res["output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startedAt) {
      res["startedAt"] = boost::any(*startedAt);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (checkRunId) {
      res["checkRunId"] = boost::any(*checkRunId);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (repositoryIdentity) {
      res["repositoryIdentity"] = boost::any(*repositoryIdentity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("annotations") != m.end() && !m["annotations"].empty()) {
      if (typeid(vector<boost::any>) == m["annotations"].type()) {
        vector<UpdateCheckRunRequestAnnotations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["annotations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateCheckRunRequestAnnotations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotations = make_shared<vector<UpdateCheckRunRequestAnnotations>>(expect1);
      }
    }
    if (m.find("completedAt") != m.end() && !m["completedAt"].empty()) {
      completedAt = make_shared<string>(boost::any_cast<string>(m["completedAt"]));
    }
    if (m.find("conclusion") != m.end() && !m["conclusion"].empty()) {
      conclusion = make_shared<string>(boost::any_cast<string>(m["conclusion"]));
    }
    if (m.find("detailsUrl") != m.end() && !m["detailsUrl"].empty()) {
      detailsUrl = make_shared<string>(boost::any_cast<string>(m["detailsUrl"]));
    }
    if (m.find("externalId") != m.end() && !m["externalId"].empty()) {
      externalId = make_shared<string>(boost::any_cast<string>(m["externalId"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("output") != m.end() && !m["output"].empty()) {
      if (typeid(map<string, boost::any>) == m["output"].type()) {
        UpdateCheckRunRequestOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["output"]));
        output = make_shared<UpdateCheckRunRequestOutput>(model1);
      }
    }
    if (m.find("startedAt") != m.end() && !m["startedAt"].empty()) {
      startedAt = make_shared<string>(boost::any_cast<string>(m["startedAt"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("checkRunId") != m.end() && !m["checkRunId"].empty()) {
      checkRunId = make_shared<long>(boost::any_cast<long>(m["checkRunId"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("repositoryIdentity") != m.end() && !m["repositoryIdentity"].empty()) {
      repositoryIdentity = make_shared<string>(boost::any_cast<string>(m["repositoryIdentity"]));
    }
  }


  virtual ~UpdateCheckRunRequest() = default;
};
class UpdateCheckRunResponseBodyResultAnnotations : public Darabonba::Model {
public:
  shared_ptr<string> annotationLevel{};
  shared_ptr<long> endColumn{};
  shared_ptr<long> endLine{};
  shared_ptr<long> id{};
  shared_ptr<string> message{};
  shared_ptr<string> path{};
  shared_ptr<string> rawDetails{};
  shared_ptr<long> startColumn{};
  shared_ptr<long> startLine{};
  shared_ptr<string> title{};

  UpdateCheckRunResponseBodyResultAnnotations() {}

  explicit UpdateCheckRunResponseBodyResultAnnotations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationLevel) {
      res["annotationLevel"] = boost::any(*annotationLevel);
    }
    if (endColumn) {
      res["endColumn"] = boost::any(*endColumn);
    }
    if (endLine) {
      res["endLine"] = boost::any(*endLine);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (rawDetails) {
      res["rawDetails"] = boost::any(*rawDetails);
    }
    if (startColumn) {
      res["startColumn"] = boost::any(*startColumn);
    }
    if (startLine) {
      res["startLine"] = boost::any(*startLine);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("annotationLevel") != m.end() && !m["annotationLevel"].empty()) {
      annotationLevel = make_shared<string>(boost::any_cast<string>(m["annotationLevel"]));
    }
    if (m.find("endColumn") != m.end() && !m["endColumn"].empty()) {
      endColumn = make_shared<long>(boost::any_cast<long>(m["endColumn"]));
    }
    if (m.find("endLine") != m.end() && !m["endLine"].empty()) {
      endLine = make_shared<long>(boost::any_cast<long>(m["endLine"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("rawDetails") != m.end() && !m["rawDetails"].empty()) {
      rawDetails = make_shared<string>(boost::any_cast<string>(m["rawDetails"]));
    }
    if (m.find("startColumn") != m.end() && !m["startColumn"].empty()) {
      startColumn = make_shared<long>(boost::any_cast<long>(m["startColumn"]));
    }
    if (m.find("startLine") != m.end() && !m["startLine"].empty()) {
      startLine = make_shared<long>(boost::any_cast<long>(m["startLine"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~UpdateCheckRunResponseBodyResultAnnotations() = default;
};
class UpdateCheckRunResponseBodyResultCheckSuite : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  UpdateCheckRunResponseBodyResultCheckSuite() {}

  explicit UpdateCheckRunResponseBodyResultCheckSuite(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
  }


  virtual ~UpdateCheckRunResponseBodyResultCheckSuite() = default;
};
class UpdateCheckRunResponseBodyResultOutputImages : public Darabonba::Model {
public:
  shared_ptr<string> alt{};
  shared_ptr<string> caption{};
  shared_ptr<string> imageUrl{};

  UpdateCheckRunResponseBodyResultOutputImages() {}

  explicit UpdateCheckRunResponseBodyResultOutputImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alt) {
      res["alt"] = boost::any(*alt);
    }
    if (caption) {
      res["caption"] = boost::any(*caption);
    }
    if (imageUrl) {
      res["imageUrl"] = boost::any(*imageUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alt") != m.end() && !m["alt"].empty()) {
      alt = make_shared<string>(boost::any_cast<string>(m["alt"]));
    }
    if (m.find("caption") != m.end() && !m["caption"].empty()) {
      caption = make_shared<string>(boost::any_cast<string>(m["caption"]));
    }
    if (m.find("imageUrl") != m.end() && !m["imageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["imageUrl"]));
    }
  }


  virtual ~UpdateCheckRunResponseBodyResultOutputImages() = default;
};
class UpdateCheckRunResponseBodyResultOutput : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateCheckRunResponseBodyResultOutputImages>> images{};
  shared_ptr<string> summary{};
  shared_ptr<string> text{};
  shared_ptr<string> title{};

  UpdateCheckRunResponseBodyResultOutput() {}

  explicit UpdateCheckRunResponseBodyResultOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (images) {
      vector<boost::any> temp1;
      for(auto item1:*images){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["images"] = boost::any(temp1);
    }
    if (summary) {
      res["summary"] = boost::any(*summary);
    }
    if (text) {
      res["text"] = boost::any(*text);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("images") != m.end() && !m["images"].empty()) {
      if (typeid(vector<boost::any>) == m["images"].type()) {
        vector<UpdateCheckRunResponseBodyResultOutputImages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["images"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateCheckRunResponseBodyResultOutputImages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        images = make_shared<vector<UpdateCheckRunResponseBodyResultOutputImages>>(expect1);
      }
    }
    if (m.find("summary") != m.end() && !m["summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["summary"]));
    }
    if (m.find("text") != m.end() && !m["text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["text"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~UpdateCheckRunResponseBodyResultOutput() = default;
};
class UpdateCheckRunResponseBodyResultWriter : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> logoUrl{};
  shared_ptr<string> name{};
  shared_ptr<string> slug{};
  shared_ptr<string> type{};

  UpdateCheckRunResponseBodyResultWriter() {}

  explicit UpdateCheckRunResponseBodyResultWriter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (logoUrl) {
      res["logoUrl"] = boost::any(*logoUrl);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (slug) {
      res["slug"] = boost::any(*slug);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("logoUrl") != m.end() && !m["logoUrl"].empty()) {
      logoUrl = make_shared<string>(boost::any_cast<string>(m["logoUrl"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("slug") != m.end() && !m["slug"].empty()) {
      slug = make_shared<string>(boost::any_cast<string>(m["slug"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~UpdateCheckRunResponseBodyResultWriter() = default;
};
class UpdateCheckRunResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateCheckRunResponseBodyResultAnnotations>> annotations{};
  shared_ptr<UpdateCheckRunResponseBodyResultCheckSuite> checkSuite{};
  shared_ptr<string> completedAt{};
  shared_ptr<string> conclusion{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> detailsUrl{};
  shared_ptr<string> externalId{};
  shared_ptr<string> headSha{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<UpdateCheckRunResponseBodyResultOutput> output{};
  shared_ptr<string> startedAt{};
  shared_ptr<string> status{};
  shared_ptr<string> updatedAt{};
  shared_ptr<UpdateCheckRunResponseBodyResultWriter> writer{};

  UpdateCheckRunResponseBodyResult() {}

  explicit UpdateCheckRunResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotations) {
      vector<boost::any> temp1;
      for(auto item1:*annotations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["annotations"] = boost::any(temp1);
    }
    if (checkSuite) {
      res["checkSuite"] = checkSuite ? boost::any(checkSuite->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (completedAt) {
      res["completedAt"] = boost::any(*completedAt);
    }
    if (conclusion) {
      res["conclusion"] = boost::any(*conclusion);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (detailsUrl) {
      res["detailsUrl"] = boost::any(*detailsUrl);
    }
    if (externalId) {
      res["externalId"] = boost::any(*externalId);
    }
    if (headSha) {
      res["headSha"] = boost::any(*headSha);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (output) {
      res["output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startedAt) {
      res["startedAt"] = boost::any(*startedAt);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (updatedAt) {
      res["updatedAt"] = boost::any(*updatedAt);
    }
    if (writer) {
      res["writer"] = writer ? boost::any(writer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("annotations") != m.end() && !m["annotations"].empty()) {
      if (typeid(vector<boost::any>) == m["annotations"].type()) {
        vector<UpdateCheckRunResponseBodyResultAnnotations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["annotations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateCheckRunResponseBodyResultAnnotations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotations = make_shared<vector<UpdateCheckRunResponseBodyResultAnnotations>>(expect1);
      }
    }
    if (m.find("checkSuite") != m.end() && !m["checkSuite"].empty()) {
      if (typeid(map<string, boost::any>) == m["checkSuite"].type()) {
        UpdateCheckRunResponseBodyResultCheckSuite model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["checkSuite"]));
        checkSuite = make_shared<UpdateCheckRunResponseBodyResultCheckSuite>(model1);
      }
    }
    if (m.find("completedAt") != m.end() && !m["completedAt"].empty()) {
      completedAt = make_shared<string>(boost::any_cast<string>(m["completedAt"]));
    }
    if (m.find("conclusion") != m.end() && !m["conclusion"].empty()) {
      conclusion = make_shared<string>(boost::any_cast<string>(m["conclusion"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("detailsUrl") != m.end() && !m["detailsUrl"].empty()) {
      detailsUrl = make_shared<string>(boost::any_cast<string>(m["detailsUrl"]));
    }
    if (m.find("externalId") != m.end() && !m["externalId"].empty()) {
      externalId = make_shared<string>(boost::any_cast<string>(m["externalId"]));
    }
    if (m.find("headSha") != m.end() && !m["headSha"].empty()) {
      headSha = make_shared<string>(boost::any_cast<string>(m["headSha"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("output") != m.end() && !m["output"].empty()) {
      if (typeid(map<string, boost::any>) == m["output"].type()) {
        UpdateCheckRunResponseBodyResultOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["output"]));
        output = make_shared<UpdateCheckRunResponseBodyResultOutput>(model1);
      }
    }
    if (m.find("startedAt") != m.end() && !m["startedAt"].empty()) {
      startedAt = make_shared<string>(boost::any_cast<string>(m["startedAt"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("updatedAt") != m.end() && !m["updatedAt"].empty()) {
      updatedAt = make_shared<string>(boost::any_cast<string>(m["updatedAt"]));
    }
    if (m.find("writer") != m.end() && !m["writer"].empty()) {
      if (typeid(map<string, boost::any>) == m["writer"].type()) {
        UpdateCheckRunResponseBodyResultWriter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["writer"]));
        writer = make_shared<UpdateCheckRunResponseBodyResultWriter>(model1);
      }
    }
  }


  virtual ~UpdateCheckRunResponseBodyResult() = default;
};
class UpdateCheckRunResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<UpdateCheckRunResponseBodyResult> result{};
  shared_ptr<bool> success{};

  UpdateCheckRunResponseBody() {}

  explicit UpdateCheckRunResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        UpdateCheckRunResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<UpdateCheckRunResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdateCheckRunResponseBody() = default;
};
class UpdateCheckRunResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCheckRunResponseBody> body{};

  UpdateCheckRunResponse() {}

  explicit UpdateCheckRunResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCheckRunResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCheckRunResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCheckRunResponse() = default;
};
class UpdateFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> branchName{};
  shared_ptr<string> commitMessage{};
  shared_ptr<string> content{};
  shared_ptr<string> encoding{};
  shared_ptr<string> newPath{};
  shared_ptr<string> oldPath{};
  shared_ptr<string> organizationId{};

  UpdateFileRequest() {}

  explicit UpdateFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (branchName) {
      res["branchName"] = boost::any(*branchName);
    }
    if (commitMessage) {
      res["commitMessage"] = boost::any(*commitMessage);
    }
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (encoding) {
      res["encoding"] = boost::any(*encoding);
    }
    if (newPath) {
      res["newPath"] = boost::any(*newPath);
    }
    if (oldPath) {
      res["oldPath"] = boost::any(*oldPath);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("branchName") != m.end() && !m["branchName"].empty()) {
      branchName = make_shared<string>(boost::any_cast<string>(m["branchName"]));
    }
    if (m.find("commitMessage") != m.end() && !m["commitMessage"].empty()) {
      commitMessage = make_shared<string>(boost::any_cast<string>(m["commitMessage"]));
    }
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("encoding") != m.end() && !m["encoding"].empty()) {
      encoding = make_shared<string>(boost::any_cast<string>(m["encoding"]));
    }
    if (m.find("newPath") != m.end() && !m["newPath"].empty()) {
      newPath = make_shared<string>(boost::any_cast<string>(m["newPath"]));
    }
    if (m.find("oldPath") != m.end() && !m["oldPath"].empty()) {
      oldPath = make_shared<string>(boost::any_cast<string>(m["oldPath"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~UpdateFileRequest() = default;
};
class UpdateFileResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> branchName{};
  shared_ptr<string> filePath{};

  UpdateFileResponseBodyResult() {}

  explicit UpdateFileResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (branchName) {
      res["branchName"] = boost::any(*branchName);
    }
    if (filePath) {
      res["filePath"] = boost::any(*filePath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("branchName") != m.end() && !m["branchName"].empty()) {
      branchName = make_shared<string>(boost::any_cast<string>(m["branchName"]));
    }
    if (m.find("filePath") != m.end() && !m["filePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["filePath"]));
    }
  }


  virtual ~UpdateFileResponseBodyResult() = default;
};
class UpdateFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<UpdateFileResponseBodyResult> result{};
  shared_ptr<bool> success{};

  UpdateFileResponseBody() {}

  explicit UpdateFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        UpdateFileResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<UpdateFileResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdateFileResponseBody() = default;
};
class UpdateFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateFileResponseBody> body{};

  UpdateFileResponse() {}

  explicit UpdateFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateFileResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateFileResponse() = default;
};
class UpdateFlowTagRequest : public Darabonba::Model {
public:
  shared_ptr<string> color{};
  shared_ptr<long> flowTagGroupId{};
  shared_ptr<string> name{};

  UpdateFlowTagRequest() {}

  explicit UpdateFlowTagRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (color) {
      res["color"] = boost::any(*color);
    }
    if (flowTagGroupId) {
      res["flowTagGroupId"] = boost::any(*flowTagGroupId);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("color") != m.end() && !m["color"].empty()) {
      color = make_shared<string>(boost::any_cast<string>(m["color"]));
    }
    if (m.find("flowTagGroupId") != m.end() && !m["flowTagGroupId"].empty()) {
      flowTagGroupId = make_shared<long>(boost::any_cast<long>(m["flowTagGroupId"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~UpdateFlowTagRequest() = default;
};
class UpdateFlowTagResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateFlowTagResponseBody() {}

  explicit UpdateFlowTagResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdateFlowTagResponseBody() = default;
};
class UpdateFlowTagResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateFlowTagResponseBody> body{};

  UpdateFlowTagResponse() {}

  explicit UpdateFlowTagResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateFlowTagResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateFlowTagResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateFlowTagResponse() = default;
};
class UpdateFlowTagGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  UpdateFlowTagGroupRequest() {}

  explicit UpdateFlowTagGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~UpdateFlowTagGroupRequest() = default;
};
class UpdateFlowTagGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateFlowTagGroupResponseBody() {}

  explicit UpdateFlowTagGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdateFlowTagGroupResponseBody() = default;
};
class UpdateFlowTagGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateFlowTagGroupResponseBody> body{};

  UpdateFlowTagGroupResponse() {}

  explicit UpdateFlowTagGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateFlowTagGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateFlowTagGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateFlowTagGroupResponse() = default;
};
class UpdateGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<string> pathWithNamespace{};
  shared_ptr<long> visibilityLevel{};
  shared_ptr<string> organizationId{};

  UpdateGroupRequest() {}

  explicit UpdateGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (pathWithNamespace) {
      res["pathWithNamespace"] = boost::any(*pathWithNamespace);
    }
    if (visibilityLevel) {
      res["visibilityLevel"] = boost::any(*visibilityLevel);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("pathWithNamespace") != m.end() && !m["pathWithNamespace"].empty()) {
      pathWithNamespace = make_shared<string>(boost::any_cast<string>(m["pathWithNamespace"]));
    }
    if (m.find("visibilityLevel") != m.end() && !m["visibilityLevel"].empty()) {
      visibilityLevel = make_shared<long>(boost::any_cast<long>(m["visibilityLevel"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~UpdateGroupRequest() = default;
};
class UpdateGroupResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> nameWithNamespace{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> parentId{};
  shared_ptr<string> path{};
  shared_ptr<string> pathWithNamespace{};
  shared_ptr<string> type{};
  shared_ptr<long> visibilityLevel{};
  shared_ptr<string> webUrl{};

  UpdateGroupResponseBodyResult() {}

  explicit UpdateGroupResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nameWithNamespace) {
      res["nameWithNamespace"] = boost::any(*nameWithNamespace);
    }
    if (ownerId) {
      res["ownerId"] = boost::any(*ownerId);
    }
    if (parentId) {
      res["parentId"] = boost::any(*parentId);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (pathWithNamespace) {
      res["pathWithNamespace"] = boost::any(*pathWithNamespace);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (visibilityLevel) {
      res["visibilityLevel"] = boost::any(*visibilityLevel);
    }
    if (webUrl) {
      res["webUrl"] = boost::any(*webUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nameWithNamespace") != m.end() && !m["nameWithNamespace"].empty()) {
      nameWithNamespace = make_shared<string>(boost::any_cast<string>(m["nameWithNamespace"]));
    }
    if (m.find("ownerId") != m.end() && !m["ownerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["ownerId"]));
    }
    if (m.find("parentId") != m.end() && !m["parentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["parentId"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("pathWithNamespace") != m.end() && !m["pathWithNamespace"].empty()) {
      pathWithNamespace = make_shared<string>(boost::any_cast<string>(m["pathWithNamespace"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("visibilityLevel") != m.end() && !m["visibilityLevel"].empty()) {
      visibilityLevel = make_shared<long>(boost::any_cast<long>(m["visibilityLevel"]));
    }
    if (m.find("webUrl") != m.end() && !m["webUrl"].empty()) {
      webUrl = make_shared<string>(boost::any_cast<string>(m["webUrl"]));
    }
  }


  virtual ~UpdateGroupResponseBodyResult() = default;
};
class UpdateGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<UpdateGroupResponseBodyResult> result{};
  shared_ptr<bool> success{};

  UpdateGroupResponseBody() {}

  explicit UpdateGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        UpdateGroupResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<UpdateGroupResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdateGroupResponseBody() = default;
};
class UpdateGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGroupResponseBody> body{};

  UpdateGroupResponse() {}

  explicit UpdateGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGroupResponse() = default;
};
class UpdateGroupMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> aliyunPk{};
  shared_ptr<long> accessLevel{};
  shared_ptr<string> memberType{};
  shared_ptr<string> organizationId{};

  UpdateGroupMemberRequest() {}

  explicit UpdateGroupMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (aliyunPk) {
      res["aliyunPk"] = boost::any(*aliyunPk);
    }
    if (accessLevel) {
      res["accessLevel"] = boost::any(*accessLevel);
    }
    if (memberType) {
      res["memberType"] = boost::any(*memberType);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("aliyunPk") != m.end() && !m["aliyunPk"].empty()) {
      aliyunPk = make_shared<string>(boost::any_cast<string>(m["aliyunPk"]));
    }
    if (m.find("accessLevel") != m.end() && !m["accessLevel"].empty()) {
      accessLevel = make_shared<long>(boost::any_cast<long>(m["accessLevel"]));
    }
    if (m.find("memberType") != m.end() && !m["memberType"].empty()) {
      memberType = make_shared<string>(boost::any_cast<string>(m["memberType"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~UpdateGroupMemberRequest() = default;
};
class UpdateGroupMemberResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> accessLevel{};
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<long> id{};
  shared_ptr<string> memberType{};
  shared_ptr<string> name{};
  shared_ptr<long> sourceId{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};

  UpdateGroupMemberResponseBodyResult() {}

  explicit UpdateGroupMemberResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessLevel) {
      res["accessLevel"] = boost::any(*accessLevel);
    }
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (memberType) {
      res["memberType"] = boost::any(*memberType);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sourceId) {
      res["sourceId"] = boost::any(*sourceId);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessLevel") != m.end() && !m["accessLevel"].empty()) {
      accessLevel = make_shared<long>(boost::any_cast<long>(m["accessLevel"]));
    }
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("memberType") != m.end() && !m["memberType"].empty()) {
      memberType = make_shared<string>(boost::any_cast<string>(m["memberType"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sourceId") != m.end() && !m["sourceId"].empty()) {
      sourceId = make_shared<long>(boost::any_cast<long>(m["sourceId"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~UpdateGroupMemberResponseBodyResult() = default;
};
class UpdateGroupMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<UpdateGroupMemberResponseBodyResult> result{};
  shared_ptr<bool> success{};

  UpdateGroupMemberResponseBody() {}

  explicit UpdateGroupMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        UpdateGroupMemberResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<UpdateGroupMemberResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdateGroupMemberResponseBody() = default;
};
class UpdateGroupMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGroupMemberResponseBody> body{};

  UpdateGroupMemberResponse() {}

  explicit UpdateGroupMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGroupMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGroupMemberResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGroupMemberResponse() = default;
};
class UpdateHostGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunRegion{};
  shared_ptr<string> ecsLabelKey{};
  shared_ptr<string> ecsLabelValue{};
  shared_ptr<string> ecsType{};
  shared_ptr<string> envId{};
  shared_ptr<string> machineInfos{};
  shared_ptr<string> name{};
  shared_ptr<long> serviceConnectionId{};
  shared_ptr<string> tagIds{};
  shared_ptr<string> type{};

  UpdateHostGroupRequest() {}

  explicit UpdateHostGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunRegion) {
      res["aliyunRegion"] = boost::any(*aliyunRegion);
    }
    if (ecsLabelKey) {
      res["ecsLabelKey"] = boost::any(*ecsLabelKey);
    }
    if (ecsLabelValue) {
      res["ecsLabelValue"] = boost::any(*ecsLabelValue);
    }
    if (ecsType) {
      res["ecsType"] = boost::any(*ecsType);
    }
    if (envId) {
      res["envId"] = boost::any(*envId);
    }
    if (machineInfos) {
      res["machineInfos"] = boost::any(*machineInfos);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (serviceConnectionId) {
      res["serviceConnectionId"] = boost::any(*serviceConnectionId);
    }
    if (tagIds) {
      res["tagIds"] = boost::any(*tagIds);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aliyunRegion") != m.end() && !m["aliyunRegion"].empty()) {
      aliyunRegion = make_shared<string>(boost::any_cast<string>(m["aliyunRegion"]));
    }
    if (m.find("ecsLabelKey") != m.end() && !m["ecsLabelKey"].empty()) {
      ecsLabelKey = make_shared<string>(boost::any_cast<string>(m["ecsLabelKey"]));
    }
    if (m.find("ecsLabelValue") != m.end() && !m["ecsLabelValue"].empty()) {
      ecsLabelValue = make_shared<string>(boost::any_cast<string>(m["ecsLabelValue"]));
    }
    if (m.find("ecsType") != m.end() && !m["ecsType"].empty()) {
      ecsType = make_shared<string>(boost::any_cast<string>(m["ecsType"]));
    }
    if (m.find("envId") != m.end() && !m["envId"].empty()) {
      envId = make_shared<string>(boost::any_cast<string>(m["envId"]));
    }
    if (m.find("machineInfos") != m.end() && !m["machineInfos"].empty()) {
      machineInfos = make_shared<string>(boost::any_cast<string>(m["machineInfos"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("serviceConnectionId") != m.end() && !m["serviceConnectionId"].empty()) {
      serviceConnectionId = make_shared<long>(boost::any_cast<long>(m["serviceConnectionId"]));
    }
    if (m.find("tagIds") != m.end() && !m["tagIds"].empty()) {
      tagIds = make_shared<string>(boost::any_cast<string>(m["tagIds"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~UpdateHostGroupRequest() = default;
};
class UpdateHostGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateHostGroupResponseBody() {}

  explicit UpdateHostGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdateHostGroupResponseBody() = default;
};
class UpdateHostGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateHostGroupResponseBody> body{};

  UpdateHostGroupResponse() {}

  explicit UpdateHostGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateHostGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateHostGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateHostGroupResponse() = default;
};
class UpdateMergeRequestRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> description{};
  shared_ptr<string> title{};
  shared_ptr<string> organizationId{};

  UpdateMergeRequestRequest() {}

  explicit UpdateMergeRequestRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~UpdateMergeRequestRequest() = default;
};
class UpdateMergeRequestResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> result{};

  UpdateMergeRequestResponseBodyResult() {}

  explicit UpdateMergeRequestResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~UpdateMergeRequestResponseBodyResult() = default;
};
class UpdateMergeRequestResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<UpdateMergeRequestResponseBodyResult> result{};
  shared_ptr<bool> success{};

  UpdateMergeRequestResponseBody() {}

  explicit UpdateMergeRequestResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        UpdateMergeRequestResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<UpdateMergeRequestResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdateMergeRequestResponseBody() = default;
};
class UpdateMergeRequestResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMergeRequestResponseBody> body{};

  UpdateMergeRequestResponse() {}

  explicit UpdateMergeRequestResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMergeRequestResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMergeRequestResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMergeRequestResponse() = default;
};
class UpdateMergeRequestPersonnelRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<vector<string>> newUserIdList{};
  shared_ptr<string> organizationId{};

  UpdateMergeRequestPersonnelRequest() {}

  explicit UpdateMergeRequestPersonnelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (newUserIdList) {
      res["newUserIdList"] = boost::any(*newUserIdList);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("newUserIdList") != m.end() && !m["newUserIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["newUserIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["newUserIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      newUserIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~UpdateMergeRequestPersonnelRequest() = default;
};
class UpdateMergeRequestPersonnelResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> result{};

  UpdateMergeRequestPersonnelResponseBodyResult() {}

  explicit UpdateMergeRequestPersonnelResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~UpdateMergeRequestPersonnelResponseBodyResult() = default;
};
class UpdateMergeRequestPersonnelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<UpdateMergeRequestPersonnelResponseBodyResult> result{};
  shared_ptr<bool> success{};

  UpdateMergeRequestPersonnelResponseBody() {}

  explicit UpdateMergeRequestPersonnelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        UpdateMergeRequestPersonnelResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<UpdateMergeRequestPersonnelResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdateMergeRequestPersonnelResponseBody() = default;
};
class UpdateMergeRequestPersonnelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMergeRequestPersonnelResponseBody> body{};

  UpdateMergeRequestPersonnelResponse() {}

  explicit UpdateMergeRequestPersonnelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMergeRequestPersonnelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMergeRequestPersonnelResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMergeRequestPersonnelResponse() = default;
};
class UpdateOrganizationMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> organizationMemberName{};

  UpdateOrganizationMemberRequest() {}

  explicit UpdateOrganizationMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationMemberName) {
      res["organizationMemberName"] = boost::any(*organizationMemberName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("organizationMemberName") != m.end() && !m["organizationMemberName"].empty()) {
      organizationMemberName = make_shared<string>(boost::any_cast<string>(m["organizationMemberName"]));
    }
  }


  virtual ~UpdateOrganizationMemberRequest() = default;
};
class UpdateOrganizationMemberResponseBodyMember : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> organizationMemberName{};

  UpdateOrganizationMemberResponseBodyMember() {}

  explicit UpdateOrganizationMemberResponseBodyMember(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    if (organizationMemberName) {
      res["organizationMemberName"] = boost::any(*organizationMemberName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
    if (m.find("organizationMemberName") != m.end() && !m["organizationMemberName"].empty()) {
      organizationMemberName = make_shared<string>(boost::any_cast<string>(m["organizationMemberName"]));
    }
  }


  virtual ~UpdateOrganizationMemberResponseBodyMember() = default;
};
class UpdateOrganizationMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<UpdateOrganizationMemberResponseBodyMember> member{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateOrganizationMemberResponseBody() {}

  explicit UpdateOrganizationMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (member) {
      res["member"] = member ? boost::any(member->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("member") != m.end() && !m["member"].empty()) {
      if (typeid(map<string, boost::any>) == m["member"].type()) {
        UpdateOrganizationMemberResponseBodyMember model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["member"]));
        member = make_shared<UpdateOrganizationMemberResponseBodyMember>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdateOrganizationMemberResponseBody() = default;
};
class UpdateOrganizationMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateOrganizationMemberResponseBody> body{};

  UpdateOrganizationMemberResponse() {}

  explicit UpdateOrganizationMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateOrganizationMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateOrganizationMemberResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateOrganizationMemberResponse() = default;
};
class UpdatePipelineRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> name{};
  shared_ptr<string> pipelineId{};

  UpdatePipelineRequest() {}

  explicit UpdatePipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (pipelineId) {
      res["pipelineId"] = boost::any(*pipelineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("pipelineId") != m.end() && !m["pipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["pipelineId"]));
    }
  }


  virtual ~UpdatePipelineRequest() = default;
};
class UpdatePipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdatePipelineResponseBody() {}

  explicit UpdatePipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdatePipelineResponseBody() = default;
};
class UpdatePipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePipelineResponseBody> body{};

  UpdatePipelineResponse() {}

  explicit UpdatePipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePipelineResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePipelineResponse() = default;
};
class UpdatePipelineBaseInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> envId{};
  shared_ptr<string> pipelineName{};
  shared_ptr<string> tagList{};

  UpdatePipelineBaseInfoRequest() {}

  explicit UpdatePipelineBaseInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (envId) {
      res["envId"] = boost::any(*envId);
    }
    if (pipelineName) {
      res["pipelineName"] = boost::any(*pipelineName);
    }
    if (tagList) {
      res["tagList"] = boost::any(*tagList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("envId") != m.end() && !m["envId"].empty()) {
      envId = make_shared<long>(boost::any_cast<long>(m["envId"]));
    }
    if (m.find("pipelineName") != m.end() && !m["pipelineName"].empty()) {
      pipelineName = make_shared<string>(boost::any_cast<string>(m["pipelineName"]));
    }
    if (m.find("tagList") != m.end() && !m["tagList"].empty()) {
      tagList = make_shared<string>(boost::any_cast<string>(m["tagList"]));
    }
  }


  virtual ~UpdatePipelineBaseInfoRequest() = default;
};
class UpdatePipelineBaseInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdatePipelineBaseInfoResponseBody() {}

  explicit UpdatePipelineBaseInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdatePipelineBaseInfoResponseBody() = default;
};
class UpdatePipelineBaseInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePipelineBaseInfoResponseBody> body{};

  UpdatePipelineBaseInfoResponse() {}

  explicit UpdatePipelineBaseInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePipelineBaseInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePipelineBaseInfoResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePipelineBaseInfoResponse() = default;
};
class UpdatePipelineGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  UpdatePipelineGroupRequest() {}

  explicit UpdatePipelineGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~UpdatePipelineGroupRequest() = default;
};
class UpdatePipelineGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdatePipelineGroupResponseBody() {}

  explicit UpdatePipelineGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdatePipelineGroupResponseBody() = default;
};
class UpdatePipelineGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePipelineGroupResponseBody> body{};

  UpdatePipelineGroupResponse() {}

  explicit UpdatePipelineGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePipelineGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePipelineGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePipelineGroupResponse() = default;
};
class UpdateProjectFieldRequestUpdateBasicFieldRequestList : public Darabonba::Model {
public:
  shared_ptr<string> propertyKey{};
  shared_ptr<string> propertyValue{};

  UpdateProjectFieldRequestUpdateBasicFieldRequestList() {}

  explicit UpdateProjectFieldRequestUpdateBasicFieldRequestList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertyKey) {
      res["propertyKey"] = boost::any(*propertyKey);
    }
    if (propertyValue) {
      res["propertyValue"] = boost::any(*propertyValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("propertyKey") != m.end() && !m["propertyKey"].empty()) {
      propertyKey = make_shared<string>(boost::any_cast<string>(m["propertyKey"]));
    }
    if (m.find("propertyValue") != m.end() && !m["propertyValue"].empty()) {
      propertyValue = make_shared<string>(boost::any_cast<string>(m["propertyValue"]));
    }
  }


  virtual ~UpdateProjectFieldRequestUpdateBasicFieldRequestList() = default;
};
class UpdateProjectFieldRequestUpdateForOpenApiList : public Darabonba::Model {
public:
  shared_ptr<string> fieldIdentifier{};
  shared_ptr<string> value{};

  UpdateProjectFieldRequestUpdateForOpenApiList() {}

  explicit UpdateProjectFieldRequestUpdateForOpenApiList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldIdentifier) {
      res["fieldIdentifier"] = boost::any(*fieldIdentifier);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fieldIdentifier") != m.end() && !m["fieldIdentifier"].empty()) {
      fieldIdentifier = make_shared<string>(boost::any_cast<string>(m["fieldIdentifier"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~UpdateProjectFieldRequestUpdateForOpenApiList() = default;
};
class UpdateProjectFieldRequest : public Darabonba::Model {
public:
  shared_ptr<string> statusIdentifier{};
  shared_ptr<vector<UpdateProjectFieldRequestUpdateBasicFieldRequestList>> updateBasicFieldRequestList{};
  shared_ptr<vector<UpdateProjectFieldRequestUpdateForOpenApiList>> updateForOpenApiList{};

  UpdateProjectFieldRequest() {}

  explicit UpdateProjectFieldRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (statusIdentifier) {
      res["statusIdentifier"] = boost::any(*statusIdentifier);
    }
    if (updateBasicFieldRequestList) {
      vector<boost::any> temp1;
      for(auto item1:*updateBasicFieldRequestList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["updateBasicFieldRequestList"] = boost::any(temp1);
    }
    if (updateForOpenApiList) {
      vector<boost::any> temp1;
      for(auto item1:*updateForOpenApiList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["updateForOpenApiList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("statusIdentifier") != m.end() && !m["statusIdentifier"].empty()) {
      statusIdentifier = make_shared<string>(boost::any_cast<string>(m["statusIdentifier"]));
    }
    if (m.find("updateBasicFieldRequestList") != m.end() && !m["updateBasicFieldRequestList"].empty()) {
      if (typeid(vector<boost::any>) == m["updateBasicFieldRequestList"].type()) {
        vector<UpdateProjectFieldRequestUpdateBasicFieldRequestList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["updateBasicFieldRequestList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateProjectFieldRequestUpdateBasicFieldRequestList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        updateBasicFieldRequestList = make_shared<vector<UpdateProjectFieldRequestUpdateBasicFieldRequestList>>(expect1);
      }
    }
    if (m.find("updateForOpenApiList") != m.end() && !m["updateForOpenApiList"].empty()) {
      if (typeid(vector<boost::any>) == m["updateForOpenApiList"].type()) {
        vector<UpdateProjectFieldRequestUpdateForOpenApiList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["updateForOpenApiList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateProjectFieldRequestUpdateForOpenApiList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        updateForOpenApiList = make_shared<vector<UpdateProjectFieldRequestUpdateForOpenApiList>>(expect1);
      }
    }
  }


  virtual ~UpdateProjectFieldRequest() = default;
};
class UpdateProjectFieldResponseBodyProjectFieldList : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> identifier{};
  shared_ptr<string> value{};
  shared_ptr<string> valueType{};

  UpdateProjectFieldResponseBodyProjectFieldList() {}

  explicit UpdateProjectFieldResponseBodyProjectFieldList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["displayName"] = boost::any(*displayName);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    if (valueType) {
      res["valueType"] = boost::any(*valueType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("displayName") != m.end() && !m["displayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["displayName"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
    if (m.find("valueType") != m.end() && !m["valueType"].empty()) {
      valueType = make_shared<string>(boost::any_cast<string>(m["valueType"]));
    }
  }


  virtual ~UpdateProjectFieldResponseBodyProjectFieldList() = default;
};
class UpdateProjectFieldResponseBodyProject : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> categoryIdentifier{};
  shared_ptr<string> creator{};
  shared_ptr<string> customCode{};
  shared_ptr<string> description{};
  shared_ptr<vector<UpdateProjectFieldResponseBodyProjectFieldList>> fieldList{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> icon{};
  shared_ptr<string> iconBig{};
  shared_ptr<string> iconGroup{};
  shared_ptr<string> iconSmall{};
  shared_ptr<string> id{};
  shared_ptr<string> identifier{};
  shared_ptr<string> identifierPath{};
  shared_ptr<string> logicalStatus{};
  shared_ptr<string> modifier{};
  shared_ptr<string> name{};
  shared_ptr<string> organizationIdentifier{};
  shared_ptr<string> parentIdentifier{};
  shared_ptr<string> scope{};
  shared_ptr<string> statusIdentifier{};
  shared_ptr<string> statusName{};
  shared_ptr<string> statusStageIdentifier{};
  shared_ptr<string> subType{};
  shared_ptr<string> typeIdentifier{};

  UpdateProjectFieldResponseBodyProject() {}

  explicit UpdateProjectFieldResponseBodyProject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (categoryIdentifier) {
      res["categoryIdentifier"] = boost::any(*categoryIdentifier);
    }
    if (creator) {
      res["creator"] = boost::any(*creator);
    }
    if (customCode) {
      res["customCode"] = boost::any(*customCode);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (fieldList) {
      vector<boost::any> temp1;
      for(auto item1:*fieldList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["fieldList"] = boost::any(temp1);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (icon) {
      res["icon"] = boost::any(*icon);
    }
    if (iconBig) {
      res["iconBig"] = boost::any(*iconBig);
    }
    if (iconGroup) {
      res["iconGroup"] = boost::any(*iconGroup);
    }
    if (iconSmall) {
      res["iconSmall"] = boost::any(*iconSmall);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (identifierPath) {
      res["identifierPath"] = boost::any(*identifierPath);
    }
    if (logicalStatus) {
      res["logicalStatus"] = boost::any(*logicalStatus);
    }
    if (modifier) {
      res["modifier"] = boost::any(*modifier);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (organizationIdentifier) {
      res["organizationIdentifier"] = boost::any(*organizationIdentifier);
    }
    if (parentIdentifier) {
      res["parentIdentifier"] = boost::any(*parentIdentifier);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (statusIdentifier) {
      res["statusIdentifier"] = boost::any(*statusIdentifier);
    }
    if (statusName) {
      res["statusName"] = boost::any(*statusName);
    }
    if (statusStageIdentifier) {
      res["statusStageIdentifier"] = boost::any(*statusStageIdentifier);
    }
    if (subType) {
      res["subType"] = boost::any(*subType);
    }
    if (typeIdentifier) {
      res["typeIdentifier"] = boost::any(*typeIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["category"]));
    }
    if (m.find("categoryIdentifier") != m.end() && !m["categoryIdentifier"].empty()) {
      categoryIdentifier = make_shared<string>(boost::any_cast<string>(m["categoryIdentifier"]));
    }
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["creator"]));
    }
    if (m.find("customCode") != m.end() && !m["customCode"].empty()) {
      customCode = make_shared<string>(boost::any_cast<string>(m["customCode"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("fieldList") != m.end() && !m["fieldList"].empty()) {
      if (typeid(vector<boost::any>) == m["fieldList"].type()) {
        vector<UpdateProjectFieldResponseBodyProjectFieldList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["fieldList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateProjectFieldResponseBodyProjectFieldList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fieldList = make_shared<vector<UpdateProjectFieldResponseBodyProjectFieldList>>(expect1);
      }
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("icon") != m.end() && !m["icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["icon"]));
    }
    if (m.find("iconBig") != m.end() && !m["iconBig"].empty()) {
      iconBig = make_shared<string>(boost::any_cast<string>(m["iconBig"]));
    }
    if (m.find("iconGroup") != m.end() && !m["iconGroup"].empty()) {
      iconGroup = make_shared<string>(boost::any_cast<string>(m["iconGroup"]));
    }
    if (m.find("iconSmall") != m.end() && !m["iconSmall"].empty()) {
      iconSmall = make_shared<string>(boost::any_cast<string>(m["iconSmall"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("identifierPath") != m.end() && !m["identifierPath"].empty()) {
      identifierPath = make_shared<string>(boost::any_cast<string>(m["identifierPath"]));
    }
    if (m.find("logicalStatus") != m.end() && !m["logicalStatus"].empty()) {
      logicalStatus = make_shared<string>(boost::any_cast<string>(m["logicalStatus"]));
    }
    if (m.find("modifier") != m.end() && !m["modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["modifier"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("organizationIdentifier") != m.end() && !m["organizationIdentifier"].empty()) {
      organizationIdentifier = make_shared<string>(boost::any_cast<string>(m["organizationIdentifier"]));
    }
    if (m.find("parentIdentifier") != m.end() && !m["parentIdentifier"].empty()) {
      parentIdentifier = make_shared<string>(boost::any_cast<string>(m["parentIdentifier"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["scope"]));
    }
    if (m.find("statusIdentifier") != m.end() && !m["statusIdentifier"].empty()) {
      statusIdentifier = make_shared<string>(boost::any_cast<string>(m["statusIdentifier"]));
    }
    if (m.find("statusName") != m.end() && !m["statusName"].empty()) {
      statusName = make_shared<string>(boost::any_cast<string>(m["statusName"]));
    }
    if (m.find("statusStageIdentifier") != m.end() && !m["statusStageIdentifier"].empty()) {
      statusStageIdentifier = make_shared<string>(boost::any_cast<string>(m["statusStageIdentifier"]));
    }
    if (m.find("subType") != m.end() && !m["subType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["subType"]));
    }
    if (m.find("typeIdentifier") != m.end() && !m["typeIdentifier"].empty()) {
      typeIdentifier = make_shared<string>(boost::any_cast<string>(m["typeIdentifier"]));
    }
  }


  virtual ~UpdateProjectFieldResponseBodyProject() = default;
};
class UpdateProjectFieldResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<UpdateProjectFieldResponseBodyProject> project{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateProjectFieldResponseBody() {}

  explicit UpdateProjectFieldResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (project) {
      res["project"] = project ? boost::any(project->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("project") != m.end() && !m["project"].empty()) {
      if (typeid(map<string, boost::any>) == m["project"].type()) {
        UpdateProjectFieldResponseBodyProject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["project"]));
        project = make_shared<UpdateProjectFieldResponseBodyProject>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdateProjectFieldResponseBody() = default;
};
class UpdateProjectFieldResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateProjectFieldResponseBody> body{};

  UpdateProjectFieldResponse() {}

  explicit UpdateProjectFieldResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateProjectFieldResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateProjectFieldResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateProjectFieldResponse() = default;
};
class UpdateProjectLabelRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> color{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> repositoryIdentity{};

  UpdateProjectLabelRequest() {}

  explicit UpdateProjectLabelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (color) {
      res["color"] = boost::any(*color);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (repositoryIdentity) {
      res["repositoryIdentity"] = boost::any(*repositoryIdentity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("color") != m.end() && !m["color"].empty()) {
      color = make_shared<string>(boost::any_cast<string>(m["color"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("repositoryIdentity") != m.end() && !m["repositoryIdentity"].empty()) {
      repositoryIdentity = make_shared<string>(boost::any_cast<string>(m["repositoryIdentity"]));
    }
  }


  virtual ~UpdateProjectLabelRequest() = default;
};
class UpdateProjectLabelResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> color{};
  shared_ptr<string> description{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  UpdateProjectLabelResponseBodyResult() {}

  explicit UpdateProjectLabelResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (color) {
      res["color"] = boost::any(*color);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("color") != m.end() && !m["color"].empty()) {
      color = make_shared<string>(boost::any_cast<string>(m["color"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~UpdateProjectLabelResponseBodyResult() = default;
};
class UpdateProjectLabelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<UpdateProjectLabelResponseBodyResult> result{};
  shared_ptr<bool> success{};

  UpdateProjectLabelResponseBody() {}

  explicit UpdateProjectLabelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        UpdateProjectLabelResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<UpdateProjectLabelResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdateProjectLabelResponseBody() = default;
};
class UpdateProjectLabelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateProjectLabelResponseBody> body{};

  UpdateProjectLabelResponse() {}

  explicit UpdateProjectLabelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateProjectLabelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateProjectLabelResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateProjectLabelResponse() = default;
};
class UpdateProjectMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> roleIdentifier{};
  shared_ptr<string> targetIdentifier{};
  shared_ptr<string> targetType{};
  shared_ptr<string> userIdentifier{};
  shared_ptr<string> userType{};

  UpdateProjectMemberRequest() {}

  explicit UpdateProjectMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleIdentifier) {
      res["roleIdentifier"] = boost::any(*roleIdentifier);
    }
    if (targetIdentifier) {
      res["targetIdentifier"] = boost::any(*targetIdentifier);
    }
    if (targetType) {
      res["targetType"] = boost::any(*targetType);
    }
    if (userIdentifier) {
      res["userIdentifier"] = boost::any(*userIdentifier);
    }
    if (userType) {
      res["userType"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("roleIdentifier") != m.end() && !m["roleIdentifier"].empty()) {
      roleIdentifier = make_shared<string>(boost::any_cast<string>(m["roleIdentifier"]));
    }
    if (m.find("targetIdentifier") != m.end() && !m["targetIdentifier"].empty()) {
      targetIdentifier = make_shared<string>(boost::any_cast<string>(m["targetIdentifier"]));
    }
    if (m.find("targetType") != m.end() && !m["targetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["targetType"]));
    }
    if (m.find("userIdentifier") != m.end() && !m["userIdentifier"].empty()) {
      userIdentifier = make_shared<string>(boost::any_cast<string>(m["userIdentifier"]));
    }
    if (m.find("userType") != m.end() && !m["userType"].empty()) {
      userType = make_shared<string>(boost::any_cast<string>(m["userType"]));
    }
  }


  virtual ~UpdateProjectMemberRequest() = default;
};
class UpdateProjectMemberResponseBodyMember : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> id{};
  shared_ptr<string> roleIdentifier{};
  shared_ptr<string> targetIdentifier{};
  shared_ptr<string> targetType{};
  shared_ptr<string> userIdentifier{};
  shared_ptr<string> userType{};

  UpdateProjectMemberResponseBodyMember() {}

  explicit UpdateProjectMemberResponseBodyMember(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (roleIdentifier) {
      res["roleIdentifier"] = boost::any(*roleIdentifier);
    }
    if (targetIdentifier) {
      res["targetIdentifier"] = boost::any(*targetIdentifier);
    }
    if (targetType) {
      res["targetType"] = boost::any(*targetType);
    }
    if (userIdentifier) {
      res["userIdentifier"] = boost::any(*userIdentifier);
    }
    if (userType) {
      res["userType"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("roleIdentifier") != m.end() && !m["roleIdentifier"].empty()) {
      roleIdentifier = make_shared<string>(boost::any_cast<string>(m["roleIdentifier"]));
    }
    if (m.find("targetIdentifier") != m.end() && !m["targetIdentifier"].empty()) {
      targetIdentifier = make_shared<string>(boost::any_cast<string>(m["targetIdentifier"]));
    }
    if (m.find("targetType") != m.end() && !m["targetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["targetType"]));
    }
    if (m.find("userIdentifier") != m.end() && !m["userIdentifier"].empty()) {
      userIdentifier = make_shared<string>(boost::any_cast<string>(m["userIdentifier"]));
    }
    if (m.find("userType") != m.end() && !m["userType"].empty()) {
      userType = make_shared<string>(boost::any_cast<string>(m["userType"]));
    }
  }


  virtual ~UpdateProjectMemberResponseBodyMember() = default;
};
class UpdateProjectMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<UpdateProjectMemberResponseBodyMember> member{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateProjectMemberResponseBody() {}

  explicit UpdateProjectMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (member) {
      res["member"] = member ? boost::any(member->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("member") != m.end() && !m["member"].empty()) {
      if (typeid(map<string, boost::any>) == m["member"].type()) {
        UpdateProjectMemberResponseBodyMember model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["member"]));
        member = make_shared<UpdateProjectMemberResponseBodyMember>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdateProjectMemberResponseBody() = default;
};
class UpdateProjectMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateProjectMemberResponseBody> body{};

  UpdateProjectMemberResponse() {}

  explicit UpdateProjectMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateProjectMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateProjectMemberResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateProjectMemberResponse() = default;
};
class UpdateProtectedBranchesRequestMergeRequestSetting : public Darabonba::Model {
public:
  shared_ptr<vector<long>> allowMergeRequestRoles{};
  shared_ptr<vector<string>> defaultAssignees{};
  shared_ptr<bool> isAllowSelfApproval{};
  shared_ptr<bool> isRequireDiscussionProcessed{};
  shared_ptr<bool> isRequired{};
  shared_ptr<bool> isResetApprovalWhenNewPush{};
  shared_ptr<long> minimumApproval{};
  shared_ptr<string> mrMode{};
  shared_ptr<string> whiteList{};

  UpdateProtectedBranchesRequestMergeRequestSetting() {}

  explicit UpdateProtectedBranchesRequestMergeRequestSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowMergeRequestRoles) {
      res["allowMergeRequestRoles"] = boost::any(*allowMergeRequestRoles);
    }
    if (defaultAssignees) {
      res["defaultAssignees"] = boost::any(*defaultAssignees);
    }
    if (isAllowSelfApproval) {
      res["isAllowSelfApproval"] = boost::any(*isAllowSelfApproval);
    }
    if (isRequireDiscussionProcessed) {
      res["isRequireDiscussionProcessed"] = boost::any(*isRequireDiscussionProcessed);
    }
    if (isRequired) {
      res["isRequired"] = boost::any(*isRequired);
    }
    if (isResetApprovalWhenNewPush) {
      res["isResetApprovalWhenNewPush"] = boost::any(*isResetApprovalWhenNewPush);
    }
    if (minimumApproval) {
      res["minimumApproval"] = boost::any(*minimumApproval);
    }
    if (mrMode) {
      res["mrMode"] = boost::any(*mrMode);
    }
    if (whiteList) {
      res["whiteList"] = boost::any(*whiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("allowMergeRequestRoles") != m.end() && !m["allowMergeRequestRoles"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["allowMergeRequestRoles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["allowMergeRequestRoles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      allowMergeRequestRoles = make_shared<vector<long>>(toVec1);
    }
    if (m.find("defaultAssignees") != m.end() && !m["defaultAssignees"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["defaultAssignees"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["defaultAssignees"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      defaultAssignees = make_shared<vector<string>>(toVec1);
    }
    if (m.find("isAllowSelfApproval") != m.end() && !m["isAllowSelfApproval"].empty()) {
      isAllowSelfApproval = make_shared<bool>(boost::any_cast<bool>(m["isAllowSelfApproval"]));
    }
    if (m.find("isRequireDiscussionProcessed") != m.end() && !m["isRequireDiscussionProcessed"].empty()) {
      isRequireDiscussionProcessed = make_shared<bool>(boost::any_cast<bool>(m["isRequireDiscussionProcessed"]));
    }
    if (m.find("isRequired") != m.end() && !m["isRequired"].empty()) {
      isRequired = make_shared<bool>(boost::any_cast<bool>(m["isRequired"]));
    }
    if (m.find("isResetApprovalWhenNewPush") != m.end() && !m["isResetApprovalWhenNewPush"].empty()) {
      isResetApprovalWhenNewPush = make_shared<bool>(boost::any_cast<bool>(m["isResetApprovalWhenNewPush"]));
    }
    if (m.find("minimumApproval") != m.end() && !m["minimumApproval"].empty()) {
      minimumApproval = make_shared<long>(boost::any_cast<long>(m["minimumApproval"]));
    }
    if (m.find("mrMode") != m.end() && !m["mrMode"].empty()) {
      mrMode = make_shared<string>(boost::any_cast<string>(m["mrMode"]));
    }
    if (m.find("whiteList") != m.end() && !m["whiteList"].empty()) {
      whiteList = make_shared<string>(boost::any_cast<string>(m["whiteList"]));
    }
  }


  virtual ~UpdateProtectedBranchesRequestMergeRequestSetting() = default;
};
class UpdateProtectedBranchesRequestTestSettingDTOCheckConfigCheckItems : public Darabonba::Model {
public:
  shared_ptr<bool> isRequired{};
  shared_ptr<string> name{};

  UpdateProtectedBranchesRequestTestSettingDTOCheckConfigCheckItems() {}

  explicit UpdateProtectedBranchesRequestTestSettingDTOCheckConfigCheckItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isRequired) {
      res["isRequired"] = boost::any(*isRequired);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("isRequired") != m.end() && !m["isRequired"].empty()) {
      isRequired = make_shared<bool>(boost::any_cast<bool>(m["isRequired"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~UpdateProtectedBranchesRequestTestSettingDTOCheckConfigCheckItems() = default;
};
class UpdateProtectedBranchesRequestTestSettingDTOCheckConfig : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateProtectedBranchesRequestTestSettingDTOCheckConfigCheckItems>> checkItems{};

  UpdateProtectedBranchesRequestTestSettingDTOCheckConfig() {}

  explicit UpdateProtectedBranchesRequestTestSettingDTOCheckConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkItems) {
      vector<boost::any> temp1;
      for(auto item1:*checkItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["checkItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("checkItems") != m.end() && !m["checkItems"].empty()) {
      if (typeid(vector<boost::any>) == m["checkItems"].type()) {
        vector<UpdateProtectedBranchesRequestTestSettingDTOCheckConfigCheckItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["checkItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateProtectedBranchesRequestTestSettingDTOCheckConfigCheckItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        checkItems = make_shared<vector<UpdateProtectedBranchesRequestTestSettingDTOCheckConfigCheckItems>>(expect1);
      }
    }
  }


  virtual ~UpdateProtectedBranchesRequestTestSettingDTOCheckConfig() = default;
};
class UpdateProtectedBranchesRequestTestSettingDTOCheckTaskQualityConfig : public Darabonba::Model {
public:
  shared_ptr<string> bizNo{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> message{};
  shared_ptr<string> taskName{};

  UpdateProtectedBranchesRequestTestSettingDTOCheckTaskQualityConfig() {}

  explicit UpdateProtectedBranchesRequestTestSettingDTOCheckTaskQualityConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizNo) {
      res["bizNo"] = boost::any(*bizNo);
    }
    if (enabled) {
      res["enabled"] = boost::any(*enabled);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (taskName) {
      res["taskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bizNo") != m.end() && !m["bizNo"].empty()) {
      bizNo = make_shared<string>(boost::any_cast<string>(m["bizNo"]));
    }
    if (m.find("enabled") != m.end() && !m["enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["enabled"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("taskName") != m.end() && !m["taskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["taskName"]));
    }
  }


  virtual ~UpdateProtectedBranchesRequestTestSettingDTOCheckTaskQualityConfig() = default;
};
class UpdateProtectedBranchesRequestTestSettingDTOCodeGuidelinesDetection : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<string> message{};

  UpdateProtectedBranchesRequestTestSettingDTOCodeGuidelinesDetection() {}

  explicit UpdateProtectedBranchesRequestTestSettingDTOCodeGuidelinesDetection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["enabled"] = boost::any(*enabled);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enabled") != m.end() && !m["enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["enabled"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
  }


  virtual ~UpdateProtectedBranchesRequestTestSettingDTOCodeGuidelinesDetection() = default;
};
class UpdateProtectedBranchesRequestTestSettingDTOSensitiveInfoDetection : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<string> message{};

  UpdateProtectedBranchesRequestTestSettingDTOSensitiveInfoDetection() {}

  explicit UpdateProtectedBranchesRequestTestSettingDTOSensitiveInfoDetection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["enabled"] = boost::any(*enabled);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enabled") != m.end() && !m["enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["enabled"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
  }


  virtual ~UpdateProtectedBranchesRequestTestSettingDTOSensitiveInfoDetection() = default;
};
class UpdateProtectedBranchesRequestTestSettingDTO : public Darabonba::Model {
public:
  shared_ptr<UpdateProtectedBranchesRequestTestSettingDTOCheckConfig> checkConfig{};
  shared_ptr<UpdateProtectedBranchesRequestTestSettingDTOCheckTaskQualityConfig> checkTaskQualityConfig{};
  shared_ptr<UpdateProtectedBranchesRequestTestSettingDTOCodeGuidelinesDetection> codeGuidelinesDetection{};
  shared_ptr<bool> isRequired{};
  shared_ptr<UpdateProtectedBranchesRequestTestSettingDTOSensitiveInfoDetection> sensitiveInfoDetection{};

  UpdateProtectedBranchesRequestTestSettingDTO() {}

  explicit UpdateProtectedBranchesRequestTestSettingDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkConfig) {
      res["checkConfig"] = checkConfig ? boost::any(checkConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (checkTaskQualityConfig) {
      res["checkTaskQualityConfig"] = checkTaskQualityConfig ? boost::any(checkTaskQualityConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (codeGuidelinesDetection) {
      res["codeGuidelinesDetection"] = codeGuidelinesDetection ? boost::any(codeGuidelinesDetection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isRequired) {
      res["isRequired"] = boost::any(*isRequired);
    }
    if (sensitiveInfoDetection) {
      res["sensitiveInfoDetection"] = sensitiveInfoDetection ? boost::any(sensitiveInfoDetection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("checkConfig") != m.end() && !m["checkConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["checkConfig"].type()) {
        UpdateProtectedBranchesRequestTestSettingDTOCheckConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["checkConfig"]));
        checkConfig = make_shared<UpdateProtectedBranchesRequestTestSettingDTOCheckConfig>(model1);
      }
    }
    if (m.find("checkTaskQualityConfig") != m.end() && !m["checkTaskQualityConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["checkTaskQualityConfig"].type()) {
        UpdateProtectedBranchesRequestTestSettingDTOCheckTaskQualityConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["checkTaskQualityConfig"]));
        checkTaskQualityConfig = make_shared<UpdateProtectedBranchesRequestTestSettingDTOCheckTaskQualityConfig>(model1);
      }
    }
    if (m.find("codeGuidelinesDetection") != m.end() && !m["codeGuidelinesDetection"].empty()) {
      if (typeid(map<string, boost::any>) == m["codeGuidelinesDetection"].type()) {
        UpdateProtectedBranchesRequestTestSettingDTOCodeGuidelinesDetection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["codeGuidelinesDetection"]));
        codeGuidelinesDetection = make_shared<UpdateProtectedBranchesRequestTestSettingDTOCodeGuidelinesDetection>(model1);
      }
    }
    if (m.find("isRequired") != m.end() && !m["isRequired"].empty()) {
      isRequired = make_shared<bool>(boost::any_cast<bool>(m["isRequired"]));
    }
    if (m.find("sensitiveInfoDetection") != m.end() && !m["sensitiveInfoDetection"].empty()) {
      if (typeid(map<string, boost::any>) == m["sensitiveInfoDetection"].type()) {
        UpdateProtectedBranchesRequestTestSettingDTOSensitiveInfoDetection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["sensitiveInfoDetection"]));
        sensitiveInfoDetection = make_shared<UpdateProtectedBranchesRequestTestSettingDTOSensitiveInfoDetection>(model1);
      }
    }
  }


  virtual ~UpdateProtectedBranchesRequestTestSettingDTO() = default;
};
class UpdateProtectedBranchesRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<vector<long>> allowMergeRoles{};
  shared_ptr<vector<string>> allowMergeUserIds{};
  shared_ptr<vector<long>> allowPushRoles{};
  shared_ptr<vector<string>> allowPushUserIds{};
  shared_ptr<string> branch{};
  shared_ptr<long> id{};
  shared_ptr<UpdateProtectedBranchesRequestMergeRequestSetting> mergeRequestSetting{};
  shared_ptr<UpdateProtectedBranchesRequestTestSettingDTO> testSettingDTO{};
  shared_ptr<string> organizationId{};

  UpdateProtectedBranchesRequest() {}

  explicit UpdateProtectedBranchesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (allowMergeRoles) {
      res["allowMergeRoles"] = boost::any(*allowMergeRoles);
    }
    if (allowMergeUserIds) {
      res["allowMergeUserIds"] = boost::any(*allowMergeUserIds);
    }
    if (allowPushRoles) {
      res["allowPushRoles"] = boost::any(*allowPushRoles);
    }
    if (allowPushUserIds) {
      res["allowPushUserIds"] = boost::any(*allowPushUserIds);
    }
    if (branch) {
      res["branch"] = boost::any(*branch);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (mergeRequestSetting) {
      res["mergeRequestSetting"] = mergeRequestSetting ? boost::any(mergeRequestSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (testSettingDTO) {
      res["testSettingDTO"] = testSettingDTO ? boost::any(testSettingDTO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("allowMergeRoles") != m.end() && !m["allowMergeRoles"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["allowMergeRoles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["allowMergeRoles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      allowMergeRoles = make_shared<vector<long>>(toVec1);
    }
    if (m.find("allowMergeUserIds") != m.end() && !m["allowMergeUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["allowMergeUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["allowMergeUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      allowMergeUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("allowPushRoles") != m.end() && !m["allowPushRoles"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["allowPushRoles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["allowPushRoles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      allowPushRoles = make_shared<vector<long>>(toVec1);
    }
    if (m.find("allowPushUserIds") != m.end() && !m["allowPushUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["allowPushUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["allowPushUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      allowPushUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("branch") != m.end() && !m["branch"].empty()) {
      branch = make_shared<string>(boost::any_cast<string>(m["branch"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("mergeRequestSetting") != m.end() && !m["mergeRequestSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["mergeRequestSetting"].type()) {
        UpdateProtectedBranchesRequestMergeRequestSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["mergeRequestSetting"]));
        mergeRequestSetting = make_shared<UpdateProtectedBranchesRequestMergeRequestSetting>(model1);
      }
    }
    if (m.find("testSettingDTO") != m.end() && !m["testSettingDTO"].empty()) {
      if (typeid(map<string, boost::any>) == m["testSettingDTO"].type()) {
        UpdateProtectedBranchesRequestTestSettingDTO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["testSettingDTO"]));
        testSettingDTO = make_shared<UpdateProtectedBranchesRequestTestSettingDTO>(model1);
      }
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~UpdateProtectedBranchesRequest() = default;
};
class UpdateProtectedBranchesResponseBodyResultMergeRequestSetting : public Darabonba::Model {
public:
  shared_ptr<vector<long>> allowMergeRequestRoles{};
  shared_ptr<vector<string>> defaultAssignees{};
  shared_ptr<bool> isAllowSelfApproval{};
  shared_ptr<bool> isRequireDiscussionProcessed{};
  shared_ptr<bool> isRequired{};
  shared_ptr<bool> isResetApprovalWhenNewPush{};
  shared_ptr<long> minimumApproval{};
  shared_ptr<string> mrMode{};
  shared_ptr<string> whiteList{};

  UpdateProtectedBranchesResponseBodyResultMergeRequestSetting() {}

  explicit UpdateProtectedBranchesResponseBodyResultMergeRequestSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowMergeRequestRoles) {
      res["allowMergeRequestRoles"] = boost::any(*allowMergeRequestRoles);
    }
    if (defaultAssignees) {
      res["defaultAssignees"] = boost::any(*defaultAssignees);
    }
    if (isAllowSelfApproval) {
      res["isAllowSelfApproval"] = boost::any(*isAllowSelfApproval);
    }
    if (isRequireDiscussionProcessed) {
      res["isRequireDiscussionProcessed"] = boost::any(*isRequireDiscussionProcessed);
    }
    if (isRequired) {
      res["isRequired"] = boost::any(*isRequired);
    }
    if (isResetApprovalWhenNewPush) {
      res["isResetApprovalWhenNewPush"] = boost::any(*isResetApprovalWhenNewPush);
    }
    if (minimumApproval) {
      res["minimumApproval"] = boost::any(*minimumApproval);
    }
    if (mrMode) {
      res["mrMode"] = boost::any(*mrMode);
    }
    if (whiteList) {
      res["whiteList"] = boost::any(*whiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("allowMergeRequestRoles") != m.end() && !m["allowMergeRequestRoles"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["allowMergeRequestRoles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["allowMergeRequestRoles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      allowMergeRequestRoles = make_shared<vector<long>>(toVec1);
    }
    if (m.find("defaultAssignees") != m.end() && !m["defaultAssignees"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["defaultAssignees"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["defaultAssignees"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      defaultAssignees = make_shared<vector<string>>(toVec1);
    }
    if (m.find("isAllowSelfApproval") != m.end() && !m["isAllowSelfApproval"].empty()) {
      isAllowSelfApproval = make_shared<bool>(boost::any_cast<bool>(m["isAllowSelfApproval"]));
    }
    if (m.find("isRequireDiscussionProcessed") != m.end() && !m["isRequireDiscussionProcessed"].empty()) {
      isRequireDiscussionProcessed = make_shared<bool>(boost::any_cast<bool>(m["isRequireDiscussionProcessed"]));
    }
    if (m.find("isRequired") != m.end() && !m["isRequired"].empty()) {
      isRequired = make_shared<bool>(boost::any_cast<bool>(m["isRequired"]));
    }
    if (m.find("isResetApprovalWhenNewPush") != m.end() && !m["isResetApprovalWhenNewPush"].empty()) {
      isResetApprovalWhenNewPush = make_shared<bool>(boost::any_cast<bool>(m["isResetApprovalWhenNewPush"]));
    }
    if (m.find("minimumApproval") != m.end() && !m["minimumApproval"].empty()) {
      minimumApproval = make_shared<long>(boost::any_cast<long>(m["minimumApproval"]));
    }
    if (m.find("mrMode") != m.end() && !m["mrMode"].empty()) {
      mrMode = make_shared<string>(boost::any_cast<string>(m["mrMode"]));
    }
    if (m.find("whiteList") != m.end() && !m["whiteList"].empty()) {
      whiteList = make_shared<string>(boost::any_cast<string>(m["whiteList"]));
    }
  }


  virtual ~UpdateProtectedBranchesResponseBodyResultMergeRequestSetting() = default;
};
class UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems : public Darabonba::Model {
public:
  shared_ptr<bool> isRequired{};
  shared_ptr<string> name{};

  UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems() {}

  explicit UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isRequired) {
      res["isRequired"] = boost::any(*isRequired);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("isRequired") != m.end() && !m["isRequired"].empty()) {
      isRequired = make_shared<bool>(boost::any_cast<bool>(m["isRequired"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems() = default;
};
class UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems>> checkItems{};

  UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig() {}

  explicit UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkItems) {
      vector<boost::any> temp1;
      for(auto item1:*checkItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["checkItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("checkItems") != m.end() && !m["checkItems"].empty()) {
      if (typeid(vector<boost::any>) == m["checkItems"].type()) {
        vector<UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["checkItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        checkItems = make_shared<vector<UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems>>(expect1);
      }
    }
  }


  virtual ~UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig() = default;
};
class UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig : public Darabonba::Model {
public:
  shared_ptr<string> bizNo{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> message{};
  shared_ptr<string> taskName{};

  UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig() {}

  explicit UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizNo) {
      res["bizNo"] = boost::any(*bizNo);
    }
    if (enabled) {
      res["enabled"] = boost::any(*enabled);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (taskName) {
      res["taskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bizNo") != m.end() && !m["bizNo"].empty()) {
      bizNo = make_shared<string>(boost::any_cast<string>(m["bizNo"]));
    }
    if (m.find("enabled") != m.end() && !m["enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["enabled"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("taskName") != m.end() && !m["taskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["taskName"]));
    }
  }


  virtual ~UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig() = default;
};
class UpdateProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<string> message{};

  UpdateProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection() {}

  explicit UpdateProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["enabled"] = boost::any(*enabled);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enabled") != m.end() && !m["enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["enabled"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
  }


  virtual ~UpdateProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection() = default;
};
class UpdateProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<string> message{};

  UpdateProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection() {}

  explicit UpdateProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["enabled"] = boost::any(*enabled);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enabled") != m.end() && !m["enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["enabled"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
  }


  virtual ~UpdateProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection() = default;
};
class UpdateProtectedBranchesResponseBodyResultTestSettingDTO : public Darabonba::Model {
public:
  shared_ptr<UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig> checkConfig{};
  shared_ptr<UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig> checkTaskQualityConfig{};
  shared_ptr<UpdateProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection> codeGuidelinesDetection{};
  shared_ptr<bool> isRequired{};
  shared_ptr<UpdateProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection> sensitiveInfoDetection{};

  UpdateProtectedBranchesResponseBodyResultTestSettingDTO() {}

  explicit UpdateProtectedBranchesResponseBodyResultTestSettingDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkConfig) {
      res["checkConfig"] = checkConfig ? boost::any(checkConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (checkTaskQualityConfig) {
      res["checkTaskQualityConfig"] = checkTaskQualityConfig ? boost::any(checkTaskQualityConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (codeGuidelinesDetection) {
      res["codeGuidelinesDetection"] = codeGuidelinesDetection ? boost::any(codeGuidelinesDetection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isRequired) {
      res["isRequired"] = boost::any(*isRequired);
    }
    if (sensitiveInfoDetection) {
      res["sensitiveInfoDetection"] = sensitiveInfoDetection ? boost::any(sensitiveInfoDetection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("checkConfig") != m.end() && !m["checkConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["checkConfig"].type()) {
        UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["checkConfig"]));
        checkConfig = make_shared<UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig>(model1);
      }
    }
    if (m.find("checkTaskQualityConfig") != m.end() && !m["checkTaskQualityConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["checkTaskQualityConfig"].type()) {
        UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["checkTaskQualityConfig"]));
        checkTaskQualityConfig = make_shared<UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig>(model1);
      }
    }
    if (m.find("codeGuidelinesDetection") != m.end() && !m["codeGuidelinesDetection"].empty()) {
      if (typeid(map<string, boost::any>) == m["codeGuidelinesDetection"].type()) {
        UpdateProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["codeGuidelinesDetection"]));
        codeGuidelinesDetection = make_shared<UpdateProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection>(model1);
      }
    }
    if (m.find("isRequired") != m.end() && !m["isRequired"].empty()) {
      isRequired = make_shared<bool>(boost::any_cast<bool>(m["isRequired"]));
    }
    if (m.find("sensitiveInfoDetection") != m.end() && !m["sensitiveInfoDetection"].empty()) {
      if (typeid(map<string, boost::any>) == m["sensitiveInfoDetection"].type()) {
        UpdateProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["sensitiveInfoDetection"]));
        sensitiveInfoDetection = make_shared<UpdateProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection>(model1);
      }
    }
  }


  virtual ~UpdateProtectedBranchesResponseBodyResultTestSettingDTO() = default;
};
class UpdateProtectedBranchesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<long>> allowMergeRoles{};
  shared_ptr<vector<long>> allowMergeUserIds{};
  shared_ptr<vector<long>> allowPushRoles{};
  shared_ptr<vector<long>> allowPushUserIds{};
  shared_ptr<string> branch{};
  shared_ptr<long> id{};
  shared_ptr<UpdateProtectedBranchesResponseBodyResultMergeRequestSetting> mergeRequestSetting{};
  shared_ptr<UpdateProtectedBranchesResponseBodyResultTestSettingDTO> testSettingDTO{};

  UpdateProtectedBranchesResponseBodyResult() {}

  explicit UpdateProtectedBranchesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowMergeRoles) {
      res["allowMergeRoles"] = boost::any(*allowMergeRoles);
    }
    if (allowMergeUserIds) {
      res["allowMergeUserIds"] = boost::any(*allowMergeUserIds);
    }
    if (allowPushRoles) {
      res["allowPushRoles"] = boost::any(*allowPushRoles);
    }
    if (allowPushUserIds) {
      res["allowPushUserIds"] = boost::any(*allowPushUserIds);
    }
    if (branch) {
      res["branch"] = boost::any(*branch);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (mergeRequestSetting) {
      res["mergeRequestSetting"] = mergeRequestSetting ? boost::any(mergeRequestSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (testSettingDTO) {
      res["testSettingDTO"] = testSettingDTO ? boost::any(testSettingDTO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("allowMergeRoles") != m.end() && !m["allowMergeRoles"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["allowMergeRoles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["allowMergeRoles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      allowMergeRoles = make_shared<vector<long>>(toVec1);
    }
    if (m.find("allowMergeUserIds") != m.end() && !m["allowMergeUserIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["allowMergeUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["allowMergeUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      allowMergeUserIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("allowPushRoles") != m.end() && !m["allowPushRoles"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["allowPushRoles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["allowPushRoles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      allowPushRoles = make_shared<vector<long>>(toVec1);
    }
    if (m.find("allowPushUserIds") != m.end() && !m["allowPushUserIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["allowPushUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["allowPushUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      allowPushUserIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("branch") != m.end() && !m["branch"].empty()) {
      branch = make_shared<string>(boost::any_cast<string>(m["branch"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("mergeRequestSetting") != m.end() && !m["mergeRequestSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["mergeRequestSetting"].type()) {
        UpdateProtectedBranchesResponseBodyResultMergeRequestSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["mergeRequestSetting"]));
        mergeRequestSetting = make_shared<UpdateProtectedBranchesResponseBodyResultMergeRequestSetting>(model1);
      }
    }
    if (m.find("testSettingDTO") != m.end() && !m["testSettingDTO"].empty()) {
      if (typeid(map<string, boost::any>) == m["testSettingDTO"].type()) {
        UpdateProtectedBranchesResponseBodyResultTestSettingDTO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["testSettingDTO"]));
        testSettingDTO = make_shared<UpdateProtectedBranchesResponseBodyResultTestSettingDTO>(model1);
      }
    }
  }


  virtual ~UpdateProtectedBranchesResponseBodyResult() = default;
};
class UpdateProtectedBranchesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<UpdateProtectedBranchesResponseBodyResult> result{};
  shared_ptr<bool> success{};

  UpdateProtectedBranchesResponseBody() {}

  explicit UpdateProtectedBranchesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        UpdateProtectedBranchesResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<UpdateProtectedBranchesResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdateProtectedBranchesResponseBody() = default;
};
class UpdateProtectedBranchesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateProtectedBranchesResponseBody> body{};

  UpdateProtectedBranchesResponse() {}

  explicit UpdateProtectedBranchesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateProtectedBranchesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateProtectedBranchesResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateProtectedBranchesResponse() = default;
};
class UpdatePushReviewOnOffRequest : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};
  shared_ptr<bool> trunkMode{};

  UpdatePushReviewOnOffRequest() {}

  explicit UpdatePushReviewOnOffRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    if (trunkMode) {
      res["trunkMode"] = boost::any(*trunkMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
    if (m.find("trunkMode") != m.end() && !m["trunkMode"].empty()) {
      trunkMode = make_shared<bool>(boost::any_cast<bool>(m["trunkMode"]));
    }
  }


  virtual ~UpdatePushReviewOnOffRequest() = default;
};
class UpdatePushReviewOnOffResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> result{};

  UpdatePushReviewOnOffResponseBodyResult() {}

  explicit UpdatePushReviewOnOffResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~UpdatePushReviewOnOffResponseBodyResult() = default;
};
class UpdatePushReviewOnOffResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<UpdatePushReviewOnOffResponseBodyResult> result{};
  shared_ptr<bool> success{};

  UpdatePushReviewOnOffResponseBody() {}

  explicit UpdatePushReviewOnOffResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        UpdatePushReviewOnOffResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<UpdatePushReviewOnOffResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdatePushReviewOnOffResponseBody() = default;
};
class UpdatePushReviewOnOffResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePushReviewOnOffResponseBody> body{};

  UpdatePushReviewOnOffResponse() {}

  explicit UpdatePushReviewOnOffResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePushReviewOnOffResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePushReviewOnOffResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePushReviewOnOffResponse() = default;
};
class UpdatePushRuleRequestRuleInfos : public Darabonba::Model {
public:
  shared_ptr<string> checkerName{};
  shared_ptr<string> checkerType{};
  shared_ptr<string> extraMessage{};
  shared_ptr<vector<string>> fileRuleRegexes{};

  UpdatePushRuleRequestRuleInfos() {}

  explicit UpdatePushRuleRequestRuleInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkerName) {
      res["checkerName"] = boost::any(*checkerName);
    }
    if (checkerType) {
      res["checkerType"] = boost::any(*checkerType);
    }
    if (extraMessage) {
      res["extraMessage"] = boost::any(*extraMessage);
    }
    if (fileRuleRegexes) {
      res["fileRuleRegexes"] = boost::any(*fileRuleRegexes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("checkerName") != m.end() && !m["checkerName"].empty()) {
      checkerName = make_shared<string>(boost::any_cast<string>(m["checkerName"]));
    }
    if (m.find("checkerType") != m.end() && !m["checkerType"].empty()) {
      checkerType = make_shared<string>(boost::any_cast<string>(m["checkerType"]));
    }
    if (m.find("extraMessage") != m.end() && !m["extraMessage"].empty()) {
      extraMessage = make_shared<string>(boost::any_cast<string>(m["extraMessage"]));
    }
    if (m.find("fileRuleRegexes") != m.end() && !m["fileRuleRegexes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["fileRuleRegexes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["fileRuleRegexes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fileRuleRegexes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdatePushRuleRequestRuleInfos() = default;
};
class UpdatePushRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<vector<UpdatePushRuleRequestRuleInfos>> ruleInfos{};
  shared_ptr<string> organizationId{};

  UpdatePushRuleRequest() {}

  explicit UpdatePushRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (ruleInfos) {
      vector<boost::any> temp1;
      for(auto item1:*ruleInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ruleInfos"] = boost::any(temp1);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("ruleInfos") != m.end() && !m["ruleInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["ruleInfos"].type()) {
        vector<UpdatePushRuleRequestRuleInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ruleInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdatePushRuleRequestRuleInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleInfos = make_shared<vector<UpdatePushRuleRequestRuleInfos>>(expect1);
      }
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~UpdatePushRuleRequest() = default;
};
class UpdatePushRuleResponseBodyResultRuleInfos : public Darabonba::Model {
public:
  shared_ptr<string> checkerName{};
  shared_ptr<string> checkerType{};
  shared_ptr<string> extraMessage{};
  shared_ptr<vector<string>> fileRuleRegexes{};

  UpdatePushRuleResponseBodyResultRuleInfos() {}

  explicit UpdatePushRuleResponseBodyResultRuleInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkerName) {
      res["checkerName"] = boost::any(*checkerName);
    }
    if (checkerType) {
      res["checkerType"] = boost::any(*checkerType);
    }
    if (extraMessage) {
      res["extraMessage"] = boost::any(*extraMessage);
    }
    if (fileRuleRegexes) {
      res["fileRuleRegexes"] = boost::any(*fileRuleRegexes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("checkerName") != m.end() && !m["checkerName"].empty()) {
      checkerName = make_shared<string>(boost::any_cast<string>(m["checkerName"]));
    }
    if (m.find("checkerType") != m.end() && !m["checkerType"].empty()) {
      checkerType = make_shared<string>(boost::any_cast<string>(m["checkerType"]));
    }
    if (m.find("extraMessage") != m.end() && !m["extraMessage"].empty()) {
      extraMessage = make_shared<string>(boost::any_cast<string>(m["extraMessage"]));
    }
    if (m.find("fileRuleRegexes") != m.end() && !m["fileRuleRegexes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["fileRuleRegexes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["fileRuleRegexes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fileRuleRegexes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdatePushRuleResponseBodyResultRuleInfos() = default;
};
class UpdatePushRuleResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<vector<UpdatePushRuleResponseBodyResultRuleInfos>> ruleInfos{};

  UpdatePushRuleResponseBodyResult() {}

  explicit UpdatePushRuleResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (ruleInfos) {
      vector<boost::any> temp1;
      for(auto item1:*ruleInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ruleInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmtModified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("ruleInfos") != m.end() && !m["ruleInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["ruleInfos"].type()) {
        vector<UpdatePushRuleResponseBodyResultRuleInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ruleInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdatePushRuleResponseBodyResultRuleInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleInfos = make_shared<vector<UpdatePushRuleResponseBodyResultRuleInfos>>(expect1);
      }
    }
  }


  virtual ~UpdatePushRuleResponseBodyResult() = default;
};
class UpdatePushRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<UpdatePushRuleResponseBodyResult> result{};
  shared_ptr<bool> success{};

  UpdatePushRuleResponseBody() {}

  explicit UpdatePushRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        UpdatePushRuleResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<UpdatePushRuleResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdatePushRuleResponseBody() = default;
};
class UpdatePushRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePushRuleResponseBody> body{};

  UpdatePushRuleResponse() {}

  explicit UpdatePushRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePushRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePushRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePushRuleResponse() = default;
};
class UpdateRepositoryRequestProjectCloneDownloadMethodList : public Darabonba::Model {
public:
  shared_ptr<bool> allowed{};
  shared_ptr<string> permissionCode{};

  UpdateRepositoryRequestProjectCloneDownloadMethodList() {}

  explicit UpdateRepositoryRequestProjectCloneDownloadMethodList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowed) {
      res["allowed"] = boost::any(*allowed);
    }
    if (permissionCode) {
      res["permissionCode"] = boost::any(*permissionCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("allowed") != m.end() && !m["allowed"].empty()) {
      allowed = make_shared<bool>(boost::any_cast<bool>(m["allowed"]));
    }
    if (m.find("permissionCode") != m.end() && !m["permissionCode"].empty()) {
      permissionCode = make_shared<string>(boost::any_cast<string>(m["permissionCode"]));
    }
  }


  virtual ~UpdateRepositoryRequestProjectCloneDownloadMethodList() = default;
};
class UpdateRepositoryRequestProjectCloneDownloadRoleList : public Darabonba::Model {
public:
  shared_ptr<bool> allowed{};
  shared_ptr<long> roleCode{};

  UpdateRepositoryRequestProjectCloneDownloadRoleList() {}

  explicit UpdateRepositoryRequestProjectCloneDownloadRoleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowed) {
      res["allowed"] = boost::any(*allowed);
    }
    if (roleCode) {
      res["roleCode"] = boost::any(*roleCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("allowed") != m.end() && !m["allowed"].empty()) {
      allowed = make_shared<bool>(boost::any_cast<bool>(m["allowed"]));
    }
    if (m.find("roleCode") != m.end() && !m["roleCode"].empty()) {
      roleCode = make_shared<long>(boost::any_cast<long>(m["roleCode"]));
    }
  }


  virtual ~UpdateRepositoryRequestProjectCloneDownloadRoleList() = default;
};
class UpdateRepositoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> adminSettingLanguage{};
  shared_ptr<string> avatar{};
  shared_ptr<bool> buildsEnabled{};
  shared_ptr<bool> checkEmail{};
  shared_ptr<string> defaultBranch{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<bool> issuesEnabled{};
  shared_ptr<bool> mergeRequestsEnabled{};
  shared_ptr<string> name{};
  shared_ptr<bool> openCloneDownloadControl{};
  shared_ptr<string> path{};
  shared_ptr<vector<UpdateRepositoryRequestProjectCloneDownloadMethodList>> projectCloneDownloadMethodList{};
  shared_ptr<vector<UpdateRepositoryRequestProjectCloneDownloadRoleList>> projectCloneDownloadRoleList{};
  shared_ptr<bool> snippetsEnabled{};
  shared_ptr<long> visibilityLevel{};
  shared_ptr<bool> wikiEnabled{};
  shared_ptr<string> organizationId{};

  UpdateRepositoryRequest() {}

  explicit UpdateRepositoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (adminSettingLanguage) {
      res["adminSettingLanguage"] = boost::any(*adminSettingLanguage);
    }
    if (avatar) {
      res["avatar"] = boost::any(*avatar);
    }
    if (buildsEnabled) {
      res["buildsEnabled"] = boost::any(*buildsEnabled);
    }
    if (checkEmail) {
      res["checkEmail"] = boost::any(*checkEmail);
    }
    if (defaultBranch) {
      res["defaultBranch"] = boost::any(*defaultBranch);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (issuesEnabled) {
      res["issuesEnabled"] = boost::any(*issuesEnabled);
    }
    if (mergeRequestsEnabled) {
      res["mergeRequestsEnabled"] = boost::any(*mergeRequestsEnabled);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (openCloneDownloadControl) {
      res["openCloneDownloadControl"] = boost::any(*openCloneDownloadControl);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (projectCloneDownloadMethodList) {
      vector<boost::any> temp1;
      for(auto item1:*projectCloneDownloadMethodList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["projectCloneDownloadMethodList"] = boost::any(temp1);
    }
    if (projectCloneDownloadRoleList) {
      vector<boost::any> temp1;
      for(auto item1:*projectCloneDownloadRoleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["projectCloneDownloadRoleList"] = boost::any(temp1);
    }
    if (snippetsEnabled) {
      res["snippetsEnabled"] = boost::any(*snippetsEnabled);
    }
    if (visibilityLevel) {
      res["visibilityLevel"] = boost::any(*visibilityLevel);
    }
    if (wikiEnabled) {
      res["wikiEnabled"] = boost::any(*wikiEnabled);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("adminSettingLanguage") != m.end() && !m["adminSettingLanguage"].empty()) {
      adminSettingLanguage = make_shared<string>(boost::any_cast<string>(m["adminSettingLanguage"]));
    }
    if (m.find("avatar") != m.end() && !m["avatar"].empty()) {
      avatar = make_shared<string>(boost::any_cast<string>(m["avatar"]));
    }
    if (m.find("buildsEnabled") != m.end() && !m["buildsEnabled"].empty()) {
      buildsEnabled = make_shared<bool>(boost::any_cast<bool>(m["buildsEnabled"]));
    }
    if (m.find("checkEmail") != m.end() && !m["checkEmail"].empty()) {
      checkEmail = make_shared<bool>(boost::any_cast<bool>(m["checkEmail"]));
    }
    if (m.find("defaultBranch") != m.end() && !m["defaultBranch"].empty()) {
      defaultBranch = make_shared<string>(boost::any_cast<string>(m["defaultBranch"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("issuesEnabled") != m.end() && !m["issuesEnabled"].empty()) {
      issuesEnabled = make_shared<bool>(boost::any_cast<bool>(m["issuesEnabled"]));
    }
    if (m.find("mergeRequestsEnabled") != m.end() && !m["mergeRequestsEnabled"].empty()) {
      mergeRequestsEnabled = make_shared<bool>(boost::any_cast<bool>(m["mergeRequestsEnabled"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("openCloneDownloadControl") != m.end() && !m["openCloneDownloadControl"].empty()) {
      openCloneDownloadControl = make_shared<bool>(boost::any_cast<bool>(m["openCloneDownloadControl"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("projectCloneDownloadMethodList") != m.end() && !m["projectCloneDownloadMethodList"].empty()) {
      if (typeid(vector<boost::any>) == m["projectCloneDownloadMethodList"].type()) {
        vector<UpdateRepositoryRequestProjectCloneDownloadMethodList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["projectCloneDownloadMethodList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateRepositoryRequestProjectCloneDownloadMethodList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        projectCloneDownloadMethodList = make_shared<vector<UpdateRepositoryRequestProjectCloneDownloadMethodList>>(expect1);
      }
    }
    if (m.find("projectCloneDownloadRoleList") != m.end() && !m["projectCloneDownloadRoleList"].empty()) {
      if (typeid(vector<boost::any>) == m["projectCloneDownloadRoleList"].type()) {
        vector<UpdateRepositoryRequestProjectCloneDownloadRoleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["projectCloneDownloadRoleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateRepositoryRequestProjectCloneDownloadRoleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        projectCloneDownloadRoleList = make_shared<vector<UpdateRepositoryRequestProjectCloneDownloadRoleList>>(expect1);
      }
    }
    if (m.find("snippetsEnabled") != m.end() && !m["snippetsEnabled"].empty()) {
      snippetsEnabled = make_shared<bool>(boost::any_cast<bool>(m["snippetsEnabled"]));
    }
    if (m.find("visibilityLevel") != m.end() && !m["visibilityLevel"].empty()) {
      visibilityLevel = make_shared<long>(boost::any_cast<long>(m["visibilityLevel"]));
    }
    if (m.find("wikiEnabled") != m.end() && !m["wikiEnabled"].empty()) {
      wikiEnabled = make_shared<bool>(boost::any_cast<bool>(m["wikiEnabled"]));
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~UpdateRepositoryRequest() = default;
};
class UpdateRepositoryResponseBodyResultNamespace : public Darabonba::Model {
public:
  shared_ptr<string> avatar{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> path{};
  shared_ptr<string> updatedAt{};
  shared_ptr<long> visibilityLevel{};

  UpdateRepositoryResponseBodyResultNamespace() {}

  explicit UpdateRepositoryResponseBodyResultNamespace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatar) {
      res["avatar"] = boost::any(*avatar);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (ownerId) {
      res["ownerId"] = boost::any(*ownerId);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (updatedAt) {
      res["updatedAt"] = boost::any(*updatedAt);
    }
    if (visibilityLevel) {
      res["visibilityLevel"] = boost::any(*visibilityLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avatar") != m.end() && !m["avatar"].empty()) {
      avatar = make_shared<string>(boost::any_cast<string>(m["avatar"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("ownerId") != m.end() && !m["ownerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["ownerId"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("updatedAt") != m.end() && !m["updatedAt"].empty()) {
      updatedAt = make_shared<string>(boost::any_cast<string>(m["updatedAt"]));
    }
    if (m.find("visibilityLevel") != m.end() && !m["visibilityLevel"].empty()) {
      visibilityLevel = make_shared<long>(boost::any_cast<long>(m["visibilityLevel"]));
    }
  }


  virtual ~UpdateRepositoryResponseBodyResultNamespace() = default;
};
class UpdateRepositoryResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> archived{};
  shared_ptr<string> avatarUrl{};
  shared_ptr<bool> buildsEnabled{};
  shared_ptr<string> createdAt{};
  shared_ptr<long> creatorId{};
  shared_ptr<string> defaultBranch{};
  shared_ptr<string> description{};
  shared_ptr<string> httpUrlToRepo{};
  shared_ptr<long> id{};
  shared_ptr<bool> issuesEnabled{};
  shared_ptr<string> lastActivityAt{};
  shared_ptr<bool> mergeRequestsEnabled{};
  shared_ptr<string> name{};
  shared_ptr<string> nameWithNamespace{};
  shared_ptr<UpdateRepositoryResponseBodyResultNamespace> namespace_{};
  shared_ptr<string> path{};
  shared_ptr<string> pathWithNamespace{};
  shared_ptr<bool> snippetsEnabled{};
  shared_ptr<string> sshUrlToRepo{};
  shared_ptr<long> visibilityLevel{};
  shared_ptr<string> webUrl{};
  shared_ptr<bool> wikiEnabled{};

  UpdateRepositoryResponseBodyResult() {}

  explicit UpdateRepositoryResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (archived) {
      res["archived"] = boost::any(*archived);
    }
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (buildsEnabled) {
      res["buildsEnabled"] = boost::any(*buildsEnabled);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (creatorId) {
      res["creatorId"] = boost::any(*creatorId);
    }
    if (defaultBranch) {
      res["defaultBranch"] = boost::any(*defaultBranch);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (httpUrlToRepo) {
      res["httpUrlToRepo"] = boost::any(*httpUrlToRepo);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (issuesEnabled) {
      res["issuesEnabled"] = boost::any(*issuesEnabled);
    }
    if (lastActivityAt) {
      res["lastActivityAt"] = boost::any(*lastActivityAt);
    }
    if (mergeRequestsEnabled) {
      res["mergeRequestsEnabled"] = boost::any(*mergeRequestsEnabled);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nameWithNamespace) {
      res["nameWithNamespace"] = boost::any(*nameWithNamespace);
    }
    if (namespace_) {
      res["namespace"] = namespace_ ? boost::any(namespace_->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (pathWithNamespace) {
      res["pathWithNamespace"] = boost::any(*pathWithNamespace);
    }
    if (snippetsEnabled) {
      res["snippetsEnabled"] = boost::any(*snippetsEnabled);
    }
    if (sshUrlToRepo) {
      res["sshUrlToRepo"] = boost::any(*sshUrlToRepo);
    }
    if (visibilityLevel) {
      res["visibilityLevel"] = boost::any(*visibilityLevel);
    }
    if (webUrl) {
      res["webUrl"] = boost::any(*webUrl);
    }
    if (wikiEnabled) {
      res["wikiEnabled"] = boost::any(*wikiEnabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("archived") != m.end() && !m["archived"].empty()) {
      archived = make_shared<bool>(boost::any_cast<bool>(m["archived"]));
    }
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("buildsEnabled") != m.end() && !m["buildsEnabled"].empty()) {
      buildsEnabled = make_shared<bool>(boost::any_cast<bool>(m["buildsEnabled"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("creatorId") != m.end() && !m["creatorId"].empty()) {
      creatorId = make_shared<long>(boost::any_cast<long>(m["creatorId"]));
    }
    if (m.find("defaultBranch") != m.end() && !m["defaultBranch"].empty()) {
      defaultBranch = make_shared<string>(boost::any_cast<string>(m["defaultBranch"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("httpUrlToRepo") != m.end() && !m["httpUrlToRepo"].empty()) {
      httpUrlToRepo = make_shared<string>(boost::any_cast<string>(m["httpUrlToRepo"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("issuesEnabled") != m.end() && !m["issuesEnabled"].empty()) {
      issuesEnabled = make_shared<bool>(boost::any_cast<bool>(m["issuesEnabled"]));
    }
    if (m.find("lastActivityAt") != m.end() && !m["lastActivityAt"].empty()) {
      lastActivityAt = make_shared<string>(boost::any_cast<string>(m["lastActivityAt"]));
    }
    if (m.find("mergeRequestsEnabled") != m.end() && !m["mergeRequestsEnabled"].empty()) {
      mergeRequestsEnabled = make_shared<bool>(boost::any_cast<bool>(m["mergeRequestsEnabled"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nameWithNamespace") != m.end() && !m["nameWithNamespace"].empty()) {
      nameWithNamespace = make_shared<string>(boost::any_cast<string>(m["nameWithNamespace"]));
    }
    if (m.find("namespace") != m.end() && !m["namespace"].empty()) {
      if (typeid(map<string, boost::any>) == m["namespace"].type()) {
        UpdateRepositoryResponseBodyResultNamespace model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["namespace"]));
        namespace_ = make_shared<UpdateRepositoryResponseBodyResultNamespace>(model1);
      }
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("pathWithNamespace") != m.end() && !m["pathWithNamespace"].empty()) {
      pathWithNamespace = make_shared<string>(boost::any_cast<string>(m["pathWithNamespace"]));
    }
    if (m.find("snippetsEnabled") != m.end() && !m["snippetsEnabled"].empty()) {
      snippetsEnabled = make_shared<bool>(boost::any_cast<bool>(m["snippetsEnabled"]));
    }
    if (m.find("sshUrlToRepo") != m.end() && !m["sshUrlToRepo"].empty()) {
      sshUrlToRepo = make_shared<string>(boost::any_cast<string>(m["sshUrlToRepo"]));
    }
    if (m.find("visibilityLevel") != m.end() && !m["visibilityLevel"].empty()) {
      visibilityLevel = make_shared<long>(boost::any_cast<long>(m["visibilityLevel"]));
    }
    if (m.find("webUrl") != m.end() && !m["webUrl"].empty()) {
      webUrl = make_shared<string>(boost::any_cast<string>(m["webUrl"]));
    }
    if (m.find("wikiEnabled") != m.end() && !m["wikiEnabled"].empty()) {
      wikiEnabled = make_shared<bool>(boost::any_cast<bool>(m["wikiEnabled"]));
    }
  }


  virtual ~UpdateRepositoryResponseBodyResult() = default;
};
class UpdateRepositoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<UpdateRepositoryResponseBodyResult> result{};
  shared_ptr<bool> success{};

  UpdateRepositoryResponseBody() {}

  explicit UpdateRepositoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        UpdateRepositoryResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<UpdateRepositoryResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdateRepositoryResponseBody() = default;
};
class UpdateRepositoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateRepositoryResponseBody> body{};

  UpdateRepositoryResponse() {}

  explicit UpdateRepositoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateRepositoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateRepositoryResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateRepositoryResponse() = default;
};
class UpdateRepositoryMemberRequestRelatedInfos : public Darabonba::Model {
public:
  shared_ptr<string> relatedId{};
  shared_ptr<long> sourceId{};
  shared_ptr<string> sourceType{};

  UpdateRepositoryMemberRequestRelatedInfos() {}

  explicit UpdateRepositoryMemberRequestRelatedInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (relatedId) {
      res["relatedId"] = boost::any(*relatedId);
    }
    if (sourceId) {
      res["sourceId"] = boost::any(*sourceId);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("relatedId") != m.end() && !m["relatedId"].empty()) {
      relatedId = make_shared<string>(boost::any_cast<string>(m["relatedId"]));
    }
    if (m.find("sourceId") != m.end() && !m["sourceId"].empty()) {
      sourceId = make_shared<long>(boost::any_cast<long>(m["sourceId"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
  }


  virtual ~UpdateRepositoryMemberRequestRelatedInfos() = default;
};
class UpdateRepositoryMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<long> accessLevel{};
  shared_ptr<string> expireAt{};
  shared_ptr<string> memberType{};
  shared_ptr<string> relatedId{};
  shared_ptr<vector<UpdateRepositoryMemberRequestRelatedInfos>> relatedInfos{};
  shared_ptr<string> organizationId{};

  UpdateRepositoryMemberRequest() {}

  explicit UpdateRepositoryMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["accessToken"] = boost::any(*accessToken);
    }
    if (accessLevel) {
      res["accessLevel"] = boost::any(*accessLevel);
    }
    if (expireAt) {
      res["expireAt"] = boost::any(*expireAt);
    }
    if (memberType) {
      res["memberType"] = boost::any(*memberType);
    }
    if (relatedId) {
      res["relatedId"] = boost::any(*relatedId);
    }
    if (relatedInfos) {
      vector<boost::any> temp1;
      for(auto item1:*relatedInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["relatedInfos"] = boost::any(temp1);
    }
    if (organizationId) {
      res["organizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessToken") != m.end() && !m["accessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["accessToken"]));
    }
    if (m.find("accessLevel") != m.end() && !m["accessLevel"].empty()) {
      accessLevel = make_shared<long>(boost::any_cast<long>(m["accessLevel"]));
    }
    if (m.find("expireAt") != m.end() && !m["expireAt"].empty()) {
      expireAt = make_shared<string>(boost::any_cast<string>(m["expireAt"]));
    }
    if (m.find("memberType") != m.end() && !m["memberType"].empty()) {
      memberType = make_shared<string>(boost::any_cast<string>(m["memberType"]));
    }
    if (m.find("relatedId") != m.end() && !m["relatedId"].empty()) {
      relatedId = make_shared<string>(boost::any_cast<string>(m["relatedId"]));
    }
    if (m.find("relatedInfos") != m.end() && !m["relatedInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["relatedInfos"].type()) {
        vector<UpdateRepositoryMemberRequestRelatedInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["relatedInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateRepositoryMemberRequestRelatedInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        relatedInfos = make_shared<vector<UpdateRepositoryMemberRequestRelatedInfos>>(expect1);
      }
    }
    if (m.find("organizationId") != m.end() && !m["organizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["organizationId"]));
    }
  }


  virtual ~UpdateRepositoryMemberRequest() = default;
};
class UpdateRepositoryMemberResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> accessLevel{};
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> email{};
  shared_ptr<string> expireAt{};
  shared_ptr<long> id{};
  shared_ptr<string> memberName{};
  shared_ptr<string> memberType{};
  shared_ptr<string> name{};
  shared_ptr<long> sourceId{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> state{};
  shared_ptr<string> username{};
  shared_ptr<string> webUrl{};

  UpdateRepositoryMemberResponseBodyResult() {}

  explicit UpdateRepositoryMemberResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessLevel) {
      res["accessLevel"] = boost::any(*accessLevel);
    }
    if (avatarUrl) {
      res["avatarUrl"] = boost::any(*avatarUrl);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (expireAt) {
      res["expireAt"] = boost::any(*expireAt);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (memberName) {
      res["memberName"] = boost::any(*memberName);
    }
    if (memberType) {
      res["memberType"] = boost::any(*memberType);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sourceId) {
      res["sourceId"] = boost::any(*sourceId);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    if (webUrl) {
      res["webUrl"] = boost::any(*webUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessLevel") != m.end() && !m["accessLevel"].empty()) {
      accessLevel = make_shared<long>(boost::any_cast<long>(m["accessLevel"]));
    }
    if (m.find("avatarUrl") != m.end() && !m["avatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["avatarUrl"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("expireAt") != m.end() && !m["expireAt"].empty()) {
      expireAt = make_shared<string>(boost::any_cast<string>(m["expireAt"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("memberName") != m.end() && !m["memberName"].empty()) {
      memberName = make_shared<string>(boost::any_cast<string>(m["memberName"]));
    }
    if (m.find("memberType") != m.end() && !m["memberType"].empty()) {
      memberType = make_shared<string>(boost::any_cast<string>(m["memberType"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sourceId") != m.end() && !m["sourceId"].empty()) {
      sourceId = make_shared<long>(boost::any_cast<long>(m["sourceId"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
    if (m.find("webUrl") != m.end() && !m["webUrl"].empty()) {
      webUrl = make_shared<string>(boost::any_cast<string>(m["webUrl"]));
    }
  }


  virtual ~UpdateRepositoryMemberResponseBodyResult() = default;
};
class UpdateRepositoryMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<UpdateRepositoryMemberResponseBodyResult> result{};
  shared_ptr<bool> success{};

  UpdateRepositoryMemberResponseBody() {}

  explicit UpdateRepositoryMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        UpdateRepositoryMemberResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<UpdateRepositoryMemberResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdateRepositoryMemberResponseBody() = default;
};
class UpdateRepositoryMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateRepositoryMemberResponseBody> body{};

  UpdateRepositoryMemberResponse() {}

  explicit UpdateRepositoryMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateRepositoryMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateRepositoryMemberResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateRepositoryMemberResponse() = default;
};
class UpdateResourceMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> roleName{};

  UpdateResourceMemberRequest() {}

  explicit UpdateResourceMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleName) {
      res["roleName"] = boost::any(*roleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("roleName") != m.end() && !m["roleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["roleName"]));
    }
  }


  virtual ~UpdateResourceMemberRequest() = default;
};
class UpdateResourceMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateResourceMemberResponseBody() {}

  explicit UpdateResourceMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdateResourceMemberResponseBody() = default;
};
class UpdateResourceMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateResourceMemberResponseBody> body{};

  UpdateResourceMemberResponse() {}

  explicit UpdateResourceMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateResourceMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateResourceMemberResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateResourceMemberResponse() = default;
};
class UpdateTestCaseRequestUpdateWorkitemPropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> fieldIdentifier{};
  shared_ptr<string> fieldValue{};

  UpdateTestCaseRequestUpdateWorkitemPropertyRequest() {}

  explicit UpdateTestCaseRequestUpdateWorkitemPropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldIdentifier) {
      res["fieldIdentifier"] = boost::any(*fieldIdentifier);
    }
    if (fieldValue) {
      res["fieldValue"] = boost::any(*fieldValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fieldIdentifier") != m.end() && !m["fieldIdentifier"].empty()) {
      fieldIdentifier = make_shared<string>(boost::any_cast<string>(m["fieldIdentifier"]));
    }
    if (m.find("fieldValue") != m.end() && !m["fieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["fieldValue"]));
    }
  }


  virtual ~UpdateTestCaseRequestUpdateWorkitemPropertyRequest() = default;
};
class UpdateTestCaseRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateTestCaseRequestUpdateWorkitemPropertyRequest>> updateWorkitemPropertyRequest{};

  UpdateTestCaseRequest() {}

  explicit UpdateTestCaseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (updateWorkitemPropertyRequest) {
      vector<boost::any> temp1;
      for(auto item1:*updateWorkitemPropertyRequest){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["updateWorkitemPropertyRequest"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("updateWorkitemPropertyRequest") != m.end() && !m["updateWorkitemPropertyRequest"].empty()) {
      if (typeid(vector<boost::any>) == m["updateWorkitemPropertyRequest"].type()) {
        vector<UpdateTestCaseRequestUpdateWorkitemPropertyRequest> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["updateWorkitemPropertyRequest"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTestCaseRequestUpdateWorkitemPropertyRequest model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        updateWorkitemPropertyRequest = make_shared<vector<UpdateTestCaseRequestUpdateWorkitemPropertyRequest>>(expect1);
      }
    }
  }


  virtual ~UpdateTestCaseRequest() = default;
};
class UpdateTestCaseResponseBodyTestcaseAssignedTo : public Darabonba::Model {
public:
  shared_ptr<string> assignIdentifier{};
  shared_ptr<string> name{};
  shared_ptr<string> tbRoleId{};

  UpdateTestCaseResponseBodyTestcaseAssignedTo() {}

  explicit UpdateTestCaseResponseBodyTestcaseAssignedTo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignIdentifier) {
      res["assignIdentifier"] = boost::any(*assignIdentifier);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (tbRoleId) {
      res["tbRoleId"] = boost::any(*tbRoleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignIdentifier") != m.end() && !m["assignIdentifier"].empty()) {
      assignIdentifier = make_shared<string>(boost::any_cast<string>(m["assignIdentifier"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("tbRoleId") != m.end() && !m["tbRoleId"].empty()) {
      tbRoleId = make_shared<string>(boost::any_cast<string>(m["tbRoleId"]));
    }
  }


  virtual ~UpdateTestCaseResponseBodyTestcaseAssignedTo() = default;
};
class UpdateTestCaseResponseBodyTestcaseCreator : public Darabonba::Model {
public:
  shared_ptr<string> createIdentifier{};
  shared_ptr<string> name{};

  UpdateTestCaseResponseBodyTestcaseCreator() {}

  explicit UpdateTestCaseResponseBodyTestcaseCreator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createIdentifier) {
      res["createIdentifier"] = boost::any(*createIdentifier);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createIdentifier") != m.end() && !m["createIdentifier"].empty()) {
      createIdentifier = make_shared<string>(boost::any_cast<string>(m["createIdentifier"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~UpdateTestCaseResponseBodyTestcaseCreator() = default;
};
class UpdateTestCaseResponseBodyTestcaseDetailInfoExpectedResult : public Darabonba::Model {
public:
  shared_ptr<string> expectContent{};
  shared_ptr<string> expectContentType{};
  shared_ptr<string> expectIdentifier{};

  UpdateTestCaseResponseBodyTestcaseDetailInfoExpectedResult() {}

  explicit UpdateTestCaseResponseBodyTestcaseDetailInfoExpectedResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expectContent) {
      res["expectContent"] = boost::any(*expectContent);
    }
    if (expectContentType) {
      res["expectContentType"] = boost::any(*expectContentType);
    }
    if (expectIdentifier) {
      res["expectIdentifier"] = boost::any(*expectIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    expectContent = make_shared<string>(boost::any_cast<string>(m["expectContent"]));
    expectContentType = make_shared<string>(boost::any_cast<string>(m["expectContentType"]));
    expectIdentifier = make_shared<string>(boost::any_cast<string>(m["expectIdentifier"]));
  }


  virtual ~UpdateTestCaseResponseBodyTestcaseDetailInfoExpectedResult() = default;
};
class UpdateTestCaseResponseBodyTestcaseDetailInfoPrecondition : public Darabonba::Model {
public:
  shared_ptr<string> preContent{};
  shared_ptr<string> preContentType{};
  shared_ptr<string> preIdentifier{};

  UpdateTestCaseResponseBodyTestcaseDetailInfoPrecondition() {}

  explicit UpdateTestCaseResponseBodyTestcaseDetailInfoPrecondition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preContent) {
      res["preContent"] = boost::any(*preContent);
    }
    if (preContentType) {
      res["preContentType"] = boost::any(*preContentType);
    }
    if (preIdentifier) {
      res["preIdentifier"] = boost::any(*preIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("preContent") != m.end() && !m["preContent"].empty()) {
      preContent = make_shared<string>(boost::any_cast<string>(m["preContent"]));
    }
    if (m.find("preContentType") != m.end() && !m["preContentType"].empty()) {
      preContentType = make_shared<string>(boost::any_cast<string>(m["preContentType"]));
    }
    if (m.find("preIdentifier") != m.end() && !m["preIdentifier"].empty()) {
      preIdentifier = make_shared<string>(boost::any_cast<string>(m["preIdentifier"]));
    }
  }


  virtual ~UpdateTestCaseResponseBodyTestcaseDetailInfoPrecondition() = default;
};
class UpdateTestCaseResponseBodyTestcaseDetailInfoStepContent : public Darabonba::Model {
public:
  shared_ptr<string> stepContent{};
  shared_ptr<string> stepContentType{};
  shared_ptr<string> stepIdentifier{};

  UpdateTestCaseResponseBodyTestcaseDetailInfoStepContent() {}

  explicit UpdateTestCaseResponseBodyTestcaseDetailInfoStepContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stepContent) {
      res["stepContent"] = boost::any(*stepContent);
    }
    if (stepContentType) {
      res["stepContentType"] = boost::any(*stepContentType);
    }
    if (stepIdentifier) {
      res["stepIdentifier"] = boost::any(*stepIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("stepContent") != m.end() && !m["stepContent"].empty()) {
      stepContent = make_shared<string>(boost::any_cast<string>(m["stepContent"]));
    }
    if (m.find("stepContentType") != m.end() && !m["stepContentType"].empty()) {
      stepContentType = make_shared<string>(boost::any_cast<string>(m["stepContentType"]));
    }
    if (m.find("stepIdentifier") != m.end() && !m["stepIdentifier"].empty()) {
      stepIdentifier = make_shared<string>(boost::any_cast<string>(m["stepIdentifier"]));
    }
  }


  virtual ~UpdateTestCaseResponseBodyTestcaseDetailInfoStepContent() = default;
};
class UpdateTestCaseResponseBodyTestcaseDetailInfo : public Darabonba::Model {
public:
  shared_ptr<UpdateTestCaseResponseBodyTestcaseDetailInfoExpectedResult> expectedResult{};
  shared_ptr<UpdateTestCaseResponseBodyTestcaseDetailInfoPrecondition> precondition{};
  shared_ptr<UpdateTestCaseResponseBodyTestcaseDetailInfoStepContent> stepContent{};
  shared_ptr<string> stepType{};

  UpdateTestCaseResponseBodyTestcaseDetailInfo() {}

  explicit UpdateTestCaseResponseBodyTestcaseDetailInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expectedResult) {
      res["expectedResult"] = expectedResult ? boost::any(expectedResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (precondition) {
      res["precondition"] = precondition ? boost::any(precondition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stepContent) {
      res["stepContent"] = stepContent ? boost::any(stepContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stepType) {
      res["stepType"] = boost::any(*stepType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (typeid(map<string, boost::any>) == m["expectedResult"].type()) {
      UpdateTestCaseResponseBodyTestcaseDetailInfoExpectedResult model1;
      model1.fromMap(boost::any_cast<map<string, boost::any>>(m["expectedResult"]));
      expectedResult = model1;
    }
    if (m.find("precondition") != m.end() && !m["precondition"].empty()) {
      if (typeid(map<string, boost::any>) == m["precondition"].type()) {
        UpdateTestCaseResponseBodyTestcaseDetailInfoPrecondition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["precondition"]));
        precondition = make_shared<UpdateTestCaseResponseBodyTestcaseDetailInfoPrecondition>(model1);
      }
    }
    if (m.find("stepContent") != m.end() && !m["stepContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["stepContent"].type()) {
        UpdateTestCaseResponseBodyTestcaseDetailInfoStepContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["stepContent"]));
        stepContent = make_shared<UpdateTestCaseResponseBodyTestcaseDetailInfoStepContent>(model1);
      }
    }
    if (m.find("stepType") != m.end() && !m["stepType"].empty()) {
      stepType = make_shared<string>(boost::any_cast<string>(m["stepType"]));
    }
  }


  virtual ~UpdateTestCaseResponseBodyTestcaseDetailInfo() = default;
};
class UpdateTestCaseResponseBodyTestcaseDirectory : public Darabonba::Model {
public:
  shared_ptr<string> childIdentifier{};
  shared_ptr<string> directoryIdentifier{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> pathName{};

  UpdateTestCaseResponseBodyTestcaseDirectory() {}

  explicit UpdateTestCaseResponseBodyTestcaseDirectory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (childIdentifier) {
      res["childIdentifier"] = boost::any(*childIdentifier);
    }
    if (directoryIdentifier) {
      res["directoryIdentifier"] = boost::any(*directoryIdentifier);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (pathName) {
      res["pathName"] = boost::any(*pathName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("childIdentifier") != m.end() && !m["childIdentifier"].empty()) {
      childIdentifier = make_shared<string>(boost::any_cast<string>(m["childIdentifier"]));
    }
    if (m.find("directoryIdentifier") != m.end() && !m["directoryIdentifier"].empty()) {
      directoryIdentifier = make_shared<string>(boost::any_cast<string>(m["directoryIdentifier"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("pathName") != m.end() && !m["pathName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["pathName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["pathName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      pathName = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateTestCaseResponseBodyTestcaseDirectory() = default;
};
class UpdateTestCaseResponseBodyTestcaseModifier : public Darabonba::Model {
public:
  shared_ptr<string> modifyIdentifier{};
  shared_ptr<string> name{};

  UpdateTestCaseResponseBodyTestcaseModifier() {}

  explicit UpdateTestCaseResponseBodyTestcaseModifier(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (modifyIdentifier) {
      res["modifyIdentifier"] = boost::any(*modifyIdentifier);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("modifyIdentifier") != m.end() && !m["modifyIdentifier"].empty()) {
      modifyIdentifier = make_shared<string>(boost::any_cast<string>(m["modifyIdentifier"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~UpdateTestCaseResponseBodyTestcaseModifier() = default;
};
class UpdateTestCaseResponseBodyTestcase : public Darabonba::Model {
public:
  shared_ptr<UpdateTestCaseResponseBodyTestcaseAssignedTo> assignedTo{};
  shared_ptr<string> categoryIdentifier{};
  shared_ptr<UpdateTestCaseResponseBodyTestcaseCreator> creator{};
  shared_ptr<UpdateTestCaseResponseBodyTestcaseDetailInfo> detailInfo{};
  shared_ptr<UpdateTestCaseResponseBodyTestcaseDirectory> directory{};
  shared_ptr<string> identifier{};
  shared_ptr<UpdateTestCaseResponseBodyTestcaseModifier> modifier{};
  shared_ptr<string> spaceIdentifier{};
  shared_ptr<string> spaceType{};
  shared_ptr<string> subject{};

  UpdateTestCaseResponseBodyTestcase() {}

  explicit UpdateTestCaseResponseBodyTestcase(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignedTo) {
      res["assignedTo"] = assignedTo ? boost::any(assignedTo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (categoryIdentifier) {
      res["categoryIdentifier"] = boost::any(*categoryIdentifier);
    }
    if (creator) {
      res["creator"] = creator ? boost::any(creator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (detailInfo) {
      res["detailInfo"] = detailInfo ? boost::any(detailInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (directory) {
      res["directory"] = directory ? boost::any(directory->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (modifier) {
      res["modifier"] = modifier ? boost::any(modifier->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spaceIdentifier) {
      res["spaceIdentifier"] = boost::any(*spaceIdentifier);
    }
    if (spaceType) {
      res["spaceType"] = boost::any(*spaceType);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignedTo") != m.end() && !m["assignedTo"].empty()) {
      if (typeid(map<string, boost::any>) == m["assignedTo"].type()) {
        UpdateTestCaseResponseBodyTestcaseAssignedTo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["assignedTo"]));
        assignedTo = make_shared<UpdateTestCaseResponseBodyTestcaseAssignedTo>(model1);
      }
    }
    if (m.find("categoryIdentifier") != m.end() && !m["categoryIdentifier"].empty()) {
      categoryIdentifier = make_shared<string>(boost::any_cast<string>(m["categoryIdentifier"]));
    }
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      if (typeid(map<string, boost::any>) == m["creator"].type()) {
        UpdateTestCaseResponseBodyTestcaseCreator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["creator"]));
        creator = make_shared<UpdateTestCaseResponseBodyTestcaseCreator>(model1);
      }
    }
    if (m.find("detailInfo") != m.end() && !m["detailInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["detailInfo"].type()) {
        UpdateTestCaseResponseBodyTestcaseDetailInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["detailInfo"]));
        detailInfo = make_shared<UpdateTestCaseResponseBodyTestcaseDetailInfo>(model1);
      }
    }
    if (m.find("directory") != m.end() && !m["directory"].empty()) {
      if (typeid(map<string, boost::any>) == m["directory"].type()) {
        UpdateTestCaseResponseBodyTestcaseDirectory model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["directory"]));
        directory = make_shared<UpdateTestCaseResponseBodyTestcaseDirectory>(model1);
      }
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("modifier") != m.end() && !m["modifier"].empty()) {
      if (typeid(map<string, boost::any>) == m["modifier"].type()) {
        UpdateTestCaseResponseBodyTestcaseModifier model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["modifier"]));
        modifier = make_shared<UpdateTestCaseResponseBodyTestcaseModifier>(model1);
      }
    }
    if (m.find("spaceIdentifier") != m.end() && !m["spaceIdentifier"].empty()) {
      spaceIdentifier = make_shared<string>(boost::any_cast<string>(m["spaceIdentifier"]));
    }
    if (m.find("spaceType") != m.end() && !m["spaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["spaceType"]));
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
  }


  virtual ~UpdateTestCaseResponseBodyTestcase() = default;
};
class UpdateTestCaseResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdateTestCaseResponseBodyTestcase> testcase{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateTestCaseResponseBody() {}

  explicit UpdateTestCaseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (testcase) {
      res["Testcase"] = testcase ? boost::any(testcase->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Testcase") != m.end() && !m["Testcase"].empty()) {
      if (typeid(map<string, boost::any>) == m["Testcase"].type()) {
        UpdateTestCaseResponseBodyTestcase model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Testcase"]));
        testcase = make_shared<UpdateTestCaseResponseBodyTestcase>(model1);
      }
    }
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdateTestCaseResponseBody() = default;
};
class UpdateTestCaseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTestCaseResponseBody> body{};

  UpdateTestCaseResponse() {}

  explicit UpdateTestCaseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTestCaseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTestCaseResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTestCaseResponse() = default;
};
class UpdateTestResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> executor{};
  shared_ptr<string> status{};

  UpdateTestResultRequest() {}

  explicit UpdateTestResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (executor) {
      res["executor"] = boost::any(*executor);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("executor") != m.end() && !m["executor"].empty()) {
      executor = make_shared<string>(boost::any_cast<string>(m["executor"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~UpdateTestResultRequest() = default;
};
class UpdateTestResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateTestResultResponseBody() {}

  explicit UpdateTestResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdateTestResultResponseBody() = default;
};
class UpdateTestResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTestResultResponseBody> body{};

  UpdateTestResultResponse() {}

  explicit UpdateTestResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTestResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTestResultResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTestResultResponse() = default;
};
class UpdateVariableGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> variables{};

  UpdateVariableGroupRequest() {}

  explicit UpdateVariableGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (variables) {
      res["variables"] = boost::any(*variables);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("variables") != m.end() && !m["variables"].empty()) {
      variables = make_shared<string>(boost::any_cast<string>(m["variables"]));
    }
  }


  virtual ~UpdateVariableGroupRequest() = default;
};
class UpdateVariableGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateVariableGroupResponseBody() {}

  explicit UpdateVariableGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdateVariableGroupResponseBody() = default;
};
class UpdateVariableGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateVariableGroupResponseBody> body{};

  UpdateVariableGroupResponse() {}

  explicit UpdateVariableGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateVariableGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateVariableGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateVariableGroupResponse() = default;
};
class UpdateWorkItemRequest : public Darabonba::Model {
public:
  shared_ptr<string> fieldType{};
  shared_ptr<string> identifier{};
  shared_ptr<string> propertyKey{};
  shared_ptr<string> propertyValue{};

  UpdateWorkItemRequest() {}

  explicit UpdateWorkItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldType) {
      res["fieldType"] = boost::any(*fieldType);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (propertyKey) {
      res["propertyKey"] = boost::any(*propertyKey);
    }
    if (propertyValue) {
      res["propertyValue"] = boost::any(*propertyValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fieldType") != m.end() && !m["fieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["fieldType"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("propertyKey") != m.end() && !m["propertyKey"].empty()) {
      propertyKey = make_shared<string>(boost::any_cast<string>(m["propertyKey"]));
    }
    if (m.find("propertyValue") != m.end() && !m["propertyValue"].empty()) {
      propertyValue = make_shared<string>(boost::any_cast<string>(m["propertyValue"]));
    }
  }


  virtual ~UpdateWorkItemRequest() = default;
};
class UpdateWorkItemResponseBodyWorkitem : public Darabonba::Model {
public:
  shared_ptr<string> assignedTo{};
  shared_ptr<string> categoryIdentifier{};
  shared_ptr<string> creator{};
  shared_ptr<string> document{};
  shared_ptr<string> documentFormat{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> identifier{};
  shared_ptr<string> logicalStatus{};
  shared_ptr<string> modifier{};
  shared_ptr<string> parentIdentifier{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> spaceIdentifier{};
  shared_ptr<string> spaceName{};
  shared_ptr<string> spaceType{};
  shared_ptr<string> sprintIdentifier{};
  shared_ptr<string> status{};
  shared_ptr<string> statusIdentifier{};
  shared_ptr<string> statusStageIdentifier{};
  shared_ptr<string> subject{};
  shared_ptr<long> updateStatusAt{};
  shared_ptr<string> workitemTypeIdentifier{};

  UpdateWorkItemResponseBodyWorkitem() {}

  explicit UpdateWorkItemResponseBodyWorkitem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignedTo) {
      res["assignedTo"] = boost::any(*assignedTo);
    }
    if (categoryIdentifier) {
      res["categoryIdentifier"] = boost::any(*categoryIdentifier);
    }
    if (creator) {
      res["creator"] = boost::any(*creator);
    }
    if (document) {
      res["document"] = boost::any(*document);
    }
    if (documentFormat) {
      res["documentFormat"] = boost::any(*documentFormat);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (logicalStatus) {
      res["logicalStatus"] = boost::any(*logicalStatus);
    }
    if (modifier) {
      res["modifier"] = boost::any(*modifier);
    }
    if (parentIdentifier) {
      res["parentIdentifier"] = boost::any(*parentIdentifier);
    }
    if (serialNumber) {
      res["serialNumber"] = boost::any(*serialNumber);
    }
    if (spaceIdentifier) {
      res["spaceIdentifier"] = boost::any(*spaceIdentifier);
    }
    if (spaceName) {
      res["spaceName"] = boost::any(*spaceName);
    }
    if (spaceType) {
      res["spaceType"] = boost::any(*spaceType);
    }
    if (sprintIdentifier) {
      res["sprintIdentifier"] = boost::any(*sprintIdentifier);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (statusIdentifier) {
      res["statusIdentifier"] = boost::any(*statusIdentifier);
    }
    if (statusStageIdentifier) {
      res["statusStageIdentifier"] = boost::any(*statusStageIdentifier);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    if (updateStatusAt) {
      res["updateStatusAt"] = boost::any(*updateStatusAt);
    }
    if (workitemTypeIdentifier) {
      res["workitemTypeIdentifier"] = boost::any(*workitemTypeIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignedTo") != m.end() && !m["assignedTo"].empty()) {
      assignedTo = make_shared<string>(boost::any_cast<string>(m["assignedTo"]));
    }
    if (m.find("categoryIdentifier") != m.end() && !m["categoryIdentifier"].empty()) {
      categoryIdentifier = make_shared<string>(boost::any_cast<string>(m["categoryIdentifier"]));
    }
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["creator"]));
    }
    if (m.find("document") != m.end() && !m["document"].empty()) {
      document = make_shared<string>(boost::any_cast<string>(m["document"]));
    }
    if (m.find("documentFormat") != m.end() && !m["documentFormat"].empty()) {
      documentFormat = make_shared<string>(boost::any_cast<string>(m["documentFormat"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("logicalStatus") != m.end() && !m["logicalStatus"].empty()) {
      logicalStatus = make_shared<string>(boost::any_cast<string>(m["logicalStatus"]));
    }
    if (m.find("modifier") != m.end() && !m["modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["modifier"]));
    }
    if (m.find("parentIdentifier") != m.end() && !m["parentIdentifier"].empty()) {
      parentIdentifier = make_shared<string>(boost::any_cast<string>(m["parentIdentifier"]));
    }
    if (m.find("serialNumber") != m.end() && !m["serialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["serialNumber"]));
    }
    if (m.find("spaceIdentifier") != m.end() && !m["spaceIdentifier"].empty()) {
      spaceIdentifier = make_shared<string>(boost::any_cast<string>(m["spaceIdentifier"]));
    }
    if (m.find("spaceName") != m.end() && !m["spaceName"].empty()) {
      spaceName = make_shared<string>(boost::any_cast<string>(m["spaceName"]));
    }
    if (m.find("spaceType") != m.end() && !m["spaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["spaceType"]));
    }
    if (m.find("sprintIdentifier") != m.end() && !m["sprintIdentifier"].empty()) {
      sprintIdentifier = make_shared<string>(boost::any_cast<string>(m["sprintIdentifier"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("statusIdentifier") != m.end() && !m["statusIdentifier"].empty()) {
      statusIdentifier = make_shared<string>(boost::any_cast<string>(m["statusIdentifier"]));
    }
    if (m.find("statusStageIdentifier") != m.end() && !m["statusStageIdentifier"].empty()) {
      statusStageIdentifier = make_shared<string>(boost::any_cast<string>(m["statusStageIdentifier"]));
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
    if (m.find("updateStatusAt") != m.end() && !m["updateStatusAt"].empty()) {
      updateStatusAt = make_shared<long>(boost::any_cast<long>(m["updateStatusAt"]));
    }
    if (m.find("workitemTypeIdentifier") != m.end() && !m["workitemTypeIdentifier"].empty()) {
      workitemTypeIdentifier = make_shared<string>(boost::any_cast<string>(m["workitemTypeIdentifier"]));
    }
  }


  virtual ~UpdateWorkItemResponseBodyWorkitem() = default;
};
class UpdateWorkItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<UpdateWorkItemResponseBodyWorkitem> workitem{};

  UpdateWorkItemResponseBody() {}

  explicit UpdateWorkItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (workitem) {
      res["workitem"] = workitem ? boost::any(workitem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("workitem") != m.end() && !m["workitem"].empty()) {
      if (typeid(map<string, boost::any>) == m["workitem"].type()) {
        UpdateWorkItemResponseBodyWorkitem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["workitem"]));
        workitem = make_shared<UpdateWorkItemResponseBodyWorkitem>(model1);
      }
    }
  }


  virtual ~UpdateWorkItemResponseBody() = default;
};
class UpdateWorkItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateWorkItemResponseBody> body{};

  UpdateWorkItemResponse() {}

  explicit UpdateWorkItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateWorkItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateWorkItemResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateWorkItemResponse() = default;
};
class UpdateWorkitemCommentRequest : public Darabonba::Model {
public:
  shared_ptr<long> commentId{};
  shared_ptr<string> content{};
  shared_ptr<string> formatType{};
  shared_ptr<string> workitemIdentifier{};

  UpdateWorkitemCommentRequest() {}

  explicit UpdateWorkitemCommentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commentId) {
      res["commentId"] = boost::any(*commentId);
    }
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (formatType) {
      res["formatType"] = boost::any(*formatType);
    }
    if (workitemIdentifier) {
      res["workitemIdentifier"] = boost::any(*workitemIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commentId") != m.end() && !m["commentId"].empty()) {
      commentId = make_shared<long>(boost::any_cast<long>(m["commentId"]));
    }
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("formatType") != m.end() && !m["formatType"].empty()) {
      formatType = make_shared<string>(boost::any_cast<string>(m["formatType"]));
    }
    if (m.find("workitemIdentifier") != m.end() && !m["workitemIdentifier"].empty()) {
      workitemIdentifier = make_shared<string>(boost::any_cast<string>(m["workitemIdentifier"]));
    }
  }


  virtual ~UpdateWorkitemCommentRequest() = default;
};
class UpdateWorkitemCommentResponseBodyCommentUser : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> avatar{};
  shared_ptr<string> displayName{};
  shared_ptr<string> identifier{};
  shared_ptr<string> nickName{};
  shared_ptr<string> realName{};

  UpdateWorkitemCommentResponseBodyCommentUser() {}

  explicit UpdateWorkitemCommentResponseBodyCommentUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["account"] = boost::any(*account);
    }
    if (avatar) {
      res["avatar"] = boost::any(*avatar);
    }
    if (displayName) {
      res["displayName"] = boost::any(*displayName);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (nickName) {
      res["nickName"] = boost::any(*nickName);
    }
    if (realName) {
      res["realName"] = boost::any(*realName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("account") != m.end() && !m["account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["account"]));
    }
    if (m.find("avatar") != m.end() && !m["avatar"].empty()) {
      avatar = make_shared<string>(boost::any_cast<string>(m["avatar"]));
    }
    if (m.find("displayName") != m.end() && !m["displayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["displayName"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("nickName") != m.end() && !m["nickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["nickName"]));
    }
    if (m.find("realName") != m.end() && !m["realName"].empty()) {
      realName = make_shared<string>(boost::any_cast<string>(m["realName"]));
    }
  }


  virtual ~UpdateWorkitemCommentResponseBodyCommentUser() = default;
};
class UpdateWorkitemCommentResponseBodyComment : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> createTime{};
  shared_ptr<string> formatType{};
  shared_ptr<string> id{};
  shared_ptr<bool> isTop{};
  shared_ptr<long> modifiedTime{};
  shared_ptr<long> parentId{};
  shared_ptr<string> targetIdentifier{};
  shared_ptr<string> targetType{};
  shared_ptr<long> topTime{};
  shared_ptr<UpdateWorkitemCommentResponseBodyCommentUser> user{};

  UpdateWorkitemCommentResponseBodyComment() {}

  explicit UpdateWorkitemCommentResponseBodyComment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (formatType) {
      res["formatType"] = boost::any(*formatType);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (isTop) {
      res["isTop"] = boost::any(*isTop);
    }
    if (modifiedTime) {
      res["modifiedTime"] = boost::any(*modifiedTime);
    }
    if (parentId) {
      res["parentId"] = boost::any(*parentId);
    }
    if (targetIdentifier) {
      res["targetIdentifier"] = boost::any(*targetIdentifier);
    }
    if (targetType) {
      res["targetType"] = boost::any(*targetType);
    }
    if (topTime) {
      res["topTime"] = boost::any(*topTime);
    }
    if (user) {
      res["user"] = user ? boost::any(user->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["createTime"]));
    }
    if (m.find("formatType") != m.end() && !m["formatType"].empty()) {
      formatType = make_shared<string>(boost::any_cast<string>(m["formatType"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("isTop") != m.end() && !m["isTop"].empty()) {
      isTop = make_shared<bool>(boost::any_cast<bool>(m["isTop"]));
    }
    if (m.find("modifiedTime") != m.end() && !m["modifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["modifiedTime"]));
    }
    if (m.find("parentId") != m.end() && !m["parentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["parentId"]));
    }
    if (m.find("targetIdentifier") != m.end() && !m["targetIdentifier"].empty()) {
      targetIdentifier = make_shared<string>(boost::any_cast<string>(m["targetIdentifier"]));
    }
    if (m.find("targetType") != m.end() && !m["targetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["targetType"]));
    }
    if (m.find("topTime") != m.end() && !m["topTime"].empty()) {
      topTime = make_shared<long>(boost::any_cast<long>(m["topTime"]));
    }
    if (m.find("user") != m.end() && !m["user"].empty()) {
      if (typeid(map<string, boost::any>) == m["user"].type()) {
        UpdateWorkitemCommentResponseBodyCommentUser model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["user"]));
        user = make_shared<UpdateWorkitemCommentResponseBodyCommentUser>(model1);
      }
    }
  }


  virtual ~UpdateWorkitemCommentResponseBodyComment() = default;
};
class UpdateWorkitemCommentResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdateWorkitemCommentResponseBodyComment> comment{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  UpdateWorkitemCommentResponseBody() {}

  explicit UpdateWorkitemCommentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["comment"] = comment ? boost::any(comment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("comment") != m.end() && !m["comment"].empty()) {
      if (typeid(map<string, boost::any>) == m["comment"].type()) {
        UpdateWorkitemCommentResponseBodyComment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["comment"]));
        comment = make_shared<UpdateWorkitemCommentResponseBodyComment>(model1);
      }
    }
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["success"]));
    }
  }


  virtual ~UpdateWorkitemCommentResponseBody() = default;
};
class UpdateWorkitemCommentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateWorkitemCommentResponseBody> body{};

  UpdateWorkitemCommentResponse() {}

  explicit UpdateWorkitemCommentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateWorkitemCommentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateWorkitemCommentResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateWorkitemCommentResponse() = default;
};
class UpdateWorkitemFieldRequestUpdateWorkitemPropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> fieldIdentifier{};
  shared_ptr<string> fieldValue{};

  UpdateWorkitemFieldRequestUpdateWorkitemPropertyRequest() {}

  explicit UpdateWorkitemFieldRequestUpdateWorkitemPropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldIdentifier) {
      res["fieldIdentifier"] = boost::any(*fieldIdentifier);
    }
    if (fieldValue) {
      res["fieldValue"] = boost::any(*fieldValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fieldIdentifier") != m.end() && !m["fieldIdentifier"].empty()) {
      fieldIdentifier = make_shared<string>(boost::any_cast<string>(m["fieldIdentifier"]));
    }
    if (m.find("fieldValue") != m.end() && !m["fieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["fieldValue"]));
    }
  }


  virtual ~UpdateWorkitemFieldRequestUpdateWorkitemPropertyRequest() = default;
};
class UpdateWorkitemFieldRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateWorkitemFieldRequestUpdateWorkitemPropertyRequest>> updateWorkitemPropertyRequest{};
  shared_ptr<string> workitemIdentifier{};

  UpdateWorkitemFieldRequest() {}

  explicit UpdateWorkitemFieldRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (updateWorkitemPropertyRequest) {
      vector<boost::any> temp1;
      for(auto item1:*updateWorkitemPropertyRequest){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["updateWorkitemPropertyRequest"] = boost::any(temp1);
    }
    if (workitemIdentifier) {
      res["workitemIdentifier"] = boost::any(*workitemIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("updateWorkitemPropertyRequest") != m.end() && !m["updateWorkitemPropertyRequest"].empty()) {
      if (typeid(vector<boost::any>) == m["updateWorkitemPropertyRequest"].type()) {
        vector<UpdateWorkitemFieldRequestUpdateWorkitemPropertyRequest> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["updateWorkitemPropertyRequest"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateWorkitemFieldRequestUpdateWorkitemPropertyRequest model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        updateWorkitemPropertyRequest = make_shared<vector<UpdateWorkitemFieldRequestUpdateWorkitemPropertyRequest>>(expect1);
      }
    }
    if (m.find("workitemIdentifier") != m.end() && !m["workitemIdentifier"].empty()) {
      workitemIdentifier = make_shared<string>(boost::any_cast<string>(m["workitemIdentifier"]));
    }
  }


  virtual ~UpdateWorkitemFieldRequest() = default;
};
class UpdateWorkitemFieldResponseBodyWorkitem : public Darabonba::Model {
public:
  shared_ptr<string> assignedTo{};
  shared_ptr<string> categoryIdentifier{};
  shared_ptr<string> creator{};
  shared_ptr<string> document{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> identifier{};
  shared_ptr<string> logicalStatus{};
  shared_ptr<string> modifier{};
  shared_ptr<string> parentIdentifier{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> spaceIdentifier{};
  shared_ptr<string> spaceName{};
  shared_ptr<string> spaceType{};
  shared_ptr<string> sprintIdentifier{};
  shared_ptr<string> status{};
  shared_ptr<string> statusIdentifier{};
  shared_ptr<string> statusStageIdentifier{};
  shared_ptr<string> subject{};
  shared_ptr<long> updateStatusAt{};
  shared_ptr<string> workitemTypeIdentifier{};

  UpdateWorkitemFieldResponseBodyWorkitem() {}

  explicit UpdateWorkitemFieldResponseBodyWorkitem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignedTo) {
      res["assignedTo"] = boost::any(*assignedTo);
    }
    if (categoryIdentifier) {
      res["categoryIdentifier"] = boost::any(*categoryIdentifier);
    }
    if (creator) {
      res["creator"] = boost::any(*creator);
    }
    if (document) {
      res["document"] = boost::any(*document);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (identifier) {
      res["identifier"] = boost::any(*identifier);
    }
    if (logicalStatus) {
      res["logicalStatus"] = boost::any(*logicalStatus);
    }
    if (modifier) {
      res["modifier"] = boost::any(*modifier);
    }
    if (parentIdentifier) {
      res["parentIdentifier"] = boost::any(*parentIdentifier);
    }
    if (serialNumber) {
      res["serialNumber"] = boost::any(*serialNumber);
    }
    if (spaceIdentifier) {
      res["spaceIdentifier"] = boost::any(*spaceIdentifier);
    }
    if (spaceName) {
      res["spaceName"] = boost::any(*spaceName);
    }
    if (spaceType) {
      res["spaceType"] = boost::any(*spaceType);
    }
    if (sprintIdentifier) {
      res["sprintIdentifier"] = boost::any(*sprintIdentifier);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (statusIdentifier) {
      res["statusIdentifier"] = boost::any(*statusIdentifier);
    }
    if (statusStageIdentifier) {
      res["statusStageIdentifier"] = boost::any(*statusStageIdentifier);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    if (updateStatusAt) {
      res["updateStatusAt"] = boost::any(*updateStatusAt);
    }
    if (workitemTypeIdentifier) {
      res["workitemTypeIdentifier"] = boost::any(*workitemTypeIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignedTo") != m.end() && !m["assignedTo"].empty()) {
      assignedTo = make_shared<string>(boost::any_cast<string>(m["assignedTo"]));
    }
    if (m.find("categoryIdentifier") != m.end() && !m["categoryIdentifier"].empty()) {
      categoryIdentifier = make_shared<string>(boost::any_cast<string>(m["categoryIdentifier"]));
    }
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["creator"]));
    }
    if (m.find("document") != m.end() && !m["document"].empty()) {
      document = make_shared<string>(boost::any_cast<string>(m["document"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmtModified"]));
    }
    if (m.find("identifier") != m.end() && !m["identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["identifier"]));
    }
    if (m.find("logicalStatus") != m.end() && !m["logicalStatus"].empty()) {
      logicalStatus = make_shared<string>(boost::any_cast<string>(m["logicalStatus"]));
    }
    if (m.find("modifier") != m.end() && !m["modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["modifier"]));
    }
    if (m.find("parentIdentifier") != m.end() && !m["parentIdentifier"].empty()) {
      parentIdentifier = make_shared<string>(boost::any_cast<string>(m["parentIdentifier"]));
    }
    if (m.find("serialNumber") != m.end() && !m["serialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["serialNumber"]));
    }
    if (m.find("spaceIdentifier") != m.end() && !m["spaceIdentifier"].empty()) {
      spaceIdentifier = make_shared<string>(boost::any_cast<string>(m["spaceIdentifier"]));
    }
    if (m.find("spaceName") != m.end() && !m["spaceName"].empty()) {
      spaceName = make_shared<string>(boost::any_cast<string>(m["spaceName"]));
    }
    if (m.find("spaceType") != m.end() && !m["spaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["spaceType"]));
    }
    if (m.find("sprintIdentifier") != m.end() && !m["sprintIdentifier"].empty()) {
      sprintIdentifier = make_shared<string>(boost::any_cast<string>(m["sprintIdentifier"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("statusIdentifier") != m.end() && !m["statusIdentifier"].empty()) {
      statusIdentifier = make_shared<string>(boost::any_cast<string>(m["statusIdentifier"]));
    }
    if (m.find("statusStageIdentifier") != m.end() && !m["statusStageIdentifier"].empty()) {
      statusStageIdentifier = make_shared<string>(boost::any_cast<string>(m["statusStageIdentifier"]));
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
    if (m.find("updateStatusAt") != m.end() && !m["updateStatusAt"].empty()) {
      updateStatusAt = make_shared<long>(boost::any_cast<long>(m["updateStatusAt"]));
    }
    if (m.find("workitemTypeIdentifier") != m.end() && !m["workitemTypeIdentifier"].empty()) {
      workitemTypeIdentifier = make_shared<string>(boost::any_cast<string>(m["workitemTypeIdentifier"]));
    }
  }


  virtual ~UpdateWorkitemFieldResponseBodyWorkitem() = default;
};
class UpdateWorkitemFieldResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<UpdateWorkitemFieldResponseBodyWorkitem> workitem{};

  UpdateWorkitemFieldResponseBody() {}

  explicit UpdateWorkitemFieldResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (workitem) {
      res["workitem"] = workitem ? boost::any(workitem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("workitem") != m.end() && !m["workitem"].empty()) {
      if (typeid(map<string, boost::any>) == m["workitem"].type()) {
        UpdateWorkitemFieldResponseBodyWorkitem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["workitem"]));
        workitem = make_shared<UpdateWorkitemFieldResponseBodyWorkitem>(model1);
      }
    }
  }


  virtual ~UpdateWorkitemFieldResponseBody() = default;
};
class UpdateWorkitemFieldResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateWorkitemFieldResponseBody> body{};

  UpdateWorkitemFieldResponse() {}

  explicit UpdateWorkitemFieldResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateWorkitemFieldResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateWorkitemFieldResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateWorkitemFieldResponse() = default;
};
class WorkitemAttachmentCreateRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileKey{};
  shared_ptr<string> originalFilename{};

  WorkitemAttachmentCreateRequest() {}

  explicit WorkitemAttachmentCreateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileKey) {
      res["fileKey"] = boost::any(*fileKey);
    }
    if (originalFilename) {
      res["originalFilename"] = boost::any(*originalFilename);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fileKey") != m.end() && !m["fileKey"].empty()) {
      fileKey = make_shared<string>(boost::any_cast<string>(m["fileKey"]));
    }
    if (m.find("originalFilename") != m.end() && !m["originalFilename"].empty()) {
      originalFilename = make_shared<string>(boost::any_cast<string>(m["originalFilename"]));
    }
  }


  virtual ~WorkitemAttachmentCreateRequest() = default;
};
class WorkitemAttachmentCreateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  WorkitemAttachmentCreateResponseBody() {}

  explicit WorkitemAttachmentCreateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["errorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMessage") != m.end() && !m["errorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["errorMessage"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["success"]));
    }
  }


  virtual ~WorkitemAttachmentCreateResponseBody() = default;
};
class WorkitemAttachmentCreateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WorkitemAttachmentCreateResponseBody> body{};

  WorkitemAttachmentCreateResponse() {}

  explicit WorkitemAttachmentCreateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WorkitemAttachmentCreateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WorkitemAttachmentCreateResponseBody>(model1);
      }
    }
  }


  virtual ~WorkitemAttachmentCreateResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddGroupMemberResponse addGroupMemberWithOptions(shared_ptr<string> groupId,
                                                   shared_ptr<AddGroupMemberRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddGroupMemberResponse addGroupMember(shared_ptr<string> groupId, shared_ptr<AddGroupMemberRequest> request);
  AddPipelineRelationsResponse addPipelineRelationsWithOptions(shared_ptr<string> organizationId,
                                                               shared_ptr<string> pipelineId,
                                                               shared_ptr<AddPipelineRelationsRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddPipelineRelationsResponse addPipelineRelations(shared_ptr<string> organizationId, shared_ptr<string> pipelineId, shared_ptr<AddPipelineRelationsRequest> request);
  AddRepositoryMemberResponse addRepositoryMemberWithOptions(shared_ptr<string> repositoryId,
                                                             shared_ptr<AddRepositoryMemberRequest> request,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddRepositoryMemberResponse addRepositoryMember(shared_ptr<string> repositoryId, shared_ptr<AddRepositoryMemberRequest> request);
  AddWebhookResponse addWebhookWithOptions(shared_ptr<string> repositoryId,
                                           shared_ptr<AddWebhookRequest> request,
                                           shared_ptr<map<string, string>> headers,
                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddWebhookResponse addWebhook(shared_ptr<string> repositoryId, shared_ptr<AddWebhookRequest> request);
  CancelExecutionReleaseStageResponse cancelExecutionReleaseStageWithOptions(shared_ptr<string> appName,
                                                                             shared_ptr<string> releaseWorkflowSn,
                                                                             shared_ptr<string> releaseStageSn,
                                                                             shared_ptr<string> executionNumber,
                                                                             shared_ptr<CancelExecutionReleaseStageRequest> request,
                                                                             shared_ptr<map<string, string>> headers,
                                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelExecutionReleaseStageResponse cancelExecutionReleaseStage(shared_ptr<string> appName,
                                                                  shared_ptr<string> releaseWorkflowSn,
                                                                  shared_ptr<string> releaseStageSn,
                                                                  shared_ptr<string> executionNumber,
                                                                  shared_ptr<CancelExecutionReleaseStageRequest> request);
  CloseMergeRequestResponse closeMergeRequestWithOptions(shared_ptr<string> repositoryId,
                                                         shared_ptr<string> localId,
                                                         shared_ptr<CloseMergeRequestRequest> request,
                                                         shared_ptr<map<string, string>> headers,
                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CloseMergeRequestResponse closeMergeRequest(shared_ptr<string> repositoryId, shared_ptr<string> localId, shared_ptr<CloseMergeRequestRequest> request);
  CreateAppMembersResponse createAppMembersWithOptions(shared_ptr<string> appName,
                                                       shared_ptr<CreateAppMembersRequest> request,
                                                       shared_ptr<map<string, string>> headers,
                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAppMembersResponse createAppMembers(shared_ptr<string> appName, shared_ptr<CreateAppMembersRequest> request);
  CreateBranchResponse createBranchWithOptions(shared_ptr<string> repositoryId,
                                               shared_ptr<CreateBranchRequest> request,
                                               shared_ptr<map<string, string>> headers,
                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBranchResponse createBranch(shared_ptr<string> repositoryId, shared_ptr<CreateBranchRequest> request);
  CreateChangeRequestResponse createChangeRequestWithOptions(shared_ptr<string> appName,
                                                             shared_ptr<CreateChangeRequestRequest> request,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateChangeRequestResponse createChangeRequest(shared_ptr<string> appName, shared_ptr<CreateChangeRequestRequest> request);
  CreateCheckRunResponse createCheckRunWithOptions(shared_ptr<CreateCheckRunRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCheckRunResponse createCheckRun(shared_ptr<CreateCheckRunRequest> request);
  CreateCommentResponse createCommentWithOptions(shared_ptr<CreateCommentRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCommentResponse createComment(shared_ptr<CreateCommentRequest> request);
  CreateCommitStatusResponse createCommitStatusWithOptions(shared_ptr<CreateCommitStatusRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCommitStatusResponse createCommitStatus(shared_ptr<CreateCommitStatusRequest> request);
  CreateCommitWithMultipleFilesResponse createCommitWithMultipleFilesWithOptions(shared_ptr<CreateCommitWithMultipleFilesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCommitWithMultipleFilesResponse createCommitWithMultipleFiles(shared_ptr<CreateCommitWithMultipleFilesRequest> request);
  CreateDeployKeyResponse createDeployKeyWithOptions(shared_ptr<string> repositoryId,
                                                     shared_ptr<CreateDeployKeyRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDeployKeyResponse createDeployKey(shared_ptr<string> repositoryId, shared_ptr<CreateDeployKeyRequest> request);
  CreateFileResponse createFileWithOptions(shared_ptr<string> repositoryId,
                                           shared_ptr<CreateFileRequest> request,
                                           shared_ptr<map<string, string>> headers,
                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFileResponse createFile(shared_ptr<string> repositoryId, shared_ptr<CreateFileRequest> request);
  CreateFlowTagResponse createFlowTagWithOptions(shared_ptr<string> organizationId,
                                                 shared_ptr<CreateFlowTagRequest> request,
                                                 shared_ptr<map<string, string>> headers,
                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFlowTagResponse createFlowTag(shared_ptr<string> organizationId, shared_ptr<CreateFlowTagRequest> request);
  CreateFlowTagGroupResponse createFlowTagGroupWithOptions(shared_ptr<string> organizationId,
                                                           shared_ptr<CreateFlowTagGroupRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFlowTagGroupResponse createFlowTagGroup(shared_ptr<string> organizationId, shared_ptr<CreateFlowTagGroupRequest> request);
  CreateHostGroupResponse createHostGroupWithOptions(shared_ptr<string> organizationId,
                                                     shared_ptr<CreateHostGroupRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateHostGroupResponse createHostGroup(shared_ptr<string> organizationId, shared_ptr<CreateHostGroupRequest> request);
  CreateMergeRequestResponse createMergeRequestWithOptions(shared_ptr<string> repositoryId,
                                                           shared_ptr<CreateMergeRequestRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMergeRequestResponse createMergeRequest(shared_ptr<string> repositoryId, shared_ptr<CreateMergeRequestRequest> request);
  CreateOAuthTokenResponse createOAuthTokenWithOptions(shared_ptr<CreateOAuthTokenRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOAuthTokenResponse createOAuthToken(shared_ptr<CreateOAuthTokenRequest> request);
  CreatePipelineResponse createPipelineWithOptions(shared_ptr<string> organizationId,
                                                   shared_ptr<CreatePipelineRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePipelineResponse createPipeline(shared_ptr<string> organizationId, shared_ptr<CreatePipelineRequest> request);
  CreatePipelineGroupResponse createPipelineGroupWithOptions(shared_ptr<string> organizationId,
                                                             shared_ptr<CreatePipelineGroupRequest> request,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePipelineGroupResponse createPipelineGroup(shared_ptr<string> organizationId, shared_ptr<CreatePipelineGroupRequest> request);
  CreateProjectResponse createProjectWithOptions(shared_ptr<string> organizationId,
                                                 shared_ptr<CreateProjectRequest> request,
                                                 shared_ptr<map<string, string>> headers,
                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProjectResponse createProject(shared_ptr<string> organizationId, shared_ptr<CreateProjectRequest> request);
  CreateProjectLabelResponse createProjectLabelWithOptions(shared_ptr<CreateProjectLabelRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProjectLabelResponse createProjectLabel(shared_ptr<CreateProjectLabelRequest> request);
  CreateProtectdBranchResponse createProtectdBranchWithOptions(shared_ptr<string> repositoryId,
                                                               shared_ptr<CreateProtectdBranchRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProtectdBranchResponse createProtectdBranch(shared_ptr<string> repositoryId, shared_ptr<CreateProtectdBranchRequest> request);
  CreatePushRuleResponse createPushRuleWithOptions(shared_ptr<string> repositoryId,
                                                   shared_ptr<CreatePushRuleRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePushRuleResponse createPushRule(shared_ptr<string> repositoryId, shared_ptr<CreatePushRuleRequest> request);
  CreateRepositoryResponse createRepositoryWithOptions(shared_ptr<CreateRepositoryRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRepositoryResponse createRepository(shared_ptr<CreateRepositoryRequest> request);
  CreateRepositoryGroupResponse createRepositoryGroupWithOptions(shared_ptr<CreateRepositoryGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRepositoryGroupResponse createRepositoryGroup(shared_ptr<CreateRepositoryGroupRequest> request);
  CreateResourceMemberResponse createResourceMemberWithOptions(shared_ptr<string> organizationId,
                                                               shared_ptr<string> resourceType,
                                                               shared_ptr<string> resourceId,
                                                               shared_ptr<CreateResourceMemberRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateResourceMemberResponse createResourceMember(shared_ptr<string> organizationId,
                                                    shared_ptr<string> resourceType,
                                                    shared_ptr<string> resourceId,
                                                    shared_ptr<CreateResourceMemberRequest> request);
  CreateServiceAuthResponse createServiceAuthWithOptions(shared_ptr<string> organizationId,
                                                         shared_ptr<CreateServiceAuthRequest> request,
                                                         shared_ptr<map<string, string>> headers,
                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateServiceAuthResponse createServiceAuth(shared_ptr<string> organizationId, shared_ptr<CreateServiceAuthRequest> request);
  CreateServiceConnectionResponse createServiceConnectionWithOptions(shared_ptr<string> organizationId,
                                                                     shared_ptr<CreateServiceConnectionRequest> request,
                                                                     shared_ptr<map<string, string>> headers,
                                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateServiceConnectionResponse createServiceConnection(shared_ptr<string> organizationId, shared_ptr<CreateServiceConnectionRequest> request);
  CreateServiceCredentialResponse createServiceCredentialWithOptions(shared_ptr<string> organizationId,
                                                                     shared_ptr<CreateServiceCredentialRequest> request,
                                                                     shared_ptr<map<string, string>> headers,
                                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateServiceCredentialResponse createServiceCredential(shared_ptr<string> organizationId, shared_ptr<CreateServiceCredentialRequest> request);
  CreateSprintResponse createSprintWithOptions(shared_ptr<string> organizationId,
                                               shared_ptr<CreateSprintRequest> request,
                                               shared_ptr<map<string, string>> headers,
                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSprintResponse createSprint(shared_ptr<string> organizationId, shared_ptr<CreateSprintRequest> request);
  CreateSshKeyResponse createSshKeyWithOptions(shared_ptr<string> organizationId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSshKeyResponse createSshKey(shared_ptr<string> organizationId);
  CreateTagResponse createTagWithOptions(shared_ptr<string> repositoryId,
                                         shared_ptr<CreateTagRequest> request,
                                         shared_ptr<map<string, string>> headers,
                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTagResponse createTag(shared_ptr<string> repositoryId, shared_ptr<CreateTagRequest> request);
  CreateTestCaseResponse createTestCaseWithOptions(shared_ptr<string> organizationId,
                                                   shared_ptr<CreateTestCaseRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTestCaseResponse createTestCase(shared_ptr<string> organizationId, shared_ptr<CreateTestCaseRequest> request);
  CreateUserKeyResponse createUserKeyWithOptions(shared_ptr<CreateUserKeyRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUserKeyResponse createUserKey(shared_ptr<CreateUserKeyRequest> request);
  CreateVariableGroupResponse createVariableGroupWithOptions(shared_ptr<string> organizationId,
                                                             shared_ptr<CreateVariableGroupRequest> request,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVariableGroupResponse createVariableGroup(shared_ptr<string> organizationId, shared_ptr<CreateVariableGroupRequest> request);
  CreateWorkitemResponse createWorkitemWithOptions(shared_ptr<string> organizationId,
                                                   shared_ptr<CreateWorkitemRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateWorkitemResponse createWorkitem(shared_ptr<string> organizationId, shared_ptr<CreateWorkitemRequest> request);
  CreateWorkitemCommentResponse createWorkitemCommentWithOptions(shared_ptr<string> organizationId,
                                                                 shared_ptr<CreateWorkitemCommentRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateWorkitemCommentResponse createWorkitemComment(shared_ptr<string> organizationId, shared_ptr<CreateWorkitemCommentRequest> request);
  CreateWorkitemEstimateResponse createWorkitemEstimateWithOptions(shared_ptr<string> organizationId,
                                                                   shared_ptr<CreateWorkitemEstimateRequest> request,
                                                                   shared_ptr<map<string, string>> headers,
                                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateWorkitemEstimateResponse createWorkitemEstimate(shared_ptr<string> organizationId, shared_ptr<CreateWorkitemEstimateRequest> request);
  CreateWorkitemRecordResponse createWorkitemRecordWithOptions(shared_ptr<string> organizationId,
                                                               shared_ptr<CreateWorkitemRecordRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateWorkitemRecordResponse createWorkitemRecord(shared_ptr<string> organizationId, shared_ptr<CreateWorkitemRecordRequest> request);
  CreateWorkitemV2Response createWorkitemV2WithOptions(shared_ptr<string> organizationId,
                                                       shared_ptr<CreateWorkitemV2Request> request,
                                                       shared_ptr<map<string, string>> headers,
                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateWorkitemV2Response createWorkitemV2(shared_ptr<string> organizationId, shared_ptr<CreateWorkitemV2Request> request);
  CreateWorkspaceResponse createWorkspaceWithOptions(shared_ptr<CreateWorkspaceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateWorkspaceResponse createWorkspace(shared_ptr<CreateWorkspaceRequest> request);
  DeleteAppMemberResponse deleteAppMemberWithOptions(shared_ptr<string> appName,
                                                     shared_ptr<DeleteAppMemberRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAppMemberResponse deleteAppMember(shared_ptr<string> appName, shared_ptr<DeleteAppMemberRequest> request);
  DeleteBranchResponse deleteBranchWithOptions(shared_ptr<string> repositoryId,
                                               shared_ptr<DeleteBranchRequest> request,
                                               shared_ptr<map<string, string>> headers,
                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBranchResponse deleteBranch(shared_ptr<string> repositoryId, shared_ptr<DeleteBranchRequest> request);
  DeleteFileResponse deleteFileWithOptions(shared_ptr<string> repositoryId,
                                           shared_ptr<DeleteFileRequest> request,
                                           shared_ptr<map<string, string>> headers,
                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFileResponse deleteFile(shared_ptr<string> repositoryId, shared_ptr<DeleteFileRequest> request);
  DeleteFlowTagResponse deleteFlowTagWithOptions(shared_ptr<string> organizationId,
                                                 shared_ptr<string> id,
                                                 shared_ptr<map<string, string>> headers,
                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFlowTagResponse deleteFlowTag(shared_ptr<string> organizationId, shared_ptr<string> id);
  DeleteFlowTagGroupResponse deleteFlowTagGroupWithOptions(shared_ptr<string> organizationId,
                                                           shared_ptr<string> id,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFlowTagGroupResponse deleteFlowTagGroup(shared_ptr<string> organizationId, shared_ptr<string> id);
  DeleteGroupMemberResponse deleteGroupMemberWithOptions(shared_ptr<string> groupId,
                                                         shared_ptr<DeleteGroupMemberRequest> request,
                                                         shared_ptr<map<string, string>> headers,
                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteGroupMemberResponse deleteGroupMember(shared_ptr<string> groupId, shared_ptr<DeleteGroupMemberRequest> request);
  DeleteHostGroupResponse deleteHostGroupWithOptions(shared_ptr<string> organizationId,
                                                     shared_ptr<string> id,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteHostGroupResponse deleteHostGroup(shared_ptr<string> organizationId, shared_ptr<string> id);
  DeletePipelineResponse deletePipelineWithOptions(shared_ptr<string> organizationId,
                                                   shared_ptr<string> pipelineId,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePipelineResponse deletePipeline(shared_ptr<string> organizationId, shared_ptr<string> pipelineId);
  DeletePipelineGroupResponse deletePipelineGroupWithOptions(shared_ptr<string> organizationId,
                                                             shared_ptr<string> groupId,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePipelineGroupResponse deletePipelineGroup(shared_ptr<string> organizationId, shared_ptr<string> groupId);
  DeletePipelineRelationsResponse deletePipelineRelationsWithOptions(shared_ptr<string> organizationId,
                                                                     shared_ptr<string> pipelineId,
                                                                     shared_ptr<DeletePipelineRelationsRequest> request,
                                                                     shared_ptr<map<string, string>> headers,
                                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePipelineRelationsResponse deletePipelineRelations(shared_ptr<string> organizationId, shared_ptr<string> pipelineId, shared_ptr<DeletePipelineRelationsRequest> request);
  DeleteProjectResponse deleteProjectWithOptions(shared_ptr<string> organizationId,
                                                 shared_ptr<DeleteProjectRequest> request,
                                                 shared_ptr<map<string, string>> headers,
                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteProjectResponse deleteProject(shared_ptr<string> organizationId, shared_ptr<DeleteProjectRequest> request);
  DeleteProjectLabelResponse deleteProjectLabelWithOptions(shared_ptr<string> labelId,
                                                           shared_ptr<DeleteProjectLabelRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteProjectLabelResponse deleteProjectLabel(shared_ptr<string> labelId, shared_ptr<DeleteProjectLabelRequest> request);
  DeleteProtectedBranchResponse deleteProtectedBranchWithOptions(shared_ptr<string> repositoryId,
                                                                 shared_ptr<string> protectedBranchId,
                                                                 shared_ptr<DeleteProtectedBranchRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteProtectedBranchResponse deleteProtectedBranch(shared_ptr<string> repositoryId, shared_ptr<string> protectedBranchId, shared_ptr<DeleteProtectedBranchRequest> request);
  DeletePushRuleResponse deletePushRuleWithOptions(shared_ptr<string> repositoryId,
                                                   shared_ptr<string> pushRuleId,
                                                   shared_ptr<DeletePushRuleRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePushRuleResponse deletePushRule(shared_ptr<string> repositoryId, shared_ptr<string> pushRuleId, shared_ptr<DeletePushRuleRequest> request);
  DeleteRepositoryResponse deleteRepositoryWithOptions(shared_ptr<string> repositoryId,
                                                       shared_ptr<DeleteRepositoryRequest> request,
                                                       shared_ptr<map<string, string>> headers,
                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRepositoryResponse deleteRepository(shared_ptr<string> repositoryId, shared_ptr<DeleteRepositoryRequest> request);
  DeleteRepositoryGroupResponse deleteRepositoryGroupWithOptions(shared_ptr<string> groupId,
                                                                 shared_ptr<DeleteRepositoryGroupRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRepositoryGroupResponse deleteRepositoryGroup(shared_ptr<string> groupId, shared_ptr<DeleteRepositoryGroupRequest> request);
  DeleteRepositoryMemberResponse deleteRepositoryMemberWithOptions(shared_ptr<string> repositoryId,
                                                                   shared_ptr<string> aliyunPk,
                                                                   shared_ptr<DeleteRepositoryMemberRequest> request,
                                                                   shared_ptr<map<string, string>> headers,
                                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRepositoryMemberResponse deleteRepositoryMember(shared_ptr<string> repositoryId, shared_ptr<string> aliyunPk, shared_ptr<DeleteRepositoryMemberRequest> request);
  DeleteRepositoryWebhookResponse deleteRepositoryWebhookWithOptions(shared_ptr<string> repositoryId,
                                                                     shared_ptr<string> hookId,
                                                                     shared_ptr<DeleteRepositoryWebhookRequest> request,
                                                                     shared_ptr<map<string, string>> headers,
                                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRepositoryWebhookResponse deleteRepositoryWebhook(shared_ptr<string> repositoryId, shared_ptr<string> hookId, shared_ptr<DeleteRepositoryWebhookRequest> request);
  DeleteResourceMemberResponse deleteResourceMemberWithOptions(shared_ptr<string> organizationId,
                                                               shared_ptr<string> resourceType,
                                                               shared_ptr<string> resourceId,
                                                               shared_ptr<string> accountId,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteResourceMemberResponse deleteResourceMember(shared_ptr<string> organizationId,
                                                    shared_ptr<string> resourceType,
                                                    shared_ptr<string> resourceId,
                                                    shared_ptr<string> accountId);
  DeleteTagResponse deleteTagWithOptions(shared_ptr<string> repositoryId,
                                         shared_ptr<DeleteTagRequest> request,
                                         shared_ptr<map<string, string>> headers,
                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTagResponse deleteTag(shared_ptr<string> repositoryId, shared_ptr<DeleteTagRequest> request);
  DeleteUserKeyResponse deleteUserKeyWithOptions(shared_ptr<string> keyId,
                                                 shared_ptr<DeleteUserKeyRequest> request,
                                                 shared_ptr<map<string, string>> headers,
                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteUserKeyResponse deleteUserKey(shared_ptr<string> keyId, shared_ptr<DeleteUserKeyRequest> request);
  DeleteVariableGroupResponse deleteVariableGroupWithOptions(shared_ptr<string> organizationId,
                                                             shared_ptr<string> id,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVariableGroupResponse deleteVariableGroup(shared_ptr<string> organizationId, shared_ptr<string> id);
  DeleteWorkitemResponse deleteWorkitemWithOptions(shared_ptr<string> organizationId,
                                                   shared_ptr<DeleteWorkitemRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWorkitemResponse deleteWorkitem(shared_ptr<string> organizationId, shared_ptr<DeleteWorkitemRequest> request);
  DeleteWorkitemAllCommentResponse deleteWorkitemAllCommentWithOptions(shared_ptr<string> organizationId,
                                                                       shared_ptr<DeleteWorkitemAllCommentRequest> request,
                                                                       shared_ptr<map<string, string>> headers,
                                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWorkitemAllCommentResponse deleteWorkitemAllComment(shared_ptr<string> organizationId, shared_ptr<DeleteWorkitemAllCommentRequest> request);
  DeleteWorkitemCommentResponse deleteWorkitemCommentWithOptions(shared_ptr<string> organizationId,
                                                                 shared_ptr<DeleteWorkitemCommentRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWorkitemCommentResponse deleteWorkitemComment(shared_ptr<string> organizationId, shared_ptr<DeleteWorkitemCommentRequest> request);
  EnableDeployKeyResponse enableDeployKeyWithOptions(shared_ptr<string> repositoryId,
                                                     shared_ptr<string> keyId,
                                                     shared_ptr<EnableDeployKeyRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableDeployKeyResponse enableDeployKey(shared_ptr<string> repositoryId, shared_ptr<string> keyId, shared_ptr<EnableDeployKeyRequest> request);
  ExecuteChangeRequestReleaseStageResponse executeChangeRequestReleaseStageWithOptions(shared_ptr<string> appName,
                                                                                       shared_ptr<string> releaseWorkflowSn,
                                                                                       shared_ptr<string> releaseStageSn,
                                                                                       shared_ptr<ExecuteChangeRequestReleaseStageRequest> request,
                                                                                       shared_ptr<map<string, string>> headers,
                                                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExecuteChangeRequestReleaseStageResponse executeChangeRequestReleaseStage(shared_ptr<string> appName,
                                                                            shared_ptr<string> releaseWorkflowSn,
                                                                            shared_ptr<string> releaseStageSn,
                                                                            shared_ptr<ExecuteChangeRequestReleaseStageRequest> request);
  ExportInsightCustomValueResponse exportInsightCustomValueWithOptions(shared_ptr<string> organizationId,
                                                                       shared_ptr<ExportInsightCustomValueRequest> request,
                                                                       shared_ptr<map<string, string>> headers,
                                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportInsightCustomValueResponse exportInsightCustomValue(shared_ptr<string> organizationId, shared_ptr<ExportInsightCustomValueRequest> request);
  ExportInsightExpectedWorkTimeResponse exportInsightExpectedWorkTimeWithOptions(shared_ptr<string> organizationId,
                                                                                 shared_ptr<ExportInsightExpectedWorkTimeRequest> request,
                                                                                 shared_ptr<map<string, string>> headers,
                                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportInsightExpectedWorkTimeResponse exportInsightExpectedWorkTime(shared_ptr<string> organizationId, shared_ptr<ExportInsightExpectedWorkTimeRequest> request);
  ExportInsightFieldResponse exportInsightFieldWithOptions(shared_ptr<string> organizationId,
                                                           shared_ptr<ExportInsightFieldRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportInsightFieldResponse exportInsightField(shared_ptr<string> organizationId, shared_ptr<ExportInsightFieldRequest> request);
  ExportInsightSpaceResponse exportInsightSpaceWithOptions(shared_ptr<string> organizationId,
                                                           shared_ptr<ExportInsightSpaceRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportInsightSpaceResponse exportInsightSpace(shared_ptr<string> organizationId, shared_ptr<ExportInsightSpaceRequest> request);
  ExportInsightSpaceRefResponse exportInsightSpaceRefWithOptions(shared_ptr<string> organizationId,
                                                                 shared_ptr<ExportInsightSpaceRefRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportInsightSpaceRefResponse exportInsightSpaceRef(shared_ptr<string> organizationId, shared_ptr<ExportInsightSpaceRefRequest> request);
  ExportInsightSprintResponse exportInsightSprintWithOptions(shared_ptr<string> organizationId,
                                                             shared_ptr<ExportInsightSprintRequest> request,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportInsightSprintResponse exportInsightSprint(shared_ptr<string> organizationId, shared_ptr<ExportInsightSprintRequest> request);
  ExportInsightTagRefResponse exportInsightTagRefWithOptions(shared_ptr<string> organizationId,
                                                             shared_ptr<ExportInsightTagRefRequest> request,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportInsightTagRefResponse exportInsightTagRef(shared_ptr<string> organizationId, shared_ptr<ExportInsightTagRefRequest> request);
  ExportInsightWorkTimeResponse exportInsightWorkTimeWithOptions(shared_ptr<string> organizationId,
                                                                 shared_ptr<ExportInsightWorkTimeRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportInsightWorkTimeResponse exportInsightWorkTime(shared_ptr<string> organizationId, shared_ptr<ExportInsightWorkTimeRequest> request);
  ExportInsightWorkitemStatusResponse exportInsightWorkitemStatusWithOptions(shared_ptr<string> organizationId,
                                                                             shared_ptr<ExportInsightWorkitemStatusRequest> request,
                                                                             shared_ptr<map<string, string>> headers,
                                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportInsightWorkitemStatusResponse exportInsightWorkitemStatus(shared_ptr<string> organizationId, shared_ptr<ExportInsightWorkitemStatusRequest> request);
  ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponse exportInsightWorkitemStatusJoinWorkitemDefectExtraWithOptions(shared_ptr<string> organizationId,
                                                                                                                           shared_ptr<ExportInsightWorkitemStatusJoinWorkitemDefectExtraRequest> request,
                                                                                                                           shared_ptr<map<string, string>> headers,
                                                                                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponse exportInsightWorkitemStatusJoinWorkitemDefectExtra(shared_ptr<string> organizationId, shared_ptr<ExportInsightWorkitemStatusJoinWorkitemDefectExtraRequest> request);
  ExportInsightWorkitemVersionResponse exportInsightWorkitemVersionWithOptions(shared_ptr<string> organizationId,
                                                                               shared_ptr<ExportInsightWorkitemVersionRequest> request,
                                                                               shared_ptr<map<string, string>> headers,
                                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportInsightWorkitemVersionResponse exportInsightWorkitemVersion(shared_ptr<string> organizationId, shared_ptr<ExportInsightWorkitemVersionRequest> request);
  ExportWorkitemActivityResponse exportWorkitemActivityWithOptions(shared_ptr<string> organizationId,
                                                                   shared_ptr<ExportWorkitemActivityRequest> request,
                                                                   shared_ptr<map<string, string>> headers,
                                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportWorkitemActivityResponse exportWorkitemActivity(shared_ptr<string> organizationId, shared_ptr<ExportWorkitemActivityRequest> request);
  FrozenWorkspaceResponse frozenWorkspaceWithOptions(shared_ptr<string> workspaceId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FrozenWorkspaceResponse frozenWorkspace(shared_ptr<string> workspaceId);
  GetApplicationResponse getApplicationWithOptions(shared_ptr<string> appName,
                                                   shared_ptr<GetApplicationRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetApplicationResponse getApplication(shared_ptr<string> appName, shared_ptr<GetApplicationRequest> request);
  GetBranchInfoResponse getBranchInfoWithOptions(shared_ptr<string> repositoryId,
                                                 shared_ptr<GetBranchInfoRequest> request,
                                                 shared_ptr<map<string, string>> headers,
                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBranchInfoResponse getBranchInfo(shared_ptr<string> repositoryId, shared_ptr<GetBranchInfoRequest> request);
  GetCheckRunResponse getCheckRunWithOptions(shared_ptr<GetCheckRunRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCheckRunResponse getCheckRun(shared_ptr<GetCheckRunRequest> request);
  GetCodeupOrganizationResponse getCodeupOrganizationWithOptions(shared_ptr<string> identity,
                                                                 shared_ptr<GetCodeupOrganizationRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCodeupOrganizationResponse getCodeupOrganization(shared_ptr<string> identity, shared_ptr<GetCodeupOrganizationRequest> request);
  GetCompareDetailResponse getCompareDetailWithOptions(shared_ptr<string> repositoryId,
                                                       shared_ptr<GetCompareDetailRequest> request,
                                                       shared_ptr<map<string, string>> headers,
                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCompareDetailResponse getCompareDetail(shared_ptr<string> repositoryId, shared_ptr<GetCompareDetailRequest> request);
  GetCustomFieldOptionResponse getCustomFieldOptionWithOptions(shared_ptr<string> organizationId,
                                                               shared_ptr<string> fieldId,
                                                               shared_ptr<GetCustomFieldOptionRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCustomFieldOptionResponse getCustomFieldOption(shared_ptr<string> organizationId, shared_ptr<string> fieldId, shared_ptr<GetCustomFieldOptionRequest> request);
  GetFileBlobsResponse getFileBlobsWithOptions(shared_ptr<string> repositoryId,
                                               shared_ptr<GetFileBlobsRequest> request,
                                               shared_ptr<map<string, string>> headers,
                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFileBlobsResponse getFileBlobs(shared_ptr<string> repositoryId, shared_ptr<GetFileBlobsRequest> request);
  GetFileLastCommitResponse getFileLastCommitWithOptions(shared_ptr<string> repositoryId,
                                                         shared_ptr<GetFileLastCommitRequest> request,
                                                         shared_ptr<map<string, string>> headers,
                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFileLastCommitResponse getFileLastCommit(shared_ptr<string> repositoryId, shared_ptr<GetFileLastCommitRequest> request);
  GetFlowTagGroupResponse getFlowTagGroupWithOptions(shared_ptr<string> organizationId,
                                                     shared_ptr<string> id,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFlowTagGroupResponse getFlowTagGroup(shared_ptr<string> organizationId, shared_ptr<string> id);
  GetGroupByPathResponse getGroupByPathWithOptions(shared_ptr<GetGroupByPathRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetGroupByPathResponse getGroupByPath(shared_ptr<GetGroupByPathRequest> request);
  GetGroupDetailResponse getGroupDetailWithOptions(shared_ptr<GetGroupDetailRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetGroupDetailResponse getGroupDetail(shared_ptr<GetGroupDetailRequest> request);
  GetHostGroupResponse getHostGroupWithOptions(shared_ptr<string> organizationId,
                                               shared_ptr<string> id,
                                               shared_ptr<map<string, string>> headers,
                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetHostGroupResponse getHostGroup(shared_ptr<string> organizationId, shared_ptr<string> id);
  GetMergeRequestResponse getMergeRequestWithOptions(shared_ptr<string> repositoryId,
                                                     shared_ptr<string> localId,
                                                     shared_ptr<GetMergeRequestRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMergeRequestResponse getMergeRequest(shared_ptr<string> repositoryId, shared_ptr<string> localId, shared_ptr<GetMergeRequestRequest> request);
  GetMergeRequestChangeTreeResponse getMergeRequestChangeTreeWithOptions(shared_ptr<GetMergeRequestChangeTreeRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMergeRequestChangeTreeResponse getMergeRequestChangeTree(shared_ptr<GetMergeRequestChangeTreeRequest> request);
  GetOrganizationMemberResponse getOrganizationMemberWithOptions(shared_ptr<string> organizationId,
                                                                 shared_ptr<string> accountId,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOrganizationMemberResponse getOrganizationMember(shared_ptr<string> organizationId, shared_ptr<string> accountId);
  GetPipelineResponse getPipelineWithOptions(shared_ptr<string> organizationId,
                                             shared_ptr<string> pipelineId,
                                             shared_ptr<map<string, string>> headers,
                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPipelineResponse getPipeline(shared_ptr<string> organizationId, shared_ptr<string> pipelineId);
  GetPipelineArtifactUrlResponse getPipelineArtifactUrlWithOptions(shared_ptr<string> organizationId,
                                                                   shared_ptr<GetPipelineArtifactUrlRequest> request,
                                                                   shared_ptr<map<string, string>> headers,
                                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPipelineArtifactUrlResponse getPipelineArtifactUrl(shared_ptr<string> organizationId, shared_ptr<GetPipelineArtifactUrlRequest> request);
  GetPipelineEmasArtifactUrlResponse getPipelineEmasArtifactUrlWithOptions(shared_ptr<string> organizationId,
                                                                           shared_ptr<string> emasJobInstanceId,
                                                                           shared_ptr<string> md5,
                                                                           shared_ptr<string> pipelineId,
                                                                           shared_ptr<string> pipelineRunId,
                                                                           shared_ptr<GetPipelineEmasArtifactUrlRequest> request,
                                                                           shared_ptr<map<string, string>> headers,
                                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPipelineEmasArtifactUrlResponse getPipelineEmasArtifactUrl(shared_ptr<string> organizationId,
                                                                shared_ptr<string> emasJobInstanceId,
                                                                shared_ptr<string> md5,
                                                                shared_ptr<string> pipelineId,
                                                                shared_ptr<string> pipelineRunId,
                                                                shared_ptr<GetPipelineEmasArtifactUrlRequest> request);
  GetPipelineGroupResponse getPipelineGroupWithOptions(shared_ptr<string> organizationId,
                                                       shared_ptr<string> groupId,
                                                       shared_ptr<map<string, string>> headers,
                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPipelineGroupResponse getPipelineGroup(shared_ptr<string> organizationId, shared_ptr<string> groupId);
  GetPipelineRunResponse getPipelineRunWithOptions(shared_ptr<string> organizationId,
                                                   shared_ptr<string> pipelineId,
                                                   shared_ptr<string> pipelineRunId,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPipelineRunResponse getPipelineRun(shared_ptr<string> organizationId, shared_ptr<string> pipelineId, shared_ptr<string> pipelineRunId);
  GetPipelineScanReportUrlResponse getPipelineScanReportUrlWithOptions(shared_ptr<string> organizationId,
                                                                       shared_ptr<GetPipelineScanReportUrlRequest> request,
                                                                       shared_ptr<map<string, string>> headers,
                                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPipelineScanReportUrlResponse getPipelineScanReportUrl(shared_ptr<string> organizationId, shared_ptr<GetPipelineScanReportUrlRequest> request);
  GetProjectInfoResponse getProjectInfoWithOptions(shared_ptr<string> organizationId,
                                                   shared_ptr<string> projectId,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetProjectInfoResponse getProjectInfo(shared_ptr<string> organizationId, shared_ptr<string> projectId);
  GetProjectMemberResponse getProjectMemberWithOptions(shared_ptr<string> repositoryId,
                                                       shared_ptr<string> aliyunPk,
                                                       shared_ptr<GetProjectMemberRequest> request,
                                                       shared_ptr<map<string, string>> headers,
                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetProjectMemberResponse getProjectMember(shared_ptr<string> repositoryId, shared_ptr<string> aliyunPk, shared_ptr<GetProjectMemberRequest> request);
  GetPushRuleResponse getPushRuleWithOptions(shared_ptr<string> repositoryId,
                                             shared_ptr<string> pushRuleId,
                                             shared_ptr<GetPushRuleRequest> request,
                                             shared_ptr<map<string, string>> headers,
                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPushRuleResponse getPushRule(shared_ptr<string> repositoryId, shared_ptr<string> pushRuleId, shared_ptr<GetPushRuleRequest> request);
  GetReleaseStagePipelineRunResponse getReleaseStagePipelineRunWithOptions(shared_ptr<string> appName,
                                                                           shared_ptr<string> releaseWorkflowSn,
                                                                           shared_ptr<string> releaseStageSn,
                                                                           shared_ptr<string> executionNumber,
                                                                           shared_ptr<GetReleaseStagePipelineRunRequest> request,
                                                                           shared_ptr<map<string, string>> headers,
                                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetReleaseStagePipelineRunResponse getReleaseStagePipelineRun(shared_ptr<string> appName,
                                                                shared_ptr<string> releaseWorkflowSn,
                                                                shared_ptr<string> releaseStageSn,
                                                                shared_ptr<string> executionNumber,
                                                                shared_ptr<GetReleaseStagePipelineRunRequest> request);
  GetRepositoryResponse getRepositoryWithOptions(shared_ptr<GetRepositoryRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRepositoryResponse getRepository(shared_ptr<GetRepositoryRequest> request);
  GetRepositoryCommitResponse getRepositoryCommitWithOptions(shared_ptr<string> repositoryId,
                                                             shared_ptr<string> sha,
                                                             shared_ptr<GetRepositoryCommitRequest> request,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRepositoryCommitResponse getRepositoryCommit(shared_ptr<string> repositoryId, shared_ptr<string> sha, shared_ptr<GetRepositoryCommitRequest> request);
  GetRepositoryTagResponse getRepositoryTagWithOptions(shared_ptr<string> repositoryId,
                                                       shared_ptr<GetRepositoryTagRequest> request,
                                                       shared_ptr<map<string, string>> headers,
                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRepositoryTagResponse getRepositoryTag(shared_ptr<string> repositoryId, shared_ptr<GetRepositoryTagRequest> request);
  GetSearchCodePreviewResponse getSearchCodePreviewWithOptions(shared_ptr<GetSearchCodePreviewRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSearchCodePreviewResponse getSearchCodePreview(shared_ptr<GetSearchCodePreviewRequest> request);
  GetSprintInfoResponse getSprintInfoWithOptions(shared_ptr<string> organizationId,
                                                 shared_ptr<string> sprintId,
                                                 shared_ptr<map<string, string>> headers,
                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSprintInfoResponse getSprintInfo(shared_ptr<string> organizationId, shared_ptr<string> sprintId);
  GetTestResultListResponse getTestResultListWithOptions(shared_ptr<string> organizationId,
                                                         shared_ptr<string> testPlanIdentifier,
                                                         shared_ptr<GetTestResultListRequest> request,
                                                         shared_ptr<map<string, string>> headers,
                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTestResultListResponse getTestResultList(shared_ptr<string> organizationId, shared_ptr<string> testPlanIdentifier, shared_ptr<GetTestResultListRequest> request);
  GetTestcaseListResponse getTestcaseListWithOptions(shared_ptr<string> organizationId,
                                                     shared_ptr<GetTestcaseListRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTestcaseListResponse getTestcaseList(shared_ptr<string> organizationId, shared_ptr<GetTestcaseListRequest> request);
  GetUserInfoResponse getUserInfoWithOptions(shared_ptr<GetUserInfoRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUserInfoResponse getUserInfo(shared_ptr<GetUserInfoRequest> request);
  GetVMDeployOrderResponse getVMDeployOrderWithOptions(shared_ptr<string> organizationId,
                                                       shared_ptr<string> pipelineId,
                                                       shared_ptr<string> deployOrderId,
                                                       shared_ptr<map<string, string>> headers,
                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVMDeployOrderResponse getVMDeployOrder(shared_ptr<string> organizationId, shared_ptr<string> pipelineId, shared_ptr<string> deployOrderId);
  GetVariableGroupResponse getVariableGroupWithOptions(shared_ptr<string> organizationId,
                                                       shared_ptr<string> id,
                                                       shared_ptr<map<string, string>> headers,
                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVariableGroupResponse getVariableGroup(shared_ptr<string> organizationId, shared_ptr<string> id);
  GetWorkItemActivityResponse getWorkItemActivityWithOptions(shared_ptr<string> organizationId,
                                                             shared_ptr<string> workitemId,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWorkItemActivityResponse getWorkItemActivity(shared_ptr<string> organizationId, shared_ptr<string> workitemId);
  GetWorkItemInfoResponse getWorkItemInfoWithOptions(shared_ptr<string> organizationId,
                                                     shared_ptr<string> workitemId,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWorkItemInfoResponse getWorkItemInfo(shared_ptr<string> organizationId, shared_ptr<string> workitemId);
  GetWorkItemWorkFlowInfoResponse getWorkItemWorkFlowInfoWithOptions(shared_ptr<string> organizationId,
                                                                     shared_ptr<string> workitemId,
                                                                     shared_ptr<GetWorkItemWorkFlowInfoRequest> request,
                                                                     shared_ptr<map<string, string>> headers,
                                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWorkItemWorkFlowInfoResponse getWorkItemWorkFlowInfo(shared_ptr<string> organizationId, shared_ptr<string> workitemId, shared_ptr<GetWorkItemWorkFlowInfoRequest> request);
  GetWorkitemAttachmentCreatemetaResponse getWorkitemAttachmentCreatemetaWithOptions(shared_ptr<string> organizationId,
                                                                                     shared_ptr<string> workitemIdentifier,
                                                                                     shared_ptr<GetWorkitemAttachmentCreatemetaRequest> request,
                                                                                     shared_ptr<map<string, string>> headers,
                                                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWorkitemAttachmentCreatemetaResponse getWorkitemAttachmentCreatemeta(shared_ptr<string> organizationId, shared_ptr<string> workitemIdentifier, shared_ptr<GetWorkitemAttachmentCreatemetaRequest> request);
  GetWorkitemCommentListResponse getWorkitemCommentListWithOptions(shared_ptr<string> organizationId,
                                                                   shared_ptr<string> workitemId,
                                                                   shared_ptr<map<string, string>> headers,
                                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWorkitemCommentListResponse getWorkitemCommentList(shared_ptr<string> organizationId, shared_ptr<string> workitemId);
  GetWorkitemFileResponse getWorkitemFileWithOptions(shared_ptr<string> organizationId,
                                                     shared_ptr<string> workitemIdentifier,
                                                     shared_ptr<string> fileIdentifier,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWorkitemFileResponse getWorkitemFile(shared_ptr<string> organizationId, shared_ptr<string> workitemIdentifier, shared_ptr<string> fileIdentifier);
  GetWorkitemRelationsResponse getWorkitemRelationsWithOptions(shared_ptr<string> organizationId,
                                                               shared_ptr<string> workitemId,
                                                               shared_ptr<GetWorkitemRelationsRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWorkitemRelationsResponse getWorkitemRelations(shared_ptr<string> organizationId, shared_ptr<string> workitemId, shared_ptr<GetWorkitemRelationsRequest> request);
  GetWorkitemTimeTypeListResponse getWorkitemTimeTypeListWithOptions(shared_ptr<string> organizationId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWorkitemTimeTypeListResponse getWorkitemTimeTypeList(shared_ptr<string> organizationId);
  GetWorkspaceResponse getWorkspaceWithOptions(shared_ptr<string> workspaceId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWorkspaceResponse getWorkspace(shared_ptr<string> workspaceId);
  JoinPipelineGroupResponse joinPipelineGroupWithOptions(shared_ptr<string> organizationId,
                                                         shared_ptr<JoinPipelineGroupRequest> request,
                                                         shared_ptr<map<string, string>> headers,
                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  JoinPipelineGroupResponse joinPipelineGroup(shared_ptr<string> organizationId, shared_ptr<JoinPipelineGroupRequest> request);
  LinkMergeRequestLabelResponse linkMergeRequestLabelWithOptions(shared_ptr<LinkMergeRequestLabelRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  LinkMergeRequestLabelResponse linkMergeRequestLabel(shared_ptr<LinkMergeRequestLabelRequest> request);
  ListAllReleaseWorkflowsResponse listAllReleaseWorkflowsWithOptions(shared_ptr<string> appName,
                                                                     shared_ptr<ListAllReleaseWorkflowsRequest> request,
                                                                     shared_ptr<map<string, string>> headers,
                                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAllReleaseWorkflowsResponse listAllReleaseWorkflows(shared_ptr<string> appName, shared_ptr<ListAllReleaseWorkflowsRequest> request);
  ListAppReleaseStageExecutionIntegratedMetadataResponse listAppReleaseStageExecutionIntegratedMetadataWithOptions(shared_ptr<string> appName,
                                                                                                                   shared_ptr<string> releaseWorkflowSn,
                                                                                                                   shared_ptr<string> releaseStageSn,
                                                                                                                   shared_ptr<string> executionNumber,
                                                                                                                   shared_ptr<ListAppReleaseStageExecutionIntegratedMetadataRequest> request,
                                                                                                                   shared_ptr<map<string, string>> headers,
                                                                                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAppReleaseStageExecutionIntegratedMetadataResponse listAppReleaseStageExecutionIntegratedMetadata(shared_ptr<string> appName,
                                                                                                        shared_ptr<string> releaseWorkflowSn,
                                                                                                        shared_ptr<string> releaseStageSn,
                                                                                                        shared_ptr<string> executionNumber,
                                                                                                        shared_ptr<ListAppReleaseStageExecutionIntegratedMetadataRequest> request);
  ListAppReleaseStageExecutionsResponse listAppReleaseStageExecutionsWithOptions(shared_ptr<string> appName,
                                                                                 shared_ptr<string> releaseWorkflowSn,
                                                                                 shared_ptr<string> releaseStageSn,
                                                                                 shared_ptr<ListAppReleaseStageExecutionsRequest> request,
                                                                                 shared_ptr<map<string, string>> headers,
                                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAppReleaseStageExecutionsResponse listAppReleaseStageExecutions(shared_ptr<string> appName,
                                                                      shared_ptr<string> releaseWorkflowSn,
                                                                      shared_ptr<string> releaseStageSn,
                                                                      shared_ptr<ListAppReleaseStageExecutionsRequest> request);
  ListApplicationMembersResponse listApplicationMembersWithOptions(shared_ptr<string> appName,
                                                                   shared_ptr<ListApplicationMembersRequest> request,
                                                                   shared_ptr<map<string, string>> headers,
                                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListApplicationMembersResponse listApplicationMembers(shared_ptr<string> appName, shared_ptr<ListApplicationMembersRequest> request);
  ListApplicationsResponse listApplicationsWithOptions(shared_ptr<ListApplicationsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListApplicationsResponse listApplications(shared_ptr<ListApplicationsRequest> request);
  ListChangeRequestWorkflowExecutionsResponse listChangeRequestWorkflowExecutionsWithOptions(shared_ptr<string> appName,
                                                                                             shared_ptr<string> sn,
                                                                                             shared_ptr<ListChangeRequestWorkflowExecutionsRequest> request,
                                                                                             shared_ptr<map<string, string>> headers,
                                                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListChangeRequestWorkflowExecutionsResponse listChangeRequestWorkflowExecutions(shared_ptr<string> appName, shared_ptr<string> sn, shared_ptr<ListChangeRequestWorkflowExecutionsRequest> request);
  ListChangeRequestsResponse listChangeRequestsWithOptions(shared_ptr<string> appName,
                                                           shared_ptr<ListChangeRequestsRequest> tmpReq,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListChangeRequestsResponse listChangeRequests(shared_ptr<string> appName, shared_ptr<ListChangeRequestsRequest> request);
  ListCheckRunsResponse listCheckRunsWithOptions(shared_ptr<ListCheckRunsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCheckRunsResponse listCheckRuns(shared_ptr<ListCheckRunsRequest> request);
  ListCommitStatusesResponse listCommitStatusesWithOptions(shared_ptr<ListCommitStatusesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCommitStatusesResponse listCommitStatuses(shared_ptr<ListCommitStatusesRequest> request);
  ListFlowTagGroupsResponse listFlowTagGroupsWithOptions(shared_ptr<string> organizationId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowTagGroupsResponse listFlowTagGroups(shared_ptr<string> organizationId);
  ListGroupMemberResponse listGroupMemberWithOptions(shared_ptr<string> groupId,
                                                     shared_ptr<ListGroupMemberRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListGroupMemberResponse listGroupMember(shared_ptr<string> groupId, shared_ptr<ListGroupMemberRequest> request);
  ListGroupRepositoriesResponse listGroupRepositoriesWithOptions(shared_ptr<string> groupId,
                                                                 shared_ptr<ListGroupRepositoriesRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListGroupRepositoriesResponse listGroupRepositories(shared_ptr<string> groupId, shared_ptr<ListGroupRepositoriesRequest> request);
  ListHostGroupsResponse listHostGroupsWithOptions(shared_ptr<string> organizationId,
                                                   shared_ptr<ListHostGroupsRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHostGroupsResponse listHostGroups(shared_ptr<string> organizationId, shared_ptr<ListHostGroupsRequest> request);
  ListJoinedOrganizationsResponse listJoinedOrganizationsWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListJoinedOrganizationsResponse listJoinedOrganizations();
  ListMergeRequestCommentsResponse listMergeRequestCommentsWithOptions(shared_ptr<ListMergeRequestCommentsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMergeRequestCommentsResponse listMergeRequestComments(shared_ptr<ListMergeRequestCommentsRequest> request);
  ListMergeRequestFilesReadsResponse listMergeRequestFilesReadsWithOptions(shared_ptr<ListMergeRequestFilesReadsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMergeRequestFilesReadsResponse listMergeRequestFilesReads(shared_ptr<ListMergeRequestFilesReadsRequest> request);
  ListMergeRequestLabelsResponse listMergeRequestLabelsWithOptions(shared_ptr<ListMergeRequestLabelsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMergeRequestLabelsResponse listMergeRequestLabels(shared_ptr<ListMergeRequestLabelsRequest> request);
  ListMergeRequestPatchSetsResponse listMergeRequestPatchSetsWithOptions(shared_ptr<ListMergeRequestPatchSetsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMergeRequestPatchSetsResponse listMergeRequestPatchSets(shared_ptr<ListMergeRequestPatchSetsRequest> request);
  ListMergeRequestsResponse listMergeRequestsWithOptions(shared_ptr<ListMergeRequestsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMergeRequestsResponse listMergeRequests(shared_ptr<ListMergeRequestsRequest> request);
  ListOrganizationMembersResponse listOrganizationMembersWithOptions(shared_ptr<string> organizationId,
                                                                     shared_ptr<ListOrganizationMembersRequest> request,
                                                                     shared_ptr<map<string, string>> headers,
                                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOrganizationMembersResponse listOrganizationMembers(shared_ptr<string> organizationId, shared_ptr<ListOrganizationMembersRequest> request);
  ListOrganizationsResponse listOrganizationsWithOptions(shared_ptr<ListOrganizationsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOrganizationsResponse listOrganizations(shared_ptr<ListOrganizationsRequest> request);
  ListPipelineGroupPipelinesResponse listPipelineGroupPipelinesWithOptions(shared_ptr<string> organizationId,
                                                                           shared_ptr<string> groupId,
                                                                           shared_ptr<ListPipelineGroupPipelinesRequest> request,
                                                                           shared_ptr<map<string, string>> headers,
                                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPipelineGroupPipelinesResponse listPipelineGroupPipelines(shared_ptr<string> organizationId, shared_ptr<string> groupId, shared_ptr<ListPipelineGroupPipelinesRequest> request);
  ListPipelineGroupsResponse listPipelineGroupsWithOptions(shared_ptr<string> organizationId,
                                                           shared_ptr<ListPipelineGroupsRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPipelineGroupsResponse listPipelineGroups(shared_ptr<string> organizationId, shared_ptr<ListPipelineGroupsRequest> request);
  ListPipelineJobHistorysResponse listPipelineJobHistorysWithOptions(shared_ptr<string> organizationId,
                                                                     shared_ptr<string> pipelineId,
                                                                     shared_ptr<ListPipelineJobHistorysRequest> request,
                                                                     shared_ptr<map<string, string>> headers,
                                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPipelineJobHistorysResponse listPipelineJobHistorys(shared_ptr<string> organizationId, shared_ptr<string> pipelineId, shared_ptr<ListPipelineJobHistorysRequest> request);
  ListPipelineJobsResponse listPipelineJobsWithOptions(shared_ptr<string> organizationId,
                                                       shared_ptr<string> pipelineId,
                                                       shared_ptr<ListPipelineJobsRequest> request,
                                                       shared_ptr<map<string, string>> headers,
                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPipelineJobsResponse listPipelineJobs(shared_ptr<string> organizationId, shared_ptr<string> pipelineId, shared_ptr<ListPipelineJobsRequest> request);
  ListPipelineRelationsResponse listPipelineRelationsWithOptions(shared_ptr<string> organizationId,
                                                                 shared_ptr<string> pipelineId,
                                                                 shared_ptr<ListPipelineRelationsRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPipelineRelationsResponse listPipelineRelations(shared_ptr<string> organizationId, shared_ptr<string> pipelineId, shared_ptr<ListPipelineRelationsRequest> request);
  ListPipelineRunsResponse listPipelineRunsWithOptions(shared_ptr<string> organizationId,
                                                       shared_ptr<string> pipelineId,
                                                       shared_ptr<ListPipelineRunsRequest> request,
                                                       shared_ptr<map<string, string>> headers,
                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPipelineRunsResponse listPipelineRuns(shared_ptr<string> organizationId, shared_ptr<string> pipelineId, shared_ptr<ListPipelineRunsRequest> request);
  ListPipelinesResponse listPipelinesWithOptions(shared_ptr<string> organizationId,
                                                 shared_ptr<ListPipelinesRequest> request,
                                                 shared_ptr<map<string, string>> headers,
                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPipelinesResponse listPipelines(shared_ptr<string> organizationId, shared_ptr<ListPipelinesRequest> request);
  ListProjectLabelsResponse listProjectLabelsWithOptions(shared_ptr<ListProjectLabelsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProjectLabelsResponse listProjectLabels(shared_ptr<ListProjectLabelsRequest> request);
  ListProjectMembersResponse listProjectMembersWithOptions(shared_ptr<string> organizationId,
                                                           shared_ptr<string> projectId,
                                                           shared_ptr<ListProjectMembersRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProjectMembersResponse listProjectMembers(shared_ptr<string> organizationId, shared_ptr<string> projectId, shared_ptr<ListProjectMembersRequest> request);
  ListProjectTemplatesResponse listProjectTemplatesWithOptions(shared_ptr<string> organizationId,
                                                               shared_ptr<ListProjectTemplatesRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProjectTemplatesResponse listProjectTemplates(shared_ptr<string> organizationId, shared_ptr<ListProjectTemplatesRequest> request);
  ListProjectWorkitemTypesResponse listProjectWorkitemTypesWithOptions(shared_ptr<string> organizationId,
                                                                       shared_ptr<string> projectId,
                                                                       shared_ptr<ListProjectWorkitemTypesRequest> request,
                                                                       shared_ptr<map<string, string>> headers,
                                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProjectWorkitemTypesResponse listProjectWorkitemTypes(shared_ptr<string> organizationId, shared_ptr<string> projectId, shared_ptr<ListProjectWorkitemTypesRequest> request);
  ListProjectsResponse listProjectsWithOptions(shared_ptr<string> organizationId,
                                               shared_ptr<ListProjectsRequest> request,
                                               shared_ptr<map<string, string>> headers,
                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProjectsResponse listProjects(shared_ptr<string> organizationId, shared_ptr<ListProjectsRequest> request);
  ListProtectedBranchesResponse listProtectedBranchesWithOptions(shared_ptr<string> repositoryId,
                                                                 shared_ptr<ListProtectedBranchesRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProtectedBranchesResponse listProtectedBranches(shared_ptr<string> repositoryId, shared_ptr<ListProtectedBranchesRequest> request);
  ListPushRulesResponse listPushRulesWithOptions(shared_ptr<string> repositoryId,
                                                 shared_ptr<ListPushRulesRequest> request,
                                                 shared_ptr<map<string, string>> headers,
                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPushRulesResponse listPushRules(shared_ptr<string> repositoryId, shared_ptr<ListPushRulesRequest> request);
  ListRepositoriesResponse listRepositoriesWithOptions(shared_ptr<ListRepositoriesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRepositoriesResponse listRepositories(shared_ptr<ListRepositoriesRequest> request);
  ListRepositoryBranchesResponse listRepositoryBranchesWithOptions(shared_ptr<string> repositoryId,
                                                                   shared_ptr<ListRepositoryBranchesRequest> request,
                                                                   shared_ptr<map<string, string>> headers,
                                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRepositoryBranchesResponse listRepositoryBranches(shared_ptr<string> repositoryId, shared_ptr<ListRepositoryBranchesRequest> request);
  ListRepositoryCommitDiffResponse listRepositoryCommitDiffWithOptions(shared_ptr<string> repositoryId,
                                                                       shared_ptr<string> sha,
                                                                       shared_ptr<ListRepositoryCommitDiffRequest> request,
                                                                       shared_ptr<map<string, string>> headers,
                                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRepositoryCommitDiffResponse listRepositoryCommitDiff(shared_ptr<string> repositoryId, shared_ptr<string> sha, shared_ptr<ListRepositoryCommitDiffRequest> request);
  ListRepositoryCommitsResponse listRepositoryCommitsWithOptions(shared_ptr<string> repositoryId,
                                                                 shared_ptr<ListRepositoryCommitsRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRepositoryCommitsResponse listRepositoryCommits(shared_ptr<string> repositoryId, shared_ptr<ListRepositoryCommitsRequest> request);
  ListRepositoryGroupsResponse listRepositoryGroupsWithOptions(shared_ptr<ListRepositoryGroupsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRepositoryGroupsResponse listRepositoryGroups(shared_ptr<ListRepositoryGroupsRequest> request);
  ListRepositoryMemberWithInheritedResponse listRepositoryMemberWithInheritedWithOptions(shared_ptr<string> repositoryId,
                                                                                         shared_ptr<ListRepositoryMemberWithInheritedRequest> request,
                                                                                         shared_ptr<map<string, string>> headers,
                                                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRepositoryMemberWithInheritedResponse listRepositoryMemberWithInherited(shared_ptr<string> repositoryId, shared_ptr<ListRepositoryMemberWithInheritedRequest> request);
  ListRepositoryTagsResponse listRepositoryTagsWithOptions(shared_ptr<string> repositoryId,
                                                           shared_ptr<ListRepositoryTagsRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRepositoryTagsResponse listRepositoryTags(shared_ptr<string> repositoryId, shared_ptr<ListRepositoryTagsRequest> request);
  ListRepositoryTreeResponse listRepositoryTreeWithOptions(shared_ptr<string> repositoryId,
                                                           shared_ptr<ListRepositoryTreeRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRepositoryTreeResponse listRepositoryTree(shared_ptr<string> repositoryId, shared_ptr<ListRepositoryTreeRequest> request);
  ListRepositoryWebhookResponse listRepositoryWebhookWithOptions(shared_ptr<string> repositoryId,
                                                                 shared_ptr<ListRepositoryWebhookRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRepositoryWebhookResponse listRepositoryWebhook(shared_ptr<string> repositoryId, shared_ptr<ListRepositoryWebhookRequest> request);
  ListResourceMembersResponse listResourceMembersWithOptions(shared_ptr<string> organizationId,
                                                             shared_ptr<string> resourceType,
                                                             shared_ptr<string> resourceId,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListResourceMembersResponse listResourceMembers(shared_ptr<string> organizationId, shared_ptr<string> resourceType, shared_ptr<string> resourceId);
  ListSearchCommitResponse listSearchCommitWithOptions(shared_ptr<ListSearchCommitRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSearchCommitResponse listSearchCommit(shared_ptr<ListSearchCommitRequest> request);
  ListSearchRepositoryResponse listSearchRepositoryWithOptions(shared_ptr<ListSearchRepositoryRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSearchRepositoryResponse listSearchRepository(shared_ptr<ListSearchRepositoryRequest> request);
  ListSearchSourceCodeResponse listSearchSourceCodeWithOptions(shared_ptr<ListSearchSourceCodeRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSearchSourceCodeResponse listSearchSourceCode(shared_ptr<ListSearchSourceCodeRequest> request);
  ListServiceAuthsResponse listServiceAuthsWithOptions(shared_ptr<string> organizationId,
                                                       shared_ptr<ListServiceAuthsRequest> request,
                                                       shared_ptr<map<string, string>> headers,
                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListServiceAuthsResponse listServiceAuths(shared_ptr<string> organizationId, shared_ptr<ListServiceAuthsRequest> request);
  ListServiceConnectionsResponse listServiceConnectionsWithOptions(shared_ptr<string> organizationId,
                                                                   shared_ptr<ListServiceConnectionsRequest> request,
                                                                   shared_ptr<map<string, string>> headers,
                                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListServiceConnectionsResponse listServiceConnections(shared_ptr<string> organizationId, shared_ptr<ListServiceConnectionsRequest> request);
  ListServiceCredentialsResponse listServiceCredentialsWithOptions(shared_ptr<string> organizationId,
                                                                   shared_ptr<ListServiceCredentialsRequest> request,
                                                                   shared_ptr<map<string, string>> headers,
                                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListServiceCredentialsResponse listServiceCredentials(shared_ptr<string> organizationId, shared_ptr<ListServiceCredentialsRequest> request);
  ListSprintsResponse listSprintsWithOptions(shared_ptr<string> organizationId,
                                             shared_ptr<ListSprintsRequest> request,
                                             shared_ptr<map<string, string>> headers,
                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSprintsResponse listSprints(shared_ptr<string> organizationId, shared_ptr<ListSprintsRequest> request);
  ListTestCaseFieldsResponse listTestCaseFieldsWithOptions(shared_ptr<string> organizationId,
                                                           shared_ptr<ListTestCaseFieldsRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTestCaseFieldsResponse listTestCaseFields(shared_ptr<string> organizationId, shared_ptr<ListTestCaseFieldsRequest> request);
  ListUserDrawRecordByPkResponse listUserDrawRecordByPkWithOptions(shared_ptr<ListUserDrawRecordByPkRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUserDrawRecordByPkResponse listUserDrawRecordByPk(shared_ptr<ListUserDrawRecordByPkRequest> request);
  ListUserKeysResponse listUserKeysWithOptions(shared_ptr<ListUserKeysRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUserKeysResponse listUserKeys(shared_ptr<ListUserKeysRequest> request);
  ListUserResourcesResponse listUserResourcesWithOptions(shared_ptr<ListUserResourcesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUserResourcesResponse listUserResources(shared_ptr<ListUserResourcesRequest> request);
  ListVariableGroupsResponse listVariableGroupsWithOptions(shared_ptr<string> organizationId,
                                                           shared_ptr<ListVariableGroupsRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListVariableGroupsResponse listVariableGroups(shared_ptr<string> organizationId, shared_ptr<ListVariableGroupsRequest> request);
  ListWorkItemAllFieldsResponse listWorkItemAllFieldsWithOptions(shared_ptr<string> organizationId,
                                                                 shared_ptr<ListWorkItemAllFieldsRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWorkItemAllFieldsResponse listWorkItemAllFields(shared_ptr<string> organizationId, shared_ptr<ListWorkItemAllFieldsRequest> request);
  ListWorkItemWorkFlowStatusResponse listWorkItemWorkFlowStatusWithOptions(shared_ptr<string> organizationId,
                                                                           shared_ptr<ListWorkItemWorkFlowStatusRequest> request,
                                                                           shared_ptr<map<string, string>> headers,
                                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWorkItemWorkFlowStatusResponse listWorkItemWorkFlowStatus(shared_ptr<string> organizationId, shared_ptr<ListWorkItemWorkFlowStatusRequest> request);
  ListWorkitemAttachmentsResponse listWorkitemAttachmentsWithOptions(shared_ptr<string> organizationId,
                                                                     shared_ptr<string> workitemIdentifier,
                                                                     shared_ptr<map<string, string>> headers,
                                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWorkitemAttachmentsResponse listWorkitemAttachments(shared_ptr<string> organizationId, shared_ptr<string> workitemIdentifier);
  ListWorkitemEstimateResponse listWorkitemEstimateWithOptions(shared_ptr<string> organizationId,
                                                               shared_ptr<string> workitemId,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWorkitemEstimateResponse listWorkitemEstimate(shared_ptr<string> organizationId, shared_ptr<string> workitemId);
  ListWorkitemTimeResponse listWorkitemTimeWithOptions(shared_ptr<string> organizationId,
                                                       shared_ptr<string> workitemId,
                                                       shared_ptr<map<string, string>> headers,
                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWorkitemTimeResponse listWorkitemTime(shared_ptr<string> organizationId, shared_ptr<string> workitemId);
  ListWorkitemsResponse listWorkitemsWithOptions(shared_ptr<string> organizationId,
                                                 shared_ptr<ListWorkitemsRequest> request,
                                                 shared_ptr<map<string, string>> headers,
                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWorkitemsResponse listWorkitems(shared_ptr<string> organizationId, shared_ptr<ListWorkitemsRequest> request);
  ListWorkspacesResponse listWorkspacesWithOptions(shared_ptr<ListWorkspacesRequest> tmpReq, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWorkspacesResponse listWorkspaces(shared_ptr<ListWorkspacesRequest> request);
  LogPipelineJobRunResponse logPipelineJobRunWithOptions(shared_ptr<string> organizationId,
                                                         shared_ptr<string> pipelineId,
                                                         shared_ptr<string> jobId,
                                                         shared_ptr<string> pipelineRunId,
                                                         shared_ptr<map<string, string>> headers,
                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  LogPipelineJobRunResponse logPipelineJobRun(shared_ptr<string> organizationId,
                                              shared_ptr<string> pipelineId,
                                              shared_ptr<string> jobId,
                                              shared_ptr<string> pipelineRunId);
  LogVMDeployMachineResponse logVMDeployMachineWithOptions(shared_ptr<string> organizationId,
                                                           shared_ptr<string> pipelineId,
                                                           shared_ptr<string> deployOrderId,
                                                           shared_ptr<string> machineSn,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  LogVMDeployMachineResponse logVMDeployMachine(shared_ptr<string> organizationId,
                                                shared_ptr<string> pipelineId,
                                                shared_ptr<string> deployOrderId,
                                                shared_ptr<string> machineSn);
  MergeMergeRequestResponse mergeMergeRequestWithOptions(shared_ptr<string> repositoryId,
                                                         shared_ptr<string> localId,
                                                         shared_ptr<MergeMergeRequestRequest> request,
                                                         shared_ptr<map<string, string>> headers,
                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MergeMergeRequestResponse mergeMergeRequest(shared_ptr<string> repositoryId, shared_ptr<string> localId, shared_ptr<MergeMergeRequestRequest> request);
  PassPipelineValidateResponse passPipelineValidateWithOptions(shared_ptr<string> organizationId,
                                                               shared_ptr<string> pipelineId,
                                                               shared_ptr<string> pipelineRunId,
                                                               shared_ptr<string> jobId,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PassPipelineValidateResponse passPipelineValidate(shared_ptr<string> organizationId,
                                                    shared_ptr<string> pipelineId,
                                                    shared_ptr<string> pipelineRunId,
                                                    shared_ptr<string> jobId);
  PassReleaseStagePipelineValidateResponse passReleaseStagePipelineValidateWithOptions(shared_ptr<string> appName,
                                                                                       shared_ptr<string> releaseWorkflowSn,
                                                                                       shared_ptr<string> releaseStageSn,
                                                                                       shared_ptr<string> executionNumber,
                                                                                       shared_ptr<PassReleaseStagePipelineValidateRequest> request,
                                                                                       shared_ptr<map<string, string>> headers,
                                                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PassReleaseStagePipelineValidateResponse passReleaseStagePipelineValidate(shared_ptr<string> appName,
                                                                            shared_ptr<string> releaseWorkflowSn,
                                                                            shared_ptr<string> releaseStageSn,
                                                                            shared_ptr<string> executionNumber,
                                                                            shared_ptr<PassReleaseStagePipelineValidateRequest> request);
  RefusePipelineValidateResponse refusePipelineValidateWithOptions(shared_ptr<string> organizationId,
                                                                   shared_ptr<string> pipelineId,
                                                                   shared_ptr<string> pipelineRunId,
                                                                   shared_ptr<string> jobId,
                                                                   shared_ptr<map<string, string>> headers,
                                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefusePipelineValidateResponse refusePipelineValidate(shared_ptr<string> organizationId,
                                                        shared_ptr<string> pipelineId,
                                                        shared_ptr<string> pipelineRunId,
                                                        shared_ptr<string> jobId);
  RefuseReleaseStagePipelineValidateResponse refuseReleaseStagePipelineValidateWithOptions(shared_ptr<string> appName,
                                                                                           shared_ptr<string> releaseWorkflowSn,
                                                                                           shared_ptr<string> releaseStageSn,
                                                                                           shared_ptr<string> executionNumber,
                                                                                           shared_ptr<RefuseReleaseStagePipelineValidateRequest> request,
                                                                                           shared_ptr<map<string, string>> headers,
                                                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefuseReleaseStagePipelineValidateResponse refuseReleaseStagePipelineValidate(shared_ptr<string> appName,
                                                                                shared_ptr<string> releaseWorkflowSn,
                                                                                shared_ptr<string> releaseStageSn,
                                                                                shared_ptr<string> executionNumber,
                                                                                shared_ptr<RefuseReleaseStagePipelineValidateRequest> request);
  ReleaseWorkspaceResponse releaseWorkspaceWithOptions(shared_ptr<string> workspaceId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseWorkspaceResponse releaseWorkspace(shared_ptr<string> workspaceId);
  ReopenMergeRequestResponse reopenMergeRequestWithOptions(shared_ptr<string> repositoryId,
                                                           shared_ptr<string> localId,
                                                           shared_ptr<ReopenMergeRequestRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReopenMergeRequestResponse reopenMergeRequest(shared_ptr<string> repositoryId, shared_ptr<string> localId, shared_ptr<ReopenMergeRequestRequest> request);
  ResetSshKeyResponse resetSshKeyWithOptions(shared_ptr<string> organizationId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetSshKeyResponse resetSshKey(shared_ptr<string> organizationId);
  ResumeVMDeployOrderResponse resumeVMDeployOrderWithOptions(shared_ptr<string> organizationId,
                                                             shared_ptr<string> pipelineId,
                                                             shared_ptr<string> deployOrderId,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResumeVMDeployOrderResponse resumeVMDeployOrder(shared_ptr<string> organizationId, shared_ptr<string> pipelineId, shared_ptr<string> deployOrderId);
  RetryPipelineJobRunResponse retryPipelineJobRunWithOptions(shared_ptr<string> organizationId,
                                                             shared_ptr<string> pipelineId,
                                                             shared_ptr<string> pipelineRunId,
                                                             shared_ptr<string> jobId,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RetryPipelineJobRunResponse retryPipelineJobRun(shared_ptr<string> organizationId,
                                                  shared_ptr<string> pipelineId,
                                                  shared_ptr<string> pipelineRunId,
                                                  shared_ptr<string> jobId);
  RetryVMDeployMachineResponse retryVMDeployMachineWithOptions(shared_ptr<string> organizationId,
                                                               shared_ptr<string> pipelineId,
                                                               shared_ptr<string> deployOrderId,
                                                               shared_ptr<string> machineSn,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RetryVMDeployMachineResponse retryVMDeployMachine(shared_ptr<string> organizationId,
                                                    shared_ptr<string> pipelineId,
                                                    shared_ptr<string> deployOrderId,
                                                    shared_ptr<string> machineSn);
  ReviewMergeRequestResponse reviewMergeRequestWithOptions(shared_ptr<string> repositoryId,
                                                           shared_ptr<string> localId,
                                                           shared_ptr<ReviewMergeRequestRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReviewMergeRequestResponse reviewMergeRequest(shared_ptr<string> repositoryId, shared_ptr<string> localId, shared_ptr<ReviewMergeRequestRequest> request);
  SkipPipelineJobRunResponse skipPipelineJobRunWithOptions(shared_ptr<string> organizationId,
                                                           shared_ptr<string> pipelineId,
                                                           shared_ptr<string> pipelineRunId,
                                                           shared_ptr<string> jobId,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SkipPipelineJobRunResponse skipPipelineJobRun(shared_ptr<string> organizationId,
                                                shared_ptr<string> pipelineId,
                                                shared_ptr<string> pipelineRunId,
                                                shared_ptr<string> jobId);
  SkipVMDeployMachineResponse skipVMDeployMachineWithOptions(shared_ptr<string> organizationId,
                                                             shared_ptr<string> pipelineId,
                                                             shared_ptr<string> deployOrderId,
                                                             shared_ptr<string> machineSn,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SkipVMDeployMachineResponse skipVMDeployMachine(shared_ptr<string> organizationId,
                                                  shared_ptr<string> pipelineId,
                                                  shared_ptr<string> deployOrderId,
                                                  shared_ptr<string> machineSn);
  StartPipelineRunResponse startPipelineRunWithOptions(shared_ptr<string> organizationId,
                                                       shared_ptr<string> pipelineId,
                                                       shared_ptr<StartPipelineRunRequest> request,
                                                       shared_ptr<map<string, string>> headers,
                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartPipelineRunResponse startPipelineRun(shared_ptr<string> organizationId, shared_ptr<string> pipelineId, shared_ptr<StartPipelineRunRequest> request);
  StopPipelineJobRunResponse stopPipelineJobRunWithOptions(shared_ptr<string> organizationId,
                                                           shared_ptr<string> pipelineId,
                                                           shared_ptr<string> pipelineRunId,
                                                           shared_ptr<string> jobId,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopPipelineJobRunResponse stopPipelineJobRun(shared_ptr<string> organizationId,
                                                shared_ptr<string> pipelineId,
                                                shared_ptr<string> pipelineRunId,
                                                shared_ptr<string> jobId);
  StopPipelineRunResponse stopPipelineRunWithOptions(shared_ptr<string> organizationId,
                                                     shared_ptr<string> pipelineId,
                                                     shared_ptr<string> pipelineRunId,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopPipelineRunResponse stopPipelineRun(shared_ptr<string> organizationId, shared_ptr<string> pipelineId, shared_ptr<string> pipelineRunId);
  StopVMDeployOrderResponse stopVMDeployOrderWithOptions(shared_ptr<string> organizationId,
                                                         shared_ptr<string> pipelineId,
                                                         shared_ptr<string> deployOrderId,
                                                         shared_ptr<map<string, string>> headers,
                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopVMDeployOrderResponse stopVMDeployOrder(shared_ptr<string> organizationId, shared_ptr<string> pipelineId, shared_ptr<string> deployOrderId);
  TransferRepositoryResponse transferRepositoryWithOptions(shared_ptr<TransferRepositoryRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TransferRepositoryResponse transferRepository(shared_ptr<TransferRepositoryRequest> request);
  TriggerRepositoryMirrorSyncResponse triggerRepositoryMirrorSyncWithOptions(shared_ptr<string> repositoryId,
                                                                             shared_ptr<TriggerRepositoryMirrorSyncRequest> request,
                                                                             shared_ptr<map<string, string>> headers,
                                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TriggerRepositoryMirrorSyncResponse triggerRepositoryMirrorSync(shared_ptr<string> repositoryId, shared_ptr<TriggerRepositoryMirrorSyncRequest> request);
  UpdateAppMemberResponse updateAppMemberWithOptions(shared_ptr<string> appName,
                                                     shared_ptr<UpdateAppMemberRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAppMemberResponse updateAppMember(shared_ptr<string> appName, shared_ptr<UpdateAppMemberRequest> request);
  UpdateApplicationResponse updateApplicationWithOptions(shared_ptr<string> appName,
                                                         shared_ptr<UpdateApplicationRequest> request,
                                                         shared_ptr<map<string, string>> headers,
                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateApplicationResponse updateApplication(shared_ptr<string> appName, shared_ptr<UpdateApplicationRequest> request);
  UpdateCheckRunResponse updateCheckRunWithOptions(shared_ptr<UpdateCheckRunRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCheckRunResponse updateCheckRun(shared_ptr<UpdateCheckRunRequest> request);
  UpdateFileResponse updateFileWithOptions(shared_ptr<string> repositoryId,
                                           shared_ptr<UpdateFileRequest> request,
                                           shared_ptr<map<string, string>> headers,
                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateFileResponse updateFile(shared_ptr<string> repositoryId, shared_ptr<UpdateFileRequest> request);
  UpdateFlowTagResponse updateFlowTagWithOptions(shared_ptr<string> organizationId,
                                                 shared_ptr<string> id,
                                                 shared_ptr<UpdateFlowTagRequest> request,
                                                 shared_ptr<map<string, string>> headers,
                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateFlowTagResponse updateFlowTag(shared_ptr<string> organizationId, shared_ptr<string> id, shared_ptr<UpdateFlowTagRequest> request);
  UpdateFlowTagGroupResponse updateFlowTagGroupWithOptions(shared_ptr<string> organizationId,
                                                           shared_ptr<string> id,
                                                           shared_ptr<UpdateFlowTagGroupRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateFlowTagGroupResponse updateFlowTagGroup(shared_ptr<string> organizationId, shared_ptr<string> id, shared_ptr<UpdateFlowTagGroupRequest> request);
  UpdateGroupResponse updateGroupWithOptions(shared_ptr<UpdateGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGroupResponse updateGroup(shared_ptr<UpdateGroupRequest> request);
  UpdateGroupMemberResponse updateGroupMemberWithOptions(shared_ptr<string> groupId,
                                                         shared_ptr<UpdateGroupMemberRequest> request,
                                                         shared_ptr<map<string, string>> headers,
                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGroupMemberResponse updateGroupMember(shared_ptr<string> groupId, shared_ptr<UpdateGroupMemberRequest> request);
  UpdateHostGroupResponse updateHostGroupWithOptions(shared_ptr<string> organizationId,
                                                     shared_ptr<string> id,
                                                     shared_ptr<UpdateHostGroupRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateHostGroupResponse updateHostGroup(shared_ptr<string> organizationId, shared_ptr<string> id, shared_ptr<UpdateHostGroupRequest> request);
  UpdateMergeRequestResponse updateMergeRequestWithOptions(shared_ptr<string> repositoryId,
                                                           shared_ptr<string> localId,
                                                           shared_ptr<UpdateMergeRequestRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMergeRequestResponse updateMergeRequest(shared_ptr<string> repositoryId, shared_ptr<string> localId, shared_ptr<UpdateMergeRequestRequest> request);
  UpdateMergeRequestPersonnelResponse updateMergeRequestPersonnelWithOptions(shared_ptr<string> repositoryId,
                                                                             shared_ptr<string> localId,
                                                                             shared_ptr<string> personType,
                                                                             shared_ptr<UpdateMergeRequestPersonnelRequest> request,
                                                                             shared_ptr<map<string, string>> headers,
                                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMergeRequestPersonnelResponse updateMergeRequestPersonnel(shared_ptr<string> repositoryId,
                                                                  shared_ptr<string> localId,
                                                                  shared_ptr<string> personType,
                                                                  shared_ptr<UpdateMergeRequestPersonnelRequest> request);
  UpdateOrganizationMemberResponse updateOrganizationMemberWithOptions(shared_ptr<string> organizationId,
                                                                       shared_ptr<string> accountId,
                                                                       shared_ptr<UpdateOrganizationMemberRequest> request,
                                                                       shared_ptr<map<string, string>> headers,
                                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateOrganizationMemberResponse updateOrganizationMember(shared_ptr<string> organizationId, shared_ptr<string> accountId, shared_ptr<UpdateOrganizationMemberRequest> request);
  UpdatePipelineResponse updatePipelineWithOptions(shared_ptr<string> organizationId,
                                                   shared_ptr<UpdatePipelineRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePipelineResponse updatePipeline(shared_ptr<string> organizationId, shared_ptr<UpdatePipelineRequest> request);
  UpdatePipelineBaseInfoResponse updatePipelineBaseInfoWithOptions(shared_ptr<string> organizationId,
                                                                   shared_ptr<string> pipelineId,
                                                                   shared_ptr<UpdatePipelineBaseInfoRequest> request,
                                                                   shared_ptr<map<string, string>> headers,
                                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePipelineBaseInfoResponse updatePipelineBaseInfo(shared_ptr<string> organizationId, shared_ptr<string> pipelineId, shared_ptr<UpdatePipelineBaseInfoRequest> request);
  UpdatePipelineGroupResponse updatePipelineGroupWithOptions(shared_ptr<string> organizationId,
                                                             shared_ptr<string> groupId,
                                                             shared_ptr<UpdatePipelineGroupRequest> request,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePipelineGroupResponse updatePipelineGroup(shared_ptr<string> organizationId, shared_ptr<string> groupId, shared_ptr<UpdatePipelineGroupRequest> request);
  UpdateProjectFieldResponse updateProjectFieldWithOptions(shared_ptr<string> organizationId,
                                                           shared_ptr<string> identifier,
                                                           shared_ptr<UpdateProjectFieldRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProjectFieldResponse updateProjectField(shared_ptr<string> organizationId, shared_ptr<string> identifier, shared_ptr<UpdateProjectFieldRequest> request);
  UpdateProjectLabelResponse updateProjectLabelWithOptions(shared_ptr<string> labelId,
                                                           shared_ptr<UpdateProjectLabelRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProjectLabelResponse updateProjectLabel(shared_ptr<string> labelId, shared_ptr<UpdateProjectLabelRequest> request);
  UpdateProjectMemberResponse updateProjectMemberWithOptions(shared_ptr<string> organizationId,
                                                             shared_ptr<string> projectId,
                                                             shared_ptr<UpdateProjectMemberRequest> request,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProjectMemberResponse updateProjectMember(shared_ptr<string> organizationId, shared_ptr<string> projectId, shared_ptr<UpdateProjectMemberRequest> request);
  UpdateProtectedBranchesResponse updateProtectedBranchesWithOptions(shared_ptr<string> repositoryId,
                                                                     shared_ptr<string> id,
                                                                     shared_ptr<UpdateProtectedBranchesRequest> request,
                                                                     shared_ptr<map<string, string>> headers,
                                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProtectedBranchesResponse updateProtectedBranches(shared_ptr<string> repositoryId, shared_ptr<string> id, shared_ptr<UpdateProtectedBranchesRequest> request);
  UpdatePushReviewOnOffResponse updatePushReviewOnOffWithOptions(shared_ptr<string> repositoryId,
                                                                 shared_ptr<UpdatePushReviewOnOffRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePushReviewOnOffResponse updatePushReviewOnOff(shared_ptr<string> repositoryId, shared_ptr<UpdatePushReviewOnOffRequest> request);
  UpdatePushRuleResponse updatePushRuleWithOptions(shared_ptr<string> repositoryId,
                                                   shared_ptr<string> pushRuleId,
                                                   shared_ptr<UpdatePushRuleRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePushRuleResponse updatePushRule(shared_ptr<string> repositoryId, shared_ptr<string> pushRuleId, shared_ptr<UpdatePushRuleRequest> request);
  UpdateRepositoryResponse updateRepositoryWithOptions(shared_ptr<string> repositoryId,
                                                       shared_ptr<UpdateRepositoryRequest> request,
                                                       shared_ptr<map<string, string>> headers,
                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRepositoryResponse updateRepository(shared_ptr<string> repositoryId, shared_ptr<UpdateRepositoryRequest> request);
  UpdateRepositoryMemberResponse updateRepositoryMemberWithOptions(shared_ptr<string> repositoryId,
                                                                   shared_ptr<string> aliyunPk,
                                                                   shared_ptr<UpdateRepositoryMemberRequest> request,
                                                                   shared_ptr<map<string, string>> headers,
                                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRepositoryMemberResponse updateRepositoryMember(shared_ptr<string> repositoryId, shared_ptr<string> aliyunPk, shared_ptr<UpdateRepositoryMemberRequest> request);
  UpdateResourceMemberResponse updateResourceMemberWithOptions(shared_ptr<string> organizationId,
                                                               shared_ptr<string> resourceType,
                                                               shared_ptr<string> resourceId,
                                                               shared_ptr<string> accountId,
                                                               shared_ptr<UpdateResourceMemberRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateResourceMemberResponse updateResourceMember(shared_ptr<string> organizationId,
                                                    shared_ptr<string> resourceType,
                                                    shared_ptr<string> resourceId,
                                                    shared_ptr<string> accountId,
                                                    shared_ptr<UpdateResourceMemberRequest> request);
  UpdateTestCaseResponse updateTestCaseWithOptions(shared_ptr<string> organizationId,
                                                   shared_ptr<string> testcaseIdentifier,
                                                   shared_ptr<UpdateTestCaseRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTestCaseResponse updateTestCase(shared_ptr<string> organizationId, shared_ptr<string> testcaseIdentifier, shared_ptr<UpdateTestCaseRequest> request);
  UpdateTestResultResponse updateTestResultWithOptions(shared_ptr<string> organizationId,
                                                       shared_ptr<string> testPlanIdentifier,
                                                       shared_ptr<string> testcaseIdentifier,
                                                       shared_ptr<UpdateTestResultRequest> request,
                                                       shared_ptr<map<string, string>> headers,
                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTestResultResponse updateTestResult(shared_ptr<string> organizationId,
                                            shared_ptr<string> testPlanIdentifier,
                                            shared_ptr<string> testcaseIdentifier,
                                            shared_ptr<UpdateTestResultRequest> request);
  UpdateVariableGroupResponse updateVariableGroupWithOptions(shared_ptr<string> organizationId,
                                                             shared_ptr<string> id,
                                                             shared_ptr<UpdateVariableGroupRequest> request,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateVariableGroupResponse updateVariableGroup(shared_ptr<string> organizationId, shared_ptr<string> id, shared_ptr<UpdateVariableGroupRequest> request);
  UpdateWorkItemResponse updateWorkItemWithOptions(shared_ptr<string> organizationId,
                                                   shared_ptr<UpdateWorkItemRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateWorkItemResponse updateWorkItem(shared_ptr<string> organizationId, shared_ptr<UpdateWorkItemRequest> request);
  UpdateWorkitemCommentResponse updateWorkitemCommentWithOptions(shared_ptr<string> organizationId,
                                                                 shared_ptr<UpdateWorkitemCommentRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateWorkitemCommentResponse updateWorkitemComment(shared_ptr<string> organizationId, shared_ptr<UpdateWorkitemCommentRequest> request);
  UpdateWorkitemFieldResponse updateWorkitemFieldWithOptions(shared_ptr<string> organizationId,
                                                             shared_ptr<UpdateWorkitemFieldRequest> request,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateWorkitemFieldResponse updateWorkitemField(shared_ptr<string> organizationId, shared_ptr<UpdateWorkitemFieldRequest> request);
  WorkitemAttachmentCreateResponse workitemAttachmentCreateWithOptions(shared_ptr<string> organizationId,
                                                                       shared_ptr<string> workitemIdentifier,
                                                                       shared_ptr<WorkitemAttachmentCreateRequest> request,
                                                                       shared_ptr<map<string, string>> headers,
                                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  WorkitemAttachmentCreateResponse workitemAttachmentCreate(shared_ptr<string> organizationId, shared_ptr<string> workitemIdentifier, shared_ptr<WorkitemAttachmentCreateRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Devops20210625

#endif
