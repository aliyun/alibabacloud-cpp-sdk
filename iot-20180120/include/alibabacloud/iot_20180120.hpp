// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_IOT20180120_H_
#define ALIBABACLOUD_IOT20180120_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Iot20180120 {
class AddDataForApiSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> content{};
  shared_ptr<string> iotInstanceId{};

  AddDataForApiSourceRequest() {}

  explicit AddDataForApiSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~AddDataForApiSourceRequest() = default;
};
class AddDataForApiSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddDataForApiSourceResponseBody() {}

  explicit AddDataForApiSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddDataForApiSourceResponseBody() = default;
};
class AddDataForApiSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddDataForApiSourceResponseBody> body{};

  AddDataForApiSourceResponse() {}

  explicit AddDataForApiSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddDataForApiSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddDataForApiSourceResponseBody>(model1);
      }
    }
  }


  virtual ~AddDataForApiSourceResponse() = default;
};
class AddDeviceToSharePromotionRequestDeviceSimpleInfoList : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> productKey{};

  AddDeviceToSharePromotionRequestDeviceSimpleInfoList() {}

  explicit AddDeviceToSharePromotionRequestDeviceSimpleInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~AddDeviceToSharePromotionRequestDeviceSimpleInfoList() = default;
};
class AddDeviceToSharePromotionRequest : public Darabonba::Model {
public:
  shared_ptr<vector<AddDeviceToSharePromotionRequestDeviceSimpleInfoList>> deviceSimpleInfoList{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> sharePromotionActivityId{};
  shared_ptr<string> shareTaskCode{};

  AddDeviceToSharePromotionRequest() {}

  explicit AddDeviceToSharePromotionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceSimpleInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*deviceSimpleInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceSimpleInfoList"] = boost::any(temp1);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (sharePromotionActivityId) {
      res["SharePromotionActivityId"] = boost::any(*sharePromotionActivityId);
    }
    if (shareTaskCode) {
      res["ShareTaskCode"] = boost::any(*shareTaskCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceSimpleInfoList") != m.end() && !m["DeviceSimpleInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceSimpleInfoList"].type()) {
        vector<AddDeviceToSharePromotionRequestDeviceSimpleInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceSimpleInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddDeviceToSharePromotionRequestDeviceSimpleInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceSimpleInfoList = make_shared<vector<AddDeviceToSharePromotionRequestDeviceSimpleInfoList>>(expect1);
      }
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("SharePromotionActivityId") != m.end() && !m["SharePromotionActivityId"].empty()) {
      sharePromotionActivityId = make_shared<string>(boost::any_cast<string>(m["SharePromotionActivityId"]));
    }
    if (m.find("ShareTaskCode") != m.end() && !m["ShareTaskCode"].empty()) {
      shareTaskCode = make_shared<string>(boost::any_cast<string>(m["ShareTaskCode"]));
    }
  }


  virtual ~AddDeviceToSharePromotionRequest() = default;
};
class AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoListItem : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<long> failCode{};
  shared_ptr<string> failReason{};
  shared_ptr<string> productKey{};

  AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoListItem() {}

  explicit AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoListItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (failCode) {
      res["FailCode"] = boost::any(*failCode);
    }
    if (failReason) {
      res["FailReason"] = boost::any(*failReason);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("FailCode") != m.end() && !m["FailCode"].empty()) {
      failCode = make_shared<long>(boost::any_cast<long>(m["FailCode"]));
    }
    if (m.find("FailReason") != m.end() && !m["FailReason"].empty()) {
      failReason = make_shared<string>(boost::any_cast<string>(m["FailReason"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoListItem() = default;
};
class AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoListItem>> item{};

  AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoList() {}

  explicit AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["item"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("item") != m.end() && !m["item"].empty()) {
      if (typeid(vector<boost::any>) == m["item"].type()) {
        vector<AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoListItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoListItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoListItem>>(expect1);
      }
    }
  }


  virtual ~AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoList() = default;
};
class AddDeviceToSharePromotionResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoList> failDeviceSimpleInfoList{};

  AddDeviceToSharePromotionResponseBodyData() {}

  explicit AddDeviceToSharePromotionResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failDeviceSimpleInfoList) {
      res["FailDeviceSimpleInfoList"] = failDeviceSimpleInfoList ? boost::any(failDeviceSimpleInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailDeviceSimpleInfoList") != m.end() && !m["FailDeviceSimpleInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailDeviceSimpleInfoList"].type()) {
        AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailDeviceSimpleInfoList"]));
        failDeviceSimpleInfoList = make_shared<AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoList>(model1);
      }
    }
  }


  virtual ~AddDeviceToSharePromotionResponseBodyData() = default;
};
class AddDeviceToSharePromotionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<AddDeviceToSharePromotionResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddDeviceToSharePromotionResponseBody() {}

  explicit AddDeviceToSharePromotionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AddDeviceToSharePromotionResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AddDeviceToSharePromotionResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddDeviceToSharePromotionResponseBody() = default;
};
class AddDeviceToSharePromotionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddDeviceToSharePromotionResponseBody> body{};

  AddDeviceToSharePromotionResponse() {}

  explicit AddDeviceToSharePromotionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddDeviceToSharePromotionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddDeviceToSharePromotionResponseBody>(model1);
      }
    }
  }


  virtual ~AddDeviceToSharePromotionResponse() = default;
};
class AddShareTaskDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> iotIdList{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> shareTaskId{};

  AddShareTaskDeviceRequest() {}

  explicit AddShareTaskDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotIdList) {
      res["IotIdList"] = boost::any(*iotIdList);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (shareTaskId) {
      res["ShareTaskId"] = boost::any(*shareTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotIdList") != m.end() && !m["IotIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ShareTaskId") != m.end() && !m["ShareTaskId"].empty()) {
      shareTaskId = make_shared<string>(boost::any_cast<string>(m["ShareTaskId"]));
    }
  }


  virtual ~AddShareTaskDeviceRequest() = default;
};
class AddShareTaskDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> failSum{};
  shared_ptr<string> failedResultCsvFile{};
  shared_ptr<long> progress{};
  shared_ptr<string> progressId{};
  shared_ptr<long> successSum{};

  AddShareTaskDeviceResponseBodyData() {}

  explicit AddShareTaskDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failSum) {
      res["FailSum"] = boost::any(*failSum);
    }
    if (failedResultCsvFile) {
      res["FailedResultCsvFile"] = boost::any(*failedResultCsvFile);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (progressId) {
      res["ProgressId"] = boost::any(*progressId);
    }
    if (successSum) {
      res["SuccessSum"] = boost::any(*successSum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailSum") != m.end() && !m["FailSum"].empty()) {
      failSum = make_shared<long>(boost::any_cast<long>(m["FailSum"]));
    }
    if (m.find("FailedResultCsvFile") != m.end() && !m["FailedResultCsvFile"].empty()) {
      failedResultCsvFile = make_shared<string>(boost::any_cast<string>(m["FailedResultCsvFile"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("ProgressId") != m.end() && !m["ProgressId"].empty()) {
      progressId = make_shared<string>(boost::any_cast<string>(m["ProgressId"]));
    }
    if (m.find("SuccessSum") != m.end() && !m["SuccessSum"].empty()) {
      successSum = make_shared<long>(boost::any_cast<long>(m["SuccessSum"]));
    }
  }


  virtual ~AddShareTaskDeviceResponseBodyData() = default;
};
class AddShareTaskDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<AddShareTaskDeviceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddShareTaskDeviceResponseBody() {}

  explicit AddShareTaskDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AddShareTaskDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AddShareTaskDeviceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddShareTaskDeviceResponseBody() = default;
};
class AddShareTaskDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddShareTaskDeviceResponseBody> body{};

  AddShareTaskDeviceResponse() {}

  explicit AddShareTaskDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddShareTaskDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddShareTaskDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~AddShareTaskDeviceResponse() = default;
};
class AsyncRRpcRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> extInfo{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> messageContent{};
  shared_ptr<string> productKey{};
  shared_ptr<string> topicFullName{};

  AsyncRRpcRequest() {}

  explicit AsyncRRpcRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (messageContent) {
      res["MessageContent"] = boost::any(*messageContent);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (topicFullName) {
      res["TopicFullName"] = boost::any(*topicFullName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfo = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("MessageContent") != m.end() && !m["MessageContent"].empty()) {
      messageContent = make_shared<string>(boost::any_cast<string>(m["MessageContent"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("TopicFullName") != m.end() && !m["TopicFullName"].empty()) {
      topicFullName = make_shared<string>(boost::any_cast<string>(m["TopicFullName"]));
    }
  }


  virtual ~AsyncRRpcRequest() = default;
};
class AsyncRRpcResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> messageId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AsyncRRpcResponseBody() {}

  explicit AsyncRRpcResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<long>(boost::any_cast<long>(m["MessageId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AsyncRRpcResponseBody() = default;
};
class AsyncRRpcResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AsyncRRpcResponseBody> body{};

  AsyncRRpcResponse() {}

  explicit AsyncRRpcResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AsyncRRpcResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AsyncRRpcResponseBody>(model1);
      }
    }
  }


  virtual ~AsyncRRpcResponse() = default;
};
class AttachDestinationRequest : public Darabonba::Model {
public:
  shared_ptr<long> destinationId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<bool> isFailover{};
  shared_ptr<long> parserId{};

  AttachDestinationRequest() {}

  explicit AttachDestinationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationId) {
      res["DestinationId"] = boost::any(*destinationId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (isFailover) {
      res["IsFailover"] = boost::any(*isFailover);
    }
    if (parserId) {
      res["ParserId"] = boost::any(*parserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationId") != m.end() && !m["DestinationId"].empty()) {
      destinationId = make_shared<long>(boost::any_cast<long>(m["DestinationId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("IsFailover") != m.end() && !m["IsFailover"].empty()) {
      isFailover = make_shared<bool>(boost::any_cast<bool>(m["IsFailover"]));
    }
    if (m.find("ParserId") != m.end() && !m["ParserId"].empty()) {
      parserId = make_shared<long>(boost::any_cast<long>(m["ParserId"]));
    }
  }


  virtual ~AttachDestinationRequest() = default;
};
class AttachDestinationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AttachDestinationResponseBody() {}

  explicit AttachDestinationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AttachDestinationResponseBody() = default;
};
class AttachDestinationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachDestinationResponseBody> body{};

  AttachDestinationResponse() {}

  explicit AttachDestinationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachDestinationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachDestinationResponseBody>(model1);
      }
    }
  }


  virtual ~AttachDestinationResponse() = default;
};
class AttachParserDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> parserId{};

  AttachParserDataSourceRequest() {}

  explicit AttachParserDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (parserId) {
      res["ParserId"] = boost::any(*parserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ParserId") != m.end() && !m["ParserId"].empty()) {
      parserId = make_shared<long>(boost::any_cast<long>(m["ParserId"]));
    }
  }


  virtual ~AttachParserDataSourceRequest() = default;
};
class AttachParserDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AttachParserDataSourceResponseBody() {}

  explicit AttachParserDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AttachParserDataSourceResponseBody() = default;
};
class AttachParserDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachParserDataSourceResponseBody> body{};

  AttachParserDataSourceResponse() {}

  explicit AttachParserDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachParserDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachParserDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~AttachParserDataSourceResponse() = default;
};
class BatchAddDataForApiSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> contentList{};
  shared_ptr<string> iotInstanceId{};

  BatchAddDataForApiSourceRequest() {}

  explicit BatchAddDataForApiSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (contentList) {
      res["ContentList"] = boost::any(*contentList);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ContentList") != m.end() && !m["ContentList"].empty()) {
      contentList = make_shared<string>(boost::any_cast<string>(m["ContentList"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~BatchAddDataForApiSourceRequest() = default;
};
class BatchAddDataForApiSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchAddDataForApiSourceResponseBody() {}

  explicit BatchAddDataForApiSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchAddDataForApiSourceResponseBody() = default;
};
class BatchAddDataForApiSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchAddDataForApiSourceResponseBody> body{};

  BatchAddDataForApiSourceResponse() {}

  explicit BatchAddDataForApiSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchAddDataForApiSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchAddDataForApiSourceResponseBody>(model1);
      }
    }
  }


  virtual ~BatchAddDataForApiSourceResponse() = default;
};
class BatchAddDeviceGroupRelationsRequestDevice : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> productKey{};

  BatchAddDeviceGroupRelationsRequestDevice() {}

  explicit BatchAddDeviceGroupRelationsRequestDevice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~BatchAddDeviceGroupRelationsRequestDevice() = default;
};
class BatchAddDeviceGroupRelationsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<BatchAddDeviceGroupRelationsRequestDevice>> device{};
  shared_ptr<string> groupId{};
  shared_ptr<string> iotInstanceId{};

  BatchAddDeviceGroupRelationsRequest() {}

  explicit BatchAddDeviceGroupRelationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (device) {
      vector<boost::any> temp1;
      for(auto item1:*device){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Device"] = boost::any(temp1);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      if (typeid(vector<boost::any>) == m["Device"].type()) {
        vector<BatchAddDeviceGroupRelationsRequestDevice> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Device"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchAddDeviceGroupRelationsRequestDevice model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        device = make_shared<vector<BatchAddDeviceGroupRelationsRequestDevice>>(expect1);
      }
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~BatchAddDeviceGroupRelationsRequest() = default;
};
class BatchAddDeviceGroupRelationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> alreadyRelatedGroupDeviceCount{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> exceedTenGroupDeviceCount{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> successAddedDeviceCount{};
  shared_ptr<long> validDeviceCount{};

  BatchAddDeviceGroupRelationsResponseBody() {}

  explicit BatchAddDeviceGroupRelationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alreadyRelatedGroupDeviceCount) {
      res["AlreadyRelatedGroupDeviceCount"] = boost::any(*alreadyRelatedGroupDeviceCount);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (exceedTenGroupDeviceCount) {
      res["ExceedTenGroupDeviceCount"] = boost::any(*exceedTenGroupDeviceCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (successAddedDeviceCount) {
      res["SuccessAddedDeviceCount"] = boost::any(*successAddedDeviceCount);
    }
    if (validDeviceCount) {
      res["ValidDeviceCount"] = boost::any(*validDeviceCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlreadyRelatedGroupDeviceCount") != m.end() && !m["AlreadyRelatedGroupDeviceCount"].empty()) {
      alreadyRelatedGroupDeviceCount = make_shared<long>(boost::any_cast<long>(m["AlreadyRelatedGroupDeviceCount"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ExceedTenGroupDeviceCount") != m.end() && !m["ExceedTenGroupDeviceCount"].empty()) {
      exceedTenGroupDeviceCount = make_shared<long>(boost::any_cast<long>(m["ExceedTenGroupDeviceCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("SuccessAddedDeviceCount") != m.end() && !m["SuccessAddedDeviceCount"].empty()) {
      successAddedDeviceCount = make_shared<long>(boost::any_cast<long>(m["SuccessAddedDeviceCount"]));
    }
    if (m.find("ValidDeviceCount") != m.end() && !m["ValidDeviceCount"].empty()) {
      validDeviceCount = make_shared<long>(boost::any_cast<long>(m["ValidDeviceCount"]));
    }
  }


  virtual ~BatchAddDeviceGroupRelationsResponseBody() = default;
};
class BatchAddDeviceGroupRelationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchAddDeviceGroupRelationsResponseBody> body{};

  BatchAddDeviceGroupRelationsResponse() {}

  explicit BatchAddDeviceGroupRelationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchAddDeviceGroupRelationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchAddDeviceGroupRelationsResponseBody>(model1);
      }
    }
  }


  virtual ~BatchAddDeviceGroupRelationsResponse() = default;
};
class BatchAddThingTopoRequestTopoAddItem : public Darabonba::Model {
public:
  shared_ptr<string> clientId{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> productKey{};
  shared_ptr<string> sign{};
  shared_ptr<string> signMethod{};
  shared_ptr<string> timestamp{};

  BatchAddThingTopoRequestTopoAddItem() {}

  explicit BatchAddThingTopoRequestTopoAddItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (sign) {
      res["Sign"] = boost::any(*sign);
    }
    if (signMethod) {
      res["SignMethod"] = boost::any(*signMethod);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Sign") != m.end() && !m["Sign"].empty()) {
      sign = make_shared<string>(boost::any_cast<string>(m["Sign"]));
    }
    if (m.find("SignMethod") != m.end() && !m["SignMethod"].empty()) {
      signMethod = make_shared<string>(boost::any_cast<string>(m["SignMethod"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
  }


  virtual ~BatchAddThingTopoRequestTopoAddItem() = default;
};
class BatchAddThingTopoRequest : public Darabonba::Model {
public:
  shared_ptr<string> gwDeviceName{};
  shared_ptr<string> gwProductKey{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<BatchAddThingTopoRequestTopoAddItem>> topoAddItem{};

  BatchAddThingTopoRequest() {}

  explicit BatchAddThingTopoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gwDeviceName) {
      res["GwDeviceName"] = boost::any(*gwDeviceName);
    }
    if (gwProductKey) {
      res["GwProductKey"] = boost::any(*gwProductKey);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (topoAddItem) {
      vector<boost::any> temp1;
      for(auto item1:*topoAddItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TopoAddItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GwDeviceName") != m.end() && !m["GwDeviceName"].empty()) {
      gwDeviceName = make_shared<string>(boost::any_cast<string>(m["GwDeviceName"]));
    }
    if (m.find("GwProductKey") != m.end() && !m["GwProductKey"].empty()) {
      gwProductKey = make_shared<string>(boost::any_cast<string>(m["GwProductKey"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("TopoAddItem") != m.end() && !m["TopoAddItem"].empty()) {
      if (typeid(vector<boost::any>) == m["TopoAddItem"].type()) {
        vector<BatchAddThingTopoRequestTopoAddItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TopoAddItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchAddThingTopoRequestTopoAddItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topoAddItem = make_shared<vector<BatchAddThingTopoRequestTopoAddItem>>(expect1);
      }
    }
  }


  virtual ~BatchAddThingTopoRequest() = default;
};
class BatchAddThingTopoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchAddThingTopoResponseBody() {}

  explicit BatchAddThingTopoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchAddThingTopoResponseBody() = default;
};
class BatchAddThingTopoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchAddThingTopoResponseBody> body{};

  BatchAddThingTopoResponse() {}

  explicit BatchAddThingTopoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchAddThingTopoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchAddThingTopoResponseBody>(model1);
      }
    }
  }


  virtual ~BatchAddThingTopoResponse() = default;
};
class BatchBindDeviceToEdgeInstanceWithDriverRequest : public Darabonba::Model {
public:
  shared_ptr<string> driverId{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> iotIds{};
  shared_ptr<string> iotInstanceId{};

  BatchBindDeviceToEdgeInstanceWithDriverRequest() {}

  explicit BatchBindDeviceToEdgeInstanceWithDriverRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotIds) {
      res["IotIds"] = boost::any(*iotIds);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotIds") != m.end() && !m["IotIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~BatchBindDeviceToEdgeInstanceWithDriverRequest() = default;
};
class BatchBindDeviceToEdgeInstanceWithDriverResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchBindDeviceToEdgeInstanceWithDriverResponseBody() {}

  explicit BatchBindDeviceToEdgeInstanceWithDriverResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchBindDeviceToEdgeInstanceWithDriverResponseBody() = default;
};
class BatchBindDeviceToEdgeInstanceWithDriverResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchBindDeviceToEdgeInstanceWithDriverResponseBody> body{};

  BatchBindDeviceToEdgeInstanceWithDriverResponse() {}

  explicit BatchBindDeviceToEdgeInstanceWithDriverResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchBindDeviceToEdgeInstanceWithDriverResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchBindDeviceToEdgeInstanceWithDriverResponseBody>(model1);
      }
    }
  }


  virtual ~BatchBindDeviceToEdgeInstanceWithDriverResponse() = default;
};
class BatchBindDevicesIntoProjectRequestDevices : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> productKey{};

  BatchBindDevicesIntoProjectRequestDevices() {}

  explicit BatchBindDevicesIntoProjectRequestDevices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~BatchBindDevicesIntoProjectRequestDevices() = default;
};
class BatchBindDevicesIntoProjectRequest : public Darabonba::Model {
public:
  shared_ptr<vector<BatchBindDevicesIntoProjectRequestDevices>> devices{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> projectId{};

  BatchBindDevicesIntoProjectRequest() {}

  explicit BatchBindDevicesIntoProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (devices) {
      vector<boost::any> temp1;
      for(auto item1:*devices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Devices"] = boost::any(temp1);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Devices") != m.end() && !m["Devices"].empty()) {
      if (typeid(vector<boost::any>) == m["Devices"].type()) {
        vector<BatchBindDevicesIntoProjectRequestDevices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Devices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchBindDevicesIntoProjectRequestDevices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        devices = make_shared<vector<BatchBindDevicesIntoProjectRequestDevices>>(expect1);
      }
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~BatchBindDevicesIntoProjectRequest() = default;
};
class BatchBindDevicesIntoProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchBindDevicesIntoProjectResponseBody() {}

  explicit BatchBindDevicesIntoProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchBindDevicesIntoProjectResponseBody() = default;
};
class BatchBindDevicesIntoProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchBindDevicesIntoProjectResponseBody> body{};

  BatchBindDevicesIntoProjectResponse() {}

  explicit BatchBindDevicesIntoProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchBindDevicesIntoProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchBindDevicesIntoProjectResponseBody>(model1);
      }
    }
  }


  virtual ~BatchBindDevicesIntoProjectResponse() = default;
};
class BatchBindProductsIntoProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<string>> productKeys{};
  shared_ptr<string> projectId{};

  BatchBindProductsIntoProjectRequest() {}

  explicit BatchBindProductsIntoProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKeys) {
      res["ProductKeys"] = boost::any(*productKeys);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKeys") != m.end() && !m["ProductKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProductKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProductKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      productKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~BatchBindProductsIntoProjectRequest() = default;
};
class BatchBindProductsIntoProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchBindProductsIntoProjectResponseBody() {}

  explicit BatchBindProductsIntoProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchBindProductsIntoProjectResponseBody() = default;
};
class BatchBindProductsIntoProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchBindProductsIntoProjectResponseBody> body{};

  BatchBindProductsIntoProjectResponse() {}

  explicit BatchBindProductsIntoProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchBindProductsIntoProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchBindProductsIntoProjectResponseBody>(model1);
      }
    }
  }


  virtual ~BatchBindProductsIntoProjectResponse() = default;
};
class BatchCheckDeviceNamesRequestDeviceNameList : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceNickname{};

  BatchCheckDeviceNamesRequestDeviceNameList() {}

  explicit BatchCheckDeviceNamesRequestDeviceNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceNickname) {
      res["DeviceNickname"] = boost::any(*deviceNickname);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceNickname") != m.end() && !m["DeviceNickname"].empty()) {
      deviceNickname = make_shared<string>(boost::any_cast<string>(m["DeviceNickname"]));
    }
  }


  virtual ~BatchCheckDeviceNamesRequestDeviceNameList() = default;
};
class BatchCheckDeviceNamesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> deviceName{};
  shared_ptr<vector<BatchCheckDeviceNamesRequestDeviceNameList>> deviceNameList{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  BatchCheckDeviceNamesRequest() {}

  explicit BatchCheckDeviceNamesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceNameList) {
      vector<boost::any> temp1;
      for(auto item1:*deviceNameList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceNameList"] = boost::any(temp1);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DeviceNameList") != m.end() && !m["DeviceNameList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceNameList"].type()) {
        vector<BatchCheckDeviceNamesRequestDeviceNameList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceNameList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchCheckDeviceNamesRequestDeviceNameList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceNameList = make_shared<vector<BatchCheckDeviceNamesRequestDeviceNameList>>(expect1);
      }
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~BatchCheckDeviceNamesRequest() = default;
};
class BatchCheckDeviceNamesResponseBodyDataInvalidDetailListInvalidDetailList : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> nickName{};

  BatchCheckDeviceNamesResponseBodyDataInvalidDetailListInvalidDetailList() {}

  explicit BatchCheckDeviceNamesResponseBodyDataInvalidDetailListInvalidDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (nickName) {
      res["NickName"] = boost::any(*nickName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("NickName") != m.end() && !m["NickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["NickName"]));
    }
  }


  virtual ~BatchCheckDeviceNamesResponseBodyDataInvalidDetailListInvalidDetailList() = default;
};
class BatchCheckDeviceNamesResponseBodyDataInvalidDetailList : public Darabonba::Model {
public:
  shared_ptr<vector<BatchCheckDeviceNamesResponseBodyDataInvalidDetailListInvalidDetailList>> invalidDetailList{};

  BatchCheckDeviceNamesResponseBodyDataInvalidDetailList() {}

  explicit BatchCheckDeviceNamesResponseBodyDataInvalidDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invalidDetailList) {
      vector<boost::any> temp1;
      for(auto item1:*invalidDetailList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InvalidDetailList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InvalidDetailList") != m.end() && !m["InvalidDetailList"].empty()) {
      if (typeid(vector<boost::any>) == m["InvalidDetailList"].type()) {
        vector<BatchCheckDeviceNamesResponseBodyDataInvalidDetailListInvalidDetailList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InvalidDetailList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchCheckDeviceNamesResponseBodyDataInvalidDetailListInvalidDetailList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        invalidDetailList = make_shared<vector<BatchCheckDeviceNamesResponseBodyDataInvalidDetailListInvalidDetailList>>(expect1);
      }
    }
  }


  virtual ~BatchCheckDeviceNamesResponseBodyDataInvalidDetailList() = default;
};
class BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> invalidDeviceName{};

  BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList() {}

  explicit BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invalidDeviceName) {
      res["InvalidDeviceName"] = boost::any(*invalidDeviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InvalidDeviceName") != m.end() && !m["InvalidDeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InvalidDeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InvalidDeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      invalidDeviceName = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList() = default;
};
class BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> invalidDeviceNickname{};

  BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList() {}

  explicit BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invalidDeviceNickname) {
      res["InvalidDeviceNickname"] = boost::any(*invalidDeviceNickname);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InvalidDeviceNickname") != m.end() && !m["InvalidDeviceNickname"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InvalidDeviceNickname"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InvalidDeviceNickname"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      invalidDeviceNickname = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList() = default;
};
class BatchCheckDeviceNamesResponseBodyDataRepeatedDeviceNameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> repeatDevieNameList{};

  BatchCheckDeviceNamesResponseBodyDataRepeatedDeviceNameList() {}

  explicit BatchCheckDeviceNamesResponseBodyDataRepeatedDeviceNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (repeatDevieNameList) {
      res["RepeatDevieNameList"] = boost::any(*repeatDevieNameList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RepeatDevieNameList") != m.end() && !m["RepeatDevieNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RepeatDevieNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RepeatDevieNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      repeatDevieNameList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchCheckDeviceNamesResponseBodyDataRepeatedDeviceNameList() = default;
};
class BatchCheckDeviceNamesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<BatchCheckDeviceNamesResponseBodyDataInvalidDetailList> invalidDetailList{};
  shared_ptr<BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList> invalidDeviceNameList{};
  shared_ptr<BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList> invalidDeviceNicknameList{};
  shared_ptr<BatchCheckDeviceNamesResponseBodyDataRepeatedDeviceNameList> repeatedDeviceNameList{};

  BatchCheckDeviceNamesResponseBodyData() {}

  explicit BatchCheckDeviceNamesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["ApplyId"] = boost::any(*applyId);
    }
    if (invalidDetailList) {
      res["InvalidDetailList"] = invalidDetailList ? boost::any(invalidDetailList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (invalidDeviceNameList) {
      res["InvalidDeviceNameList"] = invalidDeviceNameList ? boost::any(invalidDeviceNameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (invalidDeviceNicknameList) {
      res["InvalidDeviceNicknameList"] = invalidDeviceNicknameList ? boost::any(invalidDeviceNicknameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (repeatedDeviceNameList) {
      res["RepeatedDeviceNameList"] = repeatedDeviceNameList ? boost::any(repeatedDeviceNameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyId") != m.end() && !m["ApplyId"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["ApplyId"]));
    }
    if (m.find("InvalidDetailList") != m.end() && !m["InvalidDetailList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvalidDetailList"].type()) {
        BatchCheckDeviceNamesResponseBodyDataInvalidDetailList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvalidDetailList"]));
        invalidDetailList = make_shared<BatchCheckDeviceNamesResponseBodyDataInvalidDetailList>(model1);
      }
    }
    if (m.find("InvalidDeviceNameList") != m.end() && !m["InvalidDeviceNameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvalidDeviceNameList"].type()) {
        BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvalidDeviceNameList"]));
        invalidDeviceNameList = make_shared<BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList>(model1);
      }
    }
    if (m.find("InvalidDeviceNicknameList") != m.end() && !m["InvalidDeviceNicknameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvalidDeviceNicknameList"].type()) {
        BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvalidDeviceNicknameList"]));
        invalidDeviceNicknameList = make_shared<BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList>(model1);
      }
    }
    if (m.find("RepeatedDeviceNameList") != m.end() && !m["RepeatedDeviceNameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RepeatedDeviceNameList"].type()) {
        BatchCheckDeviceNamesResponseBodyDataRepeatedDeviceNameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RepeatedDeviceNameList"]));
        repeatedDeviceNameList = make_shared<BatchCheckDeviceNamesResponseBodyDataRepeatedDeviceNameList>(model1);
      }
    }
  }


  virtual ~BatchCheckDeviceNamesResponseBodyData() = default;
};
class BatchCheckDeviceNamesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<BatchCheckDeviceNamesResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchCheckDeviceNamesResponseBody() {}

  explicit BatchCheckDeviceNamesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BatchCheckDeviceNamesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BatchCheckDeviceNamesResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchCheckDeviceNamesResponseBody() = default;
};
class BatchCheckDeviceNamesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchCheckDeviceNamesResponseBody> body{};

  BatchCheckDeviceNamesResponse() {}

  explicit BatchCheckDeviceNamesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchCheckDeviceNamesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchCheckDeviceNamesResponseBody>(model1);
      }
    }
  }


  virtual ~BatchCheckDeviceNamesResponse() = default;
};
class BatchCheckImportDeviceRequestDeviceList : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceSecret{};
  shared_ptr<string> sn{};

  BatchCheckImportDeviceRequestDeviceList() {}

  explicit BatchCheckImportDeviceRequestDeviceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceSecret) {
      res["DeviceSecret"] = boost::any(*deviceSecret);
    }
    if (sn) {
      res["Sn"] = boost::any(*sn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceSecret") != m.end() && !m["DeviceSecret"].empty()) {
      deviceSecret = make_shared<string>(boost::any_cast<string>(m["DeviceSecret"]));
    }
    if (m.find("Sn") != m.end() && !m["Sn"].empty()) {
      sn = make_shared<string>(boost::any_cast<string>(m["Sn"]));
    }
  }


  virtual ~BatchCheckImportDeviceRequestDeviceList() = default;
};
class BatchCheckImportDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<vector<BatchCheckImportDeviceRequestDeviceList>> deviceList{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  BatchCheckImportDeviceRequest() {}

  explicit BatchCheckImportDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceList) {
      vector<boost::any> temp1;
      for(auto item1:*deviceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceList"] = boost::any(temp1);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceList") != m.end() && !m["DeviceList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceList"].type()) {
        vector<BatchCheckImportDeviceRequestDeviceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchCheckImportDeviceRequestDeviceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceList = make_shared<vector<BatchCheckImportDeviceRequestDeviceList>>(expect1);
      }
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~BatchCheckImportDeviceRequest() = default;
};
class BatchCheckImportDeviceResponseBodyDataInvalidDetailList : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceSecret{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> sn{};

  BatchCheckImportDeviceResponseBodyDataInvalidDetailList() {}

  explicit BatchCheckImportDeviceResponseBodyDataInvalidDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceSecret) {
      res["DeviceSecret"] = boost::any(*deviceSecret);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (sn) {
      res["Sn"] = boost::any(*sn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceSecret") != m.end() && !m["DeviceSecret"].empty()) {
      deviceSecret = make_shared<string>(boost::any_cast<string>(m["DeviceSecret"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("Sn") != m.end() && !m["Sn"].empty()) {
      sn = make_shared<string>(boost::any_cast<string>(m["Sn"]));
    }
  }


  virtual ~BatchCheckImportDeviceResponseBodyDataInvalidDetailList() = default;
};
class BatchCheckImportDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<BatchCheckImportDeviceResponseBodyDataInvalidDetailList>> invalidDetailList{};
  shared_ptr<vector<string>> invalidDeviceNameList{};
  shared_ptr<vector<string>> invalidDeviceSecretList{};
  shared_ptr<vector<string>> invalidSnList{};
  shared_ptr<vector<string>> repeatedDeviceNameList{};

  BatchCheckImportDeviceResponseBodyData() {}

  explicit BatchCheckImportDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invalidDetailList) {
      vector<boost::any> temp1;
      for(auto item1:*invalidDetailList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InvalidDetailList"] = boost::any(temp1);
    }
    if (invalidDeviceNameList) {
      res["InvalidDeviceNameList"] = boost::any(*invalidDeviceNameList);
    }
    if (invalidDeviceSecretList) {
      res["InvalidDeviceSecretList"] = boost::any(*invalidDeviceSecretList);
    }
    if (invalidSnList) {
      res["InvalidSnList"] = boost::any(*invalidSnList);
    }
    if (repeatedDeviceNameList) {
      res["RepeatedDeviceNameList"] = boost::any(*repeatedDeviceNameList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InvalidDetailList") != m.end() && !m["InvalidDetailList"].empty()) {
      if (typeid(vector<boost::any>) == m["InvalidDetailList"].type()) {
        vector<BatchCheckImportDeviceResponseBodyDataInvalidDetailList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InvalidDetailList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchCheckImportDeviceResponseBodyDataInvalidDetailList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        invalidDetailList = make_shared<vector<BatchCheckImportDeviceResponseBodyDataInvalidDetailList>>(expect1);
      }
    }
    if (m.find("InvalidDeviceNameList") != m.end() && !m["InvalidDeviceNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InvalidDeviceNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InvalidDeviceNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      invalidDeviceNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InvalidDeviceSecretList") != m.end() && !m["InvalidDeviceSecretList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InvalidDeviceSecretList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InvalidDeviceSecretList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      invalidDeviceSecretList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InvalidSnList") != m.end() && !m["InvalidSnList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InvalidSnList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InvalidSnList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      invalidSnList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RepeatedDeviceNameList") != m.end() && !m["RepeatedDeviceNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RepeatedDeviceNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RepeatedDeviceNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      repeatedDeviceNameList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchCheckImportDeviceResponseBodyData() = default;
};
class BatchCheckImportDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<BatchCheckImportDeviceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchCheckImportDeviceResponseBody() {}

  explicit BatchCheckImportDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BatchCheckImportDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BatchCheckImportDeviceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchCheckImportDeviceResponseBody() = default;
};
class BatchCheckImportDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchCheckImportDeviceResponseBody> body{};

  BatchCheckImportDeviceResponse() {}

  explicit BatchCheckImportDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchCheckImportDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchCheckImportDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~BatchCheckImportDeviceResponse() = default;
};
class BatchCheckVehicleDeviceRequestDeviceList : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceModel{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> manufacturer{};

  BatchCheckVehicleDeviceRequestDeviceList() {}

  explicit BatchCheckVehicleDeviceRequestDeviceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (manufacturer) {
      res["Manufacturer"] = boost::any(*manufacturer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Manufacturer") != m.end() && !m["Manufacturer"].empty()) {
      manufacturer = make_shared<string>(boost::any_cast<string>(m["Manufacturer"]));
    }
  }


  virtual ~BatchCheckVehicleDeviceRequestDeviceList() = default;
};
class BatchCheckVehicleDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<vector<BatchCheckVehicleDeviceRequestDeviceList>> deviceList{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  BatchCheckVehicleDeviceRequest() {}

  explicit BatchCheckVehicleDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceList) {
      vector<boost::any> temp1;
      for(auto item1:*deviceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceList"] = boost::any(temp1);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceList") != m.end() && !m["DeviceList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceList"].type()) {
        vector<BatchCheckVehicleDeviceRequestDeviceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchCheckVehicleDeviceRequestDeviceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceList = make_shared<vector<BatchCheckVehicleDeviceRequestDeviceList>>(expect1);
      }
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~BatchCheckVehicleDeviceRequest() = default;
};
class BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceModel{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> manufacturer{};

  BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList() {}

  explicit BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (manufacturer) {
      res["Manufacturer"] = boost::any(*manufacturer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("Manufacturer") != m.end() && !m["Manufacturer"].empty()) {
      manufacturer = make_shared<string>(boost::any_cast<string>(m["Manufacturer"]));
    }
  }


  virtual ~BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList() = default;
};
class BatchCheckVehicleDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList>> invalidDetailList{};
  shared_ptr<vector<string>> invalidDeviceIdList{};
  shared_ptr<vector<string>> invalidDeviceModelList{};
  shared_ptr<vector<string>> invalidDeviceNameList{};
  shared_ptr<vector<string>> invalidManufacturerList{};
  shared_ptr<vector<string>> repeatedDeviceIdList{};
  shared_ptr<vector<string>> repeatedDeviceNameList{};

  BatchCheckVehicleDeviceResponseBodyData() {}

  explicit BatchCheckVehicleDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invalidDetailList) {
      vector<boost::any> temp1;
      for(auto item1:*invalidDetailList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InvalidDetailList"] = boost::any(temp1);
    }
    if (invalidDeviceIdList) {
      res["InvalidDeviceIdList"] = boost::any(*invalidDeviceIdList);
    }
    if (invalidDeviceModelList) {
      res["InvalidDeviceModelList"] = boost::any(*invalidDeviceModelList);
    }
    if (invalidDeviceNameList) {
      res["InvalidDeviceNameList"] = boost::any(*invalidDeviceNameList);
    }
    if (invalidManufacturerList) {
      res["InvalidManufacturerList"] = boost::any(*invalidManufacturerList);
    }
    if (repeatedDeviceIdList) {
      res["RepeatedDeviceIdList"] = boost::any(*repeatedDeviceIdList);
    }
    if (repeatedDeviceNameList) {
      res["RepeatedDeviceNameList"] = boost::any(*repeatedDeviceNameList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InvalidDetailList") != m.end() && !m["InvalidDetailList"].empty()) {
      if (typeid(vector<boost::any>) == m["InvalidDetailList"].type()) {
        vector<BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InvalidDetailList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        invalidDetailList = make_shared<vector<BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList>>(expect1);
      }
    }
    if (m.find("InvalidDeviceIdList") != m.end() && !m["InvalidDeviceIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InvalidDeviceIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InvalidDeviceIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      invalidDeviceIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InvalidDeviceModelList") != m.end() && !m["InvalidDeviceModelList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InvalidDeviceModelList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InvalidDeviceModelList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      invalidDeviceModelList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InvalidDeviceNameList") != m.end() && !m["InvalidDeviceNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InvalidDeviceNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InvalidDeviceNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      invalidDeviceNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InvalidManufacturerList") != m.end() && !m["InvalidManufacturerList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InvalidManufacturerList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InvalidManufacturerList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      invalidManufacturerList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RepeatedDeviceIdList") != m.end() && !m["RepeatedDeviceIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RepeatedDeviceIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RepeatedDeviceIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      repeatedDeviceIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RepeatedDeviceNameList") != m.end() && !m["RepeatedDeviceNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RepeatedDeviceNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RepeatedDeviceNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      repeatedDeviceNameList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchCheckVehicleDeviceResponseBodyData() = default;
};
class BatchCheckVehicleDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<BatchCheckVehicleDeviceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchCheckVehicleDeviceResponseBody() {}

  explicit BatchCheckVehicleDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BatchCheckVehicleDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BatchCheckVehicleDeviceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchCheckVehicleDeviceResponseBody() = default;
};
class BatchCheckVehicleDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchCheckVehicleDeviceResponseBody> body{};

  BatchCheckVehicleDeviceResponse() {}

  explicit BatchCheckVehicleDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchCheckVehicleDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchCheckVehicleDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~BatchCheckVehicleDeviceResponse() = default;
};
class BatchClearEdgeInstanceDeviceConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> iotIds{};
  shared_ptr<string> iotInstanceId{};

  BatchClearEdgeInstanceDeviceConfigRequest() {}

  explicit BatchClearEdgeInstanceDeviceConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotIds) {
      res["IotIds"] = boost::any(*iotIds);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotIds") != m.end() && !m["IotIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~BatchClearEdgeInstanceDeviceConfigRequest() = default;
};
class BatchClearEdgeInstanceDeviceConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchClearEdgeInstanceDeviceConfigResponseBody() {}

  explicit BatchClearEdgeInstanceDeviceConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchClearEdgeInstanceDeviceConfigResponseBody() = default;
};
class BatchClearEdgeInstanceDeviceConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchClearEdgeInstanceDeviceConfigResponseBody> body{};

  BatchClearEdgeInstanceDeviceConfigResponse() {}

  explicit BatchClearEdgeInstanceDeviceConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchClearEdgeInstanceDeviceConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchClearEdgeInstanceDeviceConfigResponseBody>(model1);
      }
    }
  }


  virtual ~BatchClearEdgeInstanceDeviceConfigResponse() = default;
};
class BatchCreateSoundCodeLabelRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> scheduleCode{};
  shared_ptr<long> total{};

  BatchCreateSoundCodeLabelRequest() {}

  explicit BatchCreateSoundCodeLabelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (scheduleCode) {
      res["ScheduleCode"] = boost::any(*scheduleCode);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ScheduleCode") != m.end() && !m["ScheduleCode"].empty()) {
      scheduleCode = make_shared<string>(boost::any_cast<string>(m["ScheduleCode"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~BatchCreateSoundCodeLabelRequest() = default;
};
class BatchCreateSoundCodeLabelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchCreateSoundCodeLabelResponseBody() {}

  explicit BatchCreateSoundCodeLabelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchCreateSoundCodeLabelResponseBody() = default;
};
class BatchCreateSoundCodeLabelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchCreateSoundCodeLabelResponseBody> body{};

  BatchCreateSoundCodeLabelResponse() {}

  explicit BatchCreateSoundCodeLabelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchCreateSoundCodeLabelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchCreateSoundCodeLabelResponseBody>(model1);
      }
    }
  }


  virtual ~BatchCreateSoundCodeLabelResponse() = default;
};
class BatchCreateSoundCodeLabelWithLabelsRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<string>> labels{};
  shared_ptr<string> scheduleCode{};

  BatchCreateSoundCodeLabelWithLabelsRequest() {}

  explicit BatchCreateSoundCodeLabelWithLabelsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (scheduleCode) {
      res["ScheduleCode"] = boost::any(*scheduleCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Labels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      labels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScheduleCode") != m.end() && !m["ScheduleCode"].empty()) {
      scheduleCode = make_shared<string>(boost::any_cast<string>(m["ScheduleCode"]));
    }
  }


  virtual ~BatchCreateSoundCodeLabelWithLabelsRequest() = default;
};
class BatchCreateSoundCodeLabelWithLabelsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchCreateSoundCodeLabelWithLabelsResponseBody() {}

  explicit BatchCreateSoundCodeLabelWithLabelsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchCreateSoundCodeLabelWithLabelsResponseBody() = default;
};
class BatchCreateSoundCodeLabelWithLabelsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchCreateSoundCodeLabelWithLabelsResponseBody> body{};

  BatchCreateSoundCodeLabelWithLabelsResponse() {}

  explicit BatchCreateSoundCodeLabelWithLabelsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchCreateSoundCodeLabelWithLabelsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchCreateSoundCodeLabelWithLabelsResponseBody>(model1);
      }
    }
  }


  virtual ~BatchCreateSoundCodeLabelWithLabelsResponse() = default;
};
class BatchDeleteDeviceGroupRelationsRequestDevice : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> productKey{};

  BatchDeleteDeviceGroupRelationsRequestDevice() {}

  explicit BatchDeleteDeviceGroupRelationsRequestDevice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~BatchDeleteDeviceGroupRelationsRequestDevice() = default;
};
class BatchDeleteDeviceGroupRelationsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<BatchDeleteDeviceGroupRelationsRequestDevice>> device{};
  shared_ptr<string> groupId{};
  shared_ptr<string> iotInstanceId{};

  BatchDeleteDeviceGroupRelationsRequest() {}

  explicit BatchDeleteDeviceGroupRelationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (device) {
      vector<boost::any> temp1;
      for(auto item1:*device){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Device"] = boost::any(temp1);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      if (typeid(vector<boost::any>) == m["Device"].type()) {
        vector<BatchDeleteDeviceGroupRelationsRequestDevice> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Device"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchDeleteDeviceGroupRelationsRequestDevice model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        device = make_shared<vector<BatchDeleteDeviceGroupRelationsRequestDevice>>(expect1);
      }
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~BatchDeleteDeviceGroupRelationsRequest() = default;
};
class BatchDeleteDeviceGroupRelationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> alreadyRelatedGroupDeviceCount{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> successDeviceCount{};
  shared_ptr<long> validDeviceCount{};

  BatchDeleteDeviceGroupRelationsResponseBody() {}

  explicit BatchDeleteDeviceGroupRelationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alreadyRelatedGroupDeviceCount) {
      res["AlreadyRelatedGroupDeviceCount"] = boost::any(*alreadyRelatedGroupDeviceCount);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (successDeviceCount) {
      res["SuccessDeviceCount"] = boost::any(*successDeviceCount);
    }
    if (validDeviceCount) {
      res["ValidDeviceCount"] = boost::any(*validDeviceCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlreadyRelatedGroupDeviceCount") != m.end() && !m["AlreadyRelatedGroupDeviceCount"].empty()) {
      alreadyRelatedGroupDeviceCount = make_shared<long>(boost::any_cast<long>(m["AlreadyRelatedGroupDeviceCount"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("SuccessDeviceCount") != m.end() && !m["SuccessDeviceCount"].empty()) {
      successDeviceCount = make_shared<long>(boost::any_cast<long>(m["SuccessDeviceCount"]));
    }
    if (m.find("ValidDeviceCount") != m.end() && !m["ValidDeviceCount"].empty()) {
      validDeviceCount = make_shared<long>(boost::any_cast<long>(m["ValidDeviceCount"]));
    }
  }


  virtual ~BatchDeleteDeviceGroupRelationsResponseBody() = default;
};
class BatchDeleteDeviceGroupRelationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchDeleteDeviceGroupRelationsResponseBody> body{};

  BatchDeleteDeviceGroupRelationsResponse() {}

  explicit BatchDeleteDeviceGroupRelationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchDeleteDeviceGroupRelationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchDeleteDeviceGroupRelationsResponseBody>(model1);
      }
    }
  }


  virtual ~BatchDeleteDeviceGroupRelationsResponse() = default;
};
class BatchDeleteEdgeInstanceChannelRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channelIds{};
  shared_ptr<string> driverId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};

  BatchDeleteEdgeInstanceChannelRequest() {}

  explicit BatchDeleteEdgeInstanceChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelIds) {
      res["ChannelIds"] = boost::any(*channelIds);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelIds") != m.end() && !m["ChannelIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ChannelIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ChannelIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channelIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~BatchDeleteEdgeInstanceChannelRequest() = default;
};
class BatchDeleteEdgeInstanceChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchDeleteEdgeInstanceChannelResponseBody() {}

  explicit BatchDeleteEdgeInstanceChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchDeleteEdgeInstanceChannelResponseBody() = default;
};
class BatchDeleteEdgeInstanceChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchDeleteEdgeInstanceChannelResponseBody> body{};

  BatchDeleteEdgeInstanceChannelResponse() {}

  explicit BatchDeleteEdgeInstanceChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchDeleteEdgeInstanceChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchDeleteEdgeInstanceChannelResponseBody>(model1);
      }
    }
  }


  virtual ~BatchDeleteEdgeInstanceChannelResponse() = default;
};
class BatchGetDeviceBindStatusRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> iotIds{};
  shared_ptr<string> iotInstanceId{};

  BatchGetDeviceBindStatusRequest() {}

  explicit BatchGetDeviceBindStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotIds) {
      res["IotIds"] = boost::any(*iotIds);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotIds") != m.end() && !m["IotIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~BatchGetDeviceBindStatusRequest() = default;
};
class BatchGetDeviceBindStatusResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> bindStatus{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotId{};

  BatchGetDeviceBindStatusResponseBodyData() {}

  explicit BatchGetDeviceBindStatusResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindStatus) {
      res["BindStatus"] = boost::any(*bindStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BindStatus") != m.end() && !m["BindStatus"].empty()) {
      bindStatus = make_shared<long>(boost::any_cast<long>(m["BindStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~BatchGetDeviceBindStatusResponseBodyData() = default;
};
class BatchGetDeviceBindStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<BatchGetDeviceBindStatusResponseBodyData>> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchGetDeviceBindStatusResponseBody() {}

  explicit BatchGetDeviceBindStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<BatchGetDeviceBindStatusResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetDeviceBindStatusResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<BatchGetDeviceBindStatusResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchGetDeviceBindStatusResponseBody() = default;
};
class BatchGetDeviceBindStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchGetDeviceBindStatusResponseBody> body{};

  BatchGetDeviceBindStatusResponse() {}

  explicit BatchGetDeviceBindStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchGetDeviceBindStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchGetDeviceBindStatusResponseBody>(model1);
      }
    }
  }


  virtual ~BatchGetDeviceBindStatusResponse() = default;
};
class BatchGetDeviceStateRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> deviceName{};
  shared_ptr<vector<string>> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  BatchGetDeviceStateRequest() {}

  explicit BatchGetDeviceStateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~BatchGetDeviceStateRequest() = default;
};
class BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus : public Darabonba::Model {
public:
  shared_ptr<string> asAddress{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> lastOnlineTime{};
  shared_ptr<string> status{};

  BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus() {}

  explicit BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asAddress) {
      res["AsAddress"] = boost::any(*asAddress);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (lastOnlineTime) {
      res["LastOnlineTime"] = boost::any(*lastOnlineTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsAddress") != m.end() && !m["AsAddress"].empty()) {
      asAddress = make_shared<string>(boost::any_cast<string>(m["AsAddress"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("LastOnlineTime") != m.end() && !m["LastOnlineTime"].empty()) {
      lastOnlineTime = make_shared<string>(boost::any_cast<string>(m["LastOnlineTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus() = default;
};
class BatchGetDeviceStateResponseBodyDeviceStatusList : public Darabonba::Model {
public:
  shared_ptr<vector<BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus>> deviceStatus{};

  BatchGetDeviceStateResponseBodyDeviceStatusList() {}

  explicit BatchGetDeviceStateResponseBodyDeviceStatusList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceStatus) {
      vector<boost::any> temp1;
      for(auto item1:*deviceStatus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceStatus"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceStatus") != m.end() && !m["DeviceStatus"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceStatus"].type()) {
        vector<BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceStatus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceStatus = make_shared<vector<BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus>>(expect1);
      }
    }
  }


  virtual ~BatchGetDeviceStateResponseBodyDeviceStatusList() = default;
};
class BatchGetDeviceStateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<BatchGetDeviceStateResponseBodyDeviceStatusList> deviceStatusList{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchGetDeviceStateResponseBody() {}

  explicit BatchGetDeviceStateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (deviceStatusList) {
      res["DeviceStatusList"] = deviceStatusList ? boost::any(deviceStatusList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DeviceStatusList") != m.end() && !m["DeviceStatusList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeviceStatusList"].type()) {
        BatchGetDeviceStateResponseBodyDeviceStatusList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeviceStatusList"]));
        deviceStatusList = make_shared<BatchGetDeviceStateResponseBodyDeviceStatusList>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchGetDeviceStateResponseBody() = default;
};
class BatchGetDeviceStateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchGetDeviceStateResponseBody> body{};

  BatchGetDeviceStateResponse() {}

  explicit BatchGetDeviceStateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchGetDeviceStateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchGetDeviceStateResponseBody>(model1);
      }
    }
  }


  virtual ~BatchGetDeviceStateResponse() = default;
};
class BatchGetEdgeDriverRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> driverIds{};
  shared_ptr<string> iotInstanceId{};

  BatchGetEdgeDriverRequest() {}

  explicit BatchGetEdgeDriverRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driverIds) {
      res["DriverIds"] = boost::any(*driverIds);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DriverIds") != m.end() && !m["DriverIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DriverIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DriverIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      driverIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~BatchGetEdgeDriverRequest() = default;
};
class BatchGetEdgeDriverResponseBodyDriverList : public Darabonba::Model {
public:
  shared_ptr<string> cpuArch{};
  shared_ptr<string> driverId{};
  shared_ptr<string> driverName{};
  shared_ptr<string> driverProtocol{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<bool> isBuiltIn{};
  shared_ptr<string> runtime{};
  shared_ptr<long> type{};

  BatchGetEdgeDriverResponseBodyDriverList() {}

  explicit BatchGetEdgeDriverResponseBodyDriverList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpuArch) {
      res["CpuArch"] = boost::any(*cpuArch);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverName) {
      res["DriverName"] = boost::any(*driverName);
    }
    if (driverProtocol) {
      res["DriverProtocol"] = boost::any(*driverProtocol);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (isBuiltIn) {
      res["IsBuiltIn"] = boost::any(*isBuiltIn);
    }
    if (runtime) {
      res["Runtime"] = boost::any(*runtime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CpuArch") != m.end() && !m["CpuArch"].empty()) {
      cpuArch = make_shared<string>(boost::any_cast<string>(m["CpuArch"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverName") != m.end() && !m["DriverName"].empty()) {
      driverName = make_shared<string>(boost::any_cast<string>(m["DriverName"]));
    }
    if (m.find("DriverProtocol") != m.end() && !m["DriverProtocol"].empty()) {
      driverProtocol = make_shared<string>(boost::any_cast<string>(m["DriverProtocol"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("IsBuiltIn") != m.end() && !m["IsBuiltIn"].empty()) {
      isBuiltIn = make_shared<bool>(boost::any_cast<bool>(m["IsBuiltIn"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      runtime = make_shared<string>(boost::any_cast<string>(m["Runtime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~BatchGetEdgeDriverResponseBodyDriverList() = default;
};
class BatchGetEdgeDriverResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<BatchGetEdgeDriverResponseBodyDriverList>> driverList{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchGetEdgeDriverResponseBody() {}

  explicit BatchGetEdgeDriverResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (driverList) {
      vector<boost::any> temp1;
      for(auto item1:*driverList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DriverList"] = boost::any(temp1);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DriverList") != m.end() && !m["DriverList"].empty()) {
      if (typeid(vector<boost::any>) == m["DriverList"].type()) {
        vector<BatchGetEdgeDriverResponseBodyDriverList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DriverList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetEdgeDriverResponseBodyDriverList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        driverList = make_shared<vector<BatchGetEdgeDriverResponseBodyDriverList>>(expect1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchGetEdgeDriverResponseBody() = default;
};
class BatchGetEdgeDriverResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchGetEdgeDriverResponseBody> body{};

  BatchGetEdgeDriverResponse() {}

  explicit BatchGetEdgeDriverResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchGetEdgeDriverResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchGetEdgeDriverResponseBody>(model1);
      }
    }
  }


  virtual ~BatchGetEdgeDriverResponse() = default;
};
class BatchGetEdgeInstanceChannelRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channelIds{};
  shared_ptr<string> driverId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};

  BatchGetEdgeInstanceChannelRequest() {}

  explicit BatchGetEdgeInstanceChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelIds) {
      res["ChannelIds"] = boost::any(*channelIds);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelIds") != m.end() && !m["ChannelIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ChannelIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ChannelIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channelIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~BatchGetEdgeInstanceChannelRequest() = default;
};
class BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<string> content{};
  shared_ptr<string> format{};
  shared_ptr<string> key{};

  BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig() {}

  explicit BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig() = default;
};
class BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig>> config{};

  BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList() {}

  explicit BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      vector<boost::any> temp1;
      for(auto item1:*config){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Config"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(vector<boost::any>) == m["Config"].type()) {
        vector<BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Config"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        config = make_shared<vector<BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig>>(expect1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList() = default;
};
class BatchGetEdgeInstanceChannelResponseBodyDataChannel : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> channelName{};
  shared_ptr<BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList> configList{};

  BatchGetEdgeInstanceChannelResponseBodyDataChannel() {}

  explicit BatchGetEdgeInstanceChannelResponseBodyDataChannel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (configList) {
      res["ConfigList"] = configList ? boost::any(configList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ConfigList") != m.end() && !m["ConfigList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigList"].type()) {
        BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigList"]));
        configList = make_shared<BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList>(model1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceChannelResponseBodyDataChannel() = default;
};
class BatchGetEdgeInstanceChannelResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<BatchGetEdgeInstanceChannelResponseBodyDataChannel>> channel{};

  BatchGetEdgeInstanceChannelResponseBodyData() {}

  explicit BatchGetEdgeInstanceChannelResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channel) {
      vector<boost::any> temp1;
      for(auto item1:*channel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Channel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      if (typeid(vector<boost::any>) == m["Channel"].type()) {
        vector<BatchGetEdgeInstanceChannelResponseBodyDataChannel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Channel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetEdgeInstanceChannelResponseBodyDataChannel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channel = make_shared<vector<BatchGetEdgeInstanceChannelResponseBodyDataChannel>>(expect1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceChannelResponseBodyData() = default;
};
class BatchGetEdgeInstanceChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<BatchGetEdgeInstanceChannelResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchGetEdgeInstanceChannelResponseBody() {}

  explicit BatchGetEdgeInstanceChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BatchGetEdgeInstanceChannelResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BatchGetEdgeInstanceChannelResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchGetEdgeInstanceChannelResponseBody() = default;
};
class BatchGetEdgeInstanceChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchGetEdgeInstanceChannelResponseBody> body{};

  BatchGetEdgeInstanceChannelResponse() {}

  explicit BatchGetEdgeInstanceChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchGetEdgeInstanceChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchGetEdgeInstanceChannelResponseBody>(model1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceChannelResponse() = default;
};
class BatchGetEdgeInstanceDeviceChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> driverId{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> iotIds{};
  shared_ptr<string> iotInstanceId{};

  BatchGetEdgeInstanceDeviceChannelRequest() {}

  explicit BatchGetEdgeInstanceDeviceChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotIds) {
      res["IotIds"] = boost::any(*iotIds);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotIds") != m.end() && !m["IotIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceChannelRequest() = default;
};
class BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> channelName{};
  shared_ptr<string> iotId{};

  BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList() {}

  explicit BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList() = default;
};
class BatchGetEdgeInstanceDeviceChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList>> deviceChannelList{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchGetEdgeInstanceDeviceChannelResponseBody() {}

  explicit BatchGetEdgeInstanceDeviceChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (deviceChannelList) {
      vector<boost::any> temp1;
      for(auto item1:*deviceChannelList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceChannelList"] = boost::any(temp1);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DeviceChannelList") != m.end() && !m["DeviceChannelList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceChannelList"].type()) {
        vector<BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceChannelList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceChannelList = make_shared<vector<BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList>>(expect1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceChannelResponseBody() = default;
};
class BatchGetEdgeInstanceDeviceChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchGetEdgeInstanceDeviceChannelResponseBody> body{};

  BatchGetEdgeInstanceDeviceChannelResponse() {}

  explicit BatchGetEdgeInstanceDeviceChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchGetEdgeInstanceDeviceChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchGetEdgeInstanceDeviceChannelResponseBody>(model1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceChannelResponse() = default;
};
class BatchGetEdgeInstanceDeviceConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> iotIds{};
  shared_ptr<string> iotInstanceId{};

  BatchGetEdgeInstanceDeviceConfigRequest() {}

  explicit BatchGetEdgeInstanceDeviceConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotIds) {
      res["IotIds"] = boost::any(*iotIds);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotIds") != m.end() && !m["IotIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceConfigRequest() = default;
};
class BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> format{};

  BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig() {}

  explicit BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig() = default;
};
class BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList : public Darabonba::Model {
public:
  shared_ptr<BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig> config{};
  shared_ptr<string> iotId{};

  BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList() {}

  explicit BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = config ? boost::any(config->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(map<string, boost::any>) == m["Config"].type()) {
        BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Config"]));
        config = make_shared<BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig>(model1);
      }
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList() = default;
};
class BatchGetEdgeInstanceDeviceConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList>> deviceConfigList{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchGetEdgeInstanceDeviceConfigResponseBody() {}

  explicit BatchGetEdgeInstanceDeviceConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (deviceConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*deviceConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceConfigList"] = boost::any(temp1);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DeviceConfigList") != m.end() && !m["DeviceConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceConfigList"].type()) {
        vector<BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceConfigList = make_shared<vector<BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList>>(expect1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceConfigResponseBody() = default;
};
class BatchGetEdgeInstanceDeviceConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchGetEdgeInstanceDeviceConfigResponseBody> body{};

  BatchGetEdgeInstanceDeviceConfigResponse() {}

  explicit BatchGetEdgeInstanceDeviceConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchGetEdgeInstanceDeviceConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchGetEdgeInstanceDeviceConfigResponseBody>(model1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceConfigResponse() = default;
};
class BatchGetEdgeInstanceDeviceDriverRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> iotIds{};
  shared_ptr<string> iotInstanceId{};

  BatchGetEdgeInstanceDeviceDriverRequest() {}

  explicit BatchGetEdgeInstanceDeviceDriverRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotIds) {
      res["IotIds"] = boost::any(*iotIds);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotIds") != m.end() && !m["IotIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceDriverRequest() = default;
};
class BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList : public Darabonba::Model {
public:
  shared_ptr<string> driverId{};
  shared_ptr<string> iotId{};

  BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList() {}

  explicit BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList() = default;
};
class BatchGetEdgeInstanceDeviceDriverResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList>> deviceDriverList{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchGetEdgeInstanceDeviceDriverResponseBody() {}

  explicit BatchGetEdgeInstanceDeviceDriverResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (deviceDriverList) {
      vector<boost::any> temp1;
      for(auto item1:*deviceDriverList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceDriverList"] = boost::any(temp1);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DeviceDriverList") != m.end() && !m["DeviceDriverList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceDriverList"].type()) {
        vector<BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceDriverList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceDriverList = make_shared<vector<BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList>>(expect1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceDriverResponseBody() = default;
};
class BatchGetEdgeInstanceDeviceDriverResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchGetEdgeInstanceDeviceDriverResponseBody> body{};

  BatchGetEdgeInstanceDeviceDriverResponse() {}

  explicit BatchGetEdgeInstanceDeviceDriverResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchGetEdgeInstanceDeviceDriverResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchGetEdgeInstanceDeviceDriverResponseBody>(model1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceDriverResponse() = default;
};
class BatchGetEdgeInstanceDriverConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> driverIds{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};

  BatchGetEdgeInstanceDriverConfigsRequest() {}

  explicit BatchGetEdgeInstanceDriverConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driverIds) {
      res["DriverIds"] = boost::any(*driverIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DriverIds") != m.end() && !m["DriverIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DriverIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DriverIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      driverIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~BatchGetEdgeInstanceDriverConfigsRequest() = default;
};
class BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<string> content{};
  shared_ptr<string> format{};
  shared_ptr<string> key{};

  BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList() {}

  explicit BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList() = default;
};
class BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList>> configList{};
  shared_ptr<string> driverId{};

  BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList() {}

  explicit BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configList) {
      vector<boost::any> temp1;
      for(auto item1:*configList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigList"] = boost::any(temp1);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigList") != m.end() && !m["ConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigList"].type()) {
        vector<BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configList = make_shared<vector<BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList>>(expect1);
      }
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
  }


  virtual ~BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList() = default;
};
class BatchGetEdgeInstanceDriverConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList>> driverConfigList{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchGetEdgeInstanceDriverConfigsResponseBody() {}

  explicit BatchGetEdgeInstanceDriverConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (driverConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*driverConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DriverConfigList"] = boost::any(temp1);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DriverConfigList") != m.end() && !m["DriverConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["DriverConfigList"].type()) {
        vector<BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DriverConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        driverConfigList = make_shared<vector<BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList>>(expect1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchGetEdgeInstanceDriverConfigsResponseBody() = default;
};
class BatchGetEdgeInstanceDriverConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchGetEdgeInstanceDriverConfigsResponseBody> body{};

  BatchGetEdgeInstanceDriverConfigsResponse() {}

  explicit BatchGetEdgeInstanceDriverConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchGetEdgeInstanceDriverConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchGetEdgeInstanceDriverConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceDriverConfigsResponse() = default;
};
class BatchGrayMigrationDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> deviceNames{};
  shared_ptr<string> productKey{};

  BatchGrayMigrationDeviceRequest() {}

  explicit BatchGrayMigrationDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceNames) {
      res["DeviceNames"] = boost::any(*deviceNames);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceNames") != m.end() && !m["DeviceNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~BatchGrayMigrationDeviceRequest() = default;
};
class BatchGrayMigrationDeviceResponseBodyDataDetailsItem : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> message{};
  shared_ptr<string> status{};

  BatchGrayMigrationDeviceResponseBodyDataDetailsItem() {}

  explicit BatchGrayMigrationDeviceResponseBodyDataDetailsItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~BatchGrayMigrationDeviceResponseBodyDataDetailsItem() = default;
};
class BatchGrayMigrationDeviceResponseBodyDataDetails : public Darabonba::Model {
public:
  shared_ptr<vector<BatchGrayMigrationDeviceResponseBodyDataDetailsItem>> item{};

  BatchGrayMigrationDeviceResponseBodyDataDetails() {}

  explicit BatchGrayMigrationDeviceResponseBodyDataDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["item"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("item") != m.end() && !m["item"].empty()) {
      if (typeid(vector<boost::any>) == m["item"].type()) {
        vector<BatchGrayMigrationDeviceResponseBodyDataDetailsItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGrayMigrationDeviceResponseBodyDataDetailsItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<BatchGrayMigrationDeviceResponseBodyDataDetailsItem>>(expect1);
      }
    }
  }


  virtual ~BatchGrayMigrationDeviceResponseBodyDataDetails() = default;
};
class BatchGrayMigrationDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<BatchGrayMigrationDeviceResponseBodyDataDetails> details{};

  BatchGrayMigrationDeviceResponseBodyData() {}

  explicit BatchGrayMigrationDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (details) {
      res["Details"] = details ? boost::any(details->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Details") != m.end() && !m["Details"].empty()) {
      if (typeid(map<string, boost::any>) == m["Details"].type()) {
        BatchGrayMigrationDeviceResponseBodyDataDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Details"]));
        details = make_shared<BatchGrayMigrationDeviceResponseBodyDataDetails>(model1);
      }
    }
  }


  virtual ~BatchGrayMigrationDeviceResponseBodyData() = default;
};
class BatchGrayMigrationDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<BatchGrayMigrationDeviceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchGrayMigrationDeviceResponseBody() {}

  explicit BatchGrayMigrationDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BatchGrayMigrationDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BatchGrayMigrationDeviceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchGrayMigrationDeviceResponseBody() = default;
};
class BatchGrayMigrationDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchGrayMigrationDeviceResponseBody> body{};

  BatchGrayMigrationDeviceResponse() {}

  explicit BatchGrayMigrationDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchGrayMigrationDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchGrayMigrationDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~BatchGrayMigrationDeviceResponse() = default;
};
class BatchImportDeviceRequestDeviceList : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceSecret{};
  shared_ptr<string> sn{};

  BatchImportDeviceRequestDeviceList() {}

  explicit BatchImportDeviceRequestDeviceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceSecret) {
      res["DeviceSecret"] = boost::any(*deviceSecret);
    }
    if (sn) {
      res["Sn"] = boost::any(*sn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceSecret") != m.end() && !m["DeviceSecret"].empty()) {
      deviceSecret = make_shared<string>(boost::any_cast<string>(m["DeviceSecret"]));
    }
    if (m.find("Sn") != m.end() && !m["Sn"].empty()) {
      sn = make_shared<string>(boost::any_cast<string>(m["Sn"]));
    }
  }


  virtual ~BatchImportDeviceRequestDeviceList() = default;
};
class BatchImportDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<vector<BatchImportDeviceRequestDeviceList>> deviceList{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  BatchImportDeviceRequest() {}

  explicit BatchImportDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceList) {
      vector<boost::any> temp1;
      for(auto item1:*deviceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceList"] = boost::any(temp1);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceList") != m.end() && !m["DeviceList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceList"].type()) {
        vector<BatchImportDeviceRequestDeviceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchImportDeviceRequestDeviceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceList = make_shared<vector<BatchImportDeviceRequestDeviceList>>(expect1);
      }
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~BatchImportDeviceRequest() = default;
};
class BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceSecret{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> sn{};

  BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList() {}

  explicit BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceSecret) {
      res["DeviceSecret"] = boost::any(*deviceSecret);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (sn) {
      res["Sn"] = boost::any(*sn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceSecret") != m.end() && !m["DeviceSecret"].empty()) {
      deviceSecret = make_shared<string>(boost::any_cast<string>(m["DeviceSecret"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("Sn") != m.end() && !m["Sn"].empty()) {
      sn = make_shared<string>(boost::any_cast<string>(m["Sn"]));
    }
  }


  virtual ~BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList() = default;
};
class BatchImportDeviceResponseBodyDataInvalidDetailList : public Darabonba::Model {
public:
  shared_ptr<vector<BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList>> invalidDetailList{};

  BatchImportDeviceResponseBodyDataInvalidDetailList() {}

  explicit BatchImportDeviceResponseBodyDataInvalidDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invalidDetailList) {
      vector<boost::any> temp1;
      for(auto item1:*invalidDetailList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InvalidDetailList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InvalidDetailList") != m.end() && !m["InvalidDetailList"].empty()) {
      if (typeid(vector<boost::any>) == m["InvalidDetailList"].type()) {
        vector<BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InvalidDetailList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        invalidDetailList = make_shared<vector<BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList>>(expect1);
      }
    }
  }


  virtual ~BatchImportDeviceResponseBodyDataInvalidDetailList() = default;
};
class BatchImportDeviceResponseBodyDataInvalidDeviceNameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> invalidDeviceName{};

  BatchImportDeviceResponseBodyDataInvalidDeviceNameList() {}

  explicit BatchImportDeviceResponseBodyDataInvalidDeviceNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invalidDeviceName) {
      res["invalidDeviceName"] = boost::any(*invalidDeviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("invalidDeviceName") != m.end() && !m["invalidDeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["invalidDeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["invalidDeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      invalidDeviceName = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchImportDeviceResponseBodyDataInvalidDeviceNameList() = default;
};
class BatchImportDeviceResponseBodyDataInvalidDeviceSecretList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> invalidDeviceSecret{};

  BatchImportDeviceResponseBodyDataInvalidDeviceSecretList() {}

  explicit BatchImportDeviceResponseBodyDataInvalidDeviceSecretList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invalidDeviceSecret) {
      res["invalidDeviceSecret"] = boost::any(*invalidDeviceSecret);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("invalidDeviceSecret") != m.end() && !m["invalidDeviceSecret"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["invalidDeviceSecret"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["invalidDeviceSecret"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      invalidDeviceSecret = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchImportDeviceResponseBodyDataInvalidDeviceSecretList() = default;
};
class BatchImportDeviceResponseBodyDataInvalidSnList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> invalidSn{};

  BatchImportDeviceResponseBodyDataInvalidSnList() {}

  explicit BatchImportDeviceResponseBodyDataInvalidSnList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invalidSn) {
      res["invalidSn"] = boost::any(*invalidSn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("invalidSn") != m.end() && !m["invalidSn"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["invalidSn"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["invalidSn"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      invalidSn = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchImportDeviceResponseBodyDataInvalidSnList() = default;
};
class BatchImportDeviceResponseBodyDataRepeatedDeviceNameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> repeatedDeviceName{};

  BatchImportDeviceResponseBodyDataRepeatedDeviceNameList() {}

  explicit BatchImportDeviceResponseBodyDataRepeatedDeviceNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (repeatedDeviceName) {
      res["repeatedDeviceName"] = boost::any(*repeatedDeviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("repeatedDeviceName") != m.end() && !m["repeatedDeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["repeatedDeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["repeatedDeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      repeatedDeviceName = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchImportDeviceResponseBodyDataRepeatedDeviceNameList() = default;
};
class BatchImportDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<BatchImportDeviceResponseBodyDataInvalidDetailList> invalidDetailList{};
  shared_ptr<BatchImportDeviceResponseBodyDataInvalidDeviceNameList> invalidDeviceNameList{};
  shared_ptr<BatchImportDeviceResponseBodyDataInvalidDeviceSecretList> invalidDeviceSecretList{};
  shared_ptr<BatchImportDeviceResponseBodyDataInvalidSnList> invalidSnList{};
  shared_ptr<BatchImportDeviceResponseBodyDataRepeatedDeviceNameList> repeatedDeviceNameList{};

  BatchImportDeviceResponseBodyData() {}

  explicit BatchImportDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["ApplyId"] = boost::any(*applyId);
    }
    if (invalidDetailList) {
      res["InvalidDetailList"] = invalidDetailList ? boost::any(invalidDetailList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (invalidDeviceNameList) {
      res["InvalidDeviceNameList"] = invalidDeviceNameList ? boost::any(invalidDeviceNameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (invalidDeviceSecretList) {
      res["InvalidDeviceSecretList"] = invalidDeviceSecretList ? boost::any(invalidDeviceSecretList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (invalidSnList) {
      res["InvalidSnList"] = invalidSnList ? boost::any(invalidSnList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (repeatedDeviceNameList) {
      res["RepeatedDeviceNameList"] = repeatedDeviceNameList ? boost::any(repeatedDeviceNameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyId") != m.end() && !m["ApplyId"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["ApplyId"]));
    }
    if (m.find("InvalidDetailList") != m.end() && !m["InvalidDetailList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvalidDetailList"].type()) {
        BatchImportDeviceResponseBodyDataInvalidDetailList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvalidDetailList"]));
        invalidDetailList = make_shared<BatchImportDeviceResponseBodyDataInvalidDetailList>(model1);
      }
    }
    if (m.find("InvalidDeviceNameList") != m.end() && !m["InvalidDeviceNameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvalidDeviceNameList"].type()) {
        BatchImportDeviceResponseBodyDataInvalidDeviceNameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvalidDeviceNameList"]));
        invalidDeviceNameList = make_shared<BatchImportDeviceResponseBodyDataInvalidDeviceNameList>(model1);
      }
    }
    if (m.find("InvalidDeviceSecretList") != m.end() && !m["InvalidDeviceSecretList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvalidDeviceSecretList"].type()) {
        BatchImportDeviceResponseBodyDataInvalidDeviceSecretList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvalidDeviceSecretList"]));
        invalidDeviceSecretList = make_shared<BatchImportDeviceResponseBodyDataInvalidDeviceSecretList>(model1);
      }
    }
    if (m.find("InvalidSnList") != m.end() && !m["InvalidSnList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvalidSnList"].type()) {
        BatchImportDeviceResponseBodyDataInvalidSnList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvalidSnList"]));
        invalidSnList = make_shared<BatchImportDeviceResponseBodyDataInvalidSnList>(model1);
      }
    }
    if (m.find("RepeatedDeviceNameList") != m.end() && !m["RepeatedDeviceNameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RepeatedDeviceNameList"].type()) {
        BatchImportDeviceResponseBodyDataRepeatedDeviceNameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RepeatedDeviceNameList"]));
        repeatedDeviceNameList = make_shared<BatchImportDeviceResponseBodyDataRepeatedDeviceNameList>(model1);
      }
    }
  }


  virtual ~BatchImportDeviceResponseBodyData() = default;
};
class BatchImportDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<BatchImportDeviceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchImportDeviceResponseBody() {}

  explicit BatchImportDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BatchImportDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BatchImportDeviceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchImportDeviceResponseBody() = default;
};
class BatchImportDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchImportDeviceResponseBody> body{};

  BatchImportDeviceResponse() {}

  explicit BatchImportDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchImportDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchImportDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~BatchImportDeviceResponse() = default;
};
class BatchImportVehicleDeviceRequestDeviceList : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceModel{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> manufacturer{};

  BatchImportVehicleDeviceRequestDeviceList() {}

  explicit BatchImportVehicleDeviceRequestDeviceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (manufacturer) {
      res["Manufacturer"] = boost::any(*manufacturer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Manufacturer") != m.end() && !m["Manufacturer"].empty()) {
      manufacturer = make_shared<string>(boost::any_cast<string>(m["Manufacturer"]));
    }
  }


  virtual ~BatchImportVehicleDeviceRequestDeviceList() = default;
};
class BatchImportVehicleDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<vector<BatchImportVehicleDeviceRequestDeviceList>> deviceList{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  BatchImportVehicleDeviceRequest() {}

  explicit BatchImportVehicleDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceList) {
      vector<boost::any> temp1;
      for(auto item1:*deviceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceList"] = boost::any(temp1);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceList") != m.end() && !m["DeviceList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceList"].type()) {
        vector<BatchImportVehicleDeviceRequestDeviceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchImportVehicleDeviceRequestDeviceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceList = make_shared<vector<BatchImportVehicleDeviceRequestDeviceList>>(expect1);
      }
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~BatchImportVehicleDeviceRequest() = default;
};
class BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceModel{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> manufacturer{};

  BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList() {}

  explicit BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (manufacturer) {
      res["Manufacturer"] = boost::any(*manufacturer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("Manufacturer") != m.end() && !m["Manufacturer"].empty()) {
      manufacturer = make_shared<string>(boost::any_cast<string>(m["Manufacturer"]));
    }
  }


  virtual ~BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList() = default;
};
class BatchImportVehicleDeviceResponseBodyDataInvalidDetailList : public Darabonba::Model {
public:
  shared_ptr<vector<BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList>> invalidDetailList{};

  BatchImportVehicleDeviceResponseBodyDataInvalidDetailList() {}

  explicit BatchImportVehicleDeviceResponseBodyDataInvalidDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invalidDetailList) {
      vector<boost::any> temp1;
      for(auto item1:*invalidDetailList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InvalidDetailList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InvalidDetailList") != m.end() && !m["InvalidDetailList"].empty()) {
      if (typeid(vector<boost::any>) == m["InvalidDetailList"].type()) {
        vector<BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InvalidDetailList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        invalidDetailList = make_shared<vector<BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList>>(expect1);
      }
    }
  }


  virtual ~BatchImportVehicleDeviceResponseBodyDataInvalidDetailList() = default;
};
class BatchImportVehicleDeviceResponseBodyDataInvalidDeviceIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> invalidDeviceIdList{};

  BatchImportVehicleDeviceResponseBodyDataInvalidDeviceIdList() {}

  explicit BatchImportVehicleDeviceResponseBodyDataInvalidDeviceIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invalidDeviceIdList) {
      res["invalidDeviceIdList"] = boost::any(*invalidDeviceIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("invalidDeviceIdList") != m.end() && !m["invalidDeviceIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["invalidDeviceIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["invalidDeviceIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      invalidDeviceIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchImportVehicleDeviceResponseBodyDataInvalidDeviceIdList() = default;
};
class BatchImportVehicleDeviceResponseBodyDataInvalidDeviceModelList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> invalidDeviceModelList{};

  BatchImportVehicleDeviceResponseBodyDataInvalidDeviceModelList() {}

  explicit BatchImportVehicleDeviceResponseBodyDataInvalidDeviceModelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invalidDeviceModelList) {
      res["invalidDeviceModelList"] = boost::any(*invalidDeviceModelList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("invalidDeviceModelList") != m.end() && !m["invalidDeviceModelList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["invalidDeviceModelList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["invalidDeviceModelList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      invalidDeviceModelList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchImportVehicleDeviceResponseBodyDataInvalidDeviceModelList() = default;
};
class BatchImportVehicleDeviceResponseBodyDataInvalidDeviceNameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> invalidDeviceNameList{};

  BatchImportVehicleDeviceResponseBodyDataInvalidDeviceNameList() {}

  explicit BatchImportVehicleDeviceResponseBodyDataInvalidDeviceNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invalidDeviceNameList) {
      res["InvalidDeviceNameList"] = boost::any(*invalidDeviceNameList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InvalidDeviceNameList") != m.end() && !m["InvalidDeviceNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InvalidDeviceNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InvalidDeviceNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      invalidDeviceNameList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchImportVehicleDeviceResponseBodyDataInvalidDeviceNameList() = default;
};
class BatchImportVehicleDeviceResponseBodyDataInvalidManufacturerList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> invalidManufacturerList{};

  BatchImportVehicleDeviceResponseBodyDataInvalidManufacturerList() {}

  explicit BatchImportVehicleDeviceResponseBodyDataInvalidManufacturerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invalidManufacturerList) {
      res["invalidManufacturerList"] = boost::any(*invalidManufacturerList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("invalidManufacturerList") != m.end() && !m["invalidManufacturerList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["invalidManufacturerList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["invalidManufacturerList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      invalidManufacturerList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchImportVehicleDeviceResponseBodyDataInvalidManufacturerList() = default;
};
class BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> repeatedDeviceIdList{};

  BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceIdList() {}

  explicit BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (repeatedDeviceIdList) {
      res["repeatedDeviceIdList"] = boost::any(*repeatedDeviceIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("repeatedDeviceIdList") != m.end() && !m["repeatedDeviceIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["repeatedDeviceIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["repeatedDeviceIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      repeatedDeviceIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceIdList() = default;
};
class BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceNameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> repeatedDeviceNameList{};

  BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceNameList() {}

  explicit BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (repeatedDeviceNameList) {
      res["RepeatedDeviceNameList"] = boost::any(*repeatedDeviceNameList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RepeatedDeviceNameList") != m.end() && !m["RepeatedDeviceNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RepeatedDeviceNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RepeatedDeviceNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      repeatedDeviceNameList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceNameList() = default;
};
class BatchImportVehicleDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<BatchImportVehicleDeviceResponseBodyDataInvalidDetailList> invalidDetailList{};
  shared_ptr<BatchImportVehicleDeviceResponseBodyDataInvalidDeviceIdList> invalidDeviceIdList{};
  shared_ptr<BatchImportVehicleDeviceResponseBodyDataInvalidDeviceModelList> invalidDeviceModelList{};
  shared_ptr<BatchImportVehicleDeviceResponseBodyDataInvalidDeviceNameList> invalidDeviceNameList{};
  shared_ptr<BatchImportVehicleDeviceResponseBodyDataInvalidManufacturerList> invalidManufacturerList{};
  shared_ptr<BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceIdList> repeatedDeviceIdList{};
  shared_ptr<BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceNameList> repeatedDeviceNameList{};

  BatchImportVehicleDeviceResponseBodyData() {}

  explicit BatchImportVehicleDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["ApplyId"] = boost::any(*applyId);
    }
    if (invalidDetailList) {
      res["InvalidDetailList"] = invalidDetailList ? boost::any(invalidDetailList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (invalidDeviceIdList) {
      res["InvalidDeviceIdList"] = invalidDeviceIdList ? boost::any(invalidDeviceIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (invalidDeviceModelList) {
      res["InvalidDeviceModelList"] = invalidDeviceModelList ? boost::any(invalidDeviceModelList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (invalidDeviceNameList) {
      res["InvalidDeviceNameList"] = invalidDeviceNameList ? boost::any(invalidDeviceNameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (invalidManufacturerList) {
      res["InvalidManufacturerList"] = invalidManufacturerList ? boost::any(invalidManufacturerList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (repeatedDeviceIdList) {
      res["RepeatedDeviceIdList"] = repeatedDeviceIdList ? boost::any(repeatedDeviceIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (repeatedDeviceNameList) {
      res["RepeatedDeviceNameList"] = repeatedDeviceNameList ? boost::any(repeatedDeviceNameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyId") != m.end() && !m["ApplyId"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["ApplyId"]));
    }
    if (m.find("InvalidDetailList") != m.end() && !m["InvalidDetailList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvalidDetailList"].type()) {
        BatchImportVehicleDeviceResponseBodyDataInvalidDetailList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvalidDetailList"]));
        invalidDetailList = make_shared<BatchImportVehicleDeviceResponseBodyDataInvalidDetailList>(model1);
      }
    }
    if (m.find("InvalidDeviceIdList") != m.end() && !m["InvalidDeviceIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvalidDeviceIdList"].type()) {
        BatchImportVehicleDeviceResponseBodyDataInvalidDeviceIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvalidDeviceIdList"]));
        invalidDeviceIdList = make_shared<BatchImportVehicleDeviceResponseBodyDataInvalidDeviceIdList>(model1);
      }
    }
    if (m.find("InvalidDeviceModelList") != m.end() && !m["InvalidDeviceModelList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvalidDeviceModelList"].type()) {
        BatchImportVehicleDeviceResponseBodyDataInvalidDeviceModelList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvalidDeviceModelList"]));
        invalidDeviceModelList = make_shared<BatchImportVehicleDeviceResponseBodyDataInvalidDeviceModelList>(model1);
      }
    }
    if (m.find("InvalidDeviceNameList") != m.end() && !m["InvalidDeviceNameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvalidDeviceNameList"].type()) {
        BatchImportVehicleDeviceResponseBodyDataInvalidDeviceNameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvalidDeviceNameList"]));
        invalidDeviceNameList = make_shared<BatchImportVehicleDeviceResponseBodyDataInvalidDeviceNameList>(model1);
      }
    }
    if (m.find("InvalidManufacturerList") != m.end() && !m["InvalidManufacturerList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvalidManufacturerList"].type()) {
        BatchImportVehicleDeviceResponseBodyDataInvalidManufacturerList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvalidManufacturerList"]));
        invalidManufacturerList = make_shared<BatchImportVehicleDeviceResponseBodyDataInvalidManufacturerList>(model1);
      }
    }
    if (m.find("RepeatedDeviceIdList") != m.end() && !m["RepeatedDeviceIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RepeatedDeviceIdList"].type()) {
        BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RepeatedDeviceIdList"]));
        repeatedDeviceIdList = make_shared<BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceIdList>(model1);
      }
    }
    if (m.find("RepeatedDeviceNameList") != m.end() && !m["RepeatedDeviceNameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RepeatedDeviceNameList"].type()) {
        BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceNameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RepeatedDeviceNameList"]));
        repeatedDeviceNameList = make_shared<BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceNameList>(model1);
      }
    }
  }


  virtual ~BatchImportVehicleDeviceResponseBodyData() = default;
};
class BatchImportVehicleDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<BatchImportVehicleDeviceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchImportVehicleDeviceResponseBody() {}

  explicit BatchImportVehicleDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BatchImportVehicleDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BatchImportVehicleDeviceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchImportVehicleDeviceResponseBody() = default;
};
class BatchImportVehicleDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchImportVehicleDeviceResponseBody> body{};

  BatchImportVehicleDeviceResponse() {}

  explicit BatchImportVehicleDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchImportVehicleDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchImportVehicleDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~BatchImportVehicleDeviceResponse() = default;
};
class BatchPubRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> messageContent{};
  shared_ptr<string> productKey{};
  shared_ptr<long> qos{};
  shared_ptr<string> topicShortName{};

  BatchPubRequest() {}

  explicit BatchPubRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (messageContent) {
      res["MessageContent"] = boost::any(*messageContent);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (qos) {
      res["Qos"] = boost::any(*qos);
    }
    if (topicShortName) {
      res["TopicShortName"] = boost::any(*topicShortName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("MessageContent") != m.end() && !m["MessageContent"].empty()) {
      messageContent = make_shared<string>(boost::any_cast<string>(m["MessageContent"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Qos") != m.end() && !m["Qos"].empty()) {
      qos = make_shared<long>(boost::any_cast<long>(m["Qos"]));
    }
    if (m.find("TopicShortName") != m.end() && !m["TopicShortName"].empty()) {
      topicShortName = make_shared<string>(boost::any_cast<string>(m["TopicShortName"]));
    }
  }


  virtual ~BatchPubRequest() = default;
};
class BatchPubResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchPubResponseBody() {}

  explicit BatchPubResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchPubResponseBody() = default;
};
class BatchPubResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchPubResponseBody> body{};

  BatchPubResponse() {}

  explicit BatchPubResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchPubResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchPubResponseBody>(model1);
      }
    }
  }


  virtual ~BatchPubResponse() = default;
};
class BatchQueryDeviceDetailRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  BatchQueryDeviceDetailRequest() {}

  explicit BatchQueryDeviceDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~BatchQueryDeviceDetailRequest() = default;
};
class BatchQueryDeviceDetailResponseBodyDataData : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceSecret{};
  shared_ptr<string> firmwareVersion{};
  shared_ptr<string> gmtActive{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> iotId{};
  shared_ptr<string> nickname{};
  shared_ptr<long> nodeType{};
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};
  shared_ptr<string> region{};
  shared_ptr<string> status{};
  shared_ptr<string> utcActive{};
  shared_ptr<string> utcCreate{};

  BatchQueryDeviceDetailResponseBodyDataData() {}

  explicit BatchQueryDeviceDetailResponseBodyDataData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceSecret) {
      res["DeviceSecret"] = boost::any(*deviceSecret);
    }
    if (firmwareVersion) {
      res["FirmwareVersion"] = boost::any(*firmwareVersion);
    }
    if (gmtActive) {
      res["GmtActive"] = boost::any(*gmtActive);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (utcActive) {
      res["UtcActive"] = boost::any(*utcActive);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceSecret") != m.end() && !m["DeviceSecret"].empty()) {
      deviceSecret = make_shared<string>(boost::any_cast<string>(m["DeviceSecret"]));
    }
    if (m.find("FirmwareVersion") != m.end() && !m["FirmwareVersion"].empty()) {
      firmwareVersion = make_shared<string>(boost::any_cast<string>(m["FirmwareVersion"]));
    }
    if (m.find("GmtActive") != m.end() && !m["GmtActive"].empty()) {
      gmtActive = make_shared<string>(boost::any_cast<string>(m["GmtActive"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<long>(boost::any_cast<long>(m["NodeType"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UtcActive") != m.end() && !m["UtcActive"].empty()) {
      utcActive = make_shared<string>(boost::any_cast<string>(m["UtcActive"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
  }


  virtual ~BatchQueryDeviceDetailResponseBodyDataData() = default;
};
class BatchQueryDeviceDetailResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<BatchQueryDeviceDetailResponseBodyDataData>> data{};

  BatchQueryDeviceDetailResponseBodyData() {}

  explicit BatchQueryDeviceDetailResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<BatchQueryDeviceDetailResponseBodyDataData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchQueryDeviceDetailResponseBodyDataData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<BatchQueryDeviceDetailResponseBodyDataData>>(expect1);
      }
    }
  }


  virtual ~BatchQueryDeviceDetailResponseBodyData() = default;
};
class BatchQueryDeviceDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<BatchQueryDeviceDetailResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchQueryDeviceDetailResponseBody() {}

  explicit BatchQueryDeviceDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BatchQueryDeviceDetailResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BatchQueryDeviceDetailResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchQueryDeviceDetailResponseBody() = default;
};
class BatchQueryDeviceDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchQueryDeviceDetailResponseBody> body{};

  BatchQueryDeviceDetailResponse() {}

  explicit BatchQueryDeviceDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchQueryDeviceDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchQueryDeviceDetailResponseBody>(model1);
      }
    }
  }


  virtual ~BatchQueryDeviceDetailResponse() = default;
};
class BatchRegisterDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  BatchRegisterDeviceRequest() {}

  explicit BatchRegisterDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~BatchRegisterDeviceRequest() = default;
};
class BatchRegisterDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};

  BatchRegisterDeviceResponseBodyData() {}

  explicit BatchRegisterDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["ApplyId"] = boost::any(*applyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyId") != m.end() && !m["ApplyId"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["ApplyId"]));
    }
  }


  virtual ~BatchRegisterDeviceResponseBodyData() = default;
};
class BatchRegisterDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<BatchRegisterDeviceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchRegisterDeviceResponseBody() {}

  explicit BatchRegisterDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BatchRegisterDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BatchRegisterDeviceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchRegisterDeviceResponseBody() = default;
};
class BatchRegisterDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchRegisterDeviceResponseBody> body{};

  BatchRegisterDeviceResponse() {}

  explicit BatchRegisterDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchRegisterDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchRegisterDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~BatchRegisterDeviceResponse() = default;
};
class BatchRegisterDeviceWithApplyIdRequest : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  BatchRegisterDeviceWithApplyIdRequest() {}

  explicit BatchRegisterDeviceWithApplyIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["ApplyId"] = boost::any(*applyId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyId") != m.end() && !m["ApplyId"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["ApplyId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~BatchRegisterDeviceWithApplyIdRequest() = default;
};
class BatchRegisterDeviceWithApplyIdResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};

  BatchRegisterDeviceWithApplyIdResponseBodyData() {}

  explicit BatchRegisterDeviceWithApplyIdResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["ApplyId"] = boost::any(*applyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyId") != m.end() && !m["ApplyId"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["ApplyId"]));
    }
  }


  virtual ~BatchRegisterDeviceWithApplyIdResponseBodyData() = default;
};
class BatchRegisterDeviceWithApplyIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<BatchRegisterDeviceWithApplyIdResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchRegisterDeviceWithApplyIdResponseBody() {}

  explicit BatchRegisterDeviceWithApplyIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BatchRegisterDeviceWithApplyIdResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BatchRegisterDeviceWithApplyIdResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchRegisterDeviceWithApplyIdResponseBody() = default;
};
class BatchRegisterDeviceWithApplyIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchRegisterDeviceWithApplyIdResponseBody> body{};

  BatchRegisterDeviceWithApplyIdResponse() {}

  explicit BatchRegisterDeviceWithApplyIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchRegisterDeviceWithApplyIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchRegisterDeviceWithApplyIdResponseBody>(model1);
      }
    }
  }


  virtual ~BatchRegisterDeviceWithApplyIdResponse() = default;
};
class BatchSetEdgeInstanceDeviceChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> driverId{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> iotIds{};
  shared_ptr<string> iotInstanceId{};

  BatchSetEdgeInstanceDeviceChannelRequest() {}

  explicit BatchSetEdgeInstanceDeviceChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotIds) {
      res["IotIds"] = boost::any(*iotIds);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotIds") != m.end() && !m["IotIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~BatchSetEdgeInstanceDeviceChannelRequest() = default;
};
class BatchSetEdgeInstanceDeviceChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchSetEdgeInstanceDeviceChannelResponseBody() {}

  explicit BatchSetEdgeInstanceDeviceChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchSetEdgeInstanceDeviceChannelResponseBody() = default;
};
class BatchSetEdgeInstanceDeviceChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchSetEdgeInstanceDeviceChannelResponseBody> body{};

  BatchSetEdgeInstanceDeviceChannelResponse() {}

  explicit BatchSetEdgeInstanceDeviceChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchSetEdgeInstanceDeviceChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchSetEdgeInstanceDeviceChannelResponseBody>(model1);
      }
    }
  }


  virtual ~BatchSetEdgeInstanceDeviceChannelResponse() = default;
};
class BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> iotId{};

  BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs() {}

  explicit BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs() = default;
};
class BatchSetEdgeInstanceDeviceConfigRequest : public Darabonba::Model {
public:
  shared_ptr<vector<BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs>> deviceConfigs{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};

  BatchSetEdgeInstanceDeviceConfigRequest() {}

  explicit BatchSetEdgeInstanceDeviceConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*deviceConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceConfigs"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceConfigs") != m.end() && !m["DeviceConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceConfigs"].type()) {
        vector<BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceConfigs = make_shared<vector<BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~BatchSetEdgeInstanceDeviceConfigRequest() = default;
};
class BatchSetEdgeInstanceDeviceConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchSetEdgeInstanceDeviceConfigResponseBody() {}

  explicit BatchSetEdgeInstanceDeviceConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchSetEdgeInstanceDeviceConfigResponseBody() = default;
};
class BatchSetEdgeInstanceDeviceConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchSetEdgeInstanceDeviceConfigResponseBody> body{};

  BatchSetEdgeInstanceDeviceConfigResponse() {}

  explicit BatchSetEdgeInstanceDeviceConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchSetEdgeInstanceDeviceConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchSetEdgeInstanceDeviceConfigResponseBody>(model1);
      }
    }
  }


  virtual ~BatchSetEdgeInstanceDeviceConfigResponse() = default;
};
class BatchUnbindDeviceFromEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> iotIds{};
  shared_ptr<string> iotInstanceId{};

  BatchUnbindDeviceFromEdgeInstanceRequest() {}

  explicit BatchUnbindDeviceFromEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotIds) {
      res["IotIds"] = boost::any(*iotIds);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotIds") != m.end() && !m["IotIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~BatchUnbindDeviceFromEdgeInstanceRequest() = default;
};
class BatchUnbindDeviceFromEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchUnbindDeviceFromEdgeInstanceResponseBody() {}

  explicit BatchUnbindDeviceFromEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchUnbindDeviceFromEdgeInstanceResponseBody() = default;
};
class BatchUnbindDeviceFromEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchUnbindDeviceFromEdgeInstanceResponseBody> body{};

  BatchUnbindDeviceFromEdgeInstanceResponse() {}

  explicit BatchUnbindDeviceFromEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchUnbindDeviceFromEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchUnbindDeviceFromEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~BatchUnbindDeviceFromEdgeInstanceResponse() = default;
};
class BatchUnbindProjectDevicesRequestDevices : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> productKey{};

  BatchUnbindProjectDevicesRequestDevices() {}

  explicit BatchUnbindProjectDevicesRequestDevices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~BatchUnbindProjectDevicesRequestDevices() = default;
};
class BatchUnbindProjectDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<BatchUnbindProjectDevicesRequestDevices>> devices{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> projectId{};

  BatchUnbindProjectDevicesRequest() {}

  explicit BatchUnbindProjectDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (devices) {
      vector<boost::any> temp1;
      for(auto item1:*devices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Devices"] = boost::any(temp1);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Devices") != m.end() && !m["Devices"].empty()) {
      if (typeid(vector<boost::any>) == m["Devices"].type()) {
        vector<BatchUnbindProjectDevicesRequestDevices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Devices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchUnbindProjectDevicesRequestDevices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        devices = make_shared<vector<BatchUnbindProjectDevicesRequestDevices>>(expect1);
      }
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~BatchUnbindProjectDevicesRequest() = default;
};
class BatchUnbindProjectDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchUnbindProjectDevicesResponseBody() {}

  explicit BatchUnbindProjectDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchUnbindProjectDevicesResponseBody() = default;
};
class BatchUnbindProjectDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchUnbindProjectDevicesResponseBody> body{};

  BatchUnbindProjectDevicesResponse() {}

  explicit BatchUnbindProjectDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchUnbindProjectDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchUnbindProjectDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~BatchUnbindProjectDevicesResponse() = default;
};
class BatchUnbindProjectProductsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<string>> productKeys{};
  shared_ptr<string> projectId{};

  BatchUnbindProjectProductsRequest() {}

  explicit BatchUnbindProjectProductsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKeys) {
      res["ProductKeys"] = boost::any(*productKeys);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKeys") != m.end() && !m["ProductKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProductKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProductKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      productKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~BatchUnbindProjectProductsRequest() = default;
};
class BatchUnbindProjectProductsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchUnbindProjectProductsResponseBody() {}

  explicit BatchUnbindProjectProductsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchUnbindProjectProductsResponseBody() = default;
};
class BatchUnbindProjectProductsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchUnbindProjectProductsResponseBody> body{};

  BatchUnbindProjectProductsResponse() {}

  explicit BatchUnbindProjectProductsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchUnbindProjectProductsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchUnbindProjectProductsResponseBody>(model1);
      }
    }
  }


  virtual ~BatchUnbindProjectProductsResponse() = default;
};
class BatchUpdateDeviceNicknameRequestDeviceNicknameInfo : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> nickname{};
  shared_ptr<string> productKey{};

  BatchUpdateDeviceNicknameRequestDeviceNicknameInfo() {}

  explicit BatchUpdateDeviceNicknameRequestDeviceNicknameInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~BatchUpdateDeviceNicknameRequestDeviceNicknameInfo() = default;
};
class BatchUpdateDeviceNicknameRequest : public Darabonba::Model {
public:
  shared_ptr<vector<BatchUpdateDeviceNicknameRequestDeviceNicknameInfo>> deviceNicknameInfo{};
  shared_ptr<string> iotInstanceId{};

  BatchUpdateDeviceNicknameRequest() {}

  explicit BatchUpdateDeviceNicknameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceNicknameInfo) {
      vector<boost::any> temp1;
      for(auto item1:*deviceNicknameInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceNicknameInfo"] = boost::any(temp1);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceNicknameInfo") != m.end() && !m["DeviceNicknameInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceNicknameInfo"].type()) {
        vector<BatchUpdateDeviceNicknameRequestDeviceNicknameInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceNicknameInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchUpdateDeviceNicknameRequestDeviceNicknameInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceNicknameInfo = make_shared<vector<BatchUpdateDeviceNicknameRequestDeviceNicknameInfo>>(expect1);
      }
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~BatchUpdateDeviceNicknameRequest() = default;
};
class BatchUpdateDeviceNicknameResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchUpdateDeviceNicknameResponseBody() {}

  explicit BatchUpdateDeviceNicknameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchUpdateDeviceNicknameResponseBody() = default;
};
class BatchUpdateDeviceNicknameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchUpdateDeviceNicknameResponseBody> body{};

  BatchUpdateDeviceNicknameResponse() {}

  explicit BatchUpdateDeviceNicknameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchUpdateDeviceNicknameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchUpdateDeviceNicknameResponseBody>(model1);
      }
    }
  }


  virtual ~BatchUpdateDeviceNicknameResponse() = default;
};
class BindApplicationToEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> applicationVersion{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};

  BindApplicationToEdgeInstanceRequest() {}

  explicit BindApplicationToEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (applicationVersion) {
      res["ApplicationVersion"] = boost::any(*applicationVersion);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("ApplicationVersion") != m.end() && !m["ApplicationVersion"].empty()) {
      applicationVersion = make_shared<string>(boost::any_cast<string>(m["ApplicationVersion"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~BindApplicationToEdgeInstanceRequest() = default;
};
class BindApplicationToEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BindApplicationToEdgeInstanceResponseBody() {}

  explicit BindApplicationToEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BindApplicationToEdgeInstanceResponseBody() = default;
};
class BindApplicationToEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BindApplicationToEdgeInstanceResponseBody> body{};

  BindApplicationToEdgeInstanceResponse() {}

  explicit BindApplicationToEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindApplicationToEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindApplicationToEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~BindApplicationToEdgeInstanceResponse() = default;
};
class BindDriverToEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> orderId{};

  BindDriverToEdgeInstanceRequest() {}

  explicit BindDriverToEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
  }


  virtual ~BindDriverToEdgeInstanceRequest() = default;
};
class BindDriverToEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BindDriverToEdgeInstanceResponseBody() {}

  explicit BindDriverToEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BindDriverToEdgeInstanceResponseBody() = default;
};
class BindDriverToEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BindDriverToEdgeInstanceResponseBody> body{};

  BindDriverToEdgeInstanceResponse() {}

  explicit BindDriverToEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindDriverToEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindDriverToEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~BindDriverToEdgeInstanceResponse() = default;
};
class BindGatewayToEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  BindGatewayToEdgeInstanceRequest() {}

  explicit BindGatewayToEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~BindGatewayToEdgeInstanceRequest() = default;
};
class BindGatewayToEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BindGatewayToEdgeInstanceResponseBody() {}

  explicit BindGatewayToEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BindGatewayToEdgeInstanceResponseBody() = default;
};
class BindGatewayToEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BindGatewayToEdgeInstanceResponseBody> body{};

  BindGatewayToEdgeInstanceResponse() {}

  explicit BindGatewayToEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindGatewayToEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindGatewayToEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~BindGatewayToEdgeInstanceResponse() = default;
};
class BindLicenseDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> deviceNameList{};
  shared_ptr<vector<string>> iotIdList{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> licenseCode{};
  shared_ptr<string> productKey{};

  BindLicenseDeviceRequest() {}

  explicit BindLicenseDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceNameList) {
      res["DeviceNameList"] = boost::any(*deviceNameList);
    }
    if (iotIdList) {
      res["IotIdList"] = boost::any(*iotIdList);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (licenseCode) {
      res["LicenseCode"] = boost::any(*licenseCode);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceNameList") != m.end() && !m["DeviceNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotIdList") != m.end() && !m["IotIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("LicenseCode") != m.end() && !m["LicenseCode"].empty()) {
      licenseCode = make_shared<string>(boost::any_cast<string>(m["LicenseCode"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~BindLicenseDeviceRequest() = default;
};
class BindLicenseDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> checkProgressId{};
  shared_ptr<long> failSum{};
  shared_ptr<long> progress{};
  shared_ptr<string> resultCsvFile{};
  shared_ptr<long> successSum{};

  BindLicenseDeviceResponseBodyData() {}

  explicit BindLicenseDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkProgressId) {
      res["CheckProgressId"] = boost::any(*checkProgressId);
    }
    if (failSum) {
      res["FailSum"] = boost::any(*failSum);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (resultCsvFile) {
      res["ResultCsvFile"] = boost::any(*resultCsvFile);
    }
    if (successSum) {
      res["SuccessSum"] = boost::any(*successSum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckProgressId") != m.end() && !m["CheckProgressId"].empty()) {
      checkProgressId = make_shared<string>(boost::any_cast<string>(m["CheckProgressId"]));
    }
    if (m.find("FailSum") != m.end() && !m["FailSum"].empty()) {
      failSum = make_shared<long>(boost::any_cast<long>(m["FailSum"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("ResultCsvFile") != m.end() && !m["ResultCsvFile"].empty()) {
      resultCsvFile = make_shared<string>(boost::any_cast<string>(m["ResultCsvFile"]));
    }
    if (m.find("SuccessSum") != m.end() && !m["SuccessSum"].empty()) {
      successSum = make_shared<long>(boost::any_cast<long>(m["SuccessSum"]));
    }
  }


  virtual ~BindLicenseDeviceResponseBodyData() = default;
};
class BindLicenseDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<BindLicenseDeviceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BindLicenseDeviceResponseBody() {}

  explicit BindLicenseDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BindLicenseDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BindLicenseDeviceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BindLicenseDeviceResponseBody() = default;
};
class BindLicenseDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BindLicenseDeviceResponseBody> body{};

  BindLicenseDeviceResponse() {}

  explicit BindLicenseDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindLicenseDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindLicenseDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~BindLicenseDeviceResponse() = default;
};
class BindLicenseProductRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> licenseCode{};
  shared_ptr<string> productKey{};

  BindLicenseProductRequest() {}

  explicit BindLicenseProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (licenseCode) {
      res["LicenseCode"] = boost::any(*licenseCode);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("LicenseCode") != m.end() && !m["LicenseCode"].empty()) {
      licenseCode = make_shared<string>(boost::any_cast<string>(m["LicenseCode"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~BindLicenseProductRequest() = default;
};
class BindLicenseProductResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BindLicenseProductResponseBody() {}

  explicit BindLicenseProductResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BindLicenseProductResponseBody() = default;
};
class BindLicenseProductResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BindLicenseProductResponseBody> body{};

  BindLicenseProductResponse() {}

  explicit BindLicenseProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindLicenseProductResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindLicenseProductResponseBody>(model1);
      }
    }
  }


  virtual ~BindLicenseProductResponse() = default;
};
class BindRoleToEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> roleName{};

  BindRoleToEdgeInstanceRequest() {}

  explicit BindRoleToEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
  }


  virtual ~BindRoleToEdgeInstanceRequest() = default;
};
class BindRoleToEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BindRoleToEdgeInstanceResponseBody() {}

  explicit BindRoleToEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BindRoleToEdgeInstanceResponseBody() = default;
};
class BindRoleToEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BindRoleToEdgeInstanceResponseBody> body{};

  BindRoleToEdgeInstanceResponse() {}

  explicit BindRoleToEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindRoleToEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindRoleToEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~BindRoleToEdgeInstanceResponse() = default;
};
class BindSceneRuleToEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> ruleId{};

  BindSceneRuleToEdgeInstanceRequest() {}

  explicit BindSceneRuleToEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~BindSceneRuleToEdgeInstanceRequest() = default;
};
class BindSceneRuleToEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BindSceneRuleToEdgeInstanceResponseBody() {}

  explicit BindSceneRuleToEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BindSceneRuleToEdgeInstanceResponseBody() = default;
};
class BindSceneRuleToEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BindSceneRuleToEdgeInstanceResponseBody> body{};

  BindSceneRuleToEdgeInstanceResponse() {}

  explicit BindSceneRuleToEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindSceneRuleToEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindSceneRuleToEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~BindSceneRuleToEdgeInstanceResponse() = default;
};
class CancelJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobId{};

  CancelJobRequest() {}

  explicit CancelJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~CancelJobRequest() = default;
};
class CancelJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CancelJobResponseBody() {}

  explicit CancelJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CancelJobResponseBody() = default;
};
class CancelJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelJobResponseBody> body{};

  CancelJobResponse() {}

  explicit CancelJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelJobResponseBody>(model1);
      }
    }
  }


  virtual ~CancelJobResponse() = default;
};
class CancelOTAStrategyByJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobId{};

  CancelOTAStrategyByJobRequest() {}

  explicit CancelOTAStrategyByJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~CancelOTAStrategyByJobRequest() = default;
};
class CancelOTAStrategyByJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CancelOTAStrategyByJobResponseBody() {}

  explicit CancelOTAStrategyByJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CancelOTAStrategyByJobResponseBody() = default;
};
class CancelOTAStrategyByJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelOTAStrategyByJobResponseBody> body{};

  CancelOTAStrategyByJobResponse() {}

  explicit CancelOTAStrategyByJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelOTAStrategyByJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelOTAStrategyByJobResponseBody>(model1);
      }
    }
  }


  virtual ~CancelOTAStrategyByJobResponse() = default;
};
class CancelOTATaskByDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> deviceName{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> productKey{};

  CancelOTATaskByDeviceRequest() {}

  explicit CancelOTATaskByDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~CancelOTATaskByDeviceRequest() = default;
};
class CancelOTATaskByDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CancelOTATaskByDeviceResponseBody() {}

  explicit CancelOTATaskByDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CancelOTATaskByDeviceResponseBody() = default;
};
class CancelOTATaskByDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelOTATaskByDeviceResponseBody> body{};

  CancelOTATaskByDeviceResponse() {}

  explicit CancelOTATaskByDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelOTATaskByDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelOTATaskByDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~CancelOTATaskByDeviceResponse() = default;
};
class CancelOTATaskByJobRequest : public Darabonba::Model {
public:
  shared_ptr<bool> cancelInProgressTask{};
  shared_ptr<bool> cancelNotifiedTask{};
  shared_ptr<bool> cancelQueuedTask{};
  shared_ptr<bool> cancelScheduledTask{};
  shared_ptr<bool> cancelUnconfirmedTask{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobId{};

  CancelOTATaskByJobRequest() {}

  explicit CancelOTATaskByJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cancelInProgressTask) {
      res["CancelInProgressTask"] = boost::any(*cancelInProgressTask);
    }
    if (cancelNotifiedTask) {
      res["CancelNotifiedTask"] = boost::any(*cancelNotifiedTask);
    }
    if (cancelQueuedTask) {
      res["CancelQueuedTask"] = boost::any(*cancelQueuedTask);
    }
    if (cancelScheduledTask) {
      res["CancelScheduledTask"] = boost::any(*cancelScheduledTask);
    }
    if (cancelUnconfirmedTask) {
      res["CancelUnconfirmedTask"] = boost::any(*cancelUnconfirmedTask);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CancelInProgressTask") != m.end() && !m["CancelInProgressTask"].empty()) {
      cancelInProgressTask = make_shared<bool>(boost::any_cast<bool>(m["CancelInProgressTask"]));
    }
    if (m.find("CancelNotifiedTask") != m.end() && !m["CancelNotifiedTask"].empty()) {
      cancelNotifiedTask = make_shared<bool>(boost::any_cast<bool>(m["CancelNotifiedTask"]));
    }
    if (m.find("CancelQueuedTask") != m.end() && !m["CancelQueuedTask"].empty()) {
      cancelQueuedTask = make_shared<bool>(boost::any_cast<bool>(m["CancelQueuedTask"]));
    }
    if (m.find("CancelScheduledTask") != m.end() && !m["CancelScheduledTask"].empty()) {
      cancelScheduledTask = make_shared<bool>(boost::any_cast<bool>(m["CancelScheduledTask"]));
    }
    if (m.find("CancelUnconfirmedTask") != m.end() && !m["CancelUnconfirmedTask"].empty()) {
      cancelUnconfirmedTask = make_shared<bool>(boost::any_cast<bool>(m["CancelUnconfirmedTask"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~CancelOTATaskByJobRequest() = default;
};
class CancelOTATaskByJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CancelOTATaskByJobResponseBody() {}

  explicit CancelOTATaskByJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CancelOTATaskByJobResponseBody() = default;
};
class CancelOTATaskByJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelOTATaskByJobResponseBody> body{};

  CancelOTATaskByJobResponse() {}

  explicit CancelOTATaskByJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelOTATaskByJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelOTATaskByJobResponseBody>(model1);
      }
    }
  }


  virtual ~CancelOTATaskByJobResponse() = default;
};
class CancelReleaseProductRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  CancelReleaseProductRequest() {}

  explicit CancelReleaseProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~CancelReleaseProductRequest() = default;
};
class CancelReleaseProductResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CancelReleaseProductResponseBody() {}

  explicit CancelReleaseProductResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CancelReleaseProductResponseBody() = default;
};
class CancelReleaseProductResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelReleaseProductResponseBody> body{};

  CancelReleaseProductResponse() {}

  explicit CancelReleaseProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelReleaseProductResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelReleaseProductResponseBody>(model1);
      }
    }
  }


  virtual ~CancelReleaseProductResponse() = default;
};
class CheckBindLicenseDeviceProgressRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkProgressId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> licenseCode{};
  shared_ptr<string> productKey{};

  CheckBindLicenseDeviceProgressRequest() {}

  explicit CheckBindLicenseDeviceProgressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkProgressId) {
      res["CheckProgressId"] = boost::any(*checkProgressId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (licenseCode) {
      res["LicenseCode"] = boost::any(*licenseCode);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckProgressId") != m.end() && !m["CheckProgressId"].empty()) {
      checkProgressId = make_shared<string>(boost::any_cast<string>(m["CheckProgressId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("LicenseCode") != m.end() && !m["LicenseCode"].empty()) {
      licenseCode = make_shared<string>(boost::any_cast<string>(m["LicenseCode"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~CheckBindLicenseDeviceProgressRequest() = default;
};
class CheckBindLicenseDeviceProgressResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> failSum{};
  shared_ptr<long> progress{};
  shared_ptr<string> resultCsvFile{};
  shared_ptr<long> successSum{};

  CheckBindLicenseDeviceProgressResponseBodyData() {}

  explicit CheckBindLicenseDeviceProgressResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failSum) {
      res["FailSum"] = boost::any(*failSum);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (resultCsvFile) {
      res["ResultCsvFile"] = boost::any(*resultCsvFile);
    }
    if (successSum) {
      res["SuccessSum"] = boost::any(*successSum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailSum") != m.end() && !m["FailSum"].empty()) {
      failSum = make_shared<long>(boost::any_cast<long>(m["FailSum"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("ResultCsvFile") != m.end() && !m["ResultCsvFile"].empty()) {
      resultCsvFile = make_shared<string>(boost::any_cast<string>(m["ResultCsvFile"]));
    }
    if (m.find("SuccessSum") != m.end() && !m["SuccessSum"].empty()) {
      successSum = make_shared<long>(boost::any_cast<long>(m["SuccessSum"]));
    }
  }


  virtual ~CheckBindLicenseDeviceProgressResponseBodyData() = default;
};
class CheckBindLicenseDeviceProgressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CheckBindLicenseDeviceProgressResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CheckBindLicenseDeviceProgressResponseBody() {}

  explicit CheckBindLicenseDeviceProgressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CheckBindLicenseDeviceProgressResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CheckBindLicenseDeviceProgressResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CheckBindLicenseDeviceProgressResponseBody() = default;
};
class CheckBindLicenseDeviceProgressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckBindLicenseDeviceProgressResponseBody> body{};

  CheckBindLicenseDeviceProgressResponse() {}

  explicit CheckBindLicenseDeviceProgressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckBindLicenseDeviceProgressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckBindLicenseDeviceProgressResponseBody>(model1);
      }
    }
  }


  virtual ~CheckBindLicenseDeviceProgressResponse() = default;
};
class ClearDeviceDesiredPropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<vector<string>> identifies{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  ClearDeviceDesiredPropertyRequest() {}

  explicit ClearDeviceDesiredPropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (identifies) {
      res["Identifies"] = boost::any(*identifies);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Identifies") != m.end() && !m["Identifies"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Identifies"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Identifies"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      identifies = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~ClearDeviceDesiredPropertyRequest() = default;
};
class ClearDeviceDesiredPropertyResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> versions{};

  ClearDeviceDesiredPropertyResponseBodyData() {}

  explicit ClearDeviceDesiredPropertyResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (versions) {
      res["Versions"] = boost::any(*versions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Versions") != m.end() && !m["Versions"].empty()) {
      versions = make_shared<string>(boost::any_cast<string>(m["Versions"]));
    }
  }


  virtual ~ClearDeviceDesiredPropertyResponseBodyData() = default;
};
class ClearDeviceDesiredPropertyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ClearDeviceDesiredPropertyResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ClearDeviceDesiredPropertyResponseBody() {}

  explicit ClearDeviceDesiredPropertyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ClearDeviceDesiredPropertyResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ClearDeviceDesiredPropertyResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ClearDeviceDesiredPropertyResponseBody() = default;
};
class ClearDeviceDesiredPropertyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ClearDeviceDesiredPropertyResponseBody> body{};

  ClearDeviceDesiredPropertyResponse() {}

  explicit ClearDeviceDesiredPropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ClearDeviceDesiredPropertyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ClearDeviceDesiredPropertyResponseBody>(model1);
      }
    }
  }


  virtual ~ClearDeviceDesiredPropertyResponse() = default;
};
class ClearEdgeInstanceDriverConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> driverId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};

  ClearEdgeInstanceDriverConfigsRequest() {}

  explicit ClearEdgeInstanceDriverConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~ClearEdgeInstanceDriverConfigsRequest() = default;
};
class ClearEdgeInstanceDriverConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ClearEdgeInstanceDriverConfigsResponseBody() {}

  explicit ClearEdgeInstanceDriverConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ClearEdgeInstanceDriverConfigsResponseBody() = default;
};
class ClearEdgeInstanceDriverConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ClearEdgeInstanceDriverConfigsResponseBody> body{};

  ClearEdgeInstanceDriverConfigsResponse() {}

  explicit ClearEdgeInstanceDriverConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ClearEdgeInstanceDriverConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ClearEdgeInstanceDriverConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~ClearEdgeInstanceDriverConfigsResponse() = default;
};
class CloseDeviceTunnelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> tunnelId{};

  CloseDeviceTunnelRequest() {}

  explicit CloseDeviceTunnelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (tunnelId) {
      res["TunnelId"] = boost::any(*tunnelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("TunnelId") != m.end() && !m["TunnelId"].empty()) {
      tunnelId = make_shared<string>(boost::any_cast<string>(m["TunnelId"]));
    }
  }


  virtual ~CloseDeviceTunnelRequest() = default;
};
class CloseDeviceTunnelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CloseDeviceTunnelResponseBody() {}

  explicit CloseDeviceTunnelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CloseDeviceTunnelResponseBody() = default;
};
class CloseDeviceTunnelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CloseDeviceTunnelResponseBody> body{};

  CloseDeviceTunnelResponse() {}

  explicit CloseDeviceTunnelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CloseDeviceTunnelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CloseDeviceTunnelResponseBody>(model1);
      }
    }
  }


  virtual ~CloseDeviceTunnelResponse() = default;
};
class CloseEdgeInstanceDeploymentRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};

  CloseEdgeInstanceDeploymentRequest() {}

  explicit CloseEdgeInstanceDeploymentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~CloseEdgeInstanceDeploymentRequest() = default;
};
class CloseEdgeInstanceDeploymentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CloseEdgeInstanceDeploymentResponseBody() {}

  explicit CloseEdgeInstanceDeploymentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CloseEdgeInstanceDeploymentResponseBody() = default;
};
class CloseEdgeInstanceDeploymentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CloseEdgeInstanceDeploymentResponseBody> body{};

  CloseEdgeInstanceDeploymentResponse() {}

  explicit CloseEdgeInstanceDeploymentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CloseEdgeInstanceDeploymentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CloseEdgeInstanceDeploymentResponseBody>(model1);
      }
    }
  }


  virtual ~CloseEdgeInstanceDeploymentResponse() = default;
};
class ConfirmOTATaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<string>> taskId{};

  ConfirmOTATaskRequest() {}

  explicit ConfirmOTATaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TaskId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      taskId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ConfirmOTATaskRequest() = default;
};
class ConfirmOTATaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ConfirmOTATaskResponseBody() {}

  explicit ConfirmOTATaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ConfirmOTATaskResponseBody() = default;
};
class ConfirmOTATaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfirmOTATaskResponseBody> body{};

  ConfirmOTATaskResponse() {}

  explicit ConfirmOTATaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfirmOTATaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfirmOTATaskResponseBody>(model1);
      }
    }
  }


  virtual ~ConfirmOTATaskResponse() = default;
};
class CopyThingModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> sourceModelVersion{};
  shared_ptr<string> sourceProductKey{};
  shared_ptr<string> targetProductKey{};

  CopyThingModelRequest() {}

  explicit CopyThingModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (sourceModelVersion) {
      res["SourceModelVersion"] = boost::any(*sourceModelVersion);
    }
    if (sourceProductKey) {
      res["SourceProductKey"] = boost::any(*sourceProductKey);
    }
    if (targetProductKey) {
      res["TargetProductKey"] = boost::any(*targetProductKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SourceModelVersion") != m.end() && !m["SourceModelVersion"].empty()) {
      sourceModelVersion = make_shared<string>(boost::any_cast<string>(m["SourceModelVersion"]));
    }
    if (m.find("SourceProductKey") != m.end() && !m["SourceProductKey"].empty()) {
      sourceProductKey = make_shared<string>(boost::any_cast<string>(m["SourceProductKey"]));
    }
    if (m.find("TargetProductKey") != m.end() && !m["TargetProductKey"].empty()) {
      targetProductKey = make_shared<string>(boost::any_cast<string>(m["TargetProductKey"]));
    }
  }


  virtual ~CopyThingModelRequest() = default;
};
class CopyThingModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CopyThingModelResponseBody() {}

  explicit CopyThingModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CopyThingModelResponseBody() = default;
};
class CopyThingModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CopyThingModelResponseBody> body{};

  CopyThingModelResponse() {}

  explicit CopyThingModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CopyThingModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CopyThingModelResponseBody>(model1);
      }
    }
  }


  virtual ~CopyThingModelResponse() = default;
};
class CountSpeechBroadcastHourRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> queryDateTimeHour{};
  shared_ptr<string> shareTaskCode{};

  CountSpeechBroadcastHourRequest() {}

  explicit CountSpeechBroadcastHourRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (queryDateTimeHour) {
      res["QueryDateTimeHour"] = boost::any(*queryDateTimeHour);
    }
    if (shareTaskCode) {
      res["ShareTaskCode"] = boost::any(*shareTaskCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("QueryDateTimeHour") != m.end() && !m["QueryDateTimeHour"].empty()) {
      queryDateTimeHour = make_shared<string>(boost::any_cast<string>(m["QueryDateTimeHour"]));
    }
    if (m.find("ShareTaskCode") != m.end() && !m["ShareTaskCode"].empty()) {
      shareTaskCode = make_shared<string>(boost::any_cast<string>(m["ShareTaskCode"]));
    }
  }


  virtual ~CountSpeechBroadcastHourRequest() = default;
};
class CountSpeechBroadcastHourResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CountSpeechBroadcastHourResponseBody() {}

  explicit CountSpeechBroadcastHourResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CountSpeechBroadcastHourResponseBody() = default;
};
class CountSpeechBroadcastHourResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CountSpeechBroadcastHourResponseBody> body{};

  CountSpeechBroadcastHourResponse() {}

  explicit CountSpeechBroadcastHourResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CountSpeechBroadcastHourResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CountSpeechBroadcastHourResponseBody>(model1);
      }
    }
  }


  virtual ~CountSpeechBroadcastHourResponse() = default;
};
class CreateConsumerGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> subBizCode{};
  shared_ptr<string> type{};

  CreateConsumerGroupRequest() {}

  explicit CreateConsumerGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (subBizCode) {
      res["SubBizCode"] = boost::any(*subBizCode);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("SubBizCode") != m.end() && !m["SubBizCode"].empty()) {
      subBizCode = make_shared<string>(boost::any_cast<string>(m["SubBizCode"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateConsumerGroupRequest() = default;
};
class CreateConsumerGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> groupId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateConsumerGroupResponseBody() {}

  explicit CreateConsumerGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateConsumerGroupResponseBody() = default;
};
class CreateConsumerGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateConsumerGroupResponseBody> body{};

  CreateConsumerGroupResponse() {}

  explicit CreateConsumerGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateConsumerGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateConsumerGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateConsumerGroupResponse() = default;
};
class CreateConsumerGroupSubscribeRelationRequest : public Darabonba::Model {
public:
  shared_ptr<string> consumerGroupId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  CreateConsumerGroupSubscribeRelationRequest() {}

  explicit CreateConsumerGroupSubscribeRelationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consumerGroupId) {
      res["ConsumerGroupId"] = boost::any(*consumerGroupId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsumerGroupId") != m.end() && !m["ConsumerGroupId"].empty()) {
      consumerGroupId = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~CreateConsumerGroupSubscribeRelationRequest() = default;
};
class CreateConsumerGroupSubscribeRelationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateConsumerGroupSubscribeRelationResponseBody() {}

  explicit CreateConsumerGroupSubscribeRelationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateConsumerGroupSubscribeRelationResponseBody() = default;
};
class CreateConsumerGroupSubscribeRelationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateConsumerGroupSubscribeRelationResponseBody> body{};

  CreateConsumerGroupSubscribeRelationResponse() {}

  explicit CreateConsumerGroupSubscribeRelationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateConsumerGroupSubscribeRelationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateConsumerGroupSubscribeRelationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateConsumerGroupSubscribeRelationResponse() = default;
};
class CreateDataAPIServiceRequestRequestParam : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> example{};
  shared_ptr<string> name{};
  shared_ptr<bool> required{};
  shared_ptr<string> type{};

  CreateDataAPIServiceRequestRequestParam() {}

  explicit CreateDataAPIServiceRequestRequestParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (example) {
      res["Example"] = boost::any(*example);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Example") != m.end() && !m["Example"].empty()) {
      example = make_shared<string>(boost::any_cast<string>(m["Example"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<bool>(boost::any_cast<bool>(m["Required"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDataAPIServiceRequestRequestParam() = default;
};
class CreateDataAPIServiceRequestResponseParam : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> example{};
  shared_ptr<string> name{};
  shared_ptr<bool> required{};
  shared_ptr<string> type{};

  CreateDataAPIServiceRequestResponseParam() {}

  explicit CreateDataAPIServiceRequestResponseParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (example) {
      res["Example"] = boost::any(*example);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Example") != m.end() && !m["Example"].empty()) {
      example = make_shared<string>(boost::any_cast<string>(m["Example"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<bool>(boost::any_cast<bool>(m["Required"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDataAPIServiceRequestResponseParam() = default;
};
class CreateDataAPIServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiPath{};
  shared_ptr<string> desc{};
  shared_ptr<string> displayName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> originSql{};
  shared_ptr<vector<CreateDataAPIServiceRequestRequestParam>> requestParam{};
  shared_ptr<vector<CreateDataAPIServiceRequestResponseParam>> responseParam{};
  shared_ptr<string> templateSql{};

  CreateDataAPIServiceRequest() {}

  explicit CreateDataAPIServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (originSql) {
      res["OriginSql"] = boost::any(*originSql);
    }
    if (requestParam) {
      vector<boost::any> temp1;
      for(auto item1:*requestParam){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParam"] = boost::any(temp1);
    }
    if (responseParam) {
      vector<boost::any> temp1;
      for(auto item1:*responseParam){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResponseParam"] = boost::any(temp1);
    }
    if (templateSql) {
      res["TemplateSql"] = boost::any(*templateSql);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("OriginSql") != m.end() && !m["OriginSql"].empty()) {
      originSql = make_shared<string>(boost::any_cast<string>(m["OriginSql"]));
    }
    if (m.find("RequestParam") != m.end() && !m["RequestParam"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParam"].type()) {
        vector<CreateDataAPIServiceRequestRequestParam> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParam"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataAPIServiceRequestRequestParam model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParam = make_shared<vector<CreateDataAPIServiceRequestRequestParam>>(expect1);
      }
    }
    if (m.find("ResponseParam") != m.end() && !m["ResponseParam"].empty()) {
      if (typeid(vector<boost::any>) == m["ResponseParam"].type()) {
        vector<CreateDataAPIServiceRequestResponseParam> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResponseParam"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataAPIServiceRequestResponseParam model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        responseParam = make_shared<vector<CreateDataAPIServiceRequestResponseParam>>(expect1);
      }
    }
    if (m.find("TemplateSql") != m.end() && !m["TemplateSql"].empty()) {
      templateSql = make_shared<string>(boost::any_cast<string>(m["TemplateSql"]));
    }
  }


  virtual ~CreateDataAPIServiceRequest() = default;
};
class CreateDataAPIServiceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> apiSrn{};
  shared_ptr<long> createTime{};
  shared_ptr<long> lastUpdateTime{};

  CreateDataAPIServiceResponseBodyData() {}

  explicit CreateDataAPIServiceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiSrn) {
      res["ApiSrn"] = boost::any(*apiSrn);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (lastUpdateTime) {
      res["LastUpdateTime"] = boost::any(*lastUpdateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiSrn") != m.end() && !m["ApiSrn"].empty()) {
      apiSrn = make_shared<string>(boost::any_cast<string>(m["ApiSrn"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("LastUpdateTime") != m.end() && !m["LastUpdateTime"].empty()) {
      lastUpdateTime = make_shared<long>(boost::any_cast<long>(m["LastUpdateTime"]));
    }
  }


  virtual ~CreateDataAPIServiceResponseBodyData() = default;
};
class CreateDataAPIServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateDataAPIServiceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateDataAPIServiceResponseBody() {}

  explicit CreateDataAPIServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateDataAPIServiceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateDataAPIServiceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateDataAPIServiceResponseBody() = default;
};
class CreateDataAPIServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDataAPIServiceResponseBody> body{};

  CreateDataAPIServiceResponse() {}

  explicit CreateDataAPIServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataAPIServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataAPIServiceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataAPIServiceResponse() = default;
};
class CreateDataSourceItemRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> scopeType{};
  shared_ptr<string> topic{};

  CreateDataSourceItemRequest() {}

  explicit CreateDataSourceItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (scopeType) {
      res["ScopeType"] = boost::any(*scopeType);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ScopeType") != m.end() && !m["ScopeType"].empty()) {
      scopeType = make_shared<string>(boost::any_cast<string>(m["ScopeType"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~CreateDataSourceItemRequest() = default;
};
class CreateDataSourceItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateDataSourceItemResponseBody() {}

  explicit CreateDataSourceItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateDataSourceItemResponseBody() = default;
};
class CreateDataSourceItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDataSourceItemResponseBody> body{};

  CreateDataSourceItemResponse() {}

  explicit CreateDataSourceItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataSourceItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataSourceItemResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataSourceItemResponse() = default;
};
class CreateDestinationRequest : public Darabonba::Model {
public:
  shared_ptr<string> configuration{};
  shared_ptr<string> description{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  CreateDestinationRequest() {}

  explicit CreateDestinationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configuration) {
      res["Configuration"] = boost::any(*configuration);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configuration = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDestinationRequest() = default;
};
class CreateDestinationResponseBodyDestination : public Darabonba::Model {
public:
  shared_ptr<string> configuration{};
  shared_ptr<long> destinationId{};
  shared_ptr<bool> isFailover{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> utcCreated{};

  CreateDestinationResponseBodyDestination() {}

  explicit CreateDestinationResponseBodyDestination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configuration) {
      res["Configuration"] = boost::any(*configuration);
    }
    if (destinationId) {
      res["DestinationId"] = boost::any(*destinationId);
    }
    if (isFailover) {
      res["IsFailover"] = boost::any(*isFailover);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (utcCreated) {
      res["UtcCreated"] = boost::any(*utcCreated);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configuration = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
    if (m.find("DestinationId") != m.end() && !m["DestinationId"].empty()) {
      destinationId = make_shared<long>(boost::any_cast<long>(m["DestinationId"]));
    }
    if (m.find("IsFailover") != m.end() && !m["IsFailover"].empty()) {
      isFailover = make_shared<bool>(boost::any_cast<bool>(m["IsFailover"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UtcCreated") != m.end() && !m["UtcCreated"].empty()) {
      utcCreated = make_shared<string>(boost::any_cast<string>(m["UtcCreated"]));
    }
  }


  virtual ~CreateDestinationResponseBodyDestination() = default;
};
class CreateDestinationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateDestinationResponseBodyDestination> destination{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateDestinationResponseBody() {}

  explicit CreateDestinationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (destination) {
      res["Destination"] = destination ? boost::any(destination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Destination"].type()) {
        CreateDestinationResponseBodyDestination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Destination"]));
        destination = make_shared<CreateDestinationResponseBodyDestination>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateDestinationResponseBody() = default;
};
class CreateDestinationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDestinationResponseBody> body{};

  CreateDestinationResponse() {}

  explicit CreateDestinationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDestinationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDestinationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDestinationResponse() = default;
};
class CreateDeviceDistributeJobRequestTargetInstanceConfig : public Darabonba::Model {
public:
  shared_ptr<string> targetInstanceId{};

  CreateDeviceDistributeJobRequestTargetInstanceConfig() {}

  explicit CreateDeviceDistributeJobRequestTargetInstanceConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
  }


  virtual ~CreateDeviceDistributeJobRequestTargetInstanceConfig() = default;
};
class CreateDeviceDistributeJobRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> deviceName{};
  shared_ptr<string> productKey{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<long> strategy{};
  shared_ptr<string> targetAliyunId{};
  shared_ptr<vector<CreateDeviceDistributeJobRequestTargetInstanceConfig>> targetInstanceConfig{};
  shared_ptr<string> targetUid{};

  CreateDeviceDistributeJobRequest() {}

  explicit CreateDeviceDistributeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (strategy) {
      res["Strategy"] = boost::any(*strategy);
    }
    if (targetAliyunId) {
      res["TargetAliyunId"] = boost::any(*targetAliyunId);
    }
    if (targetInstanceConfig) {
      vector<boost::any> temp1;
      for(auto item1:*targetInstanceConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TargetInstanceConfig"] = boost::any(temp1);
    }
    if (targetUid) {
      res["TargetUid"] = boost::any(*targetUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      strategy = make_shared<long>(boost::any_cast<long>(m["Strategy"]));
    }
    if (m.find("TargetAliyunId") != m.end() && !m["TargetAliyunId"].empty()) {
      targetAliyunId = make_shared<string>(boost::any_cast<string>(m["TargetAliyunId"]));
    }
    if (m.find("TargetInstanceConfig") != m.end() && !m["TargetInstanceConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["TargetInstanceConfig"].type()) {
        vector<CreateDeviceDistributeJobRequestTargetInstanceConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TargetInstanceConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDeviceDistributeJobRequestTargetInstanceConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targetInstanceConfig = make_shared<vector<CreateDeviceDistributeJobRequestTargetInstanceConfig>>(expect1);
      }
    }
    if (m.find("TargetUid") != m.end() && !m["TargetUid"].empty()) {
      targetUid = make_shared<string>(boost::any_cast<string>(m["TargetUid"]));
    }
  }


  virtual ~CreateDeviceDistributeJobRequest() = default;
};
class CreateDeviceDistributeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateDeviceDistributeJobResponseBody() {}

  explicit CreateDeviceDistributeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateDeviceDistributeJobResponseBody() = default;
};
class CreateDeviceDistributeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDeviceDistributeJobResponseBody> body{};

  CreateDeviceDistributeJobResponse() {}

  explicit CreateDeviceDistributeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDeviceDistributeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDeviceDistributeJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDeviceDistributeJobResponse() = default;
};
class CreateDeviceDynamicGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> dynamicGroupExpression{};
  shared_ptr<string> groupDesc{};
  shared_ptr<string> groupName{};
  shared_ptr<string> iotInstanceId{};

  CreateDeviceDynamicGroupRequest() {}

  explicit CreateDeviceDynamicGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicGroupExpression) {
      res["DynamicGroupExpression"] = boost::any(*dynamicGroupExpression);
    }
    if (groupDesc) {
      res["GroupDesc"] = boost::any(*groupDesc);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicGroupExpression") != m.end() && !m["DynamicGroupExpression"].empty()) {
      dynamicGroupExpression = make_shared<string>(boost::any_cast<string>(m["DynamicGroupExpression"]));
    }
    if (m.find("GroupDesc") != m.end() && !m["GroupDesc"].empty()) {
      groupDesc = make_shared<string>(boost::any_cast<string>(m["GroupDesc"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~CreateDeviceDynamicGroupRequest() = default;
};
class CreateDeviceDynamicGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> dynamicGroupExpression{};
  shared_ptr<string> groupDesc{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> utcCreate{};

  CreateDeviceDynamicGroupResponseBodyData() {}

  explicit CreateDeviceDynamicGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicGroupExpression) {
      res["DynamicGroupExpression"] = boost::any(*dynamicGroupExpression);
    }
    if (groupDesc) {
      res["GroupDesc"] = boost::any(*groupDesc);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicGroupExpression") != m.end() && !m["DynamicGroupExpression"].empty()) {
      dynamicGroupExpression = make_shared<string>(boost::any_cast<string>(m["DynamicGroupExpression"]));
    }
    if (m.find("GroupDesc") != m.end() && !m["GroupDesc"].empty()) {
      groupDesc = make_shared<string>(boost::any_cast<string>(m["GroupDesc"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
  }


  virtual ~CreateDeviceDynamicGroupResponseBodyData() = default;
};
class CreateDeviceDynamicGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateDeviceDynamicGroupResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateDeviceDynamicGroupResponseBody() {}

  explicit CreateDeviceDynamicGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateDeviceDynamicGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateDeviceDynamicGroupResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateDeviceDynamicGroupResponseBody() = default;
};
class CreateDeviceDynamicGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDeviceDynamicGroupResponseBody> body{};

  CreateDeviceDynamicGroupResponse() {}

  explicit CreateDeviceDynamicGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDeviceDynamicGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDeviceDynamicGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDeviceDynamicGroupResponse() = default;
};
class CreateDeviceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupDesc{};
  shared_ptr<string> groupName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> superGroupId{};

  CreateDeviceGroupRequest() {}

  explicit CreateDeviceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupDesc) {
      res["GroupDesc"] = boost::any(*groupDesc);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (superGroupId) {
      res["SuperGroupId"] = boost::any(*superGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupDesc") != m.end() && !m["GroupDesc"].empty()) {
      groupDesc = make_shared<string>(boost::any_cast<string>(m["GroupDesc"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("SuperGroupId") != m.end() && !m["SuperGroupId"].empty()) {
      superGroupId = make_shared<string>(boost::any_cast<string>(m["SuperGroupId"]));
    }
  }


  virtual ~CreateDeviceGroupRequest() = default;
};
class CreateDeviceGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> groupDesc{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> utcCreate{};

  CreateDeviceGroupResponseBodyData() {}

  explicit CreateDeviceGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupDesc) {
      res["GroupDesc"] = boost::any(*groupDesc);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupDesc") != m.end() && !m["GroupDesc"].empty()) {
      groupDesc = make_shared<string>(boost::any_cast<string>(m["GroupDesc"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
  }


  virtual ~CreateDeviceGroupResponseBodyData() = default;
};
class CreateDeviceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateDeviceGroupResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateDeviceGroupResponseBody() {}

  explicit CreateDeviceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateDeviceGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateDeviceGroupResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateDeviceGroupResponseBody() = default;
};
class CreateDeviceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDeviceGroupResponseBody> body{};

  CreateDeviceGroupResponse() {}

  explicit CreateDeviceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDeviceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDeviceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDeviceGroupResponse() = default;
};
class CreateDeviceTunnelRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> udi{};

  CreateDeviceTunnelRequest() {}

  explicit CreateDeviceTunnelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (udi) {
      res["Udi"] = boost::any(*udi);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Udi") != m.end() && !m["Udi"].empty()) {
      udi = make_shared<string>(boost::any_cast<string>(m["Udi"]));
    }
  }


  virtual ~CreateDeviceTunnelRequest() = default;
};
class CreateDeviceTunnelResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> sourceAccessToken{};
  shared_ptr<string> sourceURI{};
  shared_ptr<string> tunnelId{};

  CreateDeviceTunnelResponseBodyData() {}

  explicit CreateDeviceTunnelResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceAccessToken) {
      res["SourceAccessToken"] = boost::any(*sourceAccessToken);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    if (tunnelId) {
      res["TunnelId"] = boost::any(*tunnelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceAccessToken") != m.end() && !m["SourceAccessToken"].empty()) {
      sourceAccessToken = make_shared<string>(boost::any_cast<string>(m["SourceAccessToken"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
    if (m.find("TunnelId") != m.end() && !m["TunnelId"].empty()) {
      tunnelId = make_shared<string>(boost::any_cast<string>(m["TunnelId"]));
    }
  }


  virtual ~CreateDeviceTunnelResponseBodyData() = default;
};
class CreateDeviceTunnelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateDeviceTunnelResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateDeviceTunnelResponseBody() {}

  explicit CreateDeviceTunnelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateDeviceTunnelResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateDeviceTunnelResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateDeviceTunnelResponseBody() = default;
};
class CreateDeviceTunnelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDeviceTunnelResponseBody> body{};

  CreateDeviceTunnelResponse() {}

  explicit CreateDeviceTunnelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDeviceTunnelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDeviceTunnelResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDeviceTunnelResponse() = default;
};
class CreateDownloadDataJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> downloadDataType{};
  shared_ptr<long> endTime{};
  shared_ptr<map<string, boost::any>> fileConfig{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> tableName{};

  CreateDownloadDataJobRequest() {}

  explicit CreateDownloadDataJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadDataType) {
      res["DownloadDataType"] = boost::any(*downloadDataType);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (fileConfig) {
      res["FileConfig"] = boost::any(*fileConfig);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadDataType") != m.end() && !m["DownloadDataType"].empty()) {
      downloadDataType = make_shared<string>(boost::any_cast<string>(m["DownloadDataType"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("FileConfig") != m.end() && !m["FileConfig"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["FileConfig"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      fileConfig = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~CreateDownloadDataJobRequest() = default;
};
class CreateDownloadDataJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> downloadDataType{};
  shared_ptr<long> endTime{};
  shared_ptr<string> fileConfigShrink{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> tableName{};

  CreateDownloadDataJobShrinkRequest() {}

  explicit CreateDownloadDataJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadDataType) {
      res["DownloadDataType"] = boost::any(*downloadDataType);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (fileConfigShrink) {
      res["FileConfig"] = boost::any(*fileConfigShrink);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadDataType") != m.end() && !m["DownloadDataType"].empty()) {
      downloadDataType = make_shared<string>(boost::any_cast<string>(m["DownloadDataType"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("FileConfig") != m.end() && !m["FileConfig"].empty()) {
      fileConfigShrink = make_shared<string>(boost::any_cast<string>(m["FileConfig"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~CreateDownloadDataJobShrinkRequest() = default;
};
class CreateDownloadDataJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> asyncExecute{};
  shared_ptr<string> csvFileName{};
  shared_ptr<string> csvUrl{};
  shared_ptr<string> longJobId{};
  shared_ptr<long> status{};

  CreateDownloadDataJobResponseBodyData() {}

  explicit CreateDownloadDataJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asyncExecute) {
      res["AsyncExecute"] = boost::any(*asyncExecute);
    }
    if (csvFileName) {
      res["CsvFileName"] = boost::any(*csvFileName);
    }
    if (csvUrl) {
      res["CsvUrl"] = boost::any(*csvUrl);
    }
    if (longJobId) {
      res["LongJobId"] = boost::any(*longJobId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsyncExecute") != m.end() && !m["AsyncExecute"].empty()) {
      asyncExecute = make_shared<bool>(boost::any_cast<bool>(m["AsyncExecute"]));
    }
    if (m.find("CsvFileName") != m.end() && !m["CsvFileName"].empty()) {
      csvFileName = make_shared<string>(boost::any_cast<string>(m["CsvFileName"]));
    }
    if (m.find("CsvUrl") != m.end() && !m["CsvUrl"].empty()) {
      csvUrl = make_shared<string>(boost::any_cast<string>(m["CsvUrl"]));
    }
    if (m.find("LongJobId") != m.end() && !m["LongJobId"].empty()) {
      longJobId = make_shared<string>(boost::any_cast<string>(m["LongJobId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~CreateDownloadDataJobResponseBodyData() = default;
};
class CreateDownloadDataJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateDownloadDataJobResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateDownloadDataJobResponseBody() {}

  explicit CreateDownloadDataJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateDownloadDataJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateDownloadDataJobResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateDownloadDataJobResponseBody() = default;
};
class CreateDownloadDataJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDownloadDataJobResponseBody> body{};

  CreateDownloadDataJobResponse() {}

  explicit CreateDownloadDataJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDownloadDataJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDownloadDataJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDownloadDataJobResponse() = default;
};
class CreateEdgeDriverRequest : public Darabonba::Model {
public:
  shared_ptr<string> cpuArch{};
  shared_ptr<string> driverName{};
  shared_ptr<string> driverProtocol{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<bool> isBuiltIn{};
  shared_ptr<string> runtime{};

  CreateEdgeDriverRequest() {}

  explicit CreateEdgeDriverRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpuArch) {
      res["CpuArch"] = boost::any(*cpuArch);
    }
    if (driverName) {
      res["DriverName"] = boost::any(*driverName);
    }
    if (driverProtocol) {
      res["DriverProtocol"] = boost::any(*driverProtocol);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (isBuiltIn) {
      res["IsBuiltIn"] = boost::any(*isBuiltIn);
    }
    if (runtime) {
      res["Runtime"] = boost::any(*runtime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CpuArch") != m.end() && !m["CpuArch"].empty()) {
      cpuArch = make_shared<string>(boost::any_cast<string>(m["CpuArch"]));
    }
    if (m.find("DriverName") != m.end() && !m["DriverName"].empty()) {
      driverName = make_shared<string>(boost::any_cast<string>(m["DriverName"]));
    }
    if (m.find("DriverProtocol") != m.end() && !m["DriverProtocol"].empty()) {
      driverProtocol = make_shared<string>(boost::any_cast<string>(m["DriverProtocol"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("IsBuiltIn") != m.end() && !m["IsBuiltIn"].empty()) {
      isBuiltIn = make_shared<bool>(boost::any_cast<bool>(m["IsBuiltIn"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      runtime = make_shared<string>(boost::any_cast<string>(m["Runtime"]));
    }
  }


  virtual ~CreateEdgeDriverRequest() = default;
};
class CreateEdgeDriverResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> driverId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateEdgeDriverResponseBody() {}

  explicit CreateEdgeDriverResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateEdgeDriverResponseBody() = default;
};
class CreateEdgeDriverResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEdgeDriverResponseBody> body{};

  CreateEdgeDriverResponse() {}

  explicit CreateEdgeDriverResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEdgeDriverResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEdgeDriverResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEdgeDriverResponse() = default;
};
class CreateEdgeDriverVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> argument{};
  shared_ptr<string> configCheckRule{};
  shared_ptr<string> containerConfig{};
  shared_ptr<string> description{};
  shared_ptr<string> driverConfig{};
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};
  shared_ptr<string> edgeVersion{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> sourceConfig{};

  CreateEdgeDriverVersionRequest() {}

  explicit CreateEdgeDriverVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (argument) {
      res["Argument"] = boost::any(*argument);
    }
    if (configCheckRule) {
      res["ConfigCheckRule"] = boost::any(*configCheckRule);
    }
    if (containerConfig) {
      res["ContainerConfig"] = boost::any(*containerConfig);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (driverConfig) {
      res["DriverConfig"] = boost::any(*driverConfig);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    if (edgeVersion) {
      res["EdgeVersion"] = boost::any(*edgeVersion);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (sourceConfig) {
      res["SourceConfig"] = boost::any(*sourceConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Argument") != m.end() && !m["Argument"].empty()) {
      argument = make_shared<string>(boost::any_cast<string>(m["Argument"]));
    }
    if (m.find("ConfigCheckRule") != m.end() && !m["ConfigCheckRule"].empty()) {
      configCheckRule = make_shared<string>(boost::any_cast<string>(m["ConfigCheckRule"]));
    }
    if (m.find("ContainerConfig") != m.end() && !m["ContainerConfig"].empty()) {
      containerConfig = make_shared<string>(boost::any_cast<string>(m["ContainerConfig"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DriverConfig") != m.end() && !m["DriverConfig"].empty()) {
      driverConfig = make_shared<string>(boost::any_cast<string>(m["DriverConfig"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
    if (m.find("EdgeVersion") != m.end() && !m["EdgeVersion"].empty()) {
      edgeVersion = make_shared<string>(boost::any_cast<string>(m["EdgeVersion"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("SourceConfig") != m.end() && !m["SourceConfig"].empty()) {
      sourceConfig = make_shared<string>(boost::any_cast<string>(m["SourceConfig"]));
    }
  }


  virtual ~CreateEdgeDriverVersionRequest() = default;
};
class CreateEdgeDriverVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateEdgeDriverVersionResponseBody() {}

  explicit CreateEdgeDriverVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateEdgeDriverVersionResponseBody() = default;
};
class CreateEdgeDriverVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEdgeDriverVersionResponseBody> body{};

  CreateEdgeDriverVersionResponse() {}

  explicit CreateEdgeDriverVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEdgeDriverVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEdgeDriverVersionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEdgeDriverVersionResponse() = default;
};
class CreateEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> spec{};
  shared_ptr<string> tags{};

  CreateEdgeInstanceRequest() {}

  explicit CreateEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<long>(boost::any_cast<long>(m["Spec"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~CreateEdgeInstanceRequest() = default;
};
class CreateEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateEdgeInstanceResponseBody() {}

  explicit CreateEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateEdgeInstanceResponseBody() = default;
};
class CreateEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEdgeInstanceResponseBody> body{};

  CreateEdgeInstanceResponse() {}

  explicit CreateEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEdgeInstanceResponse() = default;
};
class CreateEdgeInstanceChannelRequestConfigs : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> format{};
  shared_ptr<string> key{};

  CreateEdgeInstanceChannelRequestConfigs() {}

  explicit CreateEdgeInstanceChannelRequestConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~CreateEdgeInstanceChannelRequestConfigs() = default;
};
class CreateEdgeInstanceChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<vector<CreateEdgeInstanceChannelRequestConfigs>> configs{};
  shared_ptr<string> driverId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};

  CreateEdgeInstanceChannelRequest() {}

  explicit CreateEdgeInstanceChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (configs) {
      vector<boost::any> temp1;
      for(auto item1:*configs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Configs"] = boost::any(temp1);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("Configs") != m.end() && !m["Configs"].empty()) {
      if (typeid(vector<boost::any>) == m["Configs"].type()) {
        vector<CreateEdgeInstanceChannelRequestConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Configs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEdgeInstanceChannelRequestConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configs = make_shared<vector<CreateEdgeInstanceChannelRequestConfigs>>(expect1);
      }
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~CreateEdgeInstanceChannelRequest() = default;
};
class CreateEdgeInstanceChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateEdgeInstanceChannelResponseBody() {}

  explicit CreateEdgeInstanceChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateEdgeInstanceChannelResponseBody() = default;
};
class CreateEdgeInstanceChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEdgeInstanceChannelResponseBody> body{};

  CreateEdgeInstanceChannelResponse() {}

  explicit CreateEdgeInstanceChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEdgeInstanceChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEdgeInstanceChannelResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEdgeInstanceChannelResponse() = default;
};
class CreateEdgeInstanceDeploymentRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> type{};

  CreateEdgeInstanceDeploymentRequest() {}

  explicit CreateEdgeInstanceDeploymentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateEdgeInstanceDeploymentRequest() = default;
};
class CreateEdgeInstanceDeploymentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> deploymentId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateEdgeInstanceDeploymentResponseBody() {}

  explicit CreateEdgeInstanceDeploymentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (deploymentId) {
      res["DeploymentId"] = boost::any(*deploymentId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DeploymentId") != m.end() && !m["DeploymentId"].empty()) {
      deploymentId = make_shared<string>(boost::any_cast<string>(m["DeploymentId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateEdgeInstanceDeploymentResponseBody() = default;
};
class CreateEdgeInstanceDeploymentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEdgeInstanceDeploymentResponseBody> body{};

  CreateEdgeInstanceDeploymentResponse() {}

  explicit CreateEdgeInstanceDeploymentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEdgeInstanceDeploymentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEdgeInstanceDeploymentResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEdgeInstanceDeploymentResponse() = default;
};
class CreateEdgeInstanceMessageRoutingRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceData{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> targetData{};
  shared_ptr<long> targetIotHubQos{};
  shared_ptr<string> targetType{};
  shared_ptr<string> topicFilter{};

  CreateEdgeInstanceMessageRoutingRequest() {}

  explicit CreateEdgeInstanceMessageRoutingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (sourceData) {
      res["SourceData"] = boost::any(*sourceData);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (targetData) {
      res["TargetData"] = boost::any(*targetData);
    }
    if (targetIotHubQos) {
      res["TargetIotHubQos"] = boost::any(*targetIotHubQos);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (topicFilter) {
      res["TopicFilter"] = boost::any(*topicFilter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SourceData") != m.end() && !m["SourceData"].empty()) {
      sourceData = make_shared<string>(boost::any_cast<string>(m["SourceData"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("TargetData") != m.end() && !m["TargetData"].empty()) {
      targetData = make_shared<string>(boost::any_cast<string>(m["TargetData"]));
    }
    if (m.find("TargetIotHubQos") != m.end() && !m["TargetIotHubQos"].empty()) {
      targetIotHubQos = make_shared<long>(boost::any_cast<long>(m["TargetIotHubQos"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("TopicFilter") != m.end() && !m["TopicFilter"].empty()) {
      topicFilter = make_shared<string>(boost::any_cast<string>(m["TopicFilter"]));
    }
  }


  virtual ~CreateEdgeInstanceMessageRoutingRequest() = default;
};
class CreateEdgeInstanceMessageRoutingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<long> routeId{};
  shared_ptr<bool> success{};

  CreateEdgeInstanceMessageRoutingResponseBody() {}

  explicit CreateEdgeInstanceMessageRoutingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<long>(boost::any_cast<long>(m["RouteId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateEdgeInstanceMessageRoutingResponseBody() = default;
};
class CreateEdgeInstanceMessageRoutingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEdgeInstanceMessageRoutingResponseBody> body{};

  CreateEdgeInstanceMessageRoutingResponse() {}

  explicit CreateEdgeInstanceMessageRoutingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEdgeInstanceMessageRoutingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEdgeInstanceMessageRoutingResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEdgeInstanceMessageRoutingResponse() = default;
};
class CreateEdgeOssPreSignedAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceVersion{};
  shared_ptr<string> type{};

  CreateEdgeOssPreSignedAddressRequest() {}

  explicit CreateEdgeOssPreSignedAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceVersion) {
      res["ResourceVersion"] = boost::any(*resourceVersion);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceVersion") != m.end() && !m["ResourceVersion"].empty()) {
      resourceVersion = make_shared<string>(boost::any_cast<string>(m["ResourceVersion"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateEdgeOssPreSignedAddressRequest() = default;
};
class CreateEdgeOssPreSignedAddressResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> ossAddress{};
  shared_ptr<string> ossPreSignedAddress{};

  CreateEdgeOssPreSignedAddressResponseBodyData() {}

  explicit CreateEdgeOssPreSignedAddressResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ossAddress) {
      res["OssAddress"] = boost::any(*ossAddress);
    }
    if (ossPreSignedAddress) {
      res["OssPreSignedAddress"] = boost::any(*ossPreSignedAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OssAddress") != m.end() && !m["OssAddress"].empty()) {
      ossAddress = make_shared<string>(boost::any_cast<string>(m["OssAddress"]));
    }
    if (m.find("OssPreSignedAddress") != m.end() && !m["OssPreSignedAddress"].empty()) {
      ossPreSignedAddress = make_shared<string>(boost::any_cast<string>(m["OssPreSignedAddress"]));
    }
  }


  virtual ~CreateEdgeOssPreSignedAddressResponseBodyData() = default;
};
class CreateEdgeOssPreSignedAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateEdgeOssPreSignedAddressResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateEdgeOssPreSignedAddressResponseBody() {}

  explicit CreateEdgeOssPreSignedAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateEdgeOssPreSignedAddressResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateEdgeOssPreSignedAddressResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateEdgeOssPreSignedAddressResponseBody() = default;
};
class CreateEdgeOssPreSignedAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEdgeOssPreSignedAddressResponseBody> body{};

  CreateEdgeOssPreSignedAddressResponse() {}

  explicit CreateEdgeOssPreSignedAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEdgeOssPreSignedAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEdgeOssPreSignedAddressResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEdgeOssPreSignedAddressResponse() = default;
};
class CreateJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobDocument{};
  shared_ptr<map<string, boost::any>> jobFile{};
  shared_ptr<string> jobName{};
  shared_ptr<map<string, boost::any>> rolloutConfig{};
  shared_ptr<long> scheduledTime{};
  shared_ptr<map<string, boost::any>> targetConfig{};
  shared_ptr<map<string, boost::any>> timeoutConfig{};
  shared_ptr<string> type{};

  CreateJobRequest() {}

  explicit CreateJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobDocument) {
      res["JobDocument"] = boost::any(*jobDocument);
    }
    if (jobFile) {
      res["JobFile"] = boost::any(*jobFile);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (rolloutConfig) {
      res["RolloutConfig"] = boost::any(*rolloutConfig);
    }
    if (scheduledTime) {
      res["ScheduledTime"] = boost::any(*scheduledTime);
    }
    if (targetConfig) {
      res["TargetConfig"] = boost::any(*targetConfig);
    }
    if (timeoutConfig) {
      res["TimeoutConfig"] = boost::any(*timeoutConfig);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobDocument") != m.end() && !m["JobDocument"].empty()) {
      jobDocument = make_shared<string>(boost::any_cast<string>(m["JobDocument"]));
    }
    if (m.find("JobFile") != m.end() && !m["JobFile"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["JobFile"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      jobFile = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("RolloutConfig") != m.end() && !m["RolloutConfig"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["RolloutConfig"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      rolloutConfig = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("ScheduledTime") != m.end() && !m["ScheduledTime"].empty()) {
      scheduledTime = make_shared<long>(boost::any_cast<long>(m["ScheduledTime"]));
    }
    if (m.find("TargetConfig") != m.end() && !m["TargetConfig"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["TargetConfig"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      targetConfig = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("TimeoutConfig") != m.end() && !m["TimeoutConfig"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["TimeoutConfig"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      timeoutConfig = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateJobRequest() = default;
};
class CreateJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobDocument{};
  shared_ptr<string> jobFileShrink{};
  shared_ptr<string> jobName{};
  shared_ptr<string> rolloutConfigShrink{};
  shared_ptr<long> scheduledTime{};
  shared_ptr<string> targetConfigShrink{};
  shared_ptr<string> timeoutConfigShrink{};
  shared_ptr<string> type{};

  CreateJobShrinkRequest() {}

  explicit CreateJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobDocument) {
      res["JobDocument"] = boost::any(*jobDocument);
    }
    if (jobFileShrink) {
      res["JobFile"] = boost::any(*jobFileShrink);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (rolloutConfigShrink) {
      res["RolloutConfig"] = boost::any(*rolloutConfigShrink);
    }
    if (scheduledTime) {
      res["ScheduledTime"] = boost::any(*scheduledTime);
    }
    if (targetConfigShrink) {
      res["TargetConfig"] = boost::any(*targetConfigShrink);
    }
    if (timeoutConfigShrink) {
      res["TimeoutConfig"] = boost::any(*timeoutConfigShrink);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobDocument") != m.end() && !m["JobDocument"].empty()) {
      jobDocument = make_shared<string>(boost::any_cast<string>(m["JobDocument"]));
    }
    if (m.find("JobFile") != m.end() && !m["JobFile"].empty()) {
      jobFileShrink = make_shared<string>(boost::any_cast<string>(m["JobFile"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("RolloutConfig") != m.end() && !m["RolloutConfig"].empty()) {
      rolloutConfigShrink = make_shared<string>(boost::any_cast<string>(m["RolloutConfig"]));
    }
    if (m.find("ScheduledTime") != m.end() && !m["ScheduledTime"].empty()) {
      scheduledTime = make_shared<long>(boost::any_cast<long>(m["ScheduledTime"]));
    }
    if (m.find("TargetConfig") != m.end() && !m["TargetConfig"].empty()) {
      targetConfigShrink = make_shared<string>(boost::any_cast<string>(m["TargetConfig"]));
    }
    if (m.find("TimeoutConfig") != m.end() && !m["TimeoutConfig"].empty()) {
      timeoutConfigShrink = make_shared<string>(boost::any_cast<string>(m["TimeoutConfig"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateJobShrinkRequest() = default;
};
class CreateJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateJobResponseBody() {}

  explicit CreateJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateJobResponseBody() = default;
};
class CreateJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateJobResponseBody> body{};

  CreateJobResponse() {}

  explicit CreateJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateJobResponse() = default;
};
class CreateLoRaNodesTaskRequestDeviceInfo : public Darabonba::Model {
public:
  shared_ptr<string> devEui{};
  shared_ptr<string> pinCode{};

  CreateLoRaNodesTaskRequestDeviceInfo() {}

  explicit CreateLoRaNodesTaskRequestDeviceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (devEui) {
      res["DevEui"] = boost::any(*devEui);
    }
    if (pinCode) {
      res["PinCode"] = boost::any(*pinCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DevEui") != m.end() && !m["DevEui"].empty()) {
      devEui = make_shared<string>(boost::any_cast<string>(m["DevEui"]));
    }
    if (m.find("PinCode") != m.end() && !m["PinCode"].empty()) {
      pinCode = make_shared<string>(boost::any_cast<string>(m["PinCode"]));
    }
  }


  virtual ~CreateLoRaNodesTaskRequestDeviceInfo() = default;
};
class CreateLoRaNodesTaskRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateLoRaNodesTaskRequestDeviceInfo>> deviceInfo{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  CreateLoRaNodesTaskRequest() {}

  explicit CreateLoRaNodesTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*deviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceInfo"] = boost::any(temp1);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceInfo") != m.end() && !m["DeviceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceInfo"].type()) {
        vector<CreateLoRaNodesTaskRequestDeviceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateLoRaNodesTaskRequestDeviceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceInfo = make_shared<vector<CreateLoRaNodesTaskRequestDeviceInfo>>(expect1);
      }
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~CreateLoRaNodesTaskRequest() = default;
};
class CreateLoRaNodesTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> taskId{};

  CreateLoRaNodesTaskResponseBody() {}

  explicit CreateLoRaNodesTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateLoRaNodesTaskResponseBody() = default;
};
class CreateLoRaNodesTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLoRaNodesTaskResponseBody> body{};

  CreateLoRaNodesTaskResponse() {}

  explicit CreateLoRaNodesTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLoRaNodesTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLoRaNodesTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLoRaNodesTaskResponse() = default;
};
class CreateOTADynamicUpgradeJobRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateOTADynamicUpgradeJobRequestTag() {}

  explicit CreateOTADynamicUpgradeJobRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateOTADynamicUpgradeJobRequestTag() = default;
};
class CreateOTADynamicUpgradeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> downloadProtocol{};
  shared_ptr<long> dynamicMode{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupType{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> maximumPerMinute{};
  shared_ptr<bool> multiModuleMode{};
  shared_ptr<bool> needConfirm{};
  shared_ptr<bool> needPush{};
  shared_ptr<long> overwriteMode{};
  shared_ptr<string> productKey{};
  shared_ptr<long> retryCount{};
  shared_ptr<long> retryInterval{};
  shared_ptr<vector<string>> srcVersion{};
  shared_ptr<vector<CreateOTADynamicUpgradeJobRequestTag>> tag{};
  shared_ptr<long> timeoutInMinutes{};

  CreateOTADynamicUpgradeJobRequest() {}

  explicit CreateOTADynamicUpgradeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadProtocol) {
      res["DownloadProtocol"] = boost::any(*downloadProtocol);
    }
    if (dynamicMode) {
      res["DynamicMode"] = boost::any(*dynamicMode);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (maximumPerMinute) {
      res["MaximumPerMinute"] = boost::any(*maximumPerMinute);
    }
    if (multiModuleMode) {
      res["MultiModuleMode"] = boost::any(*multiModuleMode);
    }
    if (needConfirm) {
      res["NeedConfirm"] = boost::any(*needConfirm);
    }
    if (needPush) {
      res["NeedPush"] = boost::any(*needPush);
    }
    if (overwriteMode) {
      res["OverwriteMode"] = boost::any(*overwriteMode);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (retryInterval) {
      res["RetryInterval"] = boost::any(*retryInterval);
    }
    if (srcVersion) {
      res["SrcVersion"] = boost::any(*srcVersion);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (timeoutInMinutes) {
      res["TimeoutInMinutes"] = boost::any(*timeoutInMinutes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadProtocol") != m.end() && !m["DownloadProtocol"].empty()) {
      downloadProtocol = make_shared<string>(boost::any_cast<string>(m["DownloadProtocol"]));
    }
    if (m.find("DynamicMode") != m.end() && !m["DynamicMode"].empty()) {
      dynamicMode = make_shared<long>(boost::any_cast<long>(m["DynamicMode"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<string>(boost::any_cast<string>(m["GroupType"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("MaximumPerMinute") != m.end() && !m["MaximumPerMinute"].empty()) {
      maximumPerMinute = make_shared<long>(boost::any_cast<long>(m["MaximumPerMinute"]));
    }
    if (m.find("MultiModuleMode") != m.end() && !m["MultiModuleMode"].empty()) {
      multiModuleMode = make_shared<bool>(boost::any_cast<bool>(m["MultiModuleMode"]));
    }
    if (m.find("NeedConfirm") != m.end() && !m["NeedConfirm"].empty()) {
      needConfirm = make_shared<bool>(boost::any_cast<bool>(m["NeedConfirm"]));
    }
    if (m.find("NeedPush") != m.end() && !m["NeedPush"].empty()) {
      needPush = make_shared<bool>(boost::any_cast<bool>(m["NeedPush"]));
    }
    if (m.find("OverwriteMode") != m.end() && !m["OverwriteMode"].empty()) {
      overwriteMode = make_shared<long>(boost::any_cast<long>(m["OverwriteMode"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<long>(boost::any_cast<long>(m["RetryCount"]));
    }
    if (m.find("RetryInterval") != m.end() && !m["RetryInterval"].empty()) {
      retryInterval = make_shared<long>(boost::any_cast<long>(m["RetryInterval"]));
    }
    if (m.find("SrcVersion") != m.end() && !m["SrcVersion"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SrcVersion"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SrcVersion"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      srcVersion = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateOTADynamicUpgradeJobRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOTADynamicUpgradeJobRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateOTADynamicUpgradeJobRequestTag>>(expect1);
      }
    }
    if (m.find("TimeoutInMinutes") != m.end() && !m["TimeoutInMinutes"].empty()) {
      timeoutInMinutes = make_shared<long>(boost::any_cast<long>(m["TimeoutInMinutes"]));
    }
  }


  virtual ~CreateOTADynamicUpgradeJobRequest() = default;
};
class CreateOTADynamicUpgradeJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> utcCreate{};

  CreateOTADynamicUpgradeJobResponseBodyData() {}

  explicit CreateOTADynamicUpgradeJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
  }


  virtual ~CreateOTADynamicUpgradeJobResponseBodyData() = default;
};
class CreateOTADynamicUpgradeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateOTADynamicUpgradeJobResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateOTADynamicUpgradeJobResponseBody() {}

  explicit CreateOTADynamicUpgradeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateOTADynamicUpgradeJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateOTADynamicUpgradeJobResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateOTADynamicUpgradeJobResponseBody() = default;
};
class CreateOTADynamicUpgradeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOTADynamicUpgradeJobResponseBody> body{};

  CreateOTADynamicUpgradeJobResponse() {}

  explicit CreateOTADynamicUpgradeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOTADynamicUpgradeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOTADynamicUpgradeJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOTADynamicUpgradeJobResponse() = default;
};
class CreateOTAFirmwareRequestMultiFiles : public Darabonba::Model {
public:
  shared_ptr<string> fileMd5{};
  shared_ptr<string> name{};
  shared_ptr<string> signValue{};
  shared_ptr<long> size{};
  shared_ptr<string> url{};

  CreateOTAFirmwareRequestMultiFiles() {}

  explicit CreateOTAFirmwareRequestMultiFiles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileMd5) {
      res["FileMd5"] = boost::any(*fileMd5);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (signValue) {
      res["SignValue"] = boost::any(*signValue);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileMd5") != m.end() && !m["FileMd5"].empty()) {
      fileMd5 = make_shared<string>(boost::any_cast<string>(m["FileMd5"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SignValue") != m.end() && !m["SignValue"].empty()) {
      signValue = make_shared<string>(boost::any_cast<string>(m["SignValue"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~CreateOTAFirmwareRequestMultiFiles() = default;
};
class CreateOTAFirmwareRequest : public Darabonba::Model {
public:
  shared_ptr<string> destVersion{};
  shared_ptr<string> firmwareDesc{};
  shared_ptr<string> firmwareName{};
  shared_ptr<string> firmwareSign{};
  shared_ptr<long> firmwareSize{};
  shared_ptr<string> firmwareUrl{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> moduleName{};
  shared_ptr<vector<CreateOTAFirmwareRequestMultiFiles>> multiFiles{};
  shared_ptr<bool> needToVerify{};
  shared_ptr<string> productKey{};
  shared_ptr<string> signMethod{};
  shared_ptr<string> srcVersion{};
  shared_ptr<long> type{};
  shared_ptr<string> udi{};

  CreateOTAFirmwareRequest() {}

  explicit CreateOTAFirmwareRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destVersion) {
      res["DestVersion"] = boost::any(*destVersion);
    }
    if (firmwareDesc) {
      res["FirmwareDesc"] = boost::any(*firmwareDesc);
    }
    if (firmwareName) {
      res["FirmwareName"] = boost::any(*firmwareName);
    }
    if (firmwareSign) {
      res["FirmwareSign"] = boost::any(*firmwareSign);
    }
    if (firmwareSize) {
      res["FirmwareSize"] = boost::any(*firmwareSize);
    }
    if (firmwareUrl) {
      res["FirmwareUrl"] = boost::any(*firmwareUrl);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    if (multiFiles) {
      vector<boost::any> temp1;
      for(auto item1:*multiFiles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MultiFiles"] = boost::any(temp1);
    }
    if (needToVerify) {
      res["NeedToVerify"] = boost::any(*needToVerify);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (signMethod) {
      res["SignMethod"] = boost::any(*signMethod);
    }
    if (srcVersion) {
      res["SrcVersion"] = boost::any(*srcVersion);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (udi) {
      res["Udi"] = boost::any(*udi);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestVersion") != m.end() && !m["DestVersion"].empty()) {
      destVersion = make_shared<string>(boost::any_cast<string>(m["DestVersion"]));
    }
    if (m.find("FirmwareDesc") != m.end() && !m["FirmwareDesc"].empty()) {
      firmwareDesc = make_shared<string>(boost::any_cast<string>(m["FirmwareDesc"]));
    }
    if (m.find("FirmwareName") != m.end() && !m["FirmwareName"].empty()) {
      firmwareName = make_shared<string>(boost::any_cast<string>(m["FirmwareName"]));
    }
    if (m.find("FirmwareSign") != m.end() && !m["FirmwareSign"].empty()) {
      firmwareSign = make_shared<string>(boost::any_cast<string>(m["FirmwareSign"]));
    }
    if (m.find("FirmwareSize") != m.end() && !m["FirmwareSize"].empty()) {
      firmwareSize = make_shared<long>(boost::any_cast<long>(m["FirmwareSize"]));
    }
    if (m.find("FirmwareUrl") != m.end() && !m["FirmwareUrl"].empty()) {
      firmwareUrl = make_shared<string>(boost::any_cast<string>(m["FirmwareUrl"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
    if (m.find("MultiFiles") != m.end() && !m["MultiFiles"].empty()) {
      if (typeid(vector<boost::any>) == m["MultiFiles"].type()) {
        vector<CreateOTAFirmwareRequestMultiFiles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MultiFiles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOTAFirmwareRequestMultiFiles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        multiFiles = make_shared<vector<CreateOTAFirmwareRequestMultiFiles>>(expect1);
      }
    }
    if (m.find("NeedToVerify") != m.end() && !m["NeedToVerify"].empty()) {
      needToVerify = make_shared<bool>(boost::any_cast<bool>(m["NeedToVerify"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("SignMethod") != m.end() && !m["SignMethod"].empty()) {
      signMethod = make_shared<string>(boost::any_cast<string>(m["SignMethod"]));
    }
    if (m.find("SrcVersion") != m.end() && !m["SrcVersion"].empty()) {
      srcVersion = make_shared<string>(boost::any_cast<string>(m["SrcVersion"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Udi") != m.end() && !m["Udi"].empty()) {
      udi = make_shared<string>(boost::any_cast<string>(m["Udi"]));
    }
  }


  virtual ~CreateOTAFirmwareRequest() = default;
};
class CreateOTAFirmwareResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> firmwareId{};
  shared_ptr<string> utcCreate{};

  CreateOTAFirmwareResponseBodyData() {}

  explicit CreateOTAFirmwareResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
  }


  virtual ~CreateOTAFirmwareResponseBodyData() = default;
};
class CreateOTAFirmwareResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateOTAFirmwareResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateOTAFirmwareResponseBody() {}

  explicit CreateOTAFirmwareResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateOTAFirmwareResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateOTAFirmwareResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateOTAFirmwareResponseBody() = default;
};
class CreateOTAFirmwareResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOTAFirmwareResponseBody> body{};

  CreateOTAFirmwareResponse() {}

  explicit CreateOTAFirmwareResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOTAFirmwareResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOTAFirmwareResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOTAFirmwareResponse() = default;
};
class CreateOTAModuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<string> desc{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> moduleName{};
  shared_ptr<string> productKey{};

  CreateOTAModuleRequest() {}

  explicit CreateOTAModuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~CreateOTAModuleRequest() = default;
};
class CreateOTAModuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateOTAModuleResponseBody() {}

  explicit CreateOTAModuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateOTAModuleResponseBody() = default;
};
class CreateOTAModuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOTAModuleResponseBody> body{};

  CreateOTAModuleResponse() {}

  explicit CreateOTAModuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOTAModuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOTAModuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOTAModuleResponse() = default;
};
class CreateOTAStaticUpgradeJobRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateOTAStaticUpgradeJobRequestTag() {}

  explicit CreateOTAStaticUpgradeJobRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateOTAStaticUpgradeJobRequestTag() = default;
};
class CreateOTAStaticUpgradeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> dnListFileUrl{};
  shared_ptr<string> downloadProtocol{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> grayPercent{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupType{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> maximumPerMinute{};
  shared_ptr<bool> multiModuleMode{};
  shared_ptr<bool> needConfirm{};
  shared_ptr<bool> needPush{};
  shared_ptr<long> overwriteMode{};
  shared_ptr<string> productKey{};
  shared_ptr<long> retryCount{};
  shared_ptr<long> retryInterval{};
  shared_ptr<long> scheduleFinishTime{};
  shared_ptr<long> scheduleTime{};
  shared_ptr<vector<string>> srcVersion{};
  shared_ptr<vector<CreateOTAStaticUpgradeJobRequestTag>> tag{};
  shared_ptr<vector<string>> targetDeviceName{};
  shared_ptr<string> targetSelection{};
  shared_ptr<long> timeoutInMinutes{};

  CreateOTAStaticUpgradeJobRequest() {}

  explicit CreateOTAStaticUpgradeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dnListFileUrl) {
      res["DnListFileUrl"] = boost::any(*dnListFileUrl);
    }
    if (downloadProtocol) {
      res["DownloadProtocol"] = boost::any(*downloadProtocol);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (grayPercent) {
      res["GrayPercent"] = boost::any(*grayPercent);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (maximumPerMinute) {
      res["MaximumPerMinute"] = boost::any(*maximumPerMinute);
    }
    if (multiModuleMode) {
      res["MultiModuleMode"] = boost::any(*multiModuleMode);
    }
    if (needConfirm) {
      res["NeedConfirm"] = boost::any(*needConfirm);
    }
    if (needPush) {
      res["NeedPush"] = boost::any(*needPush);
    }
    if (overwriteMode) {
      res["OverwriteMode"] = boost::any(*overwriteMode);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (retryInterval) {
      res["RetryInterval"] = boost::any(*retryInterval);
    }
    if (scheduleFinishTime) {
      res["ScheduleFinishTime"] = boost::any(*scheduleFinishTime);
    }
    if (scheduleTime) {
      res["ScheduleTime"] = boost::any(*scheduleTime);
    }
    if (srcVersion) {
      res["SrcVersion"] = boost::any(*srcVersion);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (targetDeviceName) {
      res["TargetDeviceName"] = boost::any(*targetDeviceName);
    }
    if (targetSelection) {
      res["TargetSelection"] = boost::any(*targetSelection);
    }
    if (timeoutInMinutes) {
      res["TimeoutInMinutes"] = boost::any(*timeoutInMinutes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DnListFileUrl") != m.end() && !m["DnListFileUrl"].empty()) {
      dnListFileUrl = make_shared<string>(boost::any_cast<string>(m["DnListFileUrl"]));
    }
    if (m.find("DownloadProtocol") != m.end() && !m["DownloadProtocol"].empty()) {
      downloadProtocol = make_shared<string>(boost::any_cast<string>(m["DownloadProtocol"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("GrayPercent") != m.end() && !m["GrayPercent"].empty()) {
      grayPercent = make_shared<string>(boost::any_cast<string>(m["GrayPercent"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<string>(boost::any_cast<string>(m["GroupType"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("MaximumPerMinute") != m.end() && !m["MaximumPerMinute"].empty()) {
      maximumPerMinute = make_shared<long>(boost::any_cast<long>(m["MaximumPerMinute"]));
    }
    if (m.find("MultiModuleMode") != m.end() && !m["MultiModuleMode"].empty()) {
      multiModuleMode = make_shared<bool>(boost::any_cast<bool>(m["MultiModuleMode"]));
    }
    if (m.find("NeedConfirm") != m.end() && !m["NeedConfirm"].empty()) {
      needConfirm = make_shared<bool>(boost::any_cast<bool>(m["NeedConfirm"]));
    }
    if (m.find("NeedPush") != m.end() && !m["NeedPush"].empty()) {
      needPush = make_shared<bool>(boost::any_cast<bool>(m["NeedPush"]));
    }
    if (m.find("OverwriteMode") != m.end() && !m["OverwriteMode"].empty()) {
      overwriteMode = make_shared<long>(boost::any_cast<long>(m["OverwriteMode"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<long>(boost::any_cast<long>(m["RetryCount"]));
    }
    if (m.find("RetryInterval") != m.end() && !m["RetryInterval"].empty()) {
      retryInterval = make_shared<long>(boost::any_cast<long>(m["RetryInterval"]));
    }
    if (m.find("ScheduleFinishTime") != m.end() && !m["ScheduleFinishTime"].empty()) {
      scheduleFinishTime = make_shared<long>(boost::any_cast<long>(m["ScheduleFinishTime"]));
    }
    if (m.find("ScheduleTime") != m.end() && !m["ScheduleTime"].empty()) {
      scheduleTime = make_shared<long>(boost::any_cast<long>(m["ScheduleTime"]));
    }
    if (m.find("SrcVersion") != m.end() && !m["SrcVersion"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SrcVersion"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SrcVersion"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      srcVersion = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateOTAStaticUpgradeJobRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOTAStaticUpgradeJobRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateOTAStaticUpgradeJobRequestTag>>(expect1);
      }
    }
    if (m.find("TargetDeviceName") != m.end() && !m["TargetDeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TargetDeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TargetDeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      targetDeviceName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TargetSelection") != m.end() && !m["TargetSelection"].empty()) {
      targetSelection = make_shared<string>(boost::any_cast<string>(m["TargetSelection"]));
    }
    if (m.find("TimeoutInMinutes") != m.end() && !m["TimeoutInMinutes"].empty()) {
      timeoutInMinutes = make_shared<long>(boost::any_cast<long>(m["TimeoutInMinutes"]));
    }
  }


  virtual ~CreateOTAStaticUpgradeJobRequest() = default;
};
class CreateOTAStaticUpgradeJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> utcCreate{};

  CreateOTAStaticUpgradeJobResponseBodyData() {}

  explicit CreateOTAStaticUpgradeJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
  }


  virtual ~CreateOTAStaticUpgradeJobResponseBodyData() = default;
};
class CreateOTAStaticUpgradeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateOTAStaticUpgradeJobResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateOTAStaticUpgradeJobResponseBody() {}

  explicit CreateOTAStaticUpgradeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateOTAStaticUpgradeJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateOTAStaticUpgradeJobResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateOTAStaticUpgradeJobResponseBody() = default;
};
class CreateOTAStaticUpgradeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOTAStaticUpgradeJobResponseBody> body{};

  CreateOTAStaticUpgradeJobResponse() {}

  explicit CreateOTAStaticUpgradeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOTAStaticUpgradeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOTAStaticUpgradeJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOTAStaticUpgradeJobResponse() = default;
};
class CreateOTAVerifyJobRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateOTAVerifyJobRequestTag() {}

  explicit CreateOTAVerifyJobRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateOTAVerifyJobRequestTag() = default;
};
class CreateOTAVerifyJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> downloadProtocol{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<bool> needConfirm{};
  shared_ptr<bool> needPush{};
  shared_ptr<string> productKey{};
  shared_ptr<vector<CreateOTAVerifyJobRequestTag>> tag{};
  shared_ptr<vector<string>> targetDeviceName{};
  shared_ptr<long> timeoutInMinutes{};

  CreateOTAVerifyJobRequest() {}

  explicit CreateOTAVerifyJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadProtocol) {
      res["DownloadProtocol"] = boost::any(*downloadProtocol);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (needConfirm) {
      res["NeedConfirm"] = boost::any(*needConfirm);
    }
    if (needPush) {
      res["NeedPush"] = boost::any(*needPush);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (targetDeviceName) {
      res["TargetDeviceName"] = boost::any(*targetDeviceName);
    }
    if (timeoutInMinutes) {
      res["TimeoutInMinutes"] = boost::any(*timeoutInMinutes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadProtocol") != m.end() && !m["DownloadProtocol"].empty()) {
      downloadProtocol = make_shared<string>(boost::any_cast<string>(m["DownloadProtocol"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("NeedConfirm") != m.end() && !m["NeedConfirm"].empty()) {
      needConfirm = make_shared<bool>(boost::any_cast<bool>(m["NeedConfirm"]));
    }
    if (m.find("NeedPush") != m.end() && !m["NeedPush"].empty()) {
      needPush = make_shared<bool>(boost::any_cast<bool>(m["NeedPush"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateOTAVerifyJobRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOTAVerifyJobRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateOTAVerifyJobRequestTag>>(expect1);
      }
    }
    if (m.find("TargetDeviceName") != m.end() && !m["TargetDeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TargetDeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TargetDeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      targetDeviceName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TimeoutInMinutes") != m.end() && !m["TimeoutInMinutes"].empty()) {
      timeoutInMinutes = make_shared<long>(boost::any_cast<long>(m["TimeoutInMinutes"]));
    }
  }


  virtual ~CreateOTAVerifyJobRequest() = default;
};
class CreateOTAVerifyJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> utcCreate{};

  CreateOTAVerifyJobResponseBodyData() {}

  explicit CreateOTAVerifyJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
  }


  virtual ~CreateOTAVerifyJobResponseBodyData() = default;
};
class CreateOTAVerifyJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateOTAVerifyJobResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateOTAVerifyJobResponseBody() {}

  explicit CreateOTAVerifyJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateOTAVerifyJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateOTAVerifyJobResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateOTAVerifyJobResponseBody() = default;
};
class CreateOTAVerifyJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOTAVerifyJobResponseBody> body{};

  CreateOTAVerifyJobResponse() {}

  explicit CreateOTAVerifyJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOTAVerifyJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOTAVerifyJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOTAVerifyJobResponse() = default;
};
class CreateParserRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> name{};

  CreateParserRequest() {}

  explicit CreateParserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreateParserRequest() = default;
};
class CreateParserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> parserId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateParserResponseBody() {}

  explicit CreateParserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (parserId) {
      res["ParserId"] = boost::any(*parserId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ParserId") != m.end() && !m["ParserId"].empty()) {
      parserId = make_shared<long>(boost::any_cast<long>(m["ParserId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateParserResponseBody() = default;
};
class CreateParserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateParserResponseBody> body{};

  CreateParserResponse() {}

  explicit CreateParserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateParserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateParserResponseBody>(model1);
      }
    }
  }


  virtual ~CreateParserResponse() = default;
};
class CreateParserDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> name{};

  CreateParserDataSourceRequest() {}

  explicit CreateParserDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreateParserDataSourceRequest() = default;
};
class CreateParserDataSourceResponseBodyDataSource : public Darabonba::Model {
public:
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> utcCreated{};

  CreateParserDataSourceResponseBodyDataSource() {}

  explicit CreateParserDataSourceResponseBodyDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (utcCreated) {
      res["UtcCreated"] = boost::any(*utcCreated);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UtcCreated") != m.end() && !m["UtcCreated"].empty()) {
      utcCreated = make_shared<string>(boost::any_cast<string>(m["UtcCreated"]));
    }
  }


  virtual ~CreateParserDataSourceResponseBodyDataSource() = default;
};
class CreateParserDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateParserDataSourceResponseBodyDataSource> dataSource{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateParserDataSourceResponseBody() {}

  explicit CreateParserDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        CreateParserDataSourceResponseBodyDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<CreateParserDataSourceResponseBodyDataSource>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateParserDataSourceResponseBody() = default;
};
class CreateParserDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateParserDataSourceResponseBody> body{};

  CreateParserDataSourceResponse() {}

  explicit CreateParserDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateParserDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateParserDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateParserDataSourceResponse() = default;
};
class CreateProductRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunCommodityCode{};
  shared_ptr<string> authType{};
  shared_ptr<string> categoryKey{};
  shared_ptr<long> dataFormat{};
  shared_ptr<string> description{};
  shared_ptr<bool> id2{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> joinPermissionId{};
  shared_ptr<string> netType{};
  shared_ptr<long> nodeType{};
  shared_ptr<string> productName{};
  shared_ptr<string> protocolType{};
  shared_ptr<bool> publishAuto{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> validateType{};

  CreateProductRequest() {}

  explicit CreateProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunCommodityCode) {
      res["AliyunCommodityCode"] = boost::any(*aliyunCommodityCode);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (categoryKey) {
      res["CategoryKey"] = boost::any(*categoryKey);
    }
    if (dataFormat) {
      res["DataFormat"] = boost::any(*dataFormat);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id2) {
      res["Id2"] = boost::any(*id2);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (joinPermissionId) {
      res["JoinPermissionId"] = boost::any(*joinPermissionId);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (publishAuto) {
      res["PublishAuto"] = boost::any(*publishAuto);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (validateType) {
      res["ValidateType"] = boost::any(*validateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunCommodityCode") != m.end() && !m["AliyunCommodityCode"].empty()) {
      aliyunCommodityCode = make_shared<string>(boost::any_cast<string>(m["AliyunCommodityCode"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("CategoryKey") != m.end() && !m["CategoryKey"].empty()) {
      categoryKey = make_shared<string>(boost::any_cast<string>(m["CategoryKey"]));
    }
    if (m.find("DataFormat") != m.end() && !m["DataFormat"].empty()) {
      dataFormat = make_shared<long>(boost::any_cast<long>(m["DataFormat"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id2") != m.end() && !m["Id2"].empty()) {
      id2 = make_shared<bool>(boost::any_cast<bool>(m["Id2"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JoinPermissionId") != m.end() && !m["JoinPermissionId"].empty()) {
      joinPermissionId = make_shared<string>(boost::any_cast<string>(m["JoinPermissionId"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<string>(boost::any_cast<string>(m["NetType"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<long>(boost::any_cast<long>(m["NodeType"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("PublishAuto") != m.end() && !m["PublishAuto"].empty()) {
      publishAuto = make_shared<bool>(boost::any_cast<bool>(m["PublishAuto"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ValidateType") != m.end() && !m["ValidateType"].empty()) {
      validateType = make_shared<long>(boost::any_cast<long>(m["ValidateType"]));
    }
  }


  virtual ~CreateProductRequest() = default;
};
class CreateProductResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> aliyunCommodityCode{};
  shared_ptr<string> authType{};
  shared_ptr<long> dataFormat{};
  shared_ptr<string> description{};
  shared_ptr<bool> id2{};
  shared_ptr<long> nodeType{};
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};
  shared_ptr<string> productSecret{};
  shared_ptr<string> protocolType{};

  CreateProductResponseBodyData() {}

  explicit CreateProductResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunCommodityCode) {
      res["AliyunCommodityCode"] = boost::any(*aliyunCommodityCode);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (dataFormat) {
      res["DataFormat"] = boost::any(*dataFormat);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id2) {
      res["Id2"] = boost::any(*id2);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (productSecret) {
      res["ProductSecret"] = boost::any(*productSecret);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunCommodityCode") != m.end() && !m["AliyunCommodityCode"].empty()) {
      aliyunCommodityCode = make_shared<string>(boost::any_cast<string>(m["AliyunCommodityCode"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("DataFormat") != m.end() && !m["DataFormat"].empty()) {
      dataFormat = make_shared<long>(boost::any_cast<long>(m["DataFormat"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id2") != m.end() && !m["Id2"].empty()) {
      id2 = make_shared<bool>(boost::any_cast<bool>(m["Id2"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<long>(boost::any_cast<long>(m["NodeType"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("ProductSecret") != m.end() && !m["ProductSecret"].empty()) {
      productSecret = make_shared<string>(boost::any_cast<string>(m["ProductSecret"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
  }


  virtual ~CreateProductResponseBodyData() = default;
};
class CreateProductResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateProductResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> productKey{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateProductResponseBody() {}

  explicit CreateProductResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateProductResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateProductResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateProductResponseBody() = default;
};
class CreateProductResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateProductResponseBody> body{};

  CreateProductResponse() {}

  explicit CreateProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProductResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProductResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProductResponse() = default;
};
class CreateProductDistributeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> targetAliyunId{};
  shared_ptr<string> targetInstanceId{};
  shared_ptr<string> targetUid{};

  CreateProductDistributeJobRequest() {}

  explicit CreateProductDistributeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (targetAliyunId) {
      res["TargetAliyunId"] = boost::any(*targetAliyunId);
    }
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    if (targetUid) {
      res["TargetUid"] = boost::any(*targetUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("TargetAliyunId") != m.end() && !m["TargetAliyunId"].empty()) {
      targetAliyunId = make_shared<string>(boost::any_cast<string>(m["TargetAliyunId"]));
    }
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
    if (m.find("TargetUid") != m.end() && !m["TargetUid"].empty()) {
      targetUid = make_shared<string>(boost::any_cast<string>(m["TargetUid"]));
    }
  }


  virtual ~CreateProductDistributeJobRequest() = default;
};
class CreateProductDistributeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateProductDistributeJobResponseBody() {}

  explicit CreateProductDistributeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateProductDistributeJobResponseBody() = default;
};
class CreateProductDistributeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateProductDistributeJobResponseBody> body{};

  CreateProductDistributeJobResponse() {}

  explicit CreateProductDistributeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProductDistributeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProductDistributeJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProductDistributeJobResponse() = default;
};
class CreateProductTagsRequestProductTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  CreateProductTagsRequestProductTag() {}

  explicit CreateProductTagsRequestProductTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~CreateProductTagsRequestProductTag() = default;
};
class CreateProductTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<vector<CreateProductTagsRequestProductTag>> productTag{};

  CreateProductTagsRequest() {}

  explicit CreateProductTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productTag) {
      vector<boost::any> temp1;
      for(auto item1:*productTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProductTag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductTag") != m.end() && !m["ProductTag"].empty()) {
      if (typeid(vector<boost::any>) == m["ProductTag"].type()) {
        vector<CreateProductTagsRequestProductTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProductTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateProductTagsRequestProductTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        productTag = make_shared<vector<CreateProductTagsRequestProductTag>>(expect1);
      }
    }
  }


  virtual ~CreateProductTagsRequest() = default;
};
class CreateProductTagsResponseBodyInvalidProductTagsProductTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  CreateProductTagsResponseBodyInvalidProductTagsProductTag() {}

  explicit CreateProductTagsResponseBodyInvalidProductTagsProductTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~CreateProductTagsResponseBodyInvalidProductTagsProductTag() = default;
};
class CreateProductTagsResponseBodyInvalidProductTags : public Darabonba::Model {
public:
  shared_ptr<vector<CreateProductTagsResponseBodyInvalidProductTagsProductTag>> productTag{};

  CreateProductTagsResponseBodyInvalidProductTags() {}

  explicit CreateProductTagsResponseBodyInvalidProductTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productTag) {
      vector<boost::any> temp1;
      for(auto item1:*productTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProductTag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductTag") != m.end() && !m["ProductTag"].empty()) {
      if (typeid(vector<boost::any>) == m["ProductTag"].type()) {
        vector<CreateProductTagsResponseBodyInvalidProductTagsProductTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProductTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateProductTagsResponseBodyInvalidProductTagsProductTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        productTag = make_shared<vector<CreateProductTagsResponseBodyInvalidProductTagsProductTag>>(expect1);
      }
    }
  }


  virtual ~CreateProductTagsResponseBodyInvalidProductTags() = default;
};
class CreateProductTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<CreateProductTagsResponseBodyInvalidProductTags> invalidProductTags{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateProductTagsResponseBody() {}

  explicit CreateProductTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (invalidProductTags) {
      res["InvalidProductTags"] = invalidProductTags ? boost::any(invalidProductTags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("InvalidProductTags") != m.end() && !m["InvalidProductTags"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvalidProductTags"].type()) {
        CreateProductTagsResponseBodyInvalidProductTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvalidProductTags"]));
        invalidProductTags = make_shared<CreateProductTagsResponseBodyInvalidProductTags>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateProductTagsResponseBody() = default;
};
class CreateProductTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateProductTagsResponseBody> body{};

  CreateProductTagsResponse() {}

  explicit CreateProductTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProductTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProductTagsResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProductTagsResponse() = default;
};
class CreateProductTopicRequest : public Darabonba::Model {
public:
  shared_ptr<string> codec{};
  shared_ptr<string> desc{};
  shared_ptr<bool> enableProxySubscribe{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> operation{};
  shared_ptr<string> productKey{};
  shared_ptr<string> topicShortName{};

  CreateProductTopicRequest() {}

  explicit CreateProductTopicRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (enableProxySubscribe) {
      res["EnableProxySubscribe"] = boost::any(*enableProxySubscribe);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (topicShortName) {
      res["TopicShortName"] = boost::any(*topicShortName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("EnableProxySubscribe") != m.end() && !m["EnableProxySubscribe"].empty()) {
      enableProxySubscribe = make_shared<bool>(boost::any_cast<bool>(m["EnableProxySubscribe"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("TopicShortName") != m.end() && !m["TopicShortName"].empty()) {
      topicShortName = make_shared<string>(boost::any_cast<string>(m["TopicShortName"]));
    }
  }


  virtual ~CreateProductTopicRequest() = default;
};
class CreateProductTopicResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> topicId{};

  CreateProductTopicResponseBody() {}

  explicit CreateProductTopicResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<long>(boost::any_cast<long>(m["TopicId"]));
    }
  }


  virtual ~CreateProductTopicResponseBody() = default;
};
class CreateProductTopicResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateProductTopicResponseBody> body{};

  CreateProductTopicResponse() {}

  explicit CreateProductTopicResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProductTopicResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProductTopicResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProductTopicResponse() = default;
};
class CreateRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataType{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> productKey{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> ruleDesc{};
  shared_ptr<string> select{};
  shared_ptr<string> shortTopic{};
  shared_ptr<string> topic{};
  shared_ptr<long> topicType{};
  shared_ptr<string> where{};

  CreateRuleRequest() {}

  explicit CreateRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (ruleDesc) {
      res["RuleDesc"] = boost::any(*ruleDesc);
    }
    if (select) {
      res["Select"] = boost::any(*select);
    }
    if (shortTopic) {
      res["ShortTopic"] = boost::any(*shortTopic);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (topicType) {
      res["TopicType"] = boost::any(*topicType);
    }
    if (where) {
      res["Where"] = boost::any(*where);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RuleDesc") != m.end() && !m["RuleDesc"].empty()) {
      ruleDesc = make_shared<string>(boost::any_cast<string>(m["RuleDesc"]));
    }
    if (m.find("Select") != m.end() && !m["Select"].empty()) {
      select = make_shared<string>(boost::any_cast<string>(m["Select"]));
    }
    if (m.find("ShortTopic") != m.end() && !m["ShortTopic"].empty()) {
      shortTopic = make_shared<string>(boost::any_cast<string>(m["ShortTopic"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("TopicType") != m.end() && !m["TopicType"].empty()) {
      topicType = make_shared<long>(boost::any_cast<long>(m["TopicType"]));
    }
    if (m.find("Where") != m.end() && !m["Where"].empty()) {
      where = make_shared<string>(boost::any_cast<string>(m["Where"]));
    }
  }


  virtual ~CreateRuleRequest() = default;
};
class CreateRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<long> ruleId{};
  shared_ptr<bool> success{};

  CreateRuleResponseBody() {}

  explicit CreateRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateRuleResponseBody() = default;
};
class CreateRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRuleResponseBody> body{};

  CreateRuleResponse() {}

  explicit CreateRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRuleResponse() = default;
};
class CreateRuleActionRequest : public Darabonba::Model {
public:
  shared_ptr<string> configuration{};
  shared_ptr<bool> errorActionFlag{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> type{};

  CreateRuleActionRequest() {}

  explicit CreateRuleActionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configuration) {
      res["Configuration"] = boost::any(*configuration);
    }
    if (errorActionFlag) {
      res["ErrorActionFlag"] = boost::any(*errorActionFlag);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configuration = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
    if (m.find("ErrorActionFlag") != m.end() && !m["ErrorActionFlag"].empty()) {
      errorActionFlag = make_shared<bool>(boost::any_cast<bool>(m["ErrorActionFlag"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateRuleActionRequest() = default;
};
class CreateRuleActionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> actionId{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateRuleActionResponseBody() {}

  explicit CreateRuleActionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionId) {
      res["ActionId"] = boost::any(*actionId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionId") != m.end() && !m["ActionId"].empty()) {
      actionId = make_shared<long>(boost::any_cast<long>(m["ActionId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateRuleActionResponseBody() = default;
};
class CreateRuleActionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRuleActionResponseBody> body{};

  CreateRuleActionResponse() {}

  explicit CreateRuleActionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRuleActionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRuleActionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRuleActionResponse() = default;
};
class CreateSceneRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> ruleContent{};
  shared_ptr<string> ruleDescription{};
  shared_ptr<string> ruleName{};

  CreateSceneRuleRequest() {}

  explicit CreateSceneRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleContent) {
      res["RuleContent"] = boost::any(*ruleContent);
    }
    if (ruleDescription) {
      res["RuleDescription"] = boost::any(*ruleDescription);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleContent") != m.end() && !m["RuleContent"].empty()) {
      ruleContent = make_shared<string>(boost::any_cast<string>(m["RuleContent"]));
    }
    if (m.find("RuleDescription") != m.end() && !m["RuleDescription"].empty()) {
      ruleDescription = make_shared<string>(boost::any_cast<string>(m["RuleDescription"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~CreateSceneRuleRequest() = default;
};
class CreateSceneRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> ruleId{};
  shared_ptr<bool> success{};

  CreateSceneRuleResponseBody() {}

  explicit CreateSceneRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateSceneRuleResponseBody() = default;
};
class CreateSceneRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSceneRuleResponseBody> body{};

  CreateSceneRuleResponse() {}

  explicit CreateSceneRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSceneRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSceneRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSceneRuleResponse() = default;
};
class CreateSchedulePeriodRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> endTime{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> scheduleCode{};
  shared_ptr<string> soundCodeContent{};
  shared_ptr<string> startTime{};

  CreateSchedulePeriodRequest() {}

  explicit CreateSchedulePeriodRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (scheduleCode) {
      res["ScheduleCode"] = boost::any(*scheduleCode);
    }
    if (soundCodeContent) {
      res["SoundCodeContent"] = boost::any(*soundCodeContent);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ScheduleCode") != m.end() && !m["ScheduleCode"].empty()) {
      scheduleCode = make_shared<string>(boost::any_cast<string>(m["ScheduleCode"]));
    }
    if (m.find("SoundCodeContent") != m.end() && !m["SoundCodeContent"].empty()) {
      soundCodeContent = make_shared<string>(boost::any_cast<string>(m["SoundCodeContent"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~CreateSchedulePeriodRequest() = default;
};
class CreateSchedulePeriodResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateSchedulePeriodResponseBody() {}

  explicit CreateSchedulePeriodResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateSchedulePeriodResponseBody() = default;
};
class CreateSchedulePeriodResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSchedulePeriodResponseBody> body{};

  CreateSchedulePeriodResponse() {}

  explicit CreateSchedulePeriodResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSchedulePeriodResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSchedulePeriodResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSchedulePeriodResponse() = default;
};
class CreateSharePromotionActivityRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> sharePromotionActivityName{};
  shared_ptr<long> startTime{};

  CreateSharePromotionActivityRequest() {}

  explicit CreateSharePromotionActivityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (sharePromotionActivityName) {
      res["SharePromotionActivityName"] = boost::any(*sharePromotionActivityName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("SharePromotionActivityName") != m.end() && !m["SharePromotionActivityName"].empty()) {
      sharePromotionActivityName = make_shared<string>(boost::any_cast<string>(m["SharePromotionActivityName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~CreateSharePromotionActivityRequest() = default;
};
class CreateSharePromotionActivityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateSharePromotionActivityResponseBody() {}

  explicit CreateSharePromotionActivityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateSharePromotionActivityResponseBody() = default;
};
class CreateSharePromotionActivityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSharePromotionActivityResponseBody> body{};

  CreateSharePromotionActivityResponse() {}

  explicit CreateSharePromotionActivityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSharePromotionActivityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSharePromotionActivityResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSharePromotionActivityResponse() = default;
};
class CreateSharePromotionSpeechModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> audioFormat{};
  shared_ptr<string> bizCode{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> sharePromotionActivityId{};
  shared_ptr<string> shareTaskCode{};
  shared_ptr<string> speechModelType{};
  shared_ptr<long> speechRate{};
  shared_ptr<string> text{};
  shared_ptr<string> voice{};
  shared_ptr<long> volume{};

  CreateSharePromotionSpeechModelRequest() {}

  explicit CreateSharePromotionSpeechModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFormat) {
      res["AudioFormat"] = boost::any(*audioFormat);
    }
    if (bizCode) {
      res["BizCode"] = boost::any(*bizCode);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (sharePromotionActivityId) {
      res["SharePromotionActivityId"] = boost::any(*sharePromotionActivityId);
    }
    if (shareTaskCode) {
      res["ShareTaskCode"] = boost::any(*shareTaskCode);
    }
    if (speechModelType) {
      res["SpeechModelType"] = boost::any(*speechModelType);
    }
    if (speechRate) {
      res["SpeechRate"] = boost::any(*speechRate);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (voice) {
      res["Voice"] = boost::any(*voice);
    }
    if (volume) {
      res["Volume"] = boost::any(*volume);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFormat") != m.end() && !m["AudioFormat"].empty()) {
      audioFormat = make_shared<string>(boost::any_cast<string>(m["AudioFormat"]));
    }
    if (m.find("BizCode") != m.end() && !m["BizCode"].empty()) {
      bizCode = make_shared<string>(boost::any_cast<string>(m["BizCode"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("SharePromotionActivityId") != m.end() && !m["SharePromotionActivityId"].empty()) {
      sharePromotionActivityId = make_shared<string>(boost::any_cast<string>(m["SharePromotionActivityId"]));
    }
    if (m.find("ShareTaskCode") != m.end() && !m["ShareTaskCode"].empty()) {
      shareTaskCode = make_shared<string>(boost::any_cast<string>(m["ShareTaskCode"]));
    }
    if (m.find("SpeechModelType") != m.end() && !m["SpeechModelType"].empty()) {
      speechModelType = make_shared<string>(boost::any_cast<string>(m["SpeechModelType"]));
    }
    if (m.find("SpeechRate") != m.end() && !m["SpeechRate"].empty()) {
      speechRate = make_shared<long>(boost::any_cast<long>(m["SpeechRate"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Voice") != m.end() && !m["Voice"].empty()) {
      voice = make_shared<string>(boost::any_cast<string>(m["Voice"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      volume = make_shared<long>(boost::any_cast<long>(m["Volume"]));
    }
  }


  virtual ~CreateSharePromotionSpeechModelRequest() = default;
};
class CreateSharePromotionSpeechModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateSharePromotionSpeechModelResponseBody() {}

  explicit CreateSharePromotionSpeechModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateSharePromotionSpeechModelResponseBody() = default;
};
class CreateSharePromotionSpeechModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSharePromotionSpeechModelResponseBody> body{};

  CreateSharePromotionSpeechModelResponse() {}

  explicit CreateSharePromotionSpeechModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSharePromotionSpeechModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSharePromotionSpeechModelResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSharePromotionSpeechModelResponse() = default;
};
class CreateSoundCodeRequest : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> openType{};
  shared_ptr<string> soundCodeContent{};

  CreateSoundCodeRequest() {}

  explicit CreateSoundCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (openType) {
      res["OpenType"] = boost::any(*openType);
    }
    if (soundCodeContent) {
      res["SoundCodeContent"] = boost::any(*soundCodeContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OpenType") != m.end() && !m["OpenType"].empty()) {
      openType = make_shared<string>(boost::any_cast<string>(m["OpenType"]));
    }
    if (m.find("SoundCodeContent") != m.end() && !m["SoundCodeContent"].empty()) {
      soundCodeContent = make_shared<string>(boost::any_cast<string>(m["SoundCodeContent"]));
    }
  }


  virtual ~CreateSoundCodeRequest() = default;
};
class CreateSoundCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateSoundCodeResponseBody() {}

  explicit CreateSoundCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateSoundCodeResponseBody() = default;
};
class CreateSoundCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSoundCodeResponseBody> body{};

  CreateSoundCodeResponse() {}

  explicit CreateSoundCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSoundCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSoundCodeResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSoundCodeResponse() = default;
};
class CreateSoundCodeLabelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> label{};
  shared_ptr<string> scheduleCode{};

  CreateSoundCodeLabelRequest() {}

  explicit CreateSoundCodeLabelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (scheduleCode) {
      res["ScheduleCode"] = boost::any(*scheduleCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("ScheduleCode") != m.end() && !m["ScheduleCode"].empty()) {
      scheduleCode = make_shared<string>(boost::any_cast<string>(m["ScheduleCode"]));
    }
  }


  virtual ~CreateSoundCodeLabelRequest() = default;
};
class CreateSoundCodeLabelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateSoundCodeLabelResponseBody() {}

  explicit CreateSoundCodeLabelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateSoundCodeLabelResponseBody() = default;
};
class CreateSoundCodeLabelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSoundCodeLabelResponseBody> body{};

  CreateSoundCodeLabelResponse() {}

  explicit CreateSoundCodeLabelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSoundCodeLabelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSoundCodeLabelResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSoundCodeLabelResponse() = default;
};
class CreateSoundCodeScheduleRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> endDate{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> openType{};
  shared_ptr<string> startDate{};

  CreateSoundCodeScheduleRequest() {}

  explicit CreateSoundCodeScheduleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (openType) {
      res["OpenType"] = boost::any(*openType);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OpenType") != m.end() && !m["OpenType"].empty()) {
      openType = make_shared<string>(boost::any_cast<string>(m["OpenType"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
  }


  virtual ~CreateSoundCodeScheduleRequest() = default;
};
class CreateSoundCodeScheduleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateSoundCodeScheduleResponseBody() {}

  explicit CreateSoundCodeScheduleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateSoundCodeScheduleResponseBody() = default;
};
class CreateSoundCodeScheduleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSoundCodeScheduleResponseBody> body{};

  CreateSoundCodeScheduleResponse() {}

  explicit CreateSoundCodeScheduleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSoundCodeScheduleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSoundCodeScheduleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSoundCodeScheduleResponse() = default;
};
class CreateSpeechRequest : public Darabonba::Model {
public:
  shared_ptr<string> audioFormat{};
  shared_ptr<string> bizCode{};
  shared_ptr<bool> enableSoundCode{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> projectCode{};
  shared_ptr<map<string, boost::any>> soundCodeConfig{};
  shared_ptr<long> speechRate{};
  shared_ptr<string> speechType{};
  shared_ptr<string> text{};
  shared_ptr<string> voice{};
  shared_ptr<long> volume{};

  CreateSpeechRequest() {}

  explicit CreateSpeechRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFormat) {
      res["AudioFormat"] = boost::any(*audioFormat);
    }
    if (bizCode) {
      res["BizCode"] = boost::any(*bizCode);
    }
    if (enableSoundCode) {
      res["EnableSoundCode"] = boost::any(*enableSoundCode);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (projectCode) {
      res["ProjectCode"] = boost::any(*projectCode);
    }
    if (soundCodeConfig) {
      res["SoundCodeConfig"] = boost::any(*soundCodeConfig);
    }
    if (speechRate) {
      res["SpeechRate"] = boost::any(*speechRate);
    }
    if (speechType) {
      res["SpeechType"] = boost::any(*speechType);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (voice) {
      res["Voice"] = boost::any(*voice);
    }
    if (volume) {
      res["Volume"] = boost::any(*volume);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFormat") != m.end() && !m["AudioFormat"].empty()) {
      audioFormat = make_shared<string>(boost::any_cast<string>(m["AudioFormat"]));
    }
    if (m.find("BizCode") != m.end() && !m["BizCode"].empty()) {
      bizCode = make_shared<string>(boost::any_cast<string>(m["BizCode"]));
    }
    if (m.find("EnableSoundCode") != m.end() && !m["EnableSoundCode"].empty()) {
      enableSoundCode = make_shared<bool>(boost::any_cast<bool>(m["EnableSoundCode"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProjectCode") != m.end() && !m["ProjectCode"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["ProjectCode"]));
    }
    if (m.find("SoundCodeConfig") != m.end() && !m["SoundCodeConfig"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["SoundCodeConfig"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      soundCodeConfig = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("SpeechRate") != m.end() && !m["SpeechRate"].empty()) {
      speechRate = make_shared<long>(boost::any_cast<long>(m["SpeechRate"]));
    }
    if (m.find("SpeechType") != m.end() && !m["SpeechType"].empty()) {
      speechType = make_shared<string>(boost::any_cast<string>(m["SpeechType"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Voice") != m.end() && !m["Voice"].empty()) {
      voice = make_shared<string>(boost::any_cast<string>(m["Voice"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      volume = make_shared<long>(boost::any_cast<long>(m["Volume"]));
    }
  }


  virtual ~CreateSpeechRequest() = default;
};
class CreateSpeechShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> audioFormat{};
  shared_ptr<string> bizCode{};
  shared_ptr<bool> enableSoundCode{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> soundCodeConfigShrink{};
  shared_ptr<long> speechRate{};
  shared_ptr<string> speechType{};
  shared_ptr<string> text{};
  shared_ptr<string> voice{};
  shared_ptr<long> volume{};

  CreateSpeechShrinkRequest() {}

  explicit CreateSpeechShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFormat) {
      res["AudioFormat"] = boost::any(*audioFormat);
    }
    if (bizCode) {
      res["BizCode"] = boost::any(*bizCode);
    }
    if (enableSoundCode) {
      res["EnableSoundCode"] = boost::any(*enableSoundCode);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (projectCode) {
      res["ProjectCode"] = boost::any(*projectCode);
    }
    if (soundCodeConfigShrink) {
      res["SoundCodeConfig"] = boost::any(*soundCodeConfigShrink);
    }
    if (speechRate) {
      res["SpeechRate"] = boost::any(*speechRate);
    }
    if (speechType) {
      res["SpeechType"] = boost::any(*speechType);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (voice) {
      res["Voice"] = boost::any(*voice);
    }
    if (volume) {
      res["Volume"] = boost::any(*volume);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFormat") != m.end() && !m["AudioFormat"].empty()) {
      audioFormat = make_shared<string>(boost::any_cast<string>(m["AudioFormat"]));
    }
    if (m.find("BizCode") != m.end() && !m["BizCode"].empty()) {
      bizCode = make_shared<string>(boost::any_cast<string>(m["BizCode"]));
    }
    if (m.find("EnableSoundCode") != m.end() && !m["EnableSoundCode"].empty()) {
      enableSoundCode = make_shared<bool>(boost::any_cast<bool>(m["EnableSoundCode"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProjectCode") != m.end() && !m["ProjectCode"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["ProjectCode"]));
    }
    if (m.find("SoundCodeConfig") != m.end() && !m["SoundCodeConfig"].empty()) {
      soundCodeConfigShrink = make_shared<string>(boost::any_cast<string>(m["SoundCodeConfig"]));
    }
    if (m.find("SpeechRate") != m.end() && !m["SpeechRate"].empty()) {
      speechRate = make_shared<long>(boost::any_cast<long>(m["SpeechRate"]));
    }
    if (m.find("SpeechType") != m.end() && !m["SpeechType"].empty()) {
      speechType = make_shared<string>(boost::any_cast<string>(m["SpeechType"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Voice") != m.end() && !m["Voice"].empty()) {
      voice = make_shared<string>(boost::any_cast<string>(m["Voice"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      volume = make_shared<long>(boost::any_cast<long>(m["Volume"]));
    }
  }


  virtual ~CreateSpeechShrinkRequest() = default;
};
class CreateSpeechResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateSpeechResponseBody() {}

  explicit CreateSpeechResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateSpeechResponseBody() = default;
};
class CreateSpeechResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSpeechResponseBody> body{};

  CreateSpeechResponse() {}

  explicit CreateSpeechResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSpeechResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSpeechResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSpeechResponse() = default;
};
class CreateStudioAppDomainOpenRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> host{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> protocol{};

  CreateStudioAppDomainOpenRequest() {}

  explicit CreateStudioAppDomainOpenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~CreateStudioAppDomainOpenRequest() = default;
};
class CreateStudioAppDomainOpenResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> host{};
  shared_ptr<long> id{};
  shared_ptr<string> isBeian{};
  shared_ptr<string> projectId{};
  shared_ptr<string> protocol{};
  shared_ptr<string> tenantId{};

  CreateStudioAppDomainOpenResponseBodyData() {}

  explicit CreateStudioAppDomainOpenResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isBeian) {
      res["IsBeian"] = boost::any(*isBeian);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsBeian") != m.end() && !m["IsBeian"].empty()) {
      isBeian = make_shared<string>(boost::any_cast<string>(m["IsBeian"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~CreateStudioAppDomainOpenResponseBodyData() = default;
};
class CreateStudioAppDomainOpenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateStudioAppDomainOpenResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateStudioAppDomainOpenResponseBody() {}

  explicit CreateStudioAppDomainOpenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateStudioAppDomainOpenResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateStudioAppDomainOpenResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateStudioAppDomainOpenResponseBody() = default;
};
class CreateStudioAppDomainOpenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateStudioAppDomainOpenResponseBody> body{};

  CreateStudioAppDomainOpenResponse() {}

  explicit CreateStudioAppDomainOpenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateStudioAppDomainOpenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateStudioAppDomainOpenResponseBody>(model1);
      }
    }
  }


  virtual ~CreateStudioAppDomainOpenResponse() = default;
};
class CreateSubscribeRelationRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> consumerGroupIds{};
  shared_ptr<bool> deviceDataFlag{};
  shared_ptr<bool> deviceLifeCycleFlag{};
  shared_ptr<bool> deviceStatusChangeFlag{};
  shared_ptr<bool> deviceTagFlag{};
  shared_ptr<bool> deviceTopoLifeCycleFlag{};
  shared_ptr<bool> foundDeviceListFlag{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> mnsConfiguration{};
  shared_ptr<bool> otaEventFlag{};
  shared_ptr<bool> otaJobFlag{};
  shared_ptr<bool> otaVersionFlag{};
  shared_ptr<string> productKey{};
  shared_ptr<string> subscribeFlags{};
  shared_ptr<bool> thingHistoryFlag{};
  shared_ptr<string> type{};

  CreateSubscribeRelationRequest() {}

  explicit CreateSubscribeRelationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consumerGroupIds) {
      res["ConsumerGroupIds"] = boost::any(*consumerGroupIds);
    }
    if (deviceDataFlag) {
      res["DeviceDataFlag"] = boost::any(*deviceDataFlag);
    }
    if (deviceLifeCycleFlag) {
      res["DeviceLifeCycleFlag"] = boost::any(*deviceLifeCycleFlag);
    }
    if (deviceStatusChangeFlag) {
      res["DeviceStatusChangeFlag"] = boost::any(*deviceStatusChangeFlag);
    }
    if (deviceTagFlag) {
      res["DeviceTagFlag"] = boost::any(*deviceTagFlag);
    }
    if (deviceTopoLifeCycleFlag) {
      res["DeviceTopoLifeCycleFlag"] = boost::any(*deviceTopoLifeCycleFlag);
    }
    if (foundDeviceListFlag) {
      res["FoundDeviceListFlag"] = boost::any(*foundDeviceListFlag);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (mnsConfiguration) {
      res["MnsConfiguration"] = boost::any(*mnsConfiguration);
    }
    if (otaEventFlag) {
      res["OtaEventFlag"] = boost::any(*otaEventFlag);
    }
    if (otaJobFlag) {
      res["OtaJobFlag"] = boost::any(*otaJobFlag);
    }
    if (otaVersionFlag) {
      res["OtaVersionFlag"] = boost::any(*otaVersionFlag);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (subscribeFlags) {
      res["SubscribeFlags"] = boost::any(*subscribeFlags);
    }
    if (thingHistoryFlag) {
      res["ThingHistoryFlag"] = boost::any(*thingHistoryFlag);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsumerGroupIds") != m.end() && !m["ConsumerGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ConsumerGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ConsumerGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      consumerGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DeviceDataFlag") != m.end() && !m["DeviceDataFlag"].empty()) {
      deviceDataFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceDataFlag"]));
    }
    if (m.find("DeviceLifeCycleFlag") != m.end() && !m["DeviceLifeCycleFlag"].empty()) {
      deviceLifeCycleFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceLifeCycleFlag"]));
    }
    if (m.find("DeviceStatusChangeFlag") != m.end() && !m["DeviceStatusChangeFlag"].empty()) {
      deviceStatusChangeFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceStatusChangeFlag"]));
    }
    if (m.find("DeviceTagFlag") != m.end() && !m["DeviceTagFlag"].empty()) {
      deviceTagFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceTagFlag"]));
    }
    if (m.find("DeviceTopoLifeCycleFlag") != m.end() && !m["DeviceTopoLifeCycleFlag"].empty()) {
      deviceTopoLifeCycleFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceTopoLifeCycleFlag"]));
    }
    if (m.find("FoundDeviceListFlag") != m.end() && !m["FoundDeviceListFlag"].empty()) {
      foundDeviceListFlag = make_shared<bool>(boost::any_cast<bool>(m["FoundDeviceListFlag"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("MnsConfiguration") != m.end() && !m["MnsConfiguration"].empty()) {
      mnsConfiguration = make_shared<string>(boost::any_cast<string>(m["MnsConfiguration"]));
    }
    if (m.find("OtaEventFlag") != m.end() && !m["OtaEventFlag"].empty()) {
      otaEventFlag = make_shared<bool>(boost::any_cast<bool>(m["OtaEventFlag"]));
    }
    if (m.find("OtaJobFlag") != m.end() && !m["OtaJobFlag"].empty()) {
      otaJobFlag = make_shared<bool>(boost::any_cast<bool>(m["OtaJobFlag"]));
    }
    if (m.find("OtaVersionFlag") != m.end() && !m["OtaVersionFlag"].empty()) {
      otaVersionFlag = make_shared<bool>(boost::any_cast<bool>(m["OtaVersionFlag"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("SubscribeFlags") != m.end() && !m["SubscribeFlags"].empty()) {
      subscribeFlags = make_shared<string>(boost::any_cast<string>(m["SubscribeFlags"]));
    }
    if (m.find("ThingHistoryFlag") != m.end() && !m["ThingHistoryFlag"].empty()) {
      thingHistoryFlag = make_shared<bool>(boost::any_cast<bool>(m["ThingHistoryFlag"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateSubscribeRelationRequest() = default;
};
class CreateSubscribeRelationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateSubscribeRelationResponseBody() {}

  explicit CreateSubscribeRelationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateSubscribeRelationResponseBody() = default;
};
class CreateSubscribeRelationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSubscribeRelationResponseBody> body{};

  CreateSubscribeRelationResponse() {}

  explicit CreateSubscribeRelationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSubscribeRelationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSubscribeRelationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSubscribeRelationResponse() = default;
};
class CreateThingModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> functionBlockId{};
  shared_ptr<string> functionBlockName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> thingModelJson{};

  CreateThingModelRequest() {}

  explicit CreateThingModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    if (functionBlockName) {
      res["FunctionBlockName"] = boost::any(*functionBlockName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (thingModelJson) {
      res["ThingModelJson"] = boost::any(*thingModelJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
    if (m.find("FunctionBlockName") != m.end() && !m["FunctionBlockName"].empty()) {
      functionBlockName = make_shared<string>(boost::any_cast<string>(m["FunctionBlockName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ThingModelJson") != m.end() && !m["ThingModelJson"].empty()) {
      thingModelJson = make_shared<string>(boost::any_cast<string>(m["ThingModelJson"]));
    }
  }


  virtual ~CreateThingModelRequest() = default;
};
class CreateThingModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateThingModelResponseBody() {}

  explicit CreateThingModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateThingModelResponseBody() = default;
};
class CreateThingModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateThingModelResponseBody> body{};

  CreateThingModelResponse() {}

  explicit CreateThingModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateThingModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateThingModelResponseBody>(model1);
      }
    }
  }


  virtual ~CreateThingModelResponse() = default;
};
class CreateThingScriptRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> scriptContent{};
  shared_ptr<string> scriptType{};

  CreateThingScriptRequest() {}

  explicit CreateThingScriptRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (scriptContent) {
      res["ScriptContent"] = boost::any(*scriptContent);
    }
    if (scriptType) {
      res["ScriptType"] = boost::any(*scriptType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ScriptContent") != m.end() && !m["ScriptContent"].empty()) {
      scriptContent = make_shared<string>(boost::any_cast<string>(m["ScriptContent"]));
    }
    if (m.find("ScriptType") != m.end() && !m["ScriptType"].empty()) {
      scriptType = make_shared<string>(boost::any_cast<string>(m["ScriptType"]));
    }
  }


  virtual ~CreateThingScriptRequest() = default;
};
class CreateThingScriptResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateThingScriptResponseBody() {}

  explicit CreateThingScriptResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateThingScriptResponseBody() = default;
};
class CreateThingScriptResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateThingScriptResponseBody> body{};

  CreateThingScriptResponse() {}

  explicit CreateThingScriptResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateThingScriptResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateThingScriptResponseBody>(model1);
      }
    }
  }


  virtual ~CreateThingScriptResponse() = default;
};
class CreateTopicConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> codec{};
  shared_ptr<string> description{};
  shared_ptr<bool> enableBroadcast{};
  shared_ptr<bool> enableProxySubscribe{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> operation{};
  shared_ptr<string> productKey{};
  shared_ptr<string> topicFullName{};

  CreateTopicConfigRequest() {}

  explicit CreateTopicConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enableBroadcast) {
      res["EnableBroadcast"] = boost::any(*enableBroadcast);
    }
    if (enableProxySubscribe) {
      res["EnableProxySubscribe"] = boost::any(*enableProxySubscribe);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (topicFullName) {
      res["TopicFullName"] = boost::any(*topicFullName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnableBroadcast") != m.end() && !m["EnableBroadcast"].empty()) {
      enableBroadcast = make_shared<bool>(boost::any_cast<bool>(m["EnableBroadcast"]));
    }
    if (m.find("EnableProxySubscribe") != m.end() && !m["EnableProxySubscribe"].empty()) {
      enableProxySubscribe = make_shared<bool>(boost::any_cast<bool>(m["EnableProxySubscribe"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("TopicFullName") != m.end() && !m["TopicFullName"].empty()) {
      topicFullName = make_shared<string>(boost::any_cast<string>(m["TopicFullName"]));
    }
  }


  virtual ~CreateTopicConfigRequest() = default;
};
class CreateTopicConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateTopicConfigResponseBody() {}

  explicit CreateTopicConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateTopicConfigResponseBody() = default;
};
class CreateTopicConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTopicConfigResponseBody> body{};

  CreateTopicConfigResponse() {}

  explicit CreateTopicConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTopicConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTopicConfigResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTopicConfigResponse() = default;
};
class CreateTopicRouteTableRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dstTopic{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> srcTopic{};

  CreateTopicRouteTableRequest() {}

  explicit CreateTopicRouteTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dstTopic) {
      res["DstTopic"] = boost::any(*dstTopic);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (srcTopic) {
      res["SrcTopic"] = boost::any(*srcTopic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DstTopic") != m.end() && !m["DstTopic"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DstTopic"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DstTopic"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dstTopic = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("SrcTopic") != m.end() && !m["SrcTopic"].empty()) {
      srcTopic = make_shared<string>(boost::any_cast<string>(m["SrcTopic"]));
    }
  }


  virtual ~CreateTopicRouteTableRequest() = default;
};
class CreateTopicRouteTableResponseBodyFailureTopics : public Darabonba::Model {
public:
  shared_ptr<vector<map<string, boost::any>>> topic{};

  CreateTopicRouteTableResponseBodyFailureTopics() {}

  explicit CreateTopicRouteTableResponseBodyFailureTopics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Topic"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Topic"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      topic = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
  }


  virtual ~CreateTopicRouteTableResponseBodyFailureTopics() = default;
};
class CreateTopicRouteTableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<CreateTopicRouteTableResponseBodyFailureTopics> failureTopics{};
  shared_ptr<bool> isAllSucceed{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateTopicRouteTableResponseBody() {}

  explicit CreateTopicRouteTableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (failureTopics) {
      res["FailureTopics"] = failureTopics ? boost::any(failureTopics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isAllSucceed) {
      res["IsAllSucceed"] = boost::any(*isAllSucceed);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("FailureTopics") != m.end() && !m["FailureTopics"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailureTopics"].type()) {
        CreateTopicRouteTableResponseBodyFailureTopics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailureTopics"]));
        failureTopics = make_shared<CreateTopicRouteTableResponseBodyFailureTopics>(model1);
      }
    }
    if (m.find("IsAllSucceed") != m.end() && !m["IsAllSucceed"].empty()) {
      isAllSucceed = make_shared<bool>(boost::any_cast<bool>(m["IsAllSucceed"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateTopicRouteTableResponseBody() = default;
};
class CreateTopicRouteTableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTopicRouteTableResponseBody> body{};

  CreateTopicRouteTableResponse() {}

  explicit CreateTopicRouteTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTopicRouteTableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTopicRouteTableResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTopicRouteTableResponse() = default;
};
class DeleteClientIdsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};

  DeleteClientIdsRequest() {}

  explicit DeleteClientIdsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~DeleteClientIdsRequest() = default;
};
class DeleteClientIdsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteClientIdsResponseBody() {}

  explicit DeleteClientIdsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteClientIdsResponseBody() = default;
};
class DeleteClientIdsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteClientIdsResponseBody> body{};

  DeleteClientIdsResponse() {}

  explicit DeleteClientIdsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteClientIdsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteClientIdsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteClientIdsResponse() = default;
};
class DeleteConsumerGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> iotInstanceId{};

  DeleteConsumerGroupRequest() {}

  explicit DeleteConsumerGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~DeleteConsumerGroupRequest() = default;
};
class DeleteConsumerGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteConsumerGroupResponseBody() {}

  explicit DeleteConsumerGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteConsumerGroupResponseBody() = default;
};
class DeleteConsumerGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteConsumerGroupResponseBody> body{};

  DeleteConsumerGroupResponse() {}

  explicit DeleteConsumerGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteConsumerGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteConsumerGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteConsumerGroupResponse() = default;
};
class DeleteConsumerGroupSubscribeRelationRequest : public Darabonba::Model {
public:
  shared_ptr<string> consumerGroupId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  DeleteConsumerGroupSubscribeRelationRequest() {}

  explicit DeleteConsumerGroupSubscribeRelationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consumerGroupId) {
      res["ConsumerGroupId"] = boost::any(*consumerGroupId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsumerGroupId") != m.end() && !m["ConsumerGroupId"].empty()) {
      consumerGroupId = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~DeleteConsumerGroupSubscribeRelationRequest() = default;
};
class DeleteConsumerGroupSubscribeRelationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteConsumerGroupSubscribeRelationResponseBody() {}

  explicit DeleteConsumerGroupSubscribeRelationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteConsumerGroupSubscribeRelationResponseBody() = default;
};
class DeleteConsumerGroupSubscribeRelationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteConsumerGroupSubscribeRelationResponseBody> body{};

  DeleteConsumerGroupSubscribeRelationResponse() {}

  explicit DeleteConsumerGroupSubscribeRelationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteConsumerGroupSubscribeRelationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteConsumerGroupSubscribeRelationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteConsumerGroupSubscribeRelationResponse() = default;
};
class DeleteDataSourceItemRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataSourceId{};
  shared_ptr<long> dataSourceItemId{};
  shared_ptr<string> iotInstanceId{};

  DeleteDataSourceItemRequest() {}

  explicit DeleteDataSourceItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (dataSourceItemId) {
      res["DataSourceItemId"] = boost::any(*dataSourceItemId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("DataSourceItemId") != m.end() && !m["DataSourceItemId"].empty()) {
      dataSourceItemId = make_shared<long>(boost::any_cast<long>(m["DataSourceItemId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~DeleteDataSourceItemRequest() = default;
};
class DeleteDataSourceItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDataSourceItemResponseBody() {}

  explicit DeleteDataSourceItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDataSourceItemResponseBody() = default;
};
class DeleteDataSourceItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDataSourceItemResponseBody> body{};

  DeleteDataSourceItemResponse() {}

  explicit DeleteDataSourceItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDataSourceItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDataSourceItemResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDataSourceItemResponse() = default;
};
class DeleteDestinationRequest : public Darabonba::Model {
public:
  shared_ptr<long> destinationId{};
  shared_ptr<string> iotInstanceId{};

  DeleteDestinationRequest() {}

  explicit DeleteDestinationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationId) {
      res["DestinationId"] = boost::any(*destinationId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationId") != m.end() && !m["DestinationId"].empty()) {
      destinationId = make_shared<long>(boost::any_cast<long>(m["DestinationId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~DeleteDestinationRequest() = default;
};
class DeleteDestinationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDestinationResponseBody() {}

  explicit DeleteDestinationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDestinationResponseBody() = default;
};
class DeleteDestinationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDestinationResponseBody> body{};

  DeleteDestinationResponse() {}

  explicit DeleteDestinationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDestinationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDestinationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDestinationResponse() = default;
};
class DeleteDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  DeleteDeviceRequest() {}

  explicit DeleteDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~DeleteDeviceRequest() = default;
};
class DeleteDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDeviceResponseBody() {}

  explicit DeleteDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDeviceResponseBody() = default;
};
class DeleteDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDeviceResponseBody> body{};

  DeleteDeviceResponse() {}

  explicit DeleteDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDeviceResponse() = default;
};
class DeleteDeviceDistributeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  DeleteDeviceDistributeJobRequest() {}

  explicit DeleteDeviceDistributeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~DeleteDeviceDistributeJobRequest() = default;
};
class DeleteDeviceDistributeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDeviceDistributeJobResponseBody() {}

  explicit DeleteDeviceDistributeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDeviceDistributeJobResponseBody() = default;
};
class DeleteDeviceDistributeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDeviceDistributeJobResponseBody> body{};

  DeleteDeviceDistributeJobResponse() {}

  explicit DeleteDeviceDistributeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDeviceDistributeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDeviceDistributeJobResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDeviceDistributeJobResponse() = default;
};
class DeleteDeviceDynamicGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> iotInstanceId{};

  DeleteDeviceDynamicGroupRequest() {}

  explicit DeleteDeviceDynamicGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~DeleteDeviceDynamicGroupRequest() = default;
};
class DeleteDeviceDynamicGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDeviceDynamicGroupResponseBody() {}

  explicit DeleteDeviceDynamicGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDeviceDynamicGroupResponseBody() = default;
};
class DeleteDeviceDynamicGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDeviceDynamicGroupResponseBody> body{};

  DeleteDeviceDynamicGroupResponse() {}

  explicit DeleteDeviceDynamicGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDeviceDynamicGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDeviceDynamicGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDeviceDynamicGroupResponse() = default;
};
class DeleteDeviceFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> fileId{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  DeleteDeviceFileRequest() {}

  explicit DeleteDeviceFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~DeleteDeviceFileRequest() = default;
};
class DeleteDeviceFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDeviceFileResponseBody() {}

  explicit DeleteDeviceFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDeviceFileResponseBody() = default;
};
class DeleteDeviceFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDeviceFileResponseBody> body{};

  DeleteDeviceFileResponse() {}

  explicit DeleteDeviceFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDeviceFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDeviceFileResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDeviceFileResponse() = default;
};
class DeleteDeviceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> iotInstanceId{};

  DeleteDeviceGroupRequest() {}

  explicit DeleteDeviceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~DeleteDeviceGroupRequest() = default;
};
class DeleteDeviceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDeviceGroupResponseBody() {}

  explicit DeleteDeviceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDeviceGroupResponseBody() = default;
};
class DeleteDeviceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDeviceGroupResponseBody> body{};

  DeleteDeviceGroupResponse() {}

  explicit DeleteDeviceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDeviceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDeviceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDeviceGroupResponse() = default;
};
class DeleteDevicePropRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> propKey{};

  DeleteDevicePropRequest() {}

  explicit DeleteDevicePropRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (propKey) {
      res["PropKey"] = boost::any(*propKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("PropKey") != m.end() && !m["PropKey"].empty()) {
      propKey = make_shared<string>(boost::any_cast<string>(m["PropKey"]));
    }
  }


  virtual ~DeleteDevicePropRequest() = default;
};
class DeleteDevicePropResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDevicePropResponseBody() {}

  explicit DeleteDevicePropResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDevicePropResponseBody() = default;
};
class DeleteDevicePropResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDevicePropResponseBody> body{};

  DeleteDevicePropResponse() {}

  explicit DeleteDevicePropResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDevicePropResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDevicePropResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDevicePropResponse() = default;
};
class DeleteDeviceSpeechRequestDeviceSpeechList : public Darabonba::Model {
public:
  shared_ptr<string> audioFormat{};
  shared_ptr<string> bizCode{};

  DeleteDeviceSpeechRequestDeviceSpeechList() {}

  explicit DeleteDeviceSpeechRequestDeviceSpeechList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFormat) {
      res["AudioFormat"] = boost::any(*audioFormat);
    }
    if (bizCode) {
      res["BizCode"] = boost::any(*bizCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFormat") != m.end() && !m["AudioFormat"].empty()) {
      audioFormat = make_shared<string>(boost::any_cast<string>(m["AudioFormat"]));
    }
    if (m.find("BizCode") != m.end() && !m["BizCode"].empty()) {
      bizCode = make_shared<string>(boost::any_cast<string>(m["BizCode"]));
    }
  }


  virtual ~DeleteDeviceSpeechRequestDeviceSpeechList() = default;
};
class DeleteDeviceSpeechRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteDeviceSpeechRequestDeviceSpeechList>> deviceSpeechList{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};

  DeleteDeviceSpeechRequest() {}

  explicit DeleteDeviceSpeechRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceSpeechList) {
      vector<boost::any> temp1;
      for(auto item1:*deviceSpeechList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceSpeechList"] = boost::any(temp1);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceSpeechList") != m.end() && !m["DeviceSpeechList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceSpeechList"].type()) {
        vector<DeleteDeviceSpeechRequestDeviceSpeechList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceSpeechList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteDeviceSpeechRequestDeviceSpeechList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceSpeechList = make_shared<vector<DeleteDeviceSpeechRequestDeviceSpeechList>>(expect1);
      }
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~DeleteDeviceSpeechRequest() = default;
};
class DeleteDeviceSpeechResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDeviceSpeechResponseBody() {}

  explicit DeleteDeviceSpeechResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDeviceSpeechResponseBody() = default;
};
class DeleteDeviceSpeechResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDeviceSpeechResponseBody> body{};

  DeleteDeviceSpeechResponse() {}

  explicit DeleteDeviceSpeechResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDeviceSpeechResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDeviceSpeechResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDeviceSpeechResponse() = default;
};
class DeleteDeviceTunnelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> tunnelId{};

  DeleteDeviceTunnelRequest() {}

  explicit DeleteDeviceTunnelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (tunnelId) {
      res["TunnelId"] = boost::any(*tunnelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("TunnelId") != m.end() && !m["TunnelId"].empty()) {
      tunnelId = make_shared<string>(boost::any_cast<string>(m["TunnelId"]));
    }
  }


  virtual ~DeleteDeviceTunnelRequest() = default;
};
class DeleteDeviceTunnelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDeviceTunnelResponseBody() {}

  explicit DeleteDeviceTunnelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDeviceTunnelResponseBody() = default;
};
class DeleteDeviceTunnelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDeviceTunnelResponseBody> body{};

  DeleteDeviceTunnelResponse() {}

  explicit DeleteDeviceTunnelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDeviceTunnelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDeviceTunnelResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDeviceTunnelResponse() = default;
};
class DeleteEdgeDriverRequest : public Darabonba::Model {
public:
  shared_ptr<string> driverId{};
  shared_ptr<string> iotInstanceId{};

  DeleteEdgeDriverRequest() {}

  explicit DeleteEdgeDriverRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~DeleteEdgeDriverRequest() = default;
};
class DeleteEdgeDriverResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteEdgeDriverResponseBody() {}

  explicit DeleteEdgeDriverResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteEdgeDriverResponseBody() = default;
};
class DeleteEdgeDriverResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEdgeDriverResponseBody> body{};

  DeleteEdgeDriverResponse() {}

  explicit DeleteEdgeDriverResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEdgeDriverResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEdgeDriverResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEdgeDriverResponse() = default;
};
class DeleteEdgeDriverVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};
  shared_ptr<string> iotInstanceId{};

  DeleteEdgeDriverVersionRequest() {}

  explicit DeleteEdgeDriverVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~DeleteEdgeDriverVersionRequest() = default;
};
class DeleteEdgeDriverVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteEdgeDriverVersionResponseBody() {}

  explicit DeleteEdgeDriverVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteEdgeDriverVersionResponseBody() = default;
};
class DeleteEdgeDriverVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEdgeDriverVersionResponseBody> body{};

  DeleteEdgeDriverVersionResponse() {}

  explicit DeleteEdgeDriverVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEdgeDriverVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEdgeDriverVersionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEdgeDriverVersionResponse() = default;
};
class DeleteEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};

  DeleteEdgeInstanceRequest() {}

  explicit DeleteEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~DeleteEdgeInstanceRequest() = default;
};
class DeleteEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteEdgeInstanceResponseBody() {}

  explicit DeleteEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteEdgeInstanceResponseBody() = default;
};
class DeleteEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEdgeInstanceResponseBody> body{};

  DeleteEdgeInstanceResponse() {}

  explicit DeleteEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEdgeInstanceResponse() = default;
};
class DeleteEdgeInstanceMessageRoutingRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> routeId{};

  DeleteEdgeInstanceMessageRoutingRequest() {}

  explicit DeleteEdgeInstanceMessageRoutingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<long>(boost::any_cast<long>(m["RouteId"]));
    }
  }


  virtual ~DeleteEdgeInstanceMessageRoutingRequest() = default;
};
class DeleteEdgeInstanceMessageRoutingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteEdgeInstanceMessageRoutingResponseBody() {}

  explicit DeleteEdgeInstanceMessageRoutingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteEdgeInstanceMessageRoutingResponseBody() = default;
};
class DeleteEdgeInstanceMessageRoutingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEdgeInstanceMessageRoutingResponseBody> body{};

  DeleteEdgeInstanceMessageRoutingResponse() {}

  explicit DeleteEdgeInstanceMessageRoutingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEdgeInstanceMessageRoutingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEdgeInstanceMessageRoutingResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEdgeInstanceMessageRoutingResponse() = default;
};
class DeleteJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobId{};

  DeleteJobRequest() {}

  explicit DeleteJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~DeleteJobRequest() = default;
};
class DeleteJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteJobResponseBody() {}

  explicit DeleteJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteJobResponseBody() = default;
};
class DeleteJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteJobResponseBody> body{};

  DeleteJobResponse() {}

  explicit DeleteJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteJobResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteJobResponse() = default;
};
class DeleteOTAFirmwareRequest : public Darabonba::Model {
public:
  shared_ptr<string> firmwareId{};
  shared_ptr<string> iotInstanceId{};

  DeleteOTAFirmwareRequest() {}

  explicit DeleteOTAFirmwareRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~DeleteOTAFirmwareRequest() = default;
};
class DeleteOTAFirmwareResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteOTAFirmwareResponseBody() {}

  explicit DeleteOTAFirmwareResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteOTAFirmwareResponseBody() = default;
};
class DeleteOTAFirmwareResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteOTAFirmwareResponseBody> body{};

  DeleteOTAFirmwareResponse() {}

  explicit DeleteOTAFirmwareResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteOTAFirmwareResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteOTAFirmwareResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteOTAFirmwareResponse() = default;
};
class DeleteOTAModuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> moduleName{};
  shared_ptr<string> productKey{};

  DeleteOTAModuleRequest() {}

  explicit DeleteOTAModuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~DeleteOTAModuleRequest() = default;
};
class DeleteOTAModuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteOTAModuleResponseBody() {}

  explicit DeleteOTAModuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteOTAModuleResponseBody() = default;
};
class DeleteOTAModuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteOTAModuleResponseBody> body{};

  DeleteOTAModuleResponse() {}

  explicit DeleteOTAModuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteOTAModuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteOTAModuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteOTAModuleResponse() = default;
};
class DeleteParserRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> parserId{};

  DeleteParserRequest() {}

  explicit DeleteParserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (parserId) {
      res["ParserId"] = boost::any(*parserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ParserId") != m.end() && !m["ParserId"].empty()) {
      parserId = make_shared<long>(boost::any_cast<long>(m["ParserId"]));
    }
  }


  virtual ~DeleteParserRequest() = default;
};
class DeleteParserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteParserResponseBody() {}

  explicit DeleteParserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteParserResponseBody() = default;
};
class DeleteParserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteParserResponseBody> body{};

  DeleteParserResponse() {}

  explicit DeleteParserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteParserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteParserResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteParserResponse() = default;
};
class DeleteParserDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> iotInstanceId{};

  DeleteParserDataSourceRequest() {}

  explicit DeleteParserDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~DeleteParserDataSourceRequest() = default;
};
class DeleteParserDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteParserDataSourceResponseBody() {}

  explicit DeleteParserDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteParserDataSourceResponseBody() = default;
};
class DeleteParserDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteParserDataSourceResponseBody> body{};

  DeleteParserDataSourceResponse() {}

  explicit DeleteParserDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteParserDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteParserDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteParserDataSourceResponse() = default;
};
class DeleteProductRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  DeleteProductRequest() {}

  explicit DeleteProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~DeleteProductRequest() = default;
};
class DeleteProductResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteProductResponseBody() {}

  explicit DeleteProductResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteProductResponseBody() = default;
};
class DeleteProductResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteProductResponseBody> body{};

  DeleteProductResponse() {}

  explicit DeleteProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteProductResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteProductResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteProductResponse() = default;
};
class DeleteProductTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<vector<string>> productTagKey{};

  DeleteProductTagsRequest() {}

  explicit DeleteProductTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productTagKey) {
      res["ProductTagKey"] = boost::any(*productTagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductTagKey") != m.end() && !m["ProductTagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProductTagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProductTagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      productTagKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteProductTagsRequest() = default;
};
class DeleteProductTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteProductTagsResponseBody() {}

  explicit DeleteProductTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteProductTagsResponseBody() = default;
};
class DeleteProductTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteProductTagsResponseBody> body{};

  DeleteProductTagsResponse() {}

  explicit DeleteProductTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteProductTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteProductTagsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteProductTagsResponse() = default;
};
class DeleteProductTopicRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> topicId{};

  DeleteProductTopicRequest() {}

  explicit DeleteProductTopicRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<string>(boost::any_cast<string>(m["TopicId"]));
    }
  }


  virtual ~DeleteProductTopicRequest() = default;
};
class DeleteProductTopicResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteProductTopicResponseBody() {}

  explicit DeleteProductTopicResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteProductTopicResponseBody() = default;
};
class DeleteProductTopicResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteProductTopicResponseBody> body{};

  DeleteProductTopicResponse() {}

  explicit DeleteProductTopicResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteProductTopicResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteProductTopicResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteProductTopicResponse() = default;
};
class DeleteRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> ruleId{};

  DeleteRuleRequest() {}

  explicit DeleteRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~DeleteRuleRequest() = default;
};
class DeleteRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteRuleResponseBody() {}

  explicit DeleteRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteRuleResponseBody() = default;
};
class DeleteRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRuleResponseBody> body{};

  DeleteRuleResponse() {}

  explicit DeleteRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRuleResponse() = default;
};
class DeleteRuleActionRequest : public Darabonba::Model {
public:
  shared_ptr<long> actionId{};
  shared_ptr<string> iotInstanceId{};

  DeleteRuleActionRequest() {}

  explicit DeleteRuleActionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionId) {
      res["ActionId"] = boost::any(*actionId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionId") != m.end() && !m["ActionId"].empty()) {
      actionId = make_shared<long>(boost::any_cast<long>(m["ActionId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~DeleteRuleActionRequest() = default;
};
class DeleteRuleActionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteRuleActionResponseBody() {}

  explicit DeleteRuleActionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteRuleActionResponseBody() = default;
};
class DeleteRuleActionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRuleActionResponseBody> body{};

  DeleteRuleActionResponse() {}

  explicit DeleteRuleActionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRuleActionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRuleActionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRuleActionResponse() = default;
};
class DeleteSceneRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> ruleId{};

  DeleteSceneRuleRequest() {}

  explicit DeleteSceneRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~DeleteSceneRuleRequest() = default;
};
class DeleteSceneRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteSceneRuleResponseBody() {}

  explicit DeleteSceneRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteSceneRuleResponseBody() = default;
};
class DeleteSceneRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSceneRuleResponseBody> body{};

  DeleteSceneRuleResponse() {}

  explicit DeleteSceneRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSceneRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSceneRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSceneRuleResponse() = default;
};
class DeleteSchedulePeriodRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> periodCode{};

  DeleteSchedulePeriodRequest() {}

  explicit DeleteSchedulePeriodRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (periodCode) {
      res["PeriodCode"] = boost::any(*periodCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PeriodCode") != m.end() && !m["PeriodCode"].empty()) {
      periodCode = make_shared<string>(boost::any_cast<string>(m["PeriodCode"]));
    }
  }


  virtual ~DeleteSchedulePeriodRequest() = default;
};
class DeleteSchedulePeriodResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteSchedulePeriodResponseBody() {}

  explicit DeleteSchedulePeriodResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteSchedulePeriodResponseBody() = default;
};
class DeleteSchedulePeriodResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSchedulePeriodResponseBody> body{};

  DeleteSchedulePeriodResponse() {}

  explicit DeleteSchedulePeriodResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSchedulePeriodResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSchedulePeriodResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSchedulePeriodResponse() = default;
};
class DeleteShareTaskDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> iotIdList{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> shareTaskId{};

  DeleteShareTaskDeviceRequest() {}

  explicit DeleteShareTaskDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotIdList) {
      res["IotIdList"] = boost::any(*iotIdList);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (shareTaskId) {
      res["ShareTaskId"] = boost::any(*shareTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotIdList") != m.end() && !m["IotIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ShareTaskId") != m.end() && !m["ShareTaskId"].empty()) {
      shareTaskId = make_shared<string>(boost::any_cast<string>(m["ShareTaskId"]));
    }
  }


  virtual ~DeleteShareTaskDeviceRequest() = default;
};
class DeleteShareTaskDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> progress{};
  shared_ptr<string> progressId{};

  DeleteShareTaskDeviceResponseBodyData() {}

  explicit DeleteShareTaskDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (progressId) {
      res["ProgressId"] = boost::any(*progressId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("ProgressId") != m.end() && !m["ProgressId"].empty()) {
      progressId = make_shared<string>(boost::any_cast<string>(m["ProgressId"]));
    }
  }


  virtual ~DeleteShareTaskDeviceResponseBodyData() = default;
};
class DeleteShareTaskDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DeleteShareTaskDeviceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteShareTaskDeviceResponseBody() {}

  explicit DeleteShareTaskDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DeleteShareTaskDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DeleteShareTaskDeviceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteShareTaskDeviceResponseBody() = default;
};
class DeleteShareTaskDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteShareTaskDeviceResponseBody> body{};

  DeleteShareTaskDeviceResponse() {}

  explicit DeleteShareTaskDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteShareTaskDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteShareTaskDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteShareTaskDeviceResponse() = default;
};
class DeleteSoundCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> soundCode{};

  DeleteSoundCodeRequest() {}

  explicit DeleteSoundCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (soundCode) {
      res["SoundCode"] = boost::any(*soundCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("SoundCode") != m.end() && !m["SoundCode"].empty()) {
      soundCode = make_shared<string>(boost::any_cast<string>(m["SoundCode"]));
    }
  }


  virtual ~DeleteSoundCodeRequest() = default;
};
class DeleteSoundCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteSoundCodeResponseBody() {}

  explicit DeleteSoundCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteSoundCodeResponseBody() = default;
};
class DeleteSoundCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSoundCodeResponseBody> body{};

  DeleteSoundCodeResponse() {}

  explicit DeleteSoundCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSoundCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSoundCodeResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSoundCodeResponse() = default;
};
class DeleteSoundCodeLabelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> soundCode{};

  DeleteSoundCodeLabelRequest() {}

  explicit DeleteSoundCodeLabelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (soundCode) {
      res["SoundCode"] = boost::any(*soundCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("SoundCode") != m.end() && !m["SoundCode"].empty()) {
      soundCode = make_shared<string>(boost::any_cast<string>(m["SoundCode"]));
    }
  }


  virtual ~DeleteSoundCodeLabelRequest() = default;
};
class DeleteSoundCodeLabelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteSoundCodeLabelResponseBody() {}

  explicit DeleteSoundCodeLabelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteSoundCodeLabelResponseBody() = default;
};
class DeleteSoundCodeLabelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSoundCodeLabelResponseBody> body{};

  DeleteSoundCodeLabelResponse() {}

  explicit DeleteSoundCodeLabelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSoundCodeLabelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSoundCodeLabelResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSoundCodeLabelResponse() = default;
};
class DeleteSoundCodeScheduleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> scheduleCode{};

  DeleteSoundCodeScheduleRequest() {}

  explicit DeleteSoundCodeScheduleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (scheduleCode) {
      res["ScheduleCode"] = boost::any(*scheduleCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ScheduleCode") != m.end() && !m["ScheduleCode"].empty()) {
      scheduleCode = make_shared<string>(boost::any_cast<string>(m["ScheduleCode"]));
    }
  }


  virtual ~DeleteSoundCodeScheduleRequest() = default;
};
class DeleteSoundCodeScheduleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteSoundCodeScheduleResponseBody() {}

  explicit DeleteSoundCodeScheduleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteSoundCodeScheduleResponseBody() = default;
};
class DeleteSoundCodeScheduleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSoundCodeScheduleResponseBody> body{};

  DeleteSoundCodeScheduleResponse() {}

  explicit DeleteSoundCodeScheduleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSoundCodeScheduleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSoundCodeScheduleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSoundCodeScheduleResponse() = default;
};
class DeleteSpeechRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<string>> speechCodeList{};

  DeleteSpeechRequest() {}

  explicit DeleteSpeechRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (speechCodeList) {
      res["SpeechCodeList"] = boost::any(*speechCodeList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("SpeechCodeList") != m.end() && !m["SpeechCodeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SpeechCodeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SpeechCodeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      speechCodeList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteSpeechRequest() = default;
};
class DeleteSpeechResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteSpeechResponseBody() {}

  explicit DeleteSpeechResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteSpeechResponseBody() = default;
};
class DeleteSpeechResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSpeechResponseBody> body{};

  DeleteSpeechResponse() {}

  explicit DeleteSpeechResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSpeechResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSpeechResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSpeechResponse() = default;
};
class DeleteStudioAppDomainOpenRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> domainId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> projectId{};

  DeleteStudioAppDomainOpenRequest() {}

  explicit DeleteStudioAppDomainOpenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<long>(boost::any_cast<long>(m["DomainId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~DeleteStudioAppDomainOpenRequest() = default;
};
class DeleteStudioAppDomainOpenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteStudioAppDomainOpenResponseBody() {}

  explicit DeleteStudioAppDomainOpenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteStudioAppDomainOpenResponseBody() = default;
};
class DeleteStudioAppDomainOpenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteStudioAppDomainOpenResponseBody> body{};

  DeleteStudioAppDomainOpenResponse() {}

  explicit DeleteStudioAppDomainOpenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteStudioAppDomainOpenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteStudioAppDomainOpenResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteStudioAppDomainOpenResponse() = default;
};
class DeleteSubscribeRelationRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> type{};

  DeleteSubscribeRelationRequest() {}

  explicit DeleteSubscribeRelationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DeleteSubscribeRelationRequest() = default;
};
class DeleteSubscribeRelationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteSubscribeRelationResponseBody() {}

  explicit DeleteSubscribeRelationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteSubscribeRelationResponseBody() = default;
};
class DeleteSubscribeRelationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSubscribeRelationResponseBody> body{};

  DeleteSubscribeRelationResponse() {}

  explicit DeleteSubscribeRelationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSubscribeRelationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSubscribeRelationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSubscribeRelationResponse() = default;
};
class DeleteThingModelRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> eventIdentifier{};
  shared_ptr<string> functionBlockId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<vector<string>> propertyIdentifier{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<string>> serviceIdentifier{};

  DeleteThingModelRequest() {}

  explicit DeleteThingModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventIdentifier) {
      res["EventIdentifier"] = boost::any(*eventIdentifier);
    }
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (propertyIdentifier) {
      res["PropertyIdentifier"] = boost::any(*propertyIdentifier);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (serviceIdentifier) {
      res["ServiceIdentifier"] = boost::any(*serviceIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventIdentifier") != m.end() && !m["EventIdentifier"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EventIdentifier"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EventIdentifier"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      eventIdentifier = make_shared<vector<string>>(toVec1);
    }
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("PropertyIdentifier") != m.end() && !m["PropertyIdentifier"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PropertyIdentifier"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PropertyIdentifier"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      propertyIdentifier = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ServiceIdentifier") != m.end() && !m["ServiceIdentifier"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ServiceIdentifier"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ServiceIdentifier"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      serviceIdentifier = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteThingModelRequest() = default;
};
class DeleteThingModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteThingModelResponseBody() {}

  explicit DeleteThingModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteThingModelResponseBody() = default;
};
class DeleteThingModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteThingModelResponseBody> body{};

  DeleteThingModelResponse() {}

  explicit DeleteThingModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteThingModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteThingModelResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteThingModelResponse() = default;
};
class DeleteTopicConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> topicFullName{};

  DeleteTopicConfigRequest() {}

  explicit DeleteTopicConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (topicFullName) {
      res["TopicFullName"] = boost::any(*topicFullName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("TopicFullName") != m.end() && !m["TopicFullName"].empty()) {
      topicFullName = make_shared<string>(boost::any_cast<string>(m["TopicFullName"]));
    }
  }


  virtual ~DeleteTopicConfigRequest() = default;
};
class DeleteTopicConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteTopicConfigResponseBody() {}

  explicit DeleteTopicConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteTopicConfigResponseBody() = default;
};
class DeleteTopicConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTopicConfigResponseBody> body{};

  DeleteTopicConfigResponse() {}

  explicit DeleteTopicConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTopicConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTopicConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTopicConfigResponse() = default;
};
class DeleteTopicRouteTableRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dstTopic{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> srcTopic{};

  DeleteTopicRouteTableRequest() {}

  explicit DeleteTopicRouteTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dstTopic) {
      res["DstTopic"] = boost::any(*dstTopic);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (srcTopic) {
      res["SrcTopic"] = boost::any(*srcTopic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DstTopic") != m.end() && !m["DstTopic"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DstTopic"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DstTopic"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dstTopic = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("SrcTopic") != m.end() && !m["SrcTopic"].empty()) {
      srcTopic = make_shared<string>(boost::any_cast<string>(m["SrcTopic"]));
    }
  }


  virtual ~DeleteTopicRouteTableRequest() = default;
};
class DeleteTopicRouteTableResponseBodyFailureTopics : public Darabonba::Model {
public:
  shared_ptr<vector<map<string, boost::any>>> topic{};

  DeleteTopicRouteTableResponseBodyFailureTopics() {}

  explicit DeleteTopicRouteTableResponseBodyFailureTopics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Topic"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Topic"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      topic = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
  }


  virtual ~DeleteTopicRouteTableResponseBodyFailureTopics() = default;
};
class DeleteTopicRouteTableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<DeleteTopicRouteTableResponseBodyFailureTopics> failureTopics{};
  shared_ptr<bool> isAllSucceed{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteTopicRouteTableResponseBody() {}

  explicit DeleteTopicRouteTableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (failureTopics) {
      res["FailureTopics"] = failureTopics ? boost::any(failureTopics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isAllSucceed) {
      res["IsAllSucceed"] = boost::any(*isAllSucceed);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("FailureTopics") != m.end() && !m["FailureTopics"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailureTopics"].type()) {
        DeleteTopicRouteTableResponseBodyFailureTopics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailureTopics"]));
        failureTopics = make_shared<DeleteTopicRouteTableResponseBodyFailureTopics>(model1);
      }
    }
    if (m.find("IsAllSucceed") != m.end() && !m["IsAllSucceed"].empty()) {
      isAllSucceed = make_shared<bool>(boost::any_cast<bool>(m["IsAllSucceed"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteTopicRouteTableResponseBody() = default;
};
class DeleteTopicRouteTableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTopicRouteTableResponseBody> body{};

  DeleteTopicRouteTableResponse() {}

  explicit DeleteTopicRouteTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTopicRouteTableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTopicRouteTableResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTopicRouteTableResponse() = default;
};
class DetachDestinationRequest : public Darabonba::Model {
public:
  shared_ptr<long> destinationId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> parserId{};

  DetachDestinationRequest() {}

  explicit DetachDestinationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationId) {
      res["DestinationId"] = boost::any(*destinationId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (parserId) {
      res["ParserId"] = boost::any(*parserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationId") != m.end() && !m["DestinationId"].empty()) {
      destinationId = make_shared<long>(boost::any_cast<long>(m["DestinationId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ParserId") != m.end() && !m["ParserId"].empty()) {
      parserId = make_shared<long>(boost::any_cast<long>(m["ParserId"]));
    }
  }


  virtual ~DetachDestinationRequest() = default;
};
class DetachDestinationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DetachDestinationResponseBody() {}

  explicit DetachDestinationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DetachDestinationResponseBody() = default;
};
class DetachDestinationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachDestinationResponseBody> body{};

  DetachDestinationResponse() {}

  explicit DetachDestinationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachDestinationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachDestinationResponseBody>(model1);
      }
    }
  }


  virtual ~DetachDestinationResponse() = default;
};
class DetachParserDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> parserId{};

  DetachParserDataSourceRequest() {}

  explicit DetachParserDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (parserId) {
      res["ParserId"] = boost::any(*parserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ParserId") != m.end() && !m["ParserId"].empty()) {
      parserId = make_shared<long>(boost::any_cast<long>(m["ParserId"]));
    }
  }


  virtual ~DetachParserDataSourceRequest() = default;
};
class DetachParserDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DetachParserDataSourceResponseBody() {}

  explicit DetachParserDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DetachParserDataSourceResponseBody() = default;
};
class DetachParserDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachParserDataSourceResponseBody> body{};

  DetachParserDataSourceResponse() {}

  explicit DetachParserDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachParserDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachParserDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~DetachParserDataSourceResponse() = default;
};
class DisableDeviceTunnelRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  DisableDeviceTunnelRequest() {}

  explicit DisableDeviceTunnelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~DisableDeviceTunnelRequest() = default;
};
class DisableDeviceTunnelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DisableDeviceTunnelResponseBody() {}

  explicit DisableDeviceTunnelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DisableDeviceTunnelResponseBody() = default;
};
class DisableDeviceTunnelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableDeviceTunnelResponseBody> body{};

  DisableDeviceTunnelResponse() {}

  explicit DisableDeviceTunnelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableDeviceTunnelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableDeviceTunnelResponseBody>(model1);
      }
    }
  }


  virtual ~DisableDeviceTunnelResponse() = default;
};
class DisableDeviceTunnelShareRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  DisableDeviceTunnelShareRequest() {}

  explicit DisableDeviceTunnelShareRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~DisableDeviceTunnelShareRequest() = default;
};
class DisableDeviceTunnelShareResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DisableDeviceTunnelShareResponseBody() {}

  explicit DisableDeviceTunnelShareResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DisableDeviceTunnelShareResponseBody() = default;
};
class DisableDeviceTunnelShareResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableDeviceTunnelShareResponseBody> body{};

  DisableDeviceTunnelShareResponse() {}

  explicit DisableDeviceTunnelShareResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableDeviceTunnelShareResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableDeviceTunnelShareResponseBody>(model1);
      }
    }
  }


  virtual ~DisableDeviceTunnelShareResponse() = default;
};
class DisableSceneRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> ruleId{};

  DisableSceneRuleRequest() {}

  explicit DisableSceneRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~DisableSceneRuleRequest() = default;
};
class DisableSceneRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DisableSceneRuleResponseBody() {}

  explicit DisableSceneRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DisableSceneRuleResponseBody() = default;
};
class DisableSceneRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableSceneRuleResponseBody> body{};

  DisableSceneRuleResponse() {}

  explicit DisableSceneRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableSceneRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableSceneRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DisableSceneRuleResponse() = default;
};
class DisableThingRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  DisableThingRequest() {}

  explicit DisableThingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~DisableThingRequest() = default;
};
class DisableThingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DisableThingResponseBody() {}

  explicit DisableThingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DisableThingResponseBody() = default;
};
class DisableThingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableThingResponseBody> body{};

  DisableThingResponse() {}

  explicit DisableThingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableThingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableThingResponseBody>(model1);
      }
    }
  }


  virtual ~DisableThingResponse() = default;
};
class EnableDeviceTunnelRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  EnableDeviceTunnelRequest() {}

  explicit EnableDeviceTunnelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~EnableDeviceTunnelRequest() = default;
};
class EnableDeviceTunnelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  EnableDeviceTunnelResponseBody() {}

  explicit EnableDeviceTunnelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~EnableDeviceTunnelResponseBody() = default;
};
class EnableDeviceTunnelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableDeviceTunnelResponseBody> body{};

  EnableDeviceTunnelResponse() {}

  explicit EnableDeviceTunnelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableDeviceTunnelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableDeviceTunnelResponseBody>(model1);
      }
    }
  }


  virtual ~EnableDeviceTunnelResponse() = default;
};
class EnableDeviceTunnelShareRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  EnableDeviceTunnelShareRequest() {}

  explicit EnableDeviceTunnelShareRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~EnableDeviceTunnelShareRequest() = default;
};
class EnableDeviceTunnelShareResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  EnableDeviceTunnelShareResponseBody() {}

  explicit EnableDeviceTunnelShareResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~EnableDeviceTunnelShareResponseBody() = default;
};
class EnableDeviceTunnelShareResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableDeviceTunnelShareResponseBody> body{};

  EnableDeviceTunnelShareResponse() {}

  explicit EnableDeviceTunnelShareResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableDeviceTunnelShareResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableDeviceTunnelShareResponseBody>(model1);
      }
    }
  }


  virtual ~EnableDeviceTunnelShareResponse() = default;
};
class EnableSceneRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> ruleId{};

  EnableSceneRuleRequest() {}

  explicit EnableSceneRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~EnableSceneRuleRequest() = default;
};
class EnableSceneRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  EnableSceneRuleResponseBody() {}

  explicit EnableSceneRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~EnableSceneRuleResponseBody() = default;
};
class EnableSceneRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableSceneRuleResponseBody> body{};

  EnableSceneRuleResponse() {}

  explicit EnableSceneRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableSceneRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableSceneRuleResponseBody>(model1);
      }
    }
  }


  virtual ~EnableSceneRuleResponse() = default;
};
class EnableThingRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  EnableThingRequest() {}

  explicit EnableThingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~EnableThingRequest() = default;
};
class EnableThingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  EnableThingResponseBody() {}

  explicit EnableThingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~EnableThingResponseBody() = default;
};
class EnableThingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableThingResponseBody> body{};

  EnableThingResponse() {}

  explicit EnableThingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableThingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableThingResponseBody>(model1);
      }
    }
  }


  virtual ~EnableThingResponse() = default;
};
class GenerateDeviceNameListURLRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};

  GenerateDeviceNameListURLRequest() {}

  explicit GenerateDeviceNameListURLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~GenerateDeviceNameListURLRequest() = default;
};
class GenerateDeviceNameListURLResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> accessKeyId{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> host{};
  shared_ptr<string> key{};
  shared_ptr<string> objectStorage{};
  shared_ptr<string> policy{};
  shared_ptr<string> signature{};
  shared_ptr<string> utcCreate{};

  GenerateDeviceNameListURLResponseBodyData() {}

  explicit GenerateDeviceNameListURLResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKeyId) {
      res["AccessKeyId"] = boost::any(*accessKeyId);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (objectStorage) {
      res["ObjectStorage"] = boost::any(*objectStorage);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessKeyId") != m.end() && !m["AccessKeyId"].empty()) {
      accessKeyId = make_shared<string>(boost::any_cast<string>(m["AccessKeyId"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("ObjectStorage") != m.end() && !m["ObjectStorage"].empty()) {
      objectStorage = make_shared<string>(boost::any_cast<string>(m["ObjectStorage"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
  }


  virtual ~GenerateDeviceNameListURLResponseBodyData() = default;
};
class GenerateDeviceNameListURLResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GenerateDeviceNameListURLResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GenerateDeviceNameListURLResponseBody() {}

  explicit GenerateDeviceNameListURLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GenerateDeviceNameListURLResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GenerateDeviceNameListURLResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GenerateDeviceNameListURLResponseBody() = default;
};
class GenerateDeviceNameListURLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GenerateDeviceNameListURLResponseBody> body{};

  GenerateDeviceNameListURLResponse() {}

  explicit GenerateDeviceNameListURLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateDeviceNameListURLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateDeviceNameListURLResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateDeviceNameListURLResponse() = default;
};
class GenerateFileUploadURLRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizCode{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSuffix{};
  shared_ptr<string> iotInstanceId{};

  GenerateFileUploadURLRequest() {}

  explicit GenerateFileUploadURLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizCode) {
      res["BizCode"] = boost::any(*bizCode);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSuffix) {
      res["FileSuffix"] = boost::any(*fileSuffix);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizCode") != m.end() && !m["BizCode"].empty()) {
      bizCode = make_shared<string>(boost::any_cast<string>(m["BizCode"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSuffix") != m.end() && !m["FileSuffix"].empty()) {
      fileSuffix = make_shared<string>(boost::any_cast<string>(m["FileSuffix"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~GenerateFileUploadURLRequest() = default;
};
class GenerateFileUploadURLResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<string> key{};
  shared_ptr<string> objectStorage{};
  shared_ptr<string> ossAccessKeyId{};
  shared_ptr<string> policy{};
  shared_ptr<string> signature{};

  GenerateFileUploadURLResponseBodyData() {}

  explicit GenerateFileUploadURLResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (objectStorage) {
      res["ObjectStorage"] = boost::any(*objectStorage);
    }
    if (ossAccessKeyId) {
      res["OssAccessKeyId"] = boost::any(*ossAccessKeyId);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("ObjectStorage") != m.end() && !m["ObjectStorage"].empty()) {
      objectStorage = make_shared<string>(boost::any_cast<string>(m["ObjectStorage"]));
    }
    if (m.find("OssAccessKeyId") != m.end() && !m["OssAccessKeyId"].empty()) {
      ossAccessKeyId = make_shared<string>(boost::any_cast<string>(m["OssAccessKeyId"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
  }


  virtual ~GenerateFileUploadURLResponseBodyData() = default;
};
class GenerateFileUploadURLResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GenerateFileUploadURLResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GenerateFileUploadURLResponseBody() {}

  explicit GenerateFileUploadURLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GenerateFileUploadURLResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GenerateFileUploadURLResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GenerateFileUploadURLResponseBody() = default;
};
class GenerateFileUploadURLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GenerateFileUploadURLResponseBody> body{};

  GenerateFileUploadURLResponse() {}

  explicit GenerateFileUploadURLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateFileUploadURLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateFileUploadURLResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateFileUploadURLResponse() = default;
};
class GenerateOTAUploadURLRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileSuffix{};
  shared_ptr<string> iotInstanceId{};

  GenerateOTAUploadURLRequest() {}

  explicit GenerateOTAUploadURLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileSuffix) {
      res["FileSuffix"] = boost::any(*fileSuffix);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileSuffix") != m.end() && !m["FileSuffix"].empty()) {
      fileSuffix = make_shared<string>(boost::any_cast<string>(m["FileSuffix"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~GenerateOTAUploadURLRequest() = default;
};
class GenerateOTAUploadURLResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> firmwareUrl{};
  shared_ptr<string> host{};
  shared_ptr<string> key{};
  shared_ptr<string> OSSAccessKeyId{};
  shared_ptr<string> objectStorage{};
  shared_ptr<string> policy{};
  shared_ptr<string> signature{};
  shared_ptr<string> utcCreate{};

  GenerateOTAUploadURLResponseBodyData() {}

  explicit GenerateOTAUploadURLResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (firmwareUrl) {
      res["FirmwareUrl"] = boost::any(*firmwareUrl);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (OSSAccessKeyId) {
      res["OSSAccessKeyId"] = boost::any(*OSSAccessKeyId);
    }
    if (objectStorage) {
      res["ObjectStorage"] = boost::any(*objectStorage);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FirmwareUrl") != m.end() && !m["FirmwareUrl"].empty()) {
      firmwareUrl = make_shared<string>(boost::any_cast<string>(m["FirmwareUrl"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("OSSAccessKeyId") != m.end() && !m["OSSAccessKeyId"].empty()) {
      OSSAccessKeyId = make_shared<string>(boost::any_cast<string>(m["OSSAccessKeyId"]));
    }
    if (m.find("ObjectStorage") != m.end() && !m["ObjectStorage"].empty()) {
      objectStorage = make_shared<string>(boost::any_cast<string>(m["ObjectStorage"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
  }


  virtual ~GenerateOTAUploadURLResponseBodyData() = default;
};
class GenerateOTAUploadURLResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GenerateOTAUploadURLResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GenerateOTAUploadURLResponseBody() {}

  explicit GenerateOTAUploadURLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GenerateOTAUploadURLResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GenerateOTAUploadURLResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GenerateOTAUploadURLResponseBody() = default;
};
class GenerateOTAUploadURLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GenerateOTAUploadURLResponseBody> body{};

  GenerateOTAUploadURLResponse() {}

  explicit GenerateOTAUploadURLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateOTAUploadURLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateOTAUploadURLResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateOTAUploadURLResponse() = default;
};
class GetDataAPIServiceDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiSrn{};
  shared_ptr<string> iotInstanceId{};

  GetDataAPIServiceDetailRequest() {}

  explicit GetDataAPIServiceDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiSrn) {
      res["ApiSrn"] = boost::any(*apiSrn);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiSrn") != m.end() && !m["ApiSrn"].empty()) {
      apiSrn = make_shared<string>(boost::any_cast<string>(m["ApiSrn"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~GetDataAPIServiceDetailRequest() = default;
};
class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> example{};
  shared_ptr<string> name{};
  shared_ptr<bool> required{};
  shared_ptr<string> type{};

  GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams() {}

  explicit GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (example) {
      res["Example"] = boost::any(*example);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Example") != m.end() && !m["Example"].empty()) {
      example = make_shared<string>(boost::any_cast<string>(m["Example"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<bool>(boost::any_cast<bool>(m["Required"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams() = default;
};
class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams : public Darabonba::Model {
public:
  shared_ptr<vector<GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams>> requestParams{};

  GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams() {}

  explicit GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParams) {
      vector<boost::any> temp1;
      for(auto item1:*requestParams){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParams"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParams") != m.end() && !m["RequestParams"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParams"].type()) {
        vector<GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParams"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParams = make_shared<vector<GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams>>(expect1);
      }
    }
  }


  virtual ~GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams() = default;
};
class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> example{};
  shared_ptr<string> name{};
  shared_ptr<bool> required{};
  shared_ptr<string> type{};

  GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams() {}

  explicit GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (example) {
      res["Example"] = boost::any(*example);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Example") != m.end() && !m["Example"].empty()) {
      example = make_shared<string>(boost::any_cast<string>(m["Example"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<bool>(boost::any_cast<bool>(m["Required"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams() = default;
};
class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams : public Darabonba::Model {
public:
  shared_ptr<vector<GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams>> responseParams{};

  GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams() {}

  explicit GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (responseParams) {
      vector<boost::any> temp1;
      for(auto item1:*responseParams){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResponseParams"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResponseParams") != m.end() && !m["ResponseParams"].empty()) {
      if (typeid(vector<boost::any>) == m["ResponseParams"].type()) {
        vector<GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResponseParams"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        responseParams = make_shared<vector<GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams>>(expect1);
      }
    }
  }


  virtual ~GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams() = default;
};
class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO : public Darabonba::Model {
public:
  shared_ptr<string> originSql{};
  shared_ptr<GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams> requestParams{};
  shared_ptr<GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams> responseParams{};
  shared_ptr<string> templateSql{};

  GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO() {}

  explicit GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (originSql) {
      res["OriginSql"] = boost::any(*originSql);
    }
    if (requestParams) {
      res["RequestParams"] = requestParams ? boost::any(requestParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (responseParams) {
      res["ResponseParams"] = responseParams ? boost::any(responseParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateSql) {
      res["TemplateSql"] = boost::any(*templateSql);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OriginSql") != m.end() && !m["OriginSql"].empty()) {
      originSql = make_shared<string>(boost::any_cast<string>(m["OriginSql"]));
    }
    if (m.find("RequestParams") != m.end() && !m["RequestParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestParams"].type()) {
        GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestParams"]));
        requestParams = make_shared<GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams>(model1);
      }
    }
    if (m.find("ResponseParams") != m.end() && !m["ResponseParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResponseParams"].type()) {
        GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResponseParams"]));
        responseParams = make_shared<GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams>(model1);
      }
    }
    if (m.find("TemplateSql") != m.end() && !m["TemplateSql"].empty()) {
      templateSql = make_shared<string>(boost::any_cast<string>(m["TemplateSql"]));
    }
  }


  virtual ~GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO() = default;
};
class GetDataAPIServiceDetailResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> apiPath{};
  shared_ptr<string> apiSrn{};
  shared_ptr<long> createTime{};
  shared_ptr<string> dateFormat{};
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<long> lastUpdateTime{};
  shared_ptr<string> requestMethod{};
  shared_ptr<string> requestProtocol{};
  shared_ptr<GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO> sqlTemplateDTO{};
  shared_ptr<long> status{};

  GetDataAPIServiceDetailResponseBodyData() {}

  explicit GetDataAPIServiceDetailResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    if (apiSrn) {
      res["ApiSrn"] = boost::any(*apiSrn);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dateFormat) {
      res["DateFormat"] = boost::any(*dateFormat);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (lastUpdateTime) {
      res["LastUpdateTime"] = boost::any(*lastUpdateTime);
    }
    if (requestMethod) {
      res["RequestMethod"] = boost::any(*requestMethod);
    }
    if (requestProtocol) {
      res["RequestProtocol"] = boost::any(*requestProtocol);
    }
    if (sqlTemplateDTO) {
      res["SqlTemplateDTO"] = sqlTemplateDTO ? boost::any(sqlTemplateDTO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
    if (m.find("ApiSrn") != m.end() && !m["ApiSrn"].empty()) {
      apiSrn = make_shared<string>(boost::any_cast<string>(m["ApiSrn"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DateFormat") != m.end() && !m["DateFormat"].empty()) {
      dateFormat = make_shared<string>(boost::any_cast<string>(m["DateFormat"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("LastUpdateTime") != m.end() && !m["LastUpdateTime"].empty()) {
      lastUpdateTime = make_shared<long>(boost::any_cast<long>(m["LastUpdateTime"]));
    }
    if (m.find("RequestMethod") != m.end() && !m["RequestMethod"].empty()) {
      requestMethod = make_shared<string>(boost::any_cast<string>(m["RequestMethod"]));
    }
    if (m.find("RequestProtocol") != m.end() && !m["RequestProtocol"].empty()) {
      requestProtocol = make_shared<string>(boost::any_cast<string>(m["RequestProtocol"]));
    }
    if (m.find("SqlTemplateDTO") != m.end() && !m["SqlTemplateDTO"].empty()) {
      if (typeid(map<string, boost::any>) == m["SqlTemplateDTO"].type()) {
        GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SqlTemplateDTO"]));
        sqlTemplateDTO = make_shared<GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~GetDataAPIServiceDetailResponseBodyData() = default;
};
class GetDataAPIServiceDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetDataAPIServiceDetailResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDataAPIServiceDetailResponseBody() {}

  explicit GetDataAPIServiceDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDataAPIServiceDetailResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDataAPIServiceDetailResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDataAPIServiceDetailResponseBody() = default;
};
class GetDataAPIServiceDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataAPIServiceDetailResponseBody> body{};

  GetDataAPIServiceDetailResponse() {}

  explicit GetDataAPIServiceDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataAPIServiceDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataAPIServiceDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataAPIServiceDetailResponse() = default;
};
class GetDestinationRequest : public Darabonba::Model {
public:
  shared_ptr<long> destinationId{};
  shared_ptr<string> iotInstanceId{};

  GetDestinationRequest() {}

  explicit GetDestinationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationId) {
      res["DestinationId"] = boost::any(*destinationId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationId") != m.end() && !m["DestinationId"].empty()) {
      destinationId = make_shared<long>(boost::any_cast<long>(m["DestinationId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~GetDestinationRequest() = default;
};
class GetDestinationResponseBodyDestination : public Darabonba::Model {
public:
  shared_ptr<string> configuration{};
  shared_ptr<string> destinationId{};
  shared_ptr<bool> isFailover{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> utcCreated{};

  GetDestinationResponseBodyDestination() {}

  explicit GetDestinationResponseBodyDestination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configuration) {
      res["Configuration"] = boost::any(*configuration);
    }
    if (destinationId) {
      res["DestinationId"] = boost::any(*destinationId);
    }
    if (isFailover) {
      res["IsFailover"] = boost::any(*isFailover);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (utcCreated) {
      res["UtcCreated"] = boost::any(*utcCreated);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configuration = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
    if (m.find("DestinationId") != m.end() && !m["DestinationId"].empty()) {
      destinationId = make_shared<string>(boost::any_cast<string>(m["DestinationId"]));
    }
    if (m.find("IsFailover") != m.end() && !m["IsFailover"].empty()) {
      isFailover = make_shared<bool>(boost::any_cast<bool>(m["IsFailover"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UtcCreated") != m.end() && !m["UtcCreated"].empty()) {
      utcCreated = make_shared<string>(boost::any_cast<string>(m["UtcCreated"]));
    }
  }


  virtual ~GetDestinationResponseBodyDestination() = default;
};
class GetDestinationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetDestinationResponseBodyDestination> destination{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDestinationResponseBody() {}

  explicit GetDestinationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (destination) {
      res["Destination"] = destination ? boost::any(destination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Destination"].type()) {
        GetDestinationResponseBodyDestination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Destination"]));
        destination = make_shared<GetDestinationResponseBodyDestination>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDestinationResponseBody() = default;
};
class GetDestinationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDestinationResponseBody> body{};

  GetDestinationResponse() {}

  explicit GetDestinationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDestinationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDestinationResponseBody>(model1);
      }
    }
  }


  virtual ~GetDestinationResponse() = default;
};
class GetDeviceShadowRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  GetDeviceShadowRequest() {}

  explicit GetDeviceShadowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~GetDeviceShadowRequest() = default;
};
class GetDeviceShadowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> shadowMessage{};
  shared_ptr<bool> success{};

  GetDeviceShadowResponseBody() {}

  explicit GetDeviceShadowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (shadowMessage) {
      res["ShadowMessage"] = boost::any(*shadowMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ShadowMessage") != m.end() && !m["ShadowMessage"].empty()) {
      shadowMessage = make_shared<string>(boost::any_cast<string>(m["ShadowMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDeviceShadowResponseBody() = default;
};
class GetDeviceShadowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDeviceShadowResponseBody> body{};

  GetDeviceShadowResponse() {}

  explicit GetDeviceShadowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDeviceShadowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDeviceShadowResponseBody>(model1);
      }
    }
  }


  virtual ~GetDeviceShadowResponse() = default;
};
class GetDeviceStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  GetDeviceStatusRequest() {}

  explicit GetDeviceStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~GetDeviceStatusRequest() = default;
};
class GetDeviceStatusResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<long> timestamp{};

  GetDeviceStatusResponseBodyData() {}

  explicit GetDeviceStatusResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~GetDeviceStatusResponseBodyData() = default;
};
class GetDeviceStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetDeviceStatusResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDeviceStatusResponseBody() {}

  explicit GetDeviceStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDeviceStatusResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDeviceStatusResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDeviceStatusResponseBody() = default;
};
class GetDeviceStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDeviceStatusResponseBody> body{};

  GetDeviceStatusResponse() {}

  explicit GetDeviceStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDeviceStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDeviceStatusResponseBody>(model1);
      }
    }
  }


  virtual ~GetDeviceStatusResponse() = default;
};
class GetDeviceTunnelShareStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  GetDeviceTunnelShareStatusRequest() {}

  explicit GetDeviceTunnelShareStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~GetDeviceTunnelShareStatusRequest() = default;
};
class GetDeviceTunnelShareStatusResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> gmtOpened{};
  shared_ptr<bool> isOpen{};
  shared_ptr<string> password{};
  shared_ptr<string> shareId{};

  GetDeviceTunnelShareStatusResponseBodyData() {}

  explicit GetDeviceTunnelShareStatusResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtOpened) {
      res["GmtOpened"] = boost::any(*gmtOpened);
    }
    if (isOpen) {
      res["IsOpen"] = boost::any(*isOpen);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (shareId) {
      res["ShareId"] = boost::any(*shareId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtOpened") != m.end() && !m["GmtOpened"].empty()) {
      gmtOpened = make_shared<long>(boost::any_cast<long>(m["GmtOpened"]));
    }
    if (m.find("IsOpen") != m.end() && !m["IsOpen"].empty()) {
      isOpen = make_shared<bool>(boost::any_cast<bool>(m["IsOpen"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("ShareId") != m.end() && !m["ShareId"].empty()) {
      shareId = make_shared<string>(boost::any_cast<string>(m["ShareId"]));
    }
  }


  virtual ~GetDeviceTunnelShareStatusResponseBodyData() = default;
};
class GetDeviceTunnelShareStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetDeviceTunnelShareStatusResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDeviceTunnelShareStatusResponseBody() {}

  explicit GetDeviceTunnelShareStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDeviceTunnelShareStatusResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDeviceTunnelShareStatusResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDeviceTunnelShareStatusResponseBody() = default;
};
class GetDeviceTunnelShareStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDeviceTunnelShareStatusResponseBody> body{};

  GetDeviceTunnelShareStatusResponse() {}

  explicit GetDeviceTunnelShareStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDeviceTunnelShareStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDeviceTunnelShareStatusResponseBody>(model1);
      }
    }
  }


  virtual ~GetDeviceTunnelShareStatusResponse() = default;
};
class GetDeviceTunnelStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  GetDeviceTunnelStatusRequest() {}

  explicit GetDeviceTunnelStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~GetDeviceTunnelStatusRequest() = default;
};
class GetDeviceTunnelStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDeviceTunnelStatusResponseBody() {}

  explicit GetDeviceTunnelStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDeviceTunnelStatusResponseBody() = default;
};
class GetDeviceTunnelStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDeviceTunnelStatusResponseBody> body{};

  GetDeviceTunnelStatusResponse() {}

  explicit GetDeviceTunnelStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDeviceTunnelStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDeviceTunnelStatusResponseBody>(model1);
      }
    }
  }


  virtual ~GetDeviceTunnelStatusResponse() = default;
};
class GetDownloadFileRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> context{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> longJobId{};

  GetDownloadFileRequest() {}

  explicit GetDownloadFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (context) {
      res["Context"] = boost::any(*context);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (longJobId) {
      res["LongJobId"] = boost::any(*longJobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Context") != m.end() && !m["Context"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Context"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      context = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("LongJobId") != m.end() && !m["LongJobId"].empty()) {
      longJobId = make_shared<string>(boost::any_cast<string>(m["LongJobId"]));
    }
  }


  virtual ~GetDownloadFileRequest() = default;
};
class GetDownloadFileShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> contextShrink{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> longJobId{};

  GetDownloadFileShrinkRequest() {}

  explicit GetDownloadFileShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contextShrink) {
      res["Context"] = boost::any(*contextShrink);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (longJobId) {
      res["LongJobId"] = boost::any(*longJobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Context") != m.end() && !m["Context"].empty()) {
      contextShrink = make_shared<string>(boost::any_cast<string>(m["Context"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("LongJobId") != m.end() && !m["LongJobId"].empty()) {
      longJobId = make_shared<string>(boost::any_cast<string>(m["LongJobId"]));
    }
  }


  virtual ~GetDownloadFileShrinkRequest() = default;
};
class GetDownloadFileResponseBodyDataHeader : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> dimDateClass{};
  shared_ptr<string> fieldName{};
  shared_ptr<string> fieldType{};
  shared_ptr<string> geoClass{};
  shared_ptr<string> timeClass{};
  shared_ptr<string> typeClass{};

  GetDownloadFileResponseBodyDataHeader() {}

  explicit GetDownloadFileResponseBodyDataHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (dimDateClass) {
      res["DimDateClass"] = boost::any(*dimDateClass);
    }
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    if (fieldType) {
      res["FieldType"] = boost::any(*fieldType);
    }
    if (geoClass) {
      res["GeoClass"] = boost::any(*geoClass);
    }
    if (timeClass) {
      res["TimeClass"] = boost::any(*timeClass);
    }
    if (typeClass) {
      res["TypeClass"] = boost::any(*typeClass);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("DimDateClass") != m.end() && !m["DimDateClass"].empty()) {
      dimDateClass = make_shared<string>(boost::any_cast<string>(m["DimDateClass"]));
    }
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
    if (m.find("FieldType") != m.end() && !m["FieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["FieldType"]));
    }
    if (m.find("GeoClass") != m.end() && !m["GeoClass"].empty()) {
      geoClass = make_shared<string>(boost::any_cast<string>(m["GeoClass"]));
    }
    if (m.find("TimeClass") != m.end() && !m["TimeClass"].empty()) {
      timeClass = make_shared<string>(boost::any_cast<string>(m["TimeClass"]));
    }
    if (m.find("TypeClass") != m.end() && !m["TypeClass"].empty()) {
      typeClass = make_shared<string>(boost::any_cast<string>(m["TypeClass"]));
    }
  }


  virtual ~GetDownloadFileResponseBodyDataHeader() = default;
};
class GetDownloadFileResponseBodyDataQuerySettingAstExpr : public Darabonba::Model {
public:
  shared_ptr<string> expr{};
  shared_ptr<string> exprType{};

  GetDownloadFileResponseBodyDataQuerySettingAstExpr() {}

  explicit GetDownloadFileResponseBodyDataQuerySettingAstExpr(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expr) {
      res["Expr"] = boost::any(*expr);
    }
    if (exprType) {
      res["ExprType"] = boost::any(*exprType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expr") != m.end() && !m["Expr"].empty()) {
      expr = make_shared<string>(boost::any_cast<string>(m["Expr"]));
    }
    if (m.find("ExprType") != m.end() && !m["ExprType"].empty()) {
      exprType = make_shared<string>(boost::any_cast<string>(m["ExprType"]));
    }
  }


  virtual ~GetDownloadFileResponseBodyDataQuerySettingAstExpr() = default;
};
class GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> dimDateClass{};
  shared_ptr<string> fieldName{};
  shared_ptr<string> fieldType{};
  shared_ptr<string> geoClass{};
  shared_ptr<string> timeClass{};

  GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders() {}

  explicit GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (dimDateClass) {
      res["DimDateClass"] = boost::any(*dimDateClass);
    }
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    if (fieldType) {
      res["FieldType"] = boost::any(*fieldType);
    }
    if (geoClass) {
      res["GeoClass"] = boost::any(*geoClass);
    }
    if (timeClass) {
      res["TimeClass"] = boost::any(*timeClass);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("DimDateClass") != m.end() && !m["DimDateClass"].empty()) {
      dimDateClass = make_shared<string>(boost::any_cast<string>(m["DimDateClass"]));
    }
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
    if (m.find("FieldType") != m.end() && !m["FieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["FieldType"]));
    }
    if (m.find("GeoClass") != m.end() && !m["GeoClass"].empty()) {
      geoClass = make_shared<string>(boost::any_cast<string>(m["GeoClass"]));
    }
    if (m.find("TimeClass") != m.end() && !m["TimeClass"].empty()) {
      timeClass = make_shared<string>(boost::any_cast<string>(m["TimeClass"]));
    }
  }


  virtual ~GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders() = default;
};
class GetDownloadFileResponseBodyDataQuerySetting : public Darabonba::Model {
public:
  shared_ptr<vector<GetDownloadFileResponseBodyDataQuerySettingAstExpr>> astExpr{};
  shared_ptr<vector<GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders>> selectedHeaders{};

  GetDownloadFileResponseBodyDataQuerySetting() {}

  explicit GetDownloadFileResponseBodyDataQuerySetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (astExpr) {
      vector<boost::any> temp1;
      for(auto item1:*astExpr){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AstExpr"] = boost::any(temp1);
    }
    if (selectedHeaders) {
      vector<boost::any> temp1;
      for(auto item1:*selectedHeaders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SelectedHeaders"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AstExpr") != m.end() && !m["AstExpr"].empty()) {
      if (typeid(vector<boost::any>) == m["AstExpr"].type()) {
        vector<GetDownloadFileResponseBodyDataQuerySettingAstExpr> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AstExpr"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDownloadFileResponseBodyDataQuerySettingAstExpr model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        astExpr = make_shared<vector<GetDownloadFileResponseBodyDataQuerySettingAstExpr>>(expect1);
      }
    }
    if (m.find("SelectedHeaders") != m.end() && !m["SelectedHeaders"].empty()) {
      if (typeid(vector<boost::any>) == m["SelectedHeaders"].type()) {
        vector<GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SelectedHeaders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        selectedHeaders = make_shared<vector<GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders>>(expect1);
      }
    }
  }


  virtual ~GetDownloadFileResponseBodyDataQuerySetting() = default;
};
class GetDownloadFileResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> asyncExecute{};
  shared_ptr<long> beginTime{};
  shared_ptr<string> csvFileName{};
  shared_ptr<string> csvUrl{};
  shared_ptr<string> datasetId{};
  shared_ptr<long> endTime{};
  shared_ptr<vector<GetDownloadFileResponseBodyDataHeader>> header{};
  shared_ptr<string> longJobId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> previewSize{};
  shared_ptr<GetDownloadFileResponseBodyDataQuerySetting> querySetting{};
  shared_ptr<vector<map<string, boost::any>>> result{};
  shared_ptr<string> resultDataInString{};
  shared_ptr<long> status{};
  shared_ptr<long> totalCount{};

  GetDownloadFileResponseBodyData() {}

  explicit GetDownloadFileResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asyncExecute) {
      res["AsyncExecute"] = boost::any(*asyncExecute);
    }
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (csvFileName) {
      res["CsvFileName"] = boost::any(*csvFileName);
    }
    if (csvUrl) {
      res["CsvUrl"] = boost::any(*csvUrl);
    }
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (header) {
      vector<boost::any> temp1;
      for(auto item1:*header){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Header"] = boost::any(temp1);
    }
    if (longJobId) {
      res["LongJobId"] = boost::any(*longJobId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (previewSize) {
      res["PreviewSize"] = boost::any(*previewSize);
    }
    if (querySetting) {
      res["QuerySetting"] = querySetting ? boost::any(querySetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (resultDataInString) {
      res["ResultDataInString"] = boost::any(*resultDataInString);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsyncExecute") != m.end() && !m["AsyncExecute"].empty()) {
      asyncExecute = make_shared<bool>(boost::any_cast<bool>(m["AsyncExecute"]));
    }
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["BeginTime"]));
    }
    if (m.find("CsvFileName") != m.end() && !m["CsvFileName"].empty()) {
      csvFileName = make_shared<string>(boost::any_cast<string>(m["CsvFileName"]));
    }
    if (m.find("CsvUrl") != m.end() && !m["CsvUrl"].empty()) {
      csvUrl = make_shared<string>(boost::any_cast<string>(m["CsvUrl"]));
    }
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<string>(boost::any_cast<string>(m["DatasetId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(vector<boost::any>) == m["Header"].type()) {
        vector<GetDownloadFileResponseBodyDataHeader> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Header"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDownloadFileResponseBodyDataHeader model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        header = make_shared<vector<GetDownloadFileResponseBodyDataHeader>>(expect1);
      }
    }
    if (m.find("LongJobId") != m.end() && !m["LongJobId"].empty()) {
      longJobId = make_shared<string>(boost::any_cast<string>(m["LongJobId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PreviewSize") != m.end() && !m["PreviewSize"].empty()) {
      previewSize = make_shared<long>(boost::any_cast<long>(m["PreviewSize"]));
    }
    if (m.find("QuerySetting") != m.end() && !m["QuerySetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["QuerySetting"].type()) {
        GetDownloadFileResponseBodyDataQuerySetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QuerySetting"]));
        querySetting = make_shared<GetDownloadFileResponseBodyDataQuerySetting>(model1);
      }
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Result"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      result = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("ResultDataInString") != m.end() && !m["ResultDataInString"].empty()) {
      resultDataInString = make_shared<string>(boost::any_cast<string>(m["ResultDataInString"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetDownloadFileResponseBodyData() = default;
};
class GetDownloadFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetDownloadFileResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDownloadFileResponseBody() {}

  explicit GetDownloadFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDownloadFileResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDownloadFileResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDownloadFileResponseBody() = default;
};
class GetDownloadFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDownloadFileResponseBody> body{};

  GetDownloadFileResponse() {}

  explicit GetDownloadFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDownloadFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDownloadFileResponseBody>(model1);
      }
    }
  }


  virtual ~GetDownloadFileResponse() = default;
};
class GetEdgeDriverVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};
  shared_ptr<string> iotInstanceId{};

  GetEdgeDriverVersionRequest() {}

  explicit GetEdgeDriverVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~GetEdgeDriverVersionRequest() = default;
};
class GetEdgeDriverVersionResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> argument{};
  shared_ptr<string> configCheckRule{};
  shared_ptr<string> containerConfig{};
  shared_ptr<string> description{};
  shared_ptr<string> driverConfig{};
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};
  shared_ptr<string> edgeVersion{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<string> sourceConfig{};
  shared_ptr<string> versionState{};

  GetEdgeDriverVersionResponseBodyData() {}

  explicit GetEdgeDriverVersionResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (argument) {
      res["Argument"] = boost::any(*argument);
    }
    if (configCheckRule) {
      res["ConfigCheckRule"] = boost::any(*configCheckRule);
    }
    if (containerConfig) {
      res["ContainerConfig"] = boost::any(*containerConfig);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (driverConfig) {
      res["DriverConfig"] = boost::any(*driverConfig);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    if (edgeVersion) {
      res["EdgeVersion"] = boost::any(*edgeVersion);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (sourceConfig) {
      res["SourceConfig"] = boost::any(*sourceConfig);
    }
    if (versionState) {
      res["VersionState"] = boost::any(*versionState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Argument") != m.end() && !m["Argument"].empty()) {
      argument = make_shared<string>(boost::any_cast<string>(m["Argument"]));
    }
    if (m.find("ConfigCheckRule") != m.end() && !m["ConfigCheckRule"].empty()) {
      configCheckRule = make_shared<string>(boost::any_cast<string>(m["ConfigCheckRule"]));
    }
    if (m.find("ContainerConfig") != m.end() && !m["ContainerConfig"].empty()) {
      containerConfig = make_shared<string>(boost::any_cast<string>(m["ContainerConfig"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DriverConfig") != m.end() && !m["DriverConfig"].empty()) {
      driverConfig = make_shared<string>(boost::any_cast<string>(m["DriverConfig"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
    if (m.find("EdgeVersion") != m.end() && !m["EdgeVersion"].empty()) {
      edgeVersion = make_shared<string>(boost::any_cast<string>(m["EdgeVersion"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("SourceConfig") != m.end() && !m["SourceConfig"].empty()) {
      sourceConfig = make_shared<string>(boost::any_cast<string>(m["SourceConfig"]));
    }
    if (m.find("VersionState") != m.end() && !m["VersionState"].empty()) {
      versionState = make_shared<string>(boost::any_cast<string>(m["VersionState"]));
    }
  }


  virtual ~GetEdgeDriverVersionResponseBodyData() = default;
};
class GetEdgeDriverVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetEdgeDriverVersionResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetEdgeDriverVersionResponseBody() {}

  explicit GetEdgeDriverVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetEdgeDriverVersionResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetEdgeDriverVersionResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetEdgeDriverVersionResponseBody() = default;
};
class GetEdgeDriverVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEdgeDriverVersionResponseBody> body{};

  GetEdgeDriverVersionResponse() {}

  explicit GetEdgeDriverVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEdgeDriverVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEdgeDriverVersionResponseBody>(model1);
      }
    }
  }


  virtual ~GetEdgeDriverVersionResponse() = default;
};
class GetEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};

  GetEdgeInstanceRequest() {}

  explicit GetEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~GetEdgeInstanceRequest() = default;
};
class GetEdgeInstanceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> bizEnable{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> latestDeploymentStatus{};
  shared_ptr<string> latestDeploymentType{};
  shared_ptr<string> name{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> roleAttachTime{};
  shared_ptr<long> roleAttachTimestamp{};
  shared_ptr<string> roleName{};
  shared_ptr<long> spec{};
  shared_ptr<string> tags{};
  shared_ptr<string> type{};

  GetEdgeInstanceResponseBodyData() {}

  explicit GetEdgeInstanceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizEnable) {
      res["BizEnable"] = boost::any(*bizEnable);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (latestDeploymentStatus) {
      res["LatestDeploymentStatus"] = boost::any(*latestDeploymentStatus);
    }
    if (latestDeploymentType) {
      res["LatestDeploymentType"] = boost::any(*latestDeploymentType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (roleAttachTime) {
      res["RoleAttachTime"] = boost::any(*roleAttachTime);
    }
    if (roleAttachTimestamp) {
      res["RoleAttachTimestamp"] = boost::any(*roleAttachTimestamp);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizEnable") != m.end() && !m["BizEnable"].empty()) {
      bizEnable = make_shared<bool>(boost::any_cast<bool>(m["BizEnable"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LatestDeploymentStatus") != m.end() && !m["LatestDeploymentStatus"].empty()) {
      latestDeploymentStatus = make_shared<long>(boost::any_cast<long>(m["LatestDeploymentStatus"]));
    }
    if (m.find("LatestDeploymentType") != m.end() && !m["LatestDeploymentType"].empty()) {
      latestDeploymentType = make_shared<string>(boost::any_cast<string>(m["LatestDeploymentType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("RoleAttachTime") != m.end() && !m["RoleAttachTime"].empty()) {
      roleAttachTime = make_shared<string>(boost::any_cast<string>(m["RoleAttachTime"]));
    }
    if (m.find("RoleAttachTimestamp") != m.end() && !m["RoleAttachTimestamp"].empty()) {
      roleAttachTimestamp = make_shared<long>(boost::any_cast<long>(m["RoleAttachTimestamp"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<long>(boost::any_cast<long>(m["Spec"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetEdgeInstanceResponseBodyData() = default;
};
class GetEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetEdgeInstanceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetEdgeInstanceResponseBody() {}

  explicit GetEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetEdgeInstanceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetEdgeInstanceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetEdgeInstanceResponseBody() = default;
};
class GetEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEdgeInstanceResponseBody> body{};

  GetEdgeInstanceResponse() {}

  explicit GetEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~GetEdgeInstanceResponse() = default;
};
class GetEdgeInstanceDeploymentRequest : public Darabonba::Model {
public:
  shared_ptr<string> deploymentId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};

  GetEdgeInstanceDeploymentRequest() {}

  explicit GetEdgeInstanceDeploymentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deploymentId) {
      res["DeploymentId"] = boost::any(*deploymentId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeploymentId") != m.end() && !m["DeploymentId"].empty()) {
      deploymentId = make_shared<string>(boost::any_cast<string>(m["DeploymentId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~GetEdgeInstanceDeploymentRequest() = default;
};
class GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList : public Darabonba::Model {
public:
  shared_ptr<string> gmtCompleted{};
  shared_ptr<long> gmtCompletedTimestamp{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<string> log{};
  shared_ptr<long> operateType{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceName{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> snapshotId{};
  shared_ptr<long> stage{};
  shared_ptr<long> status{};

  GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList() {}

  explicit GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCompleted) {
      res["GmtCompleted"] = boost::any(*gmtCompleted);
    }
    if (gmtCompletedTimestamp) {
      res["GmtCompletedTimestamp"] = boost::any(*gmtCompletedTimestamp);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (log) {
      res["Log"] = boost::any(*log);
    }
    if (operateType) {
      res["OperateType"] = boost::any(*operateType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (stage) {
      res["Stage"] = boost::any(*stage);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCompleted") != m.end() && !m["GmtCompleted"].empty()) {
      gmtCompleted = make_shared<string>(boost::any_cast<string>(m["GmtCompleted"]));
    }
    if (m.find("GmtCompletedTimestamp") != m.end() && !m["GmtCompletedTimestamp"].empty()) {
      gmtCompletedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCompletedTimestamp"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("Log") != m.end() && !m["Log"].empty()) {
      log = make_shared<string>(boost::any_cast<string>(m["Log"]));
    }
    if (m.find("OperateType") != m.end() && !m["OperateType"].empty()) {
      operateType = make_shared<long>(boost::any_cast<long>(m["OperateType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("Stage") != m.end() && !m["Stage"].empty()) {
      stage = make_shared<long>(boost::any_cast<long>(m["Stage"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList() = default;
};
class GetEdgeInstanceDeploymentResponseBodyDataTaskList : public Darabonba::Model {
public:
  shared_ptr<string> gatewayId{};
  shared_ptr<string> gmtCompleted{};
  shared_ptr<long> gmtCompletedTimestamp{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<vector<GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList>> resourceSnapshotList{};
  shared_ptr<long> stage{};
  shared_ptr<long> status{};
  shared_ptr<string> taskId{};

  GetEdgeInstanceDeploymentResponseBodyDataTaskList() {}

  explicit GetEdgeInstanceDeploymentResponseBodyDataTaskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gmtCompleted) {
      res["GmtCompleted"] = boost::any(*gmtCompleted);
    }
    if (gmtCompletedTimestamp) {
      res["GmtCompletedTimestamp"] = boost::any(*gmtCompletedTimestamp);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (resourceSnapshotList) {
      vector<boost::any> temp1;
      for(auto item1:*resourceSnapshotList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceSnapshotList"] = boost::any(temp1);
    }
    if (stage) {
      res["Stage"] = boost::any(*stage);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<string>(boost::any_cast<string>(m["GatewayId"]));
    }
    if (m.find("GmtCompleted") != m.end() && !m["GmtCompleted"].empty()) {
      gmtCompleted = make_shared<string>(boost::any_cast<string>(m["GmtCompleted"]));
    }
    if (m.find("GmtCompletedTimestamp") != m.end() && !m["GmtCompletedTimestamp"].empty()) {
      gmtCompletedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCompletedTimestamp"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("ResourceSnapshotList") != m.end() && !m["ResourceSnapshotList"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceSnapshotList"].type()) {
        vector<GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceSnapshotList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceSnapshotList = make_shared<vector<GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList>>(expect1);
      }
    }
    if (m.find("Stage") != m.end() && !m["Stage"].empty()) {
      stage = make_shared<long>(boost::any_cast<long>(m["Stage"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetEdgeInstanceDeploymentResponseBodyDataTaskList() = default;
};
class GetEdgeInstanceDeploymentResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> deploymentId{};
  shared_ptr<string> description{};
  shared_ptr<string> gmtCompleted{};
  shared_ptr<long> gmtCompletedTimestamp{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<long> status{};
  shared_ptr<vector<GetEdgeInstanceDeploymentResponseBodyDataTaskList>> taskList{};
  shared_ptr<string> type{};

  GetEdgeInstanceDeploymentResponseBodyData() {}

  explicit GetEdgeInstanceDeploymentResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deploymentId) {
      res["DeploymentId"] = boost::any(*deploymentId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCompleted) {
      res["GmtCompleted"] = boost::any(*gmtCompleted);
    }
    if (gmtCompletedTimestamp) {
      res["GmtCompletedTimestamp"] = boost::any(*gmtCompletedTimestamp);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskList) {
      vector<boost::any> temp1;
      for(auto item1:*taskList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskList"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeploymentId") != m.end() && !m["DeploymentId"].empty()) {
      deploymentId = make_shared<string>(boost::any_cast<string>(m["DeploymentId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCompleted") != m.end() && !m["GmtCompleted"].empty()) {
      gmtCompleted = make_shared<string>(boost::any_cast<string>(m["GmtCompleted"]));
    }
    if (m.find("GmtCompletedTimestamp") != m.end() && !m["GmtCompletedTimestamp"].empty()) {
      gmtCompletedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCompletedTimestamp"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TaskList") != m.end() && !m["TaskList"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskList"].type()) {
        vector<GetEdgeInstanceDeploymentResponseBodyDataTaskList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEdgeInstanceDeploymentResponseBodyDataTaskList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskList = make_shared<vector<GetEdgeInstanceDeploymentResponseBodyDataTaskList>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetEdgeInstanceDeploymentResponseBodyData() = default;
};
class GetEdgeInstanceDeploymentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetEdgeInstanceDeploymentResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetEdgeInstanceDeploymentResponseBody() {}

  explicit GetEdgeInstanceDeploymentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetEdgeInstanceDeploymentResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetEdgeInstanceDeploymentResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetEdgeInstanceDeploymentResponseBody() = default;
};
class GetEdgeInstanceDeploymentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEdgeInstanceDeploymentResponseBody> body{};

  GetEdgeInstanceDeploymentResponse() {}

  explicit GetEdgeInstanceDeploymentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEdgeInstanceDeploymentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEdgeInstanceDeploymentResponseBody>(model1);
      }
    }
  }


  virtual ~GetEdgeInstanceDeploymentResponse() = default;
};
class GetEdgeInstanceMessageRoutingRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> routeId{};

  GetEdgeInstanceMessageRoutingRequest() {}

  explicit GetEdgeInstanceMessageRoutingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<long>(boost::any_cast<long>(m["RouteId"]));
    }
  }


  virtual ~GetEdgeInstanceMessageRoutingRequest() = default;
};
class GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext : public Darabonba::Model {
public:
  shared_ptr<string> qos{};
  shared_ptr<string> sourceApplicationName{};
  shared_ptr<string> sourceFcFunctionName{};
  shared_ptr<string> sourceFcServiceName{};
  shared_ptr<string> targetApplicationName{};
  shared_ptr<string> targetFcFunctionName{};
  shared_ptr<string> targetFcServiceName{};

  GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext() {}

  explicit GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qos) {
      res["Qos"] = boost::any(*qos);
    }
    if (sourceApplicationName) {
      res["SourceApplicationName"] = boost::any(*sourceApplicationName);
    }
    if (sourceFcFunctionName) {
      res["SourceFcFunctionName"] = boost::any(*sourceFcFunctionName);
    }
    if (sourceFcServiceName) {
      res["SourceFcServiceName"] = boost::any(*sourceFcServiceName);
    }
    if (targetApplicationName) {
      res["TargetApplicationName"] = boost::any(*targetApplicationName);
    }
    if (targetFcFunctionName) {
      res["TargetFcFunctionName"] = boost::any(*targetFcFunctionName);
    }
    if (targetFcServiceName) {
      res["TargetFcServiceName"] = boost::any(*targetFcServiceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Qos") != m.end() && !m["Qos"].empty()) {
      qos = make_shared<string>(boost::any_cast<string>(m["Qos"]));
    }
    if (m.find("SourceApplicationName") != m.end() && !m["SourceApplicationName"].empty()) {
      sourceApplicationName = make_shared<string>(boost::any_cast<string>(m["SourceApplicationName"]));
    }
    if (m.find("SourceFcFunctionName") != m.end() && !m["SourceFcFunctionName"].empty()) {
      sourceFcFunctionName = make_shared<string>(boost::any_cast<string>(m["SourceFcFunctionName"]));
    }
    if (m.find("SourceFcServiceName") != m.end() && !m["SourceFcServiceName"].empty()) {
      sourceFcServiceName = make_shared<string>(boost::any_cast<string>(m["SourceFcServiceName"]));
    }
    if (m.find("TargetApplicationName") != m.end() && !m["TargetApplicationName"].empty()) {
      targetApplicationName = make_shared<string>(boost::any_cast<string>(m["TargetApplicationName"]));
    }
    if (m.find("TargetFcFunctionName") != m.end() && !m["TargetFcFunctionName"].empty()) {
      targetFcFunctionName = make_shared<string>(boost::any_cast<string>(m["TargetFcFunctionName"]));
    }
    if (m.find("TargetFcServiceName") != m.end() && !m["TargetFcServiceName"].empty()) {
      targetFcServiceName = make_shared<string>(boost::any_cast<string>(m["TargetFcServiceName"]));
    }
  }


  virtual ~GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext() = default;
};
class GetEdgeInstanceMessageRoutingResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreate{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<string> name{};
  shared_ptr<GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext> routeContext{};
  shared_ptr<string> sourceData{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> targetData{};
  shared_ptr<string> targetType{};
  shared_ptr<string> topicFilter{};

  GetEdgeInstanceMessageRoutingResponseBodyData() {}

  explicit GetEdgeInstanceMessageRoutingResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (routeContext) {
      res["RouteContext"] = routeContext ? boost::any(routeContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourceData) {
      res["SourceData"] = boost::any(*sourceData);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (targetData) {
      res["TargetData"] = boost::any(*targetData);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (topicFilter) {
      res["TopicFilter"] = boost::any(*topicFilter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RouteContext") != m.end() && !m["RouteContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["RouteContext"].type()) {
        GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RouteContext"]));
        routeContext = make_shared<GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext>(model1);
      }
    }
    if (m.find("SourceData") != m.end() && !m["SourceData"].empty()) {
      sourceData = make_shared<string>(boost::any_cast<string>(m["SourceData"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("TargetData") != m.end() && !m["TargetData"].empty()) {
      targetData = make_shared<string>(boost::any_cast<string>(m["TargetData"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("TopicFilter") != m.end() && !m["TopicFilter"].empty()) {
      topicFilter = make_shared<string>(boost::any_cast<string>(m["TopicFilter"]));
    }
  }


  virtual ~GetEdgeInstanceMessageRoutingResponseBodyData() = default;
};
class GetEdgeInstanceMessageRoutingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetEdgeInstanceMessageRoutingResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetEdgeInstanceMessageRoutingResponseBody() {}

  explicit GetEdgeInstanceMessageRoutingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetEdgeInstanceMessageRoutingResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetEdgeInstanceMessageRoutingResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetEdgeInstanceMessageRoutingResponseBody() = default;
};
class GetEdgeInstanceMessageRoutingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEdgeInstanceMessageRoutingResponseBody> body{};

  GetEdgeInstanceMessageRoutingResponse() {}

  explicit GetEdgeInstanceMessageRoutingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEdgeInstanceMessageRoutingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEdgeInstanceMessageRoutingResponseBody>(model1);
      }
    }
  }


  virtual ~GetEdgeInstanceMessageRoutingResponse() = default;
};
class GetGatewayBySubDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  GetGatewayBySubDeviceRequest() {}

  explicit GetGatewayBySubDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~GetGatewayBySubDeviceRequest() = default;
};
class GetGatewayBySubDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceSecret{};
  shared_ptr<string> firmwareVersion{};
  shared_ptr<string> gmtActive{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtOnline{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> nodeType{};
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};
  shared_ptr<string> status{};
  shared_ptr<string> utcActive{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> utcOnline{};
  shared_ptr<string> iotId{};
  shared_ptr<string> region{};

  GetGatewayBySubDeviceResponseBodyData() {}

  explicit GetGatewayBySubDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceSecret) {
      res["DeviceSecret"] = boost::any(*deviceSecret);
    }
    if (firmwareVersion) {
      res["FirmwareVersion"] = boost::any(*firmwareVersion);
    }
    if (gmtActive) {
      res["GmtActive"] = boost::any(*gmtActive);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtOnline) {
      res["GmtOnline"] = boost::any(*gmtOnline);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (utcActive) {
      res["UtcActive"] = boost::any(*utcActive);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (utcOnline) {
      res["UtcOnline"] = boost::any(*utcOnline);
    }
    if (iotId) {
      res["iotId"] = boost::any(*iotId);
    }
    if (region) {
      res["region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceSecret") != m.end() && !m["DeviceSecret"].empty()) {
      deviceSecret = make_shared<string>(boost::any_cast<string>(m["DeviceSecret"]));
    }
    if (m.find("FirmwareVersion") != m.end() && !m["FirmwareVersion"].empty()) {
      firmwareVersion = make_shared<string>(boost::any_cast<string>(m["FirmwareVersion"]));
    }
    if (m.find("GmtActive") != m.end() && !m["GmtActive"].empty()) {
      gmtActive = make_shared<string>(boost::any_cast<string>(m["GmtActive"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtOnline") != m.end() && !m["GmtOnline"].empty()) {
      gmtOnline = make_shared<string>(boost::any_cast<string>(m["GmtOnline"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UtcActive") != m.end() && !m["UtcActive"].empty()) {
      utcActive = make_shared<string>(boost::any_cast<string>(m["UtcActive"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("UtcOnline") != m.end() && !m["UtcOnline"].empty()) {
      utcOnline = make_shared<string>(boost::any_cast<string>(m["UtcOnline"]));
    }
    if (m.find("iotId") != m.end() && !m["iotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["iotId"]));
    }
    if (m.find("region") != m.end() && !m["region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["region"]));
    }
  }


  virtual ~GetGatewayBySubDeviceResponseBodyData() = default;
};
class GetGatewayBySubDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetGatewayBySubDeviceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetGatewayBySubDeviceResponseBody() {}

  explicit GetGatewayBySubDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetGatewayBySubDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetGatewayBySubDeviceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetGatewayBySubDeviceResponseBody() = default;
};
class GetGatewayBySubDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetGatewayBySubDeviceResponseBody> body{};

  GetGatewayBySubDeviceResponse() {}

  explicit GetGatewayBySubDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetGatewayBySubDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetGatewayBySubDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~GetGatewayBySubDeviceResponse() = default;
};
class GetLoraNodesTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> taskId{};

  GetLoraNodesTaskRequest() {}

  explicit GetLoraNodesTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetLoraNodesTaskRequest() = default;
};
class GetLoraNodesTaskResponseBodySuccessDevEuis : public Darabonba::Model {
public:
  shared_ptr<vector<string>> successDevEui{};

  GetLoraNodesTaskResponseBodySuccessDevEuis() {}

  explicit GetLoraNodesTaskResponseBodySuccessDevEuis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (successDevEui) {
      res["SuccessDevEui"] = boost::any(*successDevEui);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SuccessDevEui") != m.end() && !m["SuccessDevEui"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SuccessDevEui"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SuccessDevEui"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      successDevEui = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetLoraNodesTaskResponseBodySuccessDevEuis() = default;
};
class GetLoraNodesTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> successCount{};
  shared_ptr<GetLoraNodesTaskResponseBodySuccessDevEuis> successDevEuis{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskState{};
  shared_ptr<long> totalCount{};

  GetLoraNodesTaskResponseBody() {}

  explicit GetLoraNodesTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    if (successDevEuis) {
      res["SuccessDevEuis"] = successDevEuis ? boost::any(successDevEuis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskState) {
      res["TaskState"] = boost::any(*taskState);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
    if (m.find("SuccessDevEuis") != m.end() && !m["SuccessDevEuis"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuccessDevEuis"].type()) {
        GetLoraNodesTaskResponseBodySuccessDevEuis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SuccessDevEuis"]));
        successDevEuis = make_shared<GetLoraNodesTaskResponseBodySuccessDevEuis>(model1);
      }
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskState") != m.end() && !m["TaskState"].empty()) {
      taskState = make_shared<string>(boost::any_cast<string>(m["TaskState"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetLoraNodesTaskResponseBody() = default;
};
class GetLoraNodesTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLoraNodesTaskResponseBody> body{};

  GetLoraNodesTaskResponse() {}

  explicit GetLoraNodesTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLoraNodesTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLoraNodesTaskResponseBody>(model1);
      }
    }
  }


  virtual ~GetLoraNodesTaskResponse() = default;
};
class GetParserRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> parserId{};

  GetParserRequest() {}

  explicit GetParserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (parserId) {
      res["ParserId"] = boost::any(*parserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ParserId") != m.end() && !m["ParserId"].empty()) {
      parserId = make_shared<long>(boost::any_cast<long>(m["ParserId"]));
    }
  }


  virtual ~GetParserRequest() = default;
};
class GetParserResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<long> parserId{};
  shared_ptr<string> script{};
  shared_ptr<string> scriptDraft{};
  shared_ptr<string> status{};
  shared_ptr<string> utcCreated{};
  shared_ptr<string> utcModified{};

  GetParserResponseBodyData() {}

  explicit GetParserResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parserId) {
      res["ParserId"] = boost::any(*parserId);
    }
    if (script) {
      res["Script"] = boost::any(*script);
    }
    if (scriptDraft) {
      res["ScriptDraft"] = boost::any(*scriptDraft);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (utcCreated) {
      res["UtcCreated"] = boost::any(*utcCreated);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParserId") != m.end() && !m["ParserId"].empty()) {
      parserId = make_shared<long>(boost::any_cast<long>(m["ParserId"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
    if (m.find("ScriptDraft") != m.end() && !m["ScriptDraft"].empty()) {
      scriptDraft = make_shared<string>(boost::any_cast<string>(m["ScriptDraft"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UtcCreated") != m.end() && !m["UtcCreated"].empty()) {
      utcCreated = make_shared<string>(boost::any_cast<string>(m["UtcCreated"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
  }


  virtual ~GetParserResponseBodyData() = default;
};
class GetParserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetParserResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetParserResponseBody() {}

  explicit GetParserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetParserResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetParserResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetParserResponseBody() = default;
};
class GetParserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetParserResponseBody> body{};

  GetParserResponse() {}

  explicit GetParserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetParserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetParserResponseBody>(model1);
      }
    }
  }


  virtual ~GetParserResponse() = default;
};
class GetParserDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> iotInstanceId{};

  GetParserDataSourceRequest() {}

  explicit GetParserDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~GetParserDataSourceRequest() = default;
};
class GetParserDataSourceResponseBodyDataSource : public Darabonba::Model {
public:
  shared_ptr<long> createUserId{};
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> utcCreated{};

  GetParserDataSourceResponseBodyDataSource() {}

  explicit GetParserDataSourceResponseBodyDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createUserId) {
      res["CreateUserId"] = boost::any(*createUserId);
    }
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (utcCreated) {
      res["UtcCreated"] = boost::any(*utcCreated);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateUserId") != m.end() && !m["CreateUserId"].empty()) {
      createUserId = make_shared<long>(boost::any_cast<long>(m["CreateUserId"]));
    }
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UtcCreated") != m.end() && !m["UtcCreated"].empty()) {
      utcCreated = make_shared<string>(boost::any_cast<string>(m["UtcCreated"]));
    }
  }


  virtual ~GetParserDataSourceResponseBodyDataSource() = default;
};
class GetParserDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetParserDataSourceResponseBodyDataSource> dataSource{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetParserDataSourceResponseBody() {}

  explicit GetParserDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dataSource) {
      res["DataSource"] = dataSource ? boost::any(dataSource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSource"].type()) {
        GetParserDataSourceResponseBodyDataSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSource"]));
        dataSource = make_shared<GetParserDataSourceResponseBodyDataSource>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetParserDataSourceResponseBody() = default;
};
class GetParserDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetParserDataSourceResponseBody> body{};

  GetParserDataSourceResponse() {}

  explicit GetParserDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetParserDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetParserDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~GetParserDataSourceResponse() = default;
};
class GetRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> ruleId{};

  GetRuleRequest() {}

  explicit GetRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~GetRuleRequest() = default;
};
class GetRuleResponseBodyRuleInfo : public Darabonba::Model {
public:
  shared_ptr<long> createUserId{};
  shared_ptr<string> created{};
  shared_ptr<string> dataType{};
  shared_ptr<long> id{};
  shared_ptr<string> modified{};
  shared_ptr<string> name{};
  shared_ptr<string> productKey{};
  shared_ptr<string> ruleDesc{};
  shared_ptr<string> select{};
  shared_ptr<string> shortTopic{};
  shared_ptr<string> status{};
  shared_ptr<string> topic{};
  shared_ptr<long> topicType{};
  shared_ptr<string> utcCreated{};
  shared_ptr<string> utcModified{};
  shared_ptr<string> where{};

  GetRuleResponseBodyRuleInfo() {}

  explicit GetRuleResponseBodyRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createUserId) {
      res["CreateUserId"] = boost::any(*createUserId);
    }
    if (created) {
      res["Created"] = boost::any(*created);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modified) {
      res["Modified"] = boost::any(*modified);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (ruleDesc) {
      res["RuleDesc"] = boost::any(*ruleDesc);
    }
    if (select) {
      res["Select"] = boost::any(*select);
    }
    if (shortTopic) {
      res["ShortTopic"] = boost::any(*shortTopic);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (topicType) {
      res["TopicType"] = boost::any(*topicType);
    }
    if (utcCreated) {
      res["UtcCreated"] = boost::any(*utcCreated);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (where) {
      res["Where"] = boost::any(*where);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateUserId") != m.end() && !m["CreateUserId"].empty()) {
      createUserId = make_shared<long>(boost::any_cast<long>(m["CreateUserId"]));
    }
    if (m.find("Created") != m.end() && !m["Created"].empty()) {
      created = make_shared<string>(boost::any_cast<string>(m["Created"]));
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Modified") != m.end() && !m["Modified"].empty()) {
      modified = make_shared<string>(boost::any_cast<string>(m["Modified"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("RuleDesc") != m.end() && !m["RuleDesc"].empty()) {
      ruleDesc = make_shared<string>(boost::any_cast<string>(m["RuleDesc"]));
    }
    if (m.find("Select") != m.end() && !m["Select"].empty()) {
      select = make_shared<string>(boost::any_cast<string>(m["Select"]));
    }
    if (m.find("ShortTopic") != m.end() && !m["ShortTopic"].empty()) {
      shortTopic = make_shared<string>(boost::any_cast<string>(m["ShortTopic"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("TopicType") != m.end() && !m["TopicType"].empty()) {
      topicType = make_shared<long>(boost::any_cast<long>(m["TopicType"]));
    }
    if (m.find("UtcCreated") != m.end() && !m["UtcCreated"].empty()) {
      utcCreated = make_shared<string>(boost::any_cast<string>(m["UtcCreated"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("Where") != m.end() && !m["Where"].empty()) {
      where = make_shared<string>(boost::any_cast<string>(m["Where"]));
    }
  }


  virtual ~GetRuleResponseBodyRuleInfo() = default;
};
class GetRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<GetRuleResponseBodyRuleInfo> ruleInfo{};
  shared_ptr<bool> success{};

  GetRuleResponseBody() {}

  explicit GetRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleInfo) {
      res["RuleInfo"] = ruleInfo ? boost::any(ruleInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleInfo") != m.end() && !m["RuleInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuleInfo"].type()) {
        GetRuleResponseBodyRuleInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuleInfo"]));
        ruleInfo = make_shared<GetRuleResponseBodyRuleInfo>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetRuleResponseBody() = default;
};
class GetRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRuleResponseBody> body{};

  GetRuleResponse() {}

  explicit GetRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRuleResponseBody>(model1);
      }
    }
  }


  virtual ~GetRuleResponse() = default;
};
class GetRuleActionRequest : public Darabonba::Model {
public:
  shared_ptr<long> actionId{};
  shared_ptr<string> iotInstanceId{};

  GetRuleActionRequest() {}

  explicit GetRuleActionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionId) {
      res["ActionId"] = boost::any(*actionId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionId") != m.end() && !m["ActionId"].empty()) {
      actionId = make_shared<long>(boost::any_cast<long>(m["ActionId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~GetRuleActionRequest() = default;
};
class GetRuleActionResponseBodyRuleActionInfo : public Darabonba::Model {
public:
  shared_ptr<string> configuration{};
  shared_ptr<bool> errorActionFlag{};
  shared_ptr<long> id{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> type{};

  GetRuleActionResponseBodyRuleActionInfo() {}

  explicit GetRuleActionResponseBodyRuleActionInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configuration) {
      res["Configuration"] = boost::any(*configuration);
    }
    if (errorActionFlag) {
      res["ErrorActionFlag"] = boost::any(*errorActionFlag);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configuration = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
    if (m.find("ErrorActionFlag") != m.end() && !m["ErrorActionFlag"].empty()) {
      errorActionFlag = make_shared<bool>(boost::any_cast<bool>(m["ErrorActionFlag"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetRuleActionResponseBodyRuleActionInfo() = default;
};
class GetRuleActionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<GetRuleActionResponseBodyRuleActionInfo> ruleActionInfo{};
  shared_ptr<bool> success{};

  GetRuleActionResponseBody() {}

  explicit GetRuleActionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleActionInfo) {
      res["RuleActionInfo"] = ruleActionInfo ? boost::any(ruleActionInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleActionInfo") != m.end() && !m["RuleActionInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuleActionInfo"].type()) {
        GetRuleActionResponseBodyRuleActionInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuleActionInfo"]));
        ruleActionInfo = make_shared<GetRuleActionResponseBodyRuleActionInfo>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetRuleActionResponseBody() = default;
};
class GetRuleActionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRuleActionResponseBody> body{};

  GetRuleActionResponse() {}

  explicit GetRuleActionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRuleActionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRuleActionResponseBody>(model1);
      }
    }
  }


  virtual ~GetRuleActionResponse() = default;
};
class GetSceneRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> ruleId{};

  GetSceneRuleRequest() {}

  explicit GetSceneRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~GetSceneRuleRequest() = default;
};
class GetSceneRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> ruleContent{};
  shared_ptr<string> ruleDescription{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> ruleStatus{};

  GetSceneRuleResponseBodyData() {}

  explicit GetSceneRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (ruleContent) {
      res["RuleContent"] = boost::any(*ruleContent);
    }
    if (ruleDescription) {
      res["RuleDescription"] = boost::any(*ruleDescription);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleStatus) {
      res["RuleStatus"] = boost::any(*ruleStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("RuleContent") != m.end() && !m["RuleContent"].empty()) {
      ruleContent = make_shared<string>(boost::any_cast<string>(m["RuleContent"]));
    }
    if (m.find("RuleDescription") != m.end() && !m["RuleDescription"].empty()) {
      ruleDescription = make_shared<string>(boost::any_cast<string>(m["RuleDescription"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleStatus") != m.end() && !m["RuleStatus"].empty()) {
      ruleStatus = make_shared<long>(boost::any_cast<long>(m["RuleStatus"]));
    }
  }


  virtual ~GetSceneRuleResponseBodyData() = default;
};
class GetSceneRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetSceneRuleResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetSceneRuleResponseBody() {}

  explicit GetSceneRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetSceneRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetSceneRuleResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetSceneRuleResponseBody() = default;
};
class GetSceneRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSceneRuleResponseBody> body{};

  GetSceneRuleResponse() {}

  explicit GetSceneRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSceneRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSceneRuleResponseBody>(model1);
      }
    }
  }


  virtual ~GetSceneRuleResponse() = default;
};
class GetShareSpeechModelAudioRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> shareTaskId{};
  shared_ptr<vector<string>> speechModelCodeList{};

  GetShareSpeechModelAudioRequest() {}

  explicit GetShareSpeechModelAudioRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (shareTaskId) {
      res["ShareTaskId"] = boost::any(*shareTaskId);
    }
    if (speechModelCodeList) {
      res["SpeechModelCodeList"] = boost::any(*speechModelCodeList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ShareTaskId") != m.end() && !m["ShareTaskId"].empty()) {
      shareTaskId = make_shared<string>(boost::any_cast<string>(m["ShareTaskId"]));
    }
    if (m.find("SpeechModelCodeList") != m.end() && !m["SpeechModelCodeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SpeechModelCodeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SpeechModelCodeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      speechModelCodeList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetShareSpeechModelAudioRequest() = default;
};
class GetShareSpeechModelAudioResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> data{};

  GetShareSpeechModelAudioResponseBodyData() {}

  explicit GetShareSpeechModelAudioResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetShareSpeechModelAudioResponseBodyData() = default;
};
class GetShareSpeechModelAudioResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetShareSpeechModelAudioResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetShareSpeechModelAudioResponseBody() {}

  explicit GetShareSpeechModelAudioResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetShareSpeechModelAudioResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetShareSpeechModelAudioResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetShareSpeechModelAudioResponseBody() = default;
};
class GetShareSpeechModelAudioResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetShareSpeechModelAudioResponseBody> body{};

  GetShareSpeechModelAudioResponse() {}

  explicit GetShareSpeechModelAudioResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetShareSpeechModelAudioResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetShareSpeechModelAudioResponseBody>(model1);
      }
    }
  }


  virtual ~GetShareSpeechModelAudioResponse() = default;
};
class GetShareTaskByDeviceOpenRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  GetShareTaskByDeviceOpenRequest() {}

  explicit GetShareTaskByDeviceOpenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~GetShareTaskByDeviceOpenRequest() = default;
};
class GetShareTaskByDeviceOpenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetShareTaskByDeviceOpenResponseBody() {}

  explicit GetShareTaskByDeviceOpenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetShareTaskByDeviceOpenResponseBody() = default;
};
class GetShareTaskByDeviceOpenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetShareTaskByDeviceOpenResponseBody> body{};

  GetShareTaskByDeviceOpenResponse() {}

  explicit GetShareTaskByDeviceOpenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetShareTaskByDeviceOpenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetShareTaskByDeviceOpenResponseBody>(model1);
      }
    }
  }


  virtual ~GetShareTaskByDeviceOpenResponse() = default;
};
class GetSoundCodeAudioRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<string>> soundCodeList{};

  GetSoundCodeAudioRequest() {}

  explicit GetSoundCodeAudioRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (soundCodeList) {
      res["SoundCodeList"] = boost::any(*soundCodeList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("SoundCodeList") != m.end() && !m["SoundCodeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SoundCodeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SoundCodeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      soundCodeList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetSoundCodeAudioRequest() = default;
};
class GetSoundCodeAudioResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> items{};

  GetSoundCodeAudioResponseBodyData() {}

  explicit GetSoundCodeAudioResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      res["Items"] = boost::any(*items);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Items"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      items = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetSoundCodeAudioResponseBodyData() = default;
};
class GetSoundCodeAudioResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetSoundCodeAudioResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetSoundCodeAudioResponseBody() {}

  explicit GetSoundCodeAudioResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetSoundCodeAudioResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetSoundCodeAudioResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetSoundCodeAudioResponseBody() = default;
};
class GetSoundCodeAudioResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSoundCodeAudioResponseBody> body{};

  GetSoundCodeAudioResponse() {}

  explicit GetSoundCodeAudioResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSoundCodeAudioResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSoundCodeAudioResponseBody>(model1);
      }
    }
  }


  virtual ~GetSoundCodeAudioResponse() = default;
};
class GetSoundCodeScheduleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> scheduleCode{};

  GetSoundCodeScheduleRequest() {}

  explicit GetSoundCodeScheduleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (scheduleCode) {
      res["ScheduleCode"] = boost::any(*scheduleCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ScheduleCode") != m.end() && !m["ScheduleCode"].empty()) {
      scheduleCode = make_shared<string>(boost::any_cast<string>(m["ScheduleCode"]));
    }
  }


  virtual ~GetSoundCodeScheduleRequest() = default;
};
class GetSoundCodeScheduleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> endDate{};
  shared_ptr<string> endTime{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> name{};
  shared_ptr<string> openType{};
  shared_ptr<string> scheduleCode{};
  shared_ptr<string> startDate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  GetSoundCodeScheduleResponseBodyData() {}

  explicit GetSoundCodeScheduleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (openType) {
      res["OpenType"] = boost::any(*openType);
    }
    if (scheduleCode) {
      res["ScheduleCode"] = boost::any(*scheduleCode);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OpenType") != m.end() && !m["OpenType"].empty()) {
      openType = make_shared<string>(boost::any_cast<string>(m["OpenType"]));
    }
    if (m.find("ScheduleCode") != m.end() && !m["ScheduleCode"].empty()) {
      scheduleCode = make_shared<string>(boost::any_cast<string>(m["ScheduleCode"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetSoundCodeScheduleResponseBodyData() = default;
};
class GetSoundCodeScheduleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetSoundCodeScheduleResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetSoundCodeScheduleResponseBody() {}

  explicit GetSoundCodeScheduleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetSoundCodeScheduleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetSoundCodeScheduleResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetSoundCodeScheduleResponseBody() = default;
};
class GetSoundCodeScheduleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSoundCodeScheduleResponseBody> body{};

  GetSoundCodeScheduleResponse() {}

  explicit GetSoundCodeScheduleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSoundCodeScheduleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSoundCodeScheduleResponseBody>(model1);
      }
    }
  }


  virtual ~GetSoundCodeScheduleResponse() = default;
};
class GetSpeechDeviceDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};

  GetSpeechDeviceDetailRequest() {}

  explicit GetSpeechDeviceDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~GetSpeechDeviceDetailRequest() = default;
};
class GetSpeechDeviceDetailResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<double> availableSpace{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> productKey{};
  shared_ptr<long> speechListUpdateTime{};
  shared_ptr<string> status{};
  shared_ptr<double> totalSpace{};

  GetSpeechDeviceDetailResponseBodyData() {}

  explicit GetSpeechDeviceDetailResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableSpace) {
      res["AvailableSpace"] = boost::any(*availableSpace);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (speechListUpdateTime) {
      res["SpeechListUpdateTime"] = boost::any(*speechListUpdateTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (totalSpace) {
      res["TotalSpace"] = boost::any(*totalSpace);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableSpace") != m.end() && !m["AvailableSpace"].empty()) {
      availableSpace = make_shared<double>(boost::any_cast<double>(m["AvailableSpace"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("SpeechListUpdateTime") != m.end() && !m["SpeechListUpdateTime"].empty()) {
      speechListUpdateTime = make_shared<long>(boost::any_cast<long>(m["SpeechListUpdateTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TotalSpace") != m.end() && !m["TotalSpace"].empty()) {
      totalSpace = make_shared<double>(boost::any_cast<double>(m["TotalSpace"]));
    }
  }


  virtual ~GetSpeechDeviceDetailResponseBodyData() = default;
};
class GetSpeechDeviceDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetSpeechDeviceDetailResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetSpeechDeviceDetailResponseBody() {}

  explicit GetSpeechDeviceDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetSpeechDeviceDetailResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetSpeechDeviceDetailResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetSpeechDeviceDetailResponseBody() = default;
};
class GetSpeechDeviceDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSpeechDeviceDetailResponseBody> body{};

  GetSpeechDeviceDetailResponse() {}

  explicit GetSpeechDeviceDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSpeechDeviceDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSpeechDeviceDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetSpeechDeviceDetailResponse() = default;
};
class GetSpeechLicenseDeviceStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};

  GetSpeechLicenseDeviceStatisticsRequest() {}

  explicit GetSpeechLicenseDeviceStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~GetSpeechLicenseDeviceStatisticsRequest() = default;
};
class GetSpeechLicenseDeviceStatisticsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> availableQuota{};
  shared_ptr<long> expiredQuota{};
  shared_ptr<long> expiringQuota{};

  GetSpeechLicenseDeviceStatisticsResponseBodyData() {}

  explicit GetSpeechLicenseDeviceStatisticsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableQuota) {
      res["AvailableQuota"] = boost::any(*availableQuota);
    }
    if (expiredQuota) {
      res["ExpiredQuota"] = boost::any(*expiredQuota);
    }
    if (expiringQuota) {
      res["ExpiringQuota"] = boost::any(*expiringQuota);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableQuota") != m.end() && !m["AvailableQuota"].empty()) {
      availableQuota = make_shared<long>(boost::any_cast<long>(m["AvailableQuota"]));
    }
    if (m.find("ExpiredQuota") != m.end() && !m["ExpiredQuota"].empty()) {
      expiredQuota = make_shared<long>(boost::any_cast<long>(m["ExpiredQuota"]));
    }
    if (m.find("ExpiringQuota") != m.end() && !m["ExpiringQuota"].empty()) {
      expiringQuota = make_shared<long>(boost::any_cast<long>(m["ExpiringQuota"]));
    }
  }


  virtual ~GetSpeechLicenseDeviceStatisticsResponseBodyData() = default;
};
class GetSpeechLicenseDeviceStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetSpeechLicenseDeviceStatisticsResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetSpeechLicenseDeviceStatisticsResponseBody() {}

  explicit GetSpeechLicenseDeviceStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetSpeechLicenseDeviceStatisticsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetSpeechLicenseDeviceStatisticsResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetSpeechLicenseDeviceStatisticsResponseBody() = default;
};
class GetSpeechLicenseDeviceStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSpeechLicenseDeviceStatisticsResponseBody> body{};

  GetSpeechLicenseDeviceStatisticsResponse() {}

  explicit GetSpeechLicenseDeviceStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSpeechLicenseDeviceStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSpeechLicenseDeviceStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~GetSpeechLicenseDeviceStatisticsResponse() = default;
};
class GetSpeechVoiceResponseBodyDataItemsVoiceListItems : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> value{};

  GetSpeechVoiceResponseBodyDataItemsVoiceListItems() {}

  explicit GetSpeechVoiceResponseBodyDataItemsVoiceListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetSpeechVoiceResponseBodyDataItemsVoiceListItems() = default;
};
class GetSpeechVoiceResponseBodyDataItemsVoiceList : public Darabonba::Model {
public:
  shared_ptr<vector<GetSpeechVoiceResponseBodyDataItemsVoiceListItems>> items{};

  GetSpeechVoiceResponseBodyDataItemsVoiceList() {}

  explicit GetSpeechVoiceResponseBodyDataItemsVoiceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<GetSpeechVoiceResponseBodyDataItemsVoiceListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSpeechVoiceResponseBodyDataItemsVoiceListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<GetSpeechVoiceResponseBodyDataItemsVoiceListItems>>(expect1);
      }
    }
  }


  virtual ~GetSpeechVoiceResponseBodyDataItemsVoiceList() = default;
};
class GetSpeechVoiceResponseBodyDataItems : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> value{};
  shared_ptr<GetSpeechVoiceResponseBodyDataItemsVoiceList> voiceList{};

  GetSpeechVoiceResponseBodyDataItems() {}

  explicit GetSpeechVoiceResponseBodyDataItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (voiceList) {
      res["VoiceList"] = voiceList ? boost::any(voiceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("VoiceList") != m.end() && !m["VoiceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VoiceList"].type()) {
        GetSpeechVoiceResponseBodyDataItemsVoiceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VoiceList"]));
        voiceList = make_shared<GetSpeechVoiceResponseBodyDataItemsVoiceList>(model1);
      }
    }
  }


  virtual ~GetSpeechVoiceResponseBodyDataItems() = default;
};
class GetSpeechVoiceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetSpeechVoiceResponseBodyDataItems>> items{};

  GetSpeechVoiceResponseBodyData() {}

  explicit GetSpeechVoiceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<GetSpeechVoiceResponseBodyDataItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSpeechVoiceResponseBodyDataItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<GetSpeechVoiceResponseBodyDataItems>>(expect1);
      }
    }
  }


  virtual ~GetSpeechVoiceResponseBodyData() = default;
};
class GetSpeechVoiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetSpeechVoiceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetSpeechVoiceResponseBody() {}

  explicit GetSpeechVoiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetSpeechVoiceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetSpeechVoiceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetSpeechVoiceResponseBody() = default;
};
class GetSpeechVoiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSpeechVoiceResponseBody> body{};

  GetSpeechVoiceResponse() {}

  explicit GetSpeechVoiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSpeechVoiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSpeechVoiceResponseBody>(model1);
      }
    }
  }


  virtual ~GetSpeechVoiceResponse() = default;
};
class GetStudioAppTokenOpenRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> projectId{};

  GetStudioAppTokenOpenRequest() {}

  explicit GetStudioAppTokenOpenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~GetStudioAppTokenOpenRequest() = default;
};
class GetStudioAppTokenOpenResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> bizType{};
  shared_ptr<string> isEnable{};
  shared_ptr<string> token{};
  shared_ptr<string> type{};

  GetStudioAppTokenOpenResponseBodyData() {}

  explicit GetStudioAppTokenOpenResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (isEnable) {
      res["IsEnable"] = boost::any(*isEnable);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("IsEnable") != m.end() && !m["IsEnable"].empty()) {
      isEnable = make_shared<string>(boost::any_cast<string>(m["IsEnable"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetStudioAppTokenOpenResponseBodyData() = default;
};
class GetStudioAppTokenOpenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetStudioAppTokenOpenResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetStudioAppTokenOpenResponseBody() {}

  explicit GetStudioAppTokenOpenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetStudioAppTokenOpenResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetStudioAppTokenOpenResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetStudioAppTokenOpenResponseBody() = default;
};
class GetStudioAppTokenOpenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetStudioAppTokenOpenResponseBody> body{};

  GetStudioAppTokenOpenResponse() {}

  explicit GetStudioAppTokenOpenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetStudioAppTokenOpenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetStudioAppTokenOpenResponseBody>(model1);
      }
    }
  }


  virtual ~GetStudioAppTokenOpenResponse() = default;
};
class GetThingModelTslRequest : public Darabonba::Model {
public:
  shared_ptr<string> functionBlockId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> modelVersion{};
  shared_ptr<string> productKey{};
  shared_ptr<bool> simple{};

  GetThingModelTslRequest() {}

  explicit GetThingModelTslRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (modelVersion) {
      res["ModelVersion"] = boost::any(*modelVersion);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (simple) {
      res["Simple"] = boost::any(*simple);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ModelVersion") != m.end() && !m["ModelVersion"].empty()) {
      modelVersion = make_shared<string>(boost::any_cast<string>(m["ModelVersion"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Simple") != m.end() && !m["Simple"].empty()) {
      simple = make_shared<bool>(boost::any_cast<bool>(m["Simple"]));
    }
  }


  virtual ~GetThingModelTslRequest() = default;
};
class GetThingModelTslResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> tslStr{};
  shared_ptr<string> tslUri{};

  GetThingModelTslResponseBodyData() {}

  explicit GetThingModelTslResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tslStr) {
      res["TslStr"] = boost::any(*tslStr);
    }
    if (tslUri) {
      res["TslUri"] = boost::any(*tslUri);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TslStr") != m.end() && !m["TslStr"].empty()) {
      tslStr = make_shared<string>(boost::any_cast<string>(m["TslStr"]));
    }
    if (m.find("TslUri") != m.end() && !m["TslUri"].empty()) {
      tslUri = make_shared<string>(boost::any_cast<string>(m["TslUri"]));
    }
  }


  virtual ~GetThingModelTslResponseBodyData() = default;
};
class GetThingModelTslResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetThingModelTslResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetThingModelTslResponseBody() {}

  explicit GetThingModelTslResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetThingModelTslResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetThingModelTslResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetThingModelTslResponseBody() = default;
};
class GetThingModelTslResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetThingModelTslResponseBody> body{};

  GetThingModelTslResponse() {}

  explicit GetThingModelTslResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetThingModelTslResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetThingModelTslResponseBody>(model1);
      }
    }
  }


  virtual ~GetThingModelTslResponse() = default;
};
class GetThingModelTslPublishedRequest : public Darabonba::Model {
public:
  shared_ptr<string> functionBlockId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> modelVersion{};
  shared_ptr<string> productKey{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> simple{};

  GetThingModelTslPublishedRequest() {}

  explicit GetThingModelTslPublishedRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (modelVersion) {
      res["ModelVersion"] = boost::any(*modelVersion);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (simple) {
      res["Simple"] = boost::any(*simple);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ModelVersion") != m.end() && !m["ModelVersion"].empty()) {
      modelVersion = make_shared<string>(boost::any_cast<string>(m["ModelVersion"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Simple") != m.end() && !m["Simple"].empty()) {
      simple = make_shared<bool>(boost::any_cast<bool>(m["Simple"]));
    }
  }


  virtual ~GetThingModelTslPublishedRequest() = default;
};
class GetThingModelTslPublishedResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> tslStr{};
  shared_ptr<string> tslUri{};

  GetThingModelTslPublishedResponseBodyData() {}

  explicit GetThingModelTslPublishedResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tslStr) {
      res["TslStr"] = boost::any(*tslStr);
    }
    if (tslUri) {
      res["TslUri"] = boost::any(*tslUri);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TslStr") != m.end() && !m["TslStr"].empty()) {
      tslStr = make_shared<string>(boost::any_cast<string>(m["TslStr"]));
    }
    if (m.find("TslUri") != m.end() && !m["TslUri"].empty()) {
      tslUri = make_shared<string>(boost::any_cast<string>(m["TslUri"]));
    }
  }


  virtual ~GetThingModelTslPublishedResponseBodyData() = default;
};
class GetThingModelTslPublishedResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetThingModelTslPublishedResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetThingModelTslPublishedResponseBody() {}

  explicit GetThingModelTslPublishedResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetThingModelTslPublishedResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetThingModelTslPublishedResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetThingModelTslPublishedResponseBody() = default;
};
class GetThingModelTslPublishedResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetThingModelTslPublishedResponseBody> body{};

  GetThingModelTslPublishedResponse() {}

  explicit GetThingModelTslPublishedResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetThingModelTslPublishedResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetThingModelTslPublishedResponseBody>(model1);
      }
    }
  }


  virtual ~GetThingModelTslPublishedResponse() = default;
};
class GetThingScriptRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  GetThingScriptRequest() {}

  explicit GetThingScriptRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~GetThingScriptRequest() = default;
};
class GetThingScriptResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> scriptType{};
  shared_ptr<string> scriptUrl{};

  GetThingScriptResponseBodyData() {}

  explicit GetThingScriptResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scriptType) {
      res["ScriptType"] = boost::any(*scriptType);
    }
    if (scriptUrl) {
      res["ScriptUrl"] = boost::any(*scriptUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScriptType") != m.end() && !m["ScriptType"].empty()) {
      scriptType = make_shared<string>(boost::any_cast<string>(m["ScriptType"]));
    }
    if (m.find("ScriptUrl") != m.end() && !m["ScriptUrl"].empty()) {
      scriptUrl = make_shared<string>(boost::any_cast<string>(m["ScriptUrl"]));
    }
  }


  virtual ~GetThingScriptResponseBodyData() = default;
};
class GetThingScriptResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetThingScriptResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetThingScriptResponseBody() {}

  explicit GetThingScriptResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetThingScriptResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetThingScriptResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetThingScriptResponseBody() = default;
};
class GetThingScriptResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetThingScriptResponseBody> body{};

  GetThingScriptResponse() {}

  explicit GetThingScriptResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetThingScriptResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetThingScriptResponseBody>(model1);
      }
    }
  }


  virtual ~GetThingScriptResponse() = default;
};
class GetThingTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> categoryKey{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> resourceGroupId{};

  GetThingTemplateRequest() {}

  explicit GetThingTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryKey) {
      res["CategoryKey"] = boost::any(*categoryKey);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryKey") != m.end() && !m["CategoryKey"].empty()) {
      categoryKey = make_shared<string>(boost::any_cast<string>(m["CategoryKey"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~GetThingTemplateRequest() = default;
};
class GetThingTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> thingModelJSON{};

  GetThingTemplateResponseBody() {}

  explicit GetThingTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (thingModelJSON) {
      res["ThingModelJSON"] = boost::any(*thingModelJSON);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ThingModelJSON") != m.end() && !m["ThingModelJSON"].empty()) {
      thingModelJSON = make_shared<string>(boost::any_cast<string>(m["ThingModelJSON"]));
    }
  }


  virtual ~GetThingTemplateResponseBody() = default;
};
class GetThingTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetThingTemplateResponseBody> body{};

  GetThingTemplateResponse() {}

  explicit GetThingTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetThingTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetThingTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~GetThingTemplateResponse() = default;
};
class GetThingTopoRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};

  GetThingTopoRequest() {}

  explicit GetThingTopoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~GetThingTopoRequest() = default;
};
class GetThingTopoResponseBodyDataListDeviceInfo : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> productKey{};

  GetThingTopoResponseBodyDataListDeviceInfo() {}

  explicit GetThingTopoResponseBodyDataListDeviceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~GetThingTopoResponseBodyDataListDeviceInfo() = default;
};
class GetThingTopoResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<GetThingTopoResponseBodyDataListDeviceInfo>> deviceInfo{};

  GetThingTopoResponseBodyDataList() {}

  explicit GetThingTopoResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*deviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["deviceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("deviceInfo") != m.end() && !m["deviceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["deviceInfo"].type()) {
        vector<GetThingTopoResponseBodyDataListDeviceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["deviceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetThingTopoResponseBodyDataListDeviceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceInfo = make_shared<vector<GetThingTopoResponseBodyDataListDeviceInfo>>(expect1);
      }
    }
  }


  virtual ~GetThingTopoResponseBodyDataList() = default;
};
class GetThingTopoResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<GetThingTopoResponseBodyDataList> list{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  GetThingTopoResponseBodyData() {}

  explicit GetThingTopoResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        GetThingTopoResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<GetThingTopoResponseBodyDataList>(model1);
      }
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetThingTopoResponseBodyData() = default;
};
class GetThingTopoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetThingTopoResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetThingTopoResponseBody() {}

  explicit GetThingTopoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetThingTopoResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetThingTopoResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetThingTopoResponseBody() = default;
};
class GetThingTopoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetThingTopoResponseBody> body{};

  GetThingTopoResponse() {}

  explicit GetThingTopoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetThingTopoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetThingTopoResponseBody>(model1);
      }
    }
  }


  virtual ~GetThingTopoResponse() = default;
};
class GisQueryDeviceLocationRequestThingList : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> productKey{};

  GisQueryDeviceLocationRequestThingList() {}

  explicit GisQueryDeviceLocationRequestThingList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~GisQueryDeviceLocationRequestThingList() = default;
};
class GisQueryDeviceLocationRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<GisQueryDeviceLocationRequestThingList>> thingList{};

  GisQueryDeviceLocationRequest() {}

  explicit GisQueryDeviceLocationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (thingList) {
      vector<boost::any> temp1;
      for(auto item1:*thingList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ThingList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ThingList") != m.end() && !m["ThingList"].empty()) {
      if (typeid(vector<boost::any>) == m["ThingList"].type()) {
        vector<GisQueryDeviceLocationRequestThingList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ThingList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GisQueryDeviceLocationRequestThingList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        thingList = make_shared<vector<GisQueryDeviceLocationRequestThingList>>(expect1);
      }
    }
  }


  virtual ~GisQueryDeviceLocationRequest() = default;
};
class GisQueryDeviceLocationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> adcode{};
  shared_ptr<string> city{};
  shared_ptr<long> coordinateSystem{};
  shared_ptr<string> country{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> ip{};
  shared_ptr<double> latitude{};
  shared_ptr<double> longitude{};
  shared_ptr<string> productKey{};
  shared_ptr<string> province{};

  GisQueryDeviceLocationResponseBodyData() {}

  explicit GisQueryDeviceLocationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adcode) {
      res["Adcode"] = boost::any(*adcode);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (coordinateSystem) {
      res["CoordinateSystem"] = boost::any(*coordinateSystem);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (latitude) {
      res["Latitude"] = boost::any(*latitude);
    }
    if (longitude) {
      res["Longitude"] = boost::any(*longitude);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Adcode") != m.end() && !m["Adcode"].empty()) {
      adcode = make_shared<long>(boost::any_cast<long>(m["Adcode"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("CoordinateSystem") != m.end() && !m["CoordinateSystem"].empty()) {
      coordinateSystem = make_shared<long>(boost::any_cast<long>(m["CoordinateSystem"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Latitude") != m.end() && !m["Latitude"].empty()) {
      latitude = make_shared<double>(boost::any_cast<double>(m["Latitude"]));
    }
    if (m.find("Longitude") != m.end() && !m["Longitude"].empty()) {
      longitude = make_shared<double>(boost::any_cast<double>(m["Longitude"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~GisQueryDeviceLocationResponseBodyData() = default;
};
class GisQueryDeviceLocationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<GisQueryDeviceLocationResponseBodyData>> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GisQueryDeviceLocationResponseBody() {}

  explicit GisQueryDeviceLocationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GisQueryDeviceLocationResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GisQueryDeviceLocationResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GisQueryDeviceLocationResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GisQueryDeviceLocationResponseBody() = default;
};
class GisQueryDeviceLocationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GisQueryDeviceLocationResponseBody> body{};

  GisQueryDeviceLocationResponse() {}

  explicit GisQueryDeviceLocationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GisQueryDeviceLocationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GisQueryDeviceLocationResponseBody>(model1);
      }
    }
  }


  virtual ~GisQueryDeviceLocationResponse() = default;
};
class GisSearchDeviceTraceRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<long> endTime{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> mapMatch{};
  shared_ptr<string> productKey{};
  shared_ptr<long> startTime{};

  GisSearchDeviceTraceRequest() {}

  explicit GisSearchDeviceTraceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (mapMatch) {
      res["MapMatch"] = boost::any(*mapMatch);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("MapMatch") != m.end() && !m["MapMatch"].empty()) {
      mapMatch = make_shared<long>(boost::any_cast<long>(m["MapMatch"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~GisSearchDeviceTraceRequest() = default;
};
class GisSearchDeviceTraceResponseBodyDataPoints : public Darabonba::Model {
public:
  shared_ptr<long> locateTime{};
  shared_ptr<string> location{};

  GisSearchDeviceTraceResponseBodyDataPoints() {}

  explicit GisSearchDeviceTraceResponseBodyDataPoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (locateTime) {
      res["LocateTime"] = boost::any(*locateTime);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocateTime") != m.end() && !m["LocateTime"].empty()) {
      locateTime = make_shared<long>(boost::any_cast<long>(m["LocateTime"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
  }


  virtual ~GisSearchDeviceTraceResponseBodyDataPoints() = default;
};
class GisSearchDeviceTraceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<vector<GisSearchDeviceTraceResponseBodyDataPoints>> points{};
  shared_ptr<string> productKey{};

  GisSearchDeviceTraceResponseBodyData() {}

  explicit GisSearchDeviceTraceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (points) {
      vector<boost::any> temp1;
      for(auto item1:*points){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Points"] = boost::any(temp1);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      if (typeid(vector<boost::any>) == m["Points"].type()) {
        vector<GisSearchDeviceTraceResponseBodyDataPoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Points"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GisSearchDeviceTraceResponseBodyDataPoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        points = make_shared<vector<GisSearchDeviceTraceResponseBodyDataPoints>>(expect1);
      }
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~GisSearchDeviceTraceResponseBodyData() = default;
};
class GisSearchDeviceTraceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GisSearchDeviceTraceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GisSearchDeviceTraceResponseBody() {}

  explicit GisSearchDeviceTraceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GisSearchDeviceTraceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GisSearchDeviceTraceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GisSearchDeviceTraceResponseBody() = default;
};
class GisSearchDeviceTraceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GisSearchDeviceTraceResponseBody> body{};

  GisSearchDeviceTraceResponse() {}

  explicit GisSearchDeviceTraceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GisSearchDeviceTraceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GisSearchDeviceTraceResponseBody>(model1);
      }
    }
  }


  virtual ~GisSearchDeviceTraceResponse() = default;
};
class ImportDTDataRequestItems : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> params{};

  ImportDTDataRequestItems() {}

  explicit ImportDTDataRequestItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
  }


  virtual ~ImportDTDataRequestItems() = default;
};
class ImportDTDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> DTInstanceId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<ImportDTDataRequestItems>> items{};
  shared_ptr<string> productKey{};

  ImportDTDataRequest() {}

  explicit ImportDTDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DTInstanceId) {
      res["DTInstanceId"] = boost::any(*DTInstanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DTInstanceId") != m.end() && !m["DTInstanceId"].empty()) {
      DTInstanceId = make_shared<string>(boost::any_cast<string>(m["DTInstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<ImportDTDataRequestItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImportDTDataRequestItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<ImportDTDataRequestItems>>(expect1);
      }
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~ImportDTDataRequest() = default;
};
class ImportDTDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ImportDTDataResponseBody() {}

  explicit ImportDTDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ImportDTDataResponseBody() = default;
};
class ImportDTDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportDTDataResponseBody> body{};

  ImportDTDataResponse() {}

  explicit ImportDTDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportDTDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportDTDataResponseBody>(model1);
      }
    }
  }


  virtual ~ImportDTDataResponse() = default;
};
class ImportDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceSecret{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> nickname{};
  shared_ptr<string> productKey{};
  shared_ptr<string> sn{};

  ImportDeviceRequest() {}

  explicit ImportDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceSecret) {
      res["DeviceSecret"] = boost::any(*deviceSecret);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (sn) {
      res["Sn"] = boost::any(*sn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceSecret") != m.end() && !m["DeviceSecret"].empty()) {
      deviceSecret = make_shared<string>(boost::any_cast<string>(m["DeviceSecret"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Sn") != m.end() && !m["Sn"].empty()) {
      sn = make_shared<string>(boost::any_cast<string>(m["Sn"]));
    }
  }


  virtual ~ImportDeviceRequest() = default;
};
class ImportDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceSecret{};
  shared_ptr<string> iotId{};
  shared_ptr<string> nickname{};
  shared_ptr<string> productKey{};
  shared_ptr<string> sn{};

  ImportDeviceResponseBodyData() {}

  explicit ImportDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceSecret) {
      res["DeviceSecret"] = boost::any(*deviceSecret);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (sn) {
      res["Sn"] = boost::any(*sn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceSecret") != m.end() && !m["DeviceSecret"].empty()) {
      deviceSecret = make_shared<string>(boost::any_cast<string>(m["DeviceSecret"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Sn") != m.end() && !m["Sn"].empty()) {
      sn = make_shared<string>(boost::any_cast<string>(m["Sn"]));
    }
  }


  virtual ~ImportDeviceResponseBodyData() = default;
};
class ImportDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ImportDeviceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ImportDeviceResponseBody() {}

  explicit ImportDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ImportDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ImportDeviceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ImportDeviceResponseBody() = default;
};
class ImportDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportDeviceResponseBody> body{};

  ImportDeviceResponse() {}

  explicit ImportDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~ImportDeviceResponse() = default;
};
class ImportThingModelTslRequest : public Darabonba::Model {
public:
  shared_ptr<string> functionBlockId{};
  shared_ptr<string> functionBlockName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> tslStr{};
  shared_ptr<string> tslUrl{};

  ImportThingModelTslRequest() {}

  explicit ImportThingModelTslRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    if (functionBlockName) {
      res["FunctionBlockName"] = boost::any(*functionBlockName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tslStr) {
      res["TslStr"] = boost::any(*tslStr);
    }
    if (tslUrl) {
      res["TslUrl"] = boost::any(*tslUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
    if (m.find("FunctionBlockName") != m.end() && !m["FunctionBlockName"].empty()) {
      functionBlockName = make_shared<string>(boost::any_cast<string>(m["FunctionBlockName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("TslStr") != m.end() && !m["TslStr"].empty()) {
      tslStr = make_shared<string>(boost::any_cast<string>(m["TslStr"]));
    }
    if (m.find("TslUrl") != m.end() && !m["TslUrl"].empty()) {
      tslUrl = make_shared<string>(boost::any_cast<string>(m["TslUrl"]));
    }
  }


  virtual ~ImportThingModelTslRequest() = default;
};
class ImportThingModelTslResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ImportThingModelTslResponseBody() {}

  explicit ImportThingModelTslResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ImportThingModelTslResponseBody() = default;
};
class ImportThingModelTslResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportThingModelTslResponseBody> body{};

  ImportThingModelTslResponse() {}

  explicit ImportThingModelTslResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportThingModelTslResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportThingModelTslResponseBody>(model1);
      }
    }
  }


  virtual ~ImportThingModelTslResponse() = default;
};
class InvokeDataAPIServiceRequestParam : public Darabonba::Model {
public:
  shared_ptr<string> listParamType{};
  shared_ptr<vector<string>> listParamValue{};
  shared_ptr<string> paramName{};
  shared_ptr<string> paramType{};
  shared_ptr<string> paramValue{};

  InvokeDataAPIServiceRequestParam() {}

  explicit InvokeDataAPIServiceRequestParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listParamType) {
      res["ListParamType"] = boost::any(*listParamType);
    }
    if (listParamValue) {
      res["ListParamValue"] = boost::any(*listParamValue);
    }
    if (paramName) {
      res["ParamName"] = boost::any(*paramName);
    }
    if (paramType) {
      res["ParamType"] = boost::any(*paramType);
    }
    if (paramValue) {
      res["ParamValue"] = boost::any(*paramValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListParamType") != m.end() && !m["ListParamType"].empty()) {
      listParamType = make_shared<string>(boost::any_cast<string>(m["ListParamType"]));
    }
    if (m.find("ListParamValue") != m.end() && !m["ListParamValue"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ListParamValue"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ListParamValue"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      listParamValue = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ParamName") != m.end() && !m["ParamName"].empty()) {
      paramName = make_shared<string>(boost::any_cast<string>(m["ParamName"]));
    }
    if (m.find("ParamType") != m.end() && !m["ParamType"].empty()) {
      paramType = make_shared<string>(boost::any_cast<string>(m["ParamType"]));
    }
    if (m.find("ParamValue") != m.end() && !m["ParamValue"].empty()) {
      paramValue = make_shared<string>(boost::any_cast<string>(m["ParamValue"]));
    }
  }


  virtual ~InvokeDataAPIServiceRequestParam() = default;
};
class InvokeDataAPIServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiSrn{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<InvokeDataAPIServiceRequestParam>> param{};

  InvokeDataAPIServiceRequest() {}

  explicit InvokeDataAPIServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiSrn) {
      res["ApiSrn"] = boost::any(*apiSrn);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (param) {
      vector<boost::any> temp1;
      for(auto item1:*param){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Param"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiSrn") != m.end() && !m["ApiSrn"].empty()) {
      apiSrn = make_shared<string>(boost::any_cast<string>(m["ApiSrn"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      if (typeid(vector<boost::any>) == m["Param"].type()) {
        vector<InvokeDataAPIServiceRequestParam> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Param"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InvokeDataAPIServiceRequestParam model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        param = make_shared<vector<InvokeDataAPIServiceRequestParam>>(expect1);
      }
    }
  }


  virtual ~InvokeDataAPIServiceRequest() = default;
};
class InvokeDataAPIServiceResponseBodyDataFieldNameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fieldNameList{};

  InvokeDataAPIServiceResponseBodyDataFieldNameList() {}

  explicit InvokeDataAPIServiceResponseBodyDataFieldNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldNameList) {
      res["FieldNameList"] = boost::any(*fieldNameList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldNameList") != m.end() && !m["FieldNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FieldNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FieldNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fieldNameList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~InvokeDataAPIServiceResponseBodyDataFieldNameList() = default;
};
class InvokeDataAPIServiceResponseBodyDataResultList : public Darabonba::Model {
public:
  shared_ptr<vector<map<string, boost::any>>> resultList{};

  InvokeDataAPIServiceResponseBodyDataResultList() {}

  explicit InvokeDataAPIServiceResponseBodyDataResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resultList) {
      res["ResultList"] = boost::any(*resultList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResultList") != m.end() && !m["ResultList"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["ResultList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResultList"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      resultList = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
  }


  virtual ~InvokeDataAPIServiceResponseBodyDataResultList() = default;
};
class InvokeDataAPIServiceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> apiSrn{};
  shared_ptr<InvokeDataAPIServiceResponseBodyDataFieldNameList> fieldNameList{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<InvokeDataAPIServiceResponseBodyDataResultList> resultList{};
  shared_ptr<long> totalSize{};

  InvokeDataAPIServiceResponseBodyData() {}

  explicit InvokeDataAPIServiceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiSrn) {
      res["ApiSrn"] = boost::any(*apiSrn);
    }
    if (fieldNameList) {
      res["FieldNameList"] = fieldNameList ? boost::any(fieldNameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resultList) {
      res["ResultList"] = resultList ? boost::any(resultList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiSrn") != m.end() && !m["ApiSrn"].empty()) {
      apiSrn = make_shared<string>(boost::any_cast<string>(m["ApiSrn"]));
    }
    if (m.find("FieldNameList") != m.end() && !m["FieldNameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["FieldNameList"].type()) {
        InvokeDataAPIServiceResponseBodyDataFieldNameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FieldNameList"]));
        fieldNameList = make_shared<InvokeDataAPIServiceResponseBodyDataFieldNameList>(model1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResultList") != m.end() && !m["ResultList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultList"].type()) {
        InvokeDataAPIServiceResponseBodyDataResultList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultList"]));
        resultList = make_shared<InvokeDataAPIServiceResponseBodyDataResultList>(model1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~InvokeDataAPIServiceResponseBodyData() = default;
};
class InvokeDataAPIServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<InvokeDataAPIServiceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  InvokeDataAPIServiceResponseBody() {}

  explicit InvokeDataAPIServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        InvokeDataAPIServiceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<InvokeDataAPIServiceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~InvokeDataAPIServiceResponseBody() = default;
};
class InvokeDataAPIServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InvokeDataAPIServiceResponseBody> body{};

  InvokeDataAPIServiceResponse() {}

  explicit InvokeDataAPIServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InvokeDataAPIServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InvokeDataAPIServiceResponseBody>(model1);
      }
    }
  }


  virtual ~InvokeDataAPIServiceResponse() = default;
};
class InvokeThingServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> args{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> identifier{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<long> qos{};

  InvokeThingServiceRequest() {}

  explicit InvokeThingServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (args) {
      res["Args"] = boost::any(*args);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (qos) {
      res["Qos"] = boost::any(*qos);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Args") != m.end() && !m["Args"].empty()) {
      args = make_shared<string>(boost::any_cast<string>(m["Args"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Qos") != m.end() && !m["Qos"].empty()) {
      qos = make_shared<long>(boost::any_cast<long>(m["Qos"]));
    }
  }


  virtual ~InvokeThingServiceRequest() = default;
};
class InvokeThingServiceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};
  shared_ptr<string> result{};

  InvokeThingServiceResponseBodyData() {}

  explicit InvokeThingServiceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~InvokeThingServiceResponseBodyData() = default;
};
class InvokeThingServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<InvokeThingServiceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  InvokeThingServiceResponseBody() {}

  explicit InvokeThingServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        InvokeThingServiceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<InvokeThingServiceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~InvokeThingServiceResponseBody() = default;
};
class InvokeThingServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InvokeThingServiceResponseBody> body{};

  InvokeThingServiceResponse() {}

  explicit InvokeThingServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InvokeThingServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InvokeThingServiceResponseBody>(model1);
      }
    }
  }


  virtual ~InvokeThingServiceResponse() = default;
};
class InvokeThingsServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> args{};
  shared_ptr<vector<string>> deviceName{};
  shared_ptr<string> identifier{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  InvokeThingsServiceRequest() {}

  explicit InvokeThingsServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (args) {
      res["Args"] = boost::any(*args);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Args") != m.end() && !m["Args"].empty()) {
      args = make_shared<string>(boost::any_cast<string>(m["Args"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~InvokeThingsServiceRequest() = default;
};
class InvokeThingsServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  InvokeThingsServiceResponseBody() {}

  explicit InvokeThingsServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~InvokeThingsServiceResponseBody() = default;
};
class InvokeThingsServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InvokeThingsServiceResponseBody> body{};

  InvokeThingsServiceResponse() {}

  explicit InvokeThingsServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InvokeThingsServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InvokeThingsServiceResponseBody>(model1);
      }
    }
  }


  virtual ~InvokeThingsServiceResponse() = default;
};
class ListAnalyticsDataRequestCondition : public Darabonba::Model {
public:
  shared_ptr<string> betweenEnd{};
  shared_ptr<string> betweenStart{};
  shared_ptr<string> fieldName{};
  shared_ptr<string> operate{};
  shared_ptr<string> value{};

  ListAnalyticsDataRequestCondition() {}

  explicit ListAnalyticsDataRequestCondition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (betweenEnd) {
      res["BetweenEnd"] = boost::any(*betweenEnd);
    }
    if (betweenStart) {
      res["BetweenStart"] = boost::any(*betweenStart);
    }
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    if (operate) {
      res["Operate"] = boost::any(*operate);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BetweenEnd") != m.end() && !m["BetweenEnd"].empty()) {
      betweenEnd = make_shared<string>(boost::any_cast<string>(m["BetweenEnd"]));
    }
    if (m.find("BetweenStart") != m.end() && !m["BetweenStart"].empty()) {
      betweenStart = make_shared<string>(boost::any_cast<string>(m["BetweenStart"]));
    }
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
    if (m.find("Operate") != m.end() && !m["Operate"].empty()) {
      operate = make_shared<string>(boost::any_cast<string>(m["Operate"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListAnalyticsDataRequestCondition() = default;
};
class ListAnalyticsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiPath{};
  shared_ptr<vector<ListAnalyticsDataRequestCondition>> condition{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> isoId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};

  ListAnalyticsDataRequest() {}

  explicit ListAnalyticsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    if (condition) {
      vector<boost::any> temp1;
      for(auto item1:*condition){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Condition"] = boost::any(temp1);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (isoId) {
      res["IsoId"] = boost::any(*isoId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      if (typeid(vector<boost::any>) == m["Condition"].type()) {
        vector<ListAnalyticsDataRequestCondition> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Condition"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAnalyticsDataRequestCondition model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        condition = make_shared<vector<ListAnalyticsDataRequestCondition>>(expect1);
      }
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("IsoId") != m.end() && !m["IsoId"].empty()) {
      isoId = make_shared<string>(boost::any_cast<string>(m["IsoId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListAnalyticsDataRequest() = default;
};
class ListAnalyticsDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<bool> hasNext{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resultJson{};

  ListAnalyticsDataResponseBodyData() {}

  explicit ListAnalyticsDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (hasNext) {
      res["HasNext"] = boost::any(*hasNext);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resultJson) {
      res["ResultJson"] = boost::any(*resultJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("HasNext") != m.end() && !m["HasNext"].empty()) {
      hasNext = make_shared<bool>(boost::any_cast<bool>(m["HasNext"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResultJson") != m.end() && !m["ResultJson"].empty()) {
      resultJson = make_shared<string>(boost::any_cast<string>(m["ResultJson"]));
    }
  }


  virtual ~ListAnalyticsDataResponseBodyData() = default;
};
class ListAnalyticsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListAnalyticsDataResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListAnalyticsDataResponseBody() {}

  explicit ListAnalyticsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListAnalyticsDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListAnalyticsDataResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAnalyticsDataResponseBody() = default;
};
class ListAnalyticsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAnalyticsDataResponseBody> body{};

  ListAnalyticsDataResponse() {}

  explicit ListAnalyticsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAnalyticsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAnalyticsDataResponseBody>(model1);
      }
    }
  }


  virtual ~ListAnalyticsDataResponse() = default;
};
class ListDataSourceItemRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchName{};

  ListDataSourceItemRequest() {}

  explicit ListDataSourceItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
  }


  virtual ~ListDataSourceItemRequest() = default;
};
class ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem : public Darabonba::Model {
public:
  shared_ptr<long> dataSourceItemId{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> productKey{};
  shared_ptr<string> scopeType{};
  shared_ptr<string> topic{};

  ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem() {}

  explicit ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceItemId) {
      res["DataSourceItemId"] = boost::any(*dataSourceItemId);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (scopeType) {
      res["ScopeType"] = boost::any(*scopeType);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceItemId") != m.end() && !m["DataSourceItemId"].empty()) {
      dataSourceItemId = make_shared<long>(boost::any_cast<long>(m["DataSourceItemId"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ScopeType") != m.end() && !m["ScopeType"].empty()) {
      scopeType = make_shared<string>(boost::any_cast<string>(m["ScopeType"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem() = default;
};
class ListDataSourceItemResponseBodyDataSourceItems : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem>> dataSourceItem{};

  ListDataSourceItemResponseBodyDataSourceItems() {}

  explicit ListDataSourceItemResponseBodyDataSourceItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceItem) {
      vector<boost::any> temp1;
      for(auto item1:*dataSourceItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["dataSourceItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dataSourceItem") != m.end() && !m["dataSourceItem"].empty()) {
      if (typeid(vector<boost::any>) == m["dataSourceItem"].type()) {
        vector<ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["dataSourceItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataSourceItem = make_shared<vector<ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem>>(expect1);
      }
    }
  }


  virtual ~ListDataSourceItemResponseBodyDataSourceItems() = default;
};
class ListDataSourceItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListDataSourceItemResponseBodyDataSourceItems> dataSourceItems{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListDataSourceItemResponseBody() {}

  explicit ListDataSourceItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dataSourceItems) {
      res["DataSourceItems"] = dataSourceItems ? boost::any(dataSourceItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DataSourceItems") != m.end() && !m["DataSourceItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSourceItems"].type()) {
        ListDataSourceItemResponseBodyDataSourceItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSourceItems"]));
        dataSourceItems = make_shared<ListDataSourceItemResponseBodyDataSourceItems>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListDataSourceItemResponseBody() = default;
};
class ListDataSourceItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataSourceItemResponseBody> body{};

  ListDataSourceItemResponse() {}

  explicit ListDataSourceItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataSourceItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataSourceItemResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataSourceItemResponse() = default;
};
class ListDestinationRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchName{};
  shared_ptr<vector<string>> types{};

  ListDestinationRequest() {}

  explicit ListDestinationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    if (types) {
      res["Types"] = boost::any(*types);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      types = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDestinationRequest() = default;
};
class ListDestinationResponseBodyDestinationsDestinations : public Darabonba::Model {
public:
  shared_ptr<string> configuration{};
  shared_ptr<string> description{};
  shared_ptr<long> destinationId{};
  shared_ptr<bool> isFailover{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> utcCreated{};

  ListDestinationResponseBodyDestinationsDestinations() {}

  explicit ListDestinationResponseBodyDestinationsDestinations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configuration) {
      res["Configuration"] = boost::any(*configuration);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destinationId) {
      res["DestinationId"] = boost::any(*destinationId);
    }
    if (isFailover) {
      res["IsFailover"] = boost::any(*isFailover);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (utcCreated) {
      res["UtcCreated"] = boost::any(*utcCreated);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configuration = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestinationId") != m.end() && !m["DestinationId"].empty()) {
      destinationId = make_shared<long>(boost::any_cast<long>(m["DestinationId"]));
    }
    if (m.find("IsFailover") != m.end() && !m["IsFailover"].empty()) {
      isFailover = make_shared<bool>(boost::any_cast<bool>(m["IsFailover"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UtcCreated") != m.end() && !m["UtcCreated"].empty()) {
      utcCreated = make_shared<string>(boost::any_cast<string>(m["UtcCreated"]));
    }
  }


  virtual ~ListDestinationResponseBodyDestinationsDestinations() = default;
};
class ListDestinationResponseBodyDestinations : public Darabonba::Model {
public:
  shared_ptr<vector<ListDestinationResponseBodyDestinationsDestinations>> destinations{};

  ListDestinationResponseBodyDestinations() {}

  explicit ListDestinationResponseBodyDestinations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinations) {
      vector<boost::any> temp1;
      for(auto item1:*destinations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["destinations"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("destinations") != m.end() && !m["destinations"].empty()) {
      if (typeid(vector<boost::any>) == m["destinations"].type()) {
        vector<ListDestinationResponseBodyDestinationsDestinations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["destinations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDestinationResponseBodyDestinationsDestinations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        destinations = make_shared<vector<ListDestinationResponseBodyDestinationsDestinations>>(expect1);
      }
    }
  }


  virtual ~ListDestinationResponseBodyDestinations() = default;
};
class ListDestinationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListDestinationResponseBodyDestinations> destinations{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListDestinationResponseBody() {}

  explicit ListDestinationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (destinations) {
      res["Destinations"] = destinations ? boost::any(destinations->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Destinations") != m.end() && !m["Destinations"].empty()) {
      if (typeid(map<string, boost::any>) == m["Destinations"].type()) {
        ListDestinationResponseBodyDestinations model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Destinations"]));
        destinations = make_shared<ListDestinationResponseBodyDestinations>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListDestinationResponseBody() = default;
};
class ListDestinationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDestinationResponseBody> body{};

  ListDestinationResponse() {}

  explicit ListDestinationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDestinationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDestinationResponseBody>(model1);
      }
    }
  }


  virtual ~ListDestinationResponse() = default;
};
class ListDeviceDistributeJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> jobId{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<long> status{};
  shared_ptr<string> targetUid{};

  ListDeviceDistributeJobRequest() {}

  explicit ListDeviceDistributeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (targetUid) {
      res["TargetUid"] = boost::any(*targetUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TargetUid") != m.end() && !m["TargetUid"].empty()) {
      targetUid = make_shared<string>(boost::any_cast<string>(m["TargetUid"]));
    }
  }


  virtual ~ListDeviceDistributeJobRequest() = default;
};
class ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs : public Darabonba::Model {
public:
  shared_ptr<string> targetInstanceId{};
  shared_ptr<string> targetInstanceName{};
  shared_ptr<string> targetRegion{};

  ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs() {}

  explicit ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    if (targetInstanceName) {
      res["TargetInstanceName"] = boost::any(*targetInstanceName);
    }
    if (targetRegion) {
      res["TargetRegion"] = boost::any(*targetRegion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
    if (m.find("TargetInstanceName") != m.end() && !m["TargetInstanceName"].empty()) {
      targetInstanceName = make_shared<string>(boost::any_cast<string>(m["TargetInstanceName"]));
    }
    if (m.find("TargetRegion") != m.end() && !m["TargetRegion"].empty()) {
      targetRegion = make_shared<string>(boost::any_cast<string>(m["TargetRegion"]));
    }
  }


  virtual ~ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs() = default;
};
class ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs>> targetInstanceConfigs{};

  ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs() {}

  explicit ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetInstanceConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*targetInstanceConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["targetInstanceConfigs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("targetInstanceConfigs") != m.end() && !m["targetInstanceConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["targetInstanceConfigs"].type()) {
        vector<ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["targetInstanceConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targetInstanceConfigs = make_shared<vector<ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs>>(expect1);
      }
    }
  }


  virtual ~ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs() = default;
};
class ListDeviceDistributeJobResponseBodyDataJobInfoItems : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> jobId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> sourceInstanceName{};
  shared_ptr<string> sourceRegion{};
  shared_ptr<string> sourceUid{};
  shared_ptr<long> status{};
  shared_ptr<long> strategy{};
  shared_ptr<ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs> targetInstanceConfigs{};
  shared_ptr<string> targetUid{};
  shared_ptr<long> total{};

  ListDeviceDistributeJobResponseBodyDataJobInfoItems() {}

  explicit ListDeviceDistributeJobResponseBodyDataJobInfoItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (sourceInstanceName) {
      res["SourceInstanceName"] = boost::any(*sourceInstanceName);
    }
    if (sourceRegion) {
      res["SourceRegion"] = boost::any(*sourceRegion);
    }
    if (sourceUid) {
      res["SourceUid"] = boost::any(*sourceUid);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (strategy) {
      res["Strategy"] = boost::any(*strategy);
    }
    if (targetInstanceConfigs) {
      res["TargetInstanceConfigs"] = targetInstanceConfigs ? boost::any(targetInstanceConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (targetUid) {
      res["TargetUid"] = boost::any(*targetUid);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("SourceInstanceName") != m.end() && !m["SourceInstanceName"].empty()) {
      sourceInstanceName = make_shared<string>(boost::any_cast<string>(m["SourceInstanceName"]));
    }
    if (m.find("SourceRegion") != m.end() && !m["SourceRegion"].empty()) {
      sourceRegion = make_shared<string>(boost::any_cast<string>(m["SourceRegion"]));
    }
    if (m.find("SourceUid") != m.end() && !m["SourceUid"].empty()) {
      sourceUid = make_shared<string>(boost::any_cast<string>(m["SourceUid"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      strategy = make_shared<long>(boost::any_cast<long>(m["Strategy"]));
    }
    if (m.find("TargetInstanceConfigs") != m.end() && !m["TargetInstanceConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["TargetInstanceConfigs"].type()) {
        ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TargetInstanceConfigs"]));
        targetInstanceConfigs = make_shared<ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs>(model1);
      }
    }
    if (m.find("TargetUid") != m.end() && !m["TargetUid"].empty()) {
      targetUid = make_shared<string>(boost::any_cast<string>(m["TargetUid"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListDeviceDistributeJobResponseBodyDataJobInfoItems() = default;
};
class ListDeviceDistributeJobResponseBodyDataJobInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDeviceDistributeJobResponseBodyDataJobInfoItems>> items{};

  ListDeviceDistributeJobResponseBodyDataJobInfo() {}

  explicit ListDeviceDistributeJobResponseBodyDataJobInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<ListDeviceDistributeJobResponseBodyDataJobInfoItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDeviceDistributeJobResponseBodyDataJobInfoItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<ListDeviceDistributeJobResponseBodyDataJobInfoItems>>(expect1);
      }
    }
  }


  virtual ~ListDeviceDistributeJobResponseBodyDataJobInfo() = default;
};
class ListDeviceDistributeJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<ListDeviceDistributeJobResponseBodyDataJobInfo> jobInfo{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> total{};

  ListDeviceDistributeJobResponseBodyData() {}

  explicit ListDeviceDistributeJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobInfo) {
      res["JobInfo"] = jobInfo ? boost::any(jobInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobInfo") != m.end() && !m["JobInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobInfo"].type()) {
        ListDeviceDistributeJobResponseBodyDataJobInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobInfo"]));
        jobInfo = make_shared<ListDeviceDistributeJobResponseBodyDataJobInfo>(model1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListDeviceDistributeJobResponseBodyData() = default;
};
class ListDeviceDistributeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListDeviceDistributeJobResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListDeviceDistributeJobResponseBody() {}

  explicit ListDeviceDistributeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListDeviceDistributeJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListDeviceDistributeJobResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListDeviceDistributeJobResponseBody() = default;
};
class ListDeviceDistributeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDeviceDistributeJobResponseBody> body{};

  ListDeviceDistributeJobResponse() {}

  explicit ListDeviceDistributeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDeviceDistributeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDeviceDistributeJobResponseBody>(model1);
      }
    }
  }


  virtual ~ListDeviceDistributeJobResponse() = default;
};
class ListDistributedDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> deviceName{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> targetUid{};

  ListDistributedDeviceRequest() {}

  explicit ListDistributedDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (targetUid) {
      res["TargetUid"] = boost::any(*targetUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("TargetUid") != m.end() && !m["TargetUid"].empty()) {
      targetUid = make_shared<string>(boost::any_cast<string>(m["TargetUid"]));
    }
  }


  virtual ~ListDistributedDeviceRequest() = default;
};
class ListDistributedDeviceResponseBodyDataInfoItems : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> productKey{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> sourceInstanceName{};
  shared_ptr<string> sourceRegion{};
  shared_ptr<string> sourceUid{};
  shared_ptr<string> targetAliyunId{};
  shared_ptr<string> targetInstanceId{};
  shared_ptr<string> targetInstanceName{};
  shared_ptr<string> targetRegion{};
  shared_ptr<string> targetUid{};

  ListDistributedDeviceResponseBodyDataInfoItems() {}

  explicit ListDistributedDeviceResponseBodyDataInfoItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (sourceInstanceName) {
      res["SourceInstanceName"] = boost::any(*sourceInstanceName);
    }
    if (sourceRegion) {
      res["SourceRegion"] = boost::any(*sourceRegion);
    }
    if (sourceUid) {
      res["SourceUid"] = boost::any(*sourceUid);
    }
    if (targetAliyunId) {
      res["TargetAliyunId"] = boost::any(*targetAliyunId);
    }
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    if (targetInstanceName) {
      res["TargetInstanceName"] = boost::any(*targetInstanceName);
    }
    if (targetRegion) {
      res["TargetRegion"] = boost::any(*targetRegion);
    }
    if (targetUid) {
      res["TargetUid"] = boost::any(*targetUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("SourceInstanceName") != m.end() && !m["SourceInstanceName"].empty()) {
      sourceInstanceName = make_shared<string>(boost::any_cast<string>(m["SourceInstanceName"]));
    }
    if (m.find("SourceRegion") != m.end() && !m["SourceRegion"].empty()) {
      sourceRegion = make_shared<string>(boost::any_cast<string>(m["SourceRegion"]));
    }
    if (m.find("SourceUid") != m.end() && !m["SourceUid"].empty()) {
      sourceUid = make_shared<string>(boost::any_cast<string>(m["SourceUid"]));
    }
    if (m.find("TargetAliyunId") != m.end() && !m["TargetAliyunId"].empty()) {
      targetAliyunId = make_shared<string>(boost::any_cast<string>(m["TargetAliyunId"]));
    }
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
    if (m.find("TargetInstanceName") != m.end() && !m["TargetInstanceName"].empty()) {
      targetInstanceName = make_shared<string>(boost::any_cast<string>(m["TargetInstanceName"]));
    }
    if (m.find("TargetRegion") != m.end() && !m["TargetRegion"].empty()) {
      targetRegion = make_shared<string>(boost::any_cast<string>(m["TargetRegion"]));
    }
    if (m.find("TargetUid") != m.end() && !m["TargetUid"].empty()) {
      targetUid = make_shared<string>(boost::any_cast<string>(m["TargetUid"]));
    }
  }


  virtual ~ListDistributedDeviceResponseBodyDataInfoItems() = default;
};
class ListDistributedDeviceResponseBodyDataInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDistributedDeviceResponseBodyDataInfoItems>> items{};

  ListDistributedDeviceResponseBodyDataInfo() {}

  explicit ListDistributedDeviceResponseBodyDataInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<ListDistributedDeviceResponseBodyDataInfoItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDistributedDeviceResponseBodyDataInfoItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<ListDistributedDeviceResponseBodyDataInfoItems>>(expect1);
      }
    }
  }


  virtual ~ListDistributedDeviceResponseBodyDataInfo() = default;
};
class ListDistributedDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<ListDistributedDeviceResponseBodyDataInfo> info{};
  shared_ptr<long> total{};

  ListDistributedDeviceResponseBodyData() {}

  explicit ListDistributedDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (info) {
      res["Info"] = info ? boost::any(info->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      if (typeid(map<string, boost::any>) == m["Info"].type()) {
        ListDistributedDeviceResponseBodyDataInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Info"]));
        info = make_shared<ListDistributedDeviceResponseBodyDataInfo>(model1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListDistributedDeviceResponseBodyData() = default;
};
class ListDistributedDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListDistributedDeviceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListDistributedDeviceResponseBody() {}

  explicit ListDistributedDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListDistributedDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListDistributedDeviceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListDistributedDeviceResponseBody() = default;
};
class ListDistributedDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDistributedDeviceResponseBody> body{};

  ListDistributedDeviceResponse() {}

  explicit ListDistributedDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDistributedDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDistributedDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~ListDistributedDeviceResponse() = default;
};
class ListDistributedProductRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> targetInstanceId{};
  shared_ptr<string> targetUid{};

  ListDistributedProductRequest() {}

  explicit ListDistributedProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    if (targetUid) {
      res["TargetUid"] = boost::any(*targetUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
    if (m.find("TargetUid") != m.end() && !m["TargetUid"].empty()) {
      targetUid = make_shared<string>(boost::any_cast<string>(m["TargetUid"]));
    }
  }


  virtual ~ListDistributedProductRequest() = default;
};
class ListDistributedProductResponseBodyDataInfoItems : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> productKey{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> sourceInstanceName{};
  shared_ptr<string> sourceRegion{};
  shared_ptr<string> sourceUid{};
  shared_ptr<string> targetAliyunId{};
  shared_ptr<string> targetInstanceId{};
  shared_ptr<string> targetInstanceName{};
  shared_ptr<string> targetRegion{};
  shared_ptr<string> targetUid{};

  ListDistributedProductResponseBodyDataInfoItems() {}

  explicit ListDistributedProductResponseBodyDataInfoItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (sourceInstanceName) {
      res["SourceInstanceName"] = boost::any(*sourceInstanceName);
    }
    if (sourceRegion) {
      res["SourceRegion"] = boost::any(*sourceRegion);
    }
    if (sourceUid) {
      res["SourceUid"] = boost::any(*sourceUid);
    }
    if (targetAliyunId) {
      res["TargetAliyunId"] = boost::any(*targetAliyunId);
    }
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    if (targetInstanceName) {
      res["TargetInstanceName"] = boost::any(*targetInstanceName);
    }
    if (targetRegion) {
      res["TargetRegion"] = boost::any(*targetRegion);
    }
    if (targetUid) {
      res["TargetUid"] = boost::any(*targetUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("SourceInstanceName") != m.end() && !m["SourceInstanceName"].empty()) {
      sourceInstanceName = make_shared<string>(boost::any_cast<string>(m["SourceInstanceName"]));
    }
    if (m.find("SourceRegion") != m.end() && !m["SourceRegion"].empty()) {
      sourceRegion = make_shared<string>(boost::any_cast<string>(m["SourceRegion"]));
    }
    if (m.find("SourceUid") != m.end() && !m["SourceUid"].empty()) {
      sourceUid = make_shared<string>(boost::any_cast<string>(m["SourceUid"]));
    }
    if (m.find("TargetAliyunId") != m.end() && !m["TargetAliyunId"].empty()) {
      targetAliyunId = make_shared<string>(boost::any_cast<string>(m["TargetAliyunId"]));
    }
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
    if (m.find("TargetInstanceName") != m.end() && !m["TargetInstanceName"].empty()) {
      targetInstanceName = make_shared<string>(boost::any_cast<string>(m["TargetInstanceName"]));
    }
    if (m.find("TargetRegion") != m.end() && !m["TargetRegion"].empty()) {
      targetRegion = make_shared<string>(boost::any_cast<string>(m["TargetRegion"]));
    }
    if (m.find("TargetUid") != m.end() && !m["TargetUid"].empty()) {
      targetUid = make_shared<string>(boost::any_cast<string>(m["TargetUid"]));
    }
  }


  virtual ~ListDistributedProductResponseBodyDataInfoItems() = default;
};
class ListDistributedProductResponseBodyDataInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDistributedProductResponseBodyDataInfoItems>> items{};

  ListDistributedProductResponseBodyDataInfo() {}

  explicit ListDistributedProductResponseBodyDataInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<ListDistributedProductResponseBodyDataInfoItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDistributedProductResponseBodyDataInfoItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<ListDistributedProductResponseBodyDataInfoItems>>(expect1);
      }
    }
  }


  virtual ~ListDistributedProductResponseBodyDataInfo() = default;
};
class ListDistributedProductResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<ListDistributedProductResponseBodyDataInfo> info{};
  shared_ptr<long> total{};

  ListDistributedProductResponseBodyData() {}

  explicit ListDistributedProductResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (info) {
      res["Info"] = info ? boost::any(info->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      if (typeid(map<string, boost::any>) == m["Info"].type()) {
        ListDistributedProductResponseBodyDataInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Info"]));
        info = make_shared<ListDistributedProductResponseBodyDataInfo>(model1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListDistributedProductResponseBodyData() = default;
};
class ListDistributedProductResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListDistributedProductResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListDistributedProductResponseBody() {}

  explicit ListDistributedProductResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListDistributedProductResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListDistributedProductResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListDistributedProductResponseBody() = default;
};
class ListDistributedProductResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDistributedProductResponseBody> body{};

  ListDistributedProductResponse() {}

  explicit ListDistributedProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDistributedProductResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDistributedProductResponseBody>(model1);
      }
    }
  }


  virtual ~ListDistributedProductResponse() = default;
};
class ListJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> status{};

  ListJobRequest() {}

  explicit ListJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListJobRequest() = default;
};
class ListJobResponseBodyDataData : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobName{};
  shared_ptr<long> scheduledTime{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> utcModified{};

  ListJobResponseBodyDataData() {}

  explicit ListJobResponseBodyDataData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (scheduledTime) {
      res["ScheduledTime"] = boost::any(*scheduledTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("ScheduledTime") != m.end() && !m["ScheduledTime"].empty()) {
      scheduledTime = make_shared<long>(boost::any_cast<long>(m["ScheduledTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
  }


  virtual ~ListJobResponseBodyDataData() = default;
};
class ListJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyDataData>> data{};

  ListJobResponseBodyData() {}

  explicit ListJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListJobResponseBodyDataData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyDataData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListJobResponseBodyDataData>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyData() = default;
};
class ListJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListJobResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListJobResponseBody() {}

  explicit ListJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListJobResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListJobResponseBody() = default;
};
class ListJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListJobResponseBody> body{};

  ListJobResponse() {}

  explicit ListJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListJobResponseBody>(model1);
      }
    }
  }


  virtual ~ListJobResponse() = default;
};
class ListOTAFirmwareRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> destVersion{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};

  ListOTAFirmwareRequest() {}

  explicit ListOTAFirmwareRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (destVersion) {
      res["DestVersion"] = boost::any(*destVersion);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DestVersion") != m.end() && !m["DestVersion"].empty()) {
      destVersion = make_shared<string>(boost::any_cast<string>(m["DestVersion"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~ListOTAFirmwareRequest() = default;
};
class ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo : public Darabonba::Model {
public:
  shared_ptr<string> destVersion{};
  shared_ptr<string> firmwareDesc{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> firmwareName{};
  shared_ptr<string> firmwareSign{};
  shared_ptr<long> firmwareSize{};
  shared_ptr<string> moduleName{};
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};
  shared_ptr<string> signMethod{};
  shared_ptr<string> srcVersion{};
  shared_ptr<long> status{};
  shared_ptr<long> type{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> utcModified{};

  ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo() {}

  explicit ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destVersion) {
      res["DestVersion"] = boost::any(*destVersion);
    }
    if (firmwareDesc) {
      res["FirmwareDesc"] = boost::any(*firmwareDesc);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (firmwareName) {
      res["FirmwareName"] = boost::any(*firmwareName);
    }
    if (firmwareSign) {
      res["FirmwareSign"] = boost::any(*firmwareSign);
    }
    if (firmwareSize) {
      res["FirmwareSize"] = boost::any(*firmwareSize);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (signMethod) {
      res["SignMethod"] = boost::any(*signMethod);
    }
    if (srcVersion) {
      res["SrcVersion"] = boost::any(*srcVersion);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestVersion") != m.end() && !m["DestVersion"].empty()) {
      destVersion = make_shared<string>(boost::any_cast<string>(m["DestVersion"]));
    }
    if (m.find("FirmwareDesc") != m.end() && !m["FirmwareDesc"].empty()) {
      firmwareDesc = make_shared<string>(boost::any_cast<string>(m["FirmwareDesc"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("FirmwareName") != m.end() && !m["FirmwareName"].empty()) {
      firmwareName = make_shared<string>(boost::any_cast<string>(m["FirmwareName"]));
    }
    if (m.find("FirmwareSign") != m.end() && !m["FirmwareSign"].empty()) {
      firmwareSign = make_shared<string>(boost::any_cast<string>(m["FirmwareSign"]));
    }
    if (m.find("FirmwareSize") != m.end() && !m["FirmwareSize"].empty()) {
      firmwareSize = make_shared<long>(boost::any_cast<long>(m["FirmwareSize"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("SignMethod") != m.end() && !m["SignMethod"].empty()) {
      signMethod = make_shared<string>(boost::any_cast<string>(m["SignMethod"]));
    }
    if (m.find("SrcVersion") != m.end() && !m["SrcVersion"].empty()) {
      srcVersion = make_shared<string>(boost::any_cast<string>(m["SrcVersion"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
  }


  virtual ~ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo() = default;
};
class ListOTAFirmwareResponseBodyFirmwareInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo>> simpleFirmwareInfo{};

  ListOTAFirmwareResponseBodyFirmwareInfo() {}

  explicit ListOTAFirmwareResponseBodyFirmwareInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (simpleFirmwareInfo) {
      vector<boost::any> temp1;
      for(auto item1:*simpleFirmwareInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SimpleFirmwareInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SimpleFirmwareInfo") != m.end() && !m["SimpleFirmwareInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SimpleFirmwareInfo"].type()) {
        vector<ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SimpleFirmwareInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        simpleFirmwareInfo = make_shared<vector<ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo>>(expect1);
      }
    }
  }


  virtual ~ListOTAFirmwareResponseBodyFirmwareInfo() = default;
};
class ListOTAFirmwareResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> errorMessage{};
  shared_ptr<ListOTAFirmwareResponseBodyFirmwareInfo> firmwareInfo{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListOTAFirmwareResponseBody() {}

  explicit ListOTAFirmwareResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (firmwareInfo) {
      res["FirmwareInfo"] = firmwareInfo ? boost::any(firmwareInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("FirmwareInfo") != m.end() && !m["FirmwareInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FirmwareInfo"].type()) {
        ListOTAFirmwareResponseBodyFirmwareInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FirmwareInfo"]));
        firmwareInfo = make_shared<ListOTAFirmwareResponseBodyFirmwareInfo>(model1);
      }
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListOTAFirmwareResponseBody() = default;
};
class ListOTAFirmwareResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListOTAFirmwareResponseBody> body{};

  ListOTAFirmwareResponse() {}

  explicit ListOTAFirmwareResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOTAFirmwareResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOTAFirmwareResponseBody>(model1);
      }
    }
  }


  virtual ~ListOTAFirmwareResponse() = default;
};
class ListOTAJobByDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};

  ListOTAJobByDeviceRequest() {}

  explicit ListOTAJobByDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~ListOTAJobByDeviceRequest() = default;
};
class ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO() {}

  explicit ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO() = default;
};
class ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags : public Darabonba::Model {
public:
  shared_ptr<vector<ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO>> otaTagDTO{};

  ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags() {}

  explicit ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (otaTagDTO) {
      vector<boost::any> temp1;
      for(auto item1:*otaTagDTO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OtaTagDTO"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OtaTagDTO") != m.end() && !m["OtaTagDTO"].empty()) {
      if (typeid(vector<boost::any>) == m["OtaTagDTO"].type()) {
        vector<ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OtaTagDTO"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        otaTagDTO = make_shared<vector<ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO>>(expect1);
      }
    }
  }


  virtual ~ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags() = default;
};
class ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo : public Darabonba::Model {
public:
  shared_ptr<string> firmwareId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobStatus{};
  shared_ptr<string> jobType{};
  shared_ptr<string> productKey{};
  shared_ptr<string> selectionType{};
  shared_ptr<ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags> tags{};
  shared_ptr<string> targetSelection{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> utcEndTime{};
  shared_ptr<string> utcModified{};
  shared_ptr<string> utcStartTime{};

  ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo() {}

  explicit ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobStatus) {
      res["JobStatus"] = boost::any(*jobStatus);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (selectionType) {
      res["SelectionType"] = boost::any(*selectionType);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (targetSelection) {
      res["TargetSelection"] = boost::any(*targetSelection);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (utcEndTime) {
      res["UtcEndTime"] = boost::any(*utcEndTime);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (utcStartTime) {
      res["UtcStartTime"] = boost::any(*utcStartTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobStatus") != m.end() && !m["JobStatus"].empty()) {
      jobStatus = make_shared<string>(boost::any_cast<string>(m["JobStatus"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("SelectionType") != m.end() && !m["SelectionType"].empty()) {
      selectionType = make_shared<string>(boost::any_cast<string>(m["SelectionType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags>(model1);
      }
    }
    if (m.find("TargetSelection") != m.end() && !m["TargetSelection"].empty()) {
      targetSelection = make_shared<string>(boost::any_cast<string>(m["TargetSelection"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("UtcEndTime") != m.end() && !m["UtcEndTime"].empty()) {
      utcEndTime = make_shared<string>(boost::any_cast<string>(m["UtcEndTime"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("UtcStartTime") != m.end() && !m["UtcStartTime"].empty()) {
      utcStartTime = make_shared<string>(boost::any_cast<string>(m["UtcStartTime"]));
    }
  }


  virtual ~ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo() = default;
};
class ListOTAJobByDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo>> simpleOTAJobInfo{};

  ListOTAJobByDeviceResponseBodyData() {}

  explicit ListOTAJobByDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (simpleOTAJobInfo) {
      vector<boost::any> temp1;
      for(auto item1:*simpleOTAJobInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SimpleOTAJobInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SimpleOTAJobInfo") != m.end() && !m["SimpleOTAJobInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SimpleOTAJobInfo"].type()) {
        vector<ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SimpleOTAJobInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        simpleOTAJobInfo = make_shared<vector<ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo>>(expect1);
      }
    }
  }


  virtual ~ListOTAJobByDeviceResponseBodyData() = default;
};
class ListOTAJobByDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> currentPage{};
  shared_ptr<ListOTAJobByDeviceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListOTAJobByDeviceResponseBody() {}

  explicit ListOTAJobByDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListOTAJobByDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListOTAJobByDeviceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListOTAJobByDeviceResponseBody() = default;
};
class ListOTAJobByDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListOTAJobByDeviceResponseBody> body{};

  ListOTAJobByDeviceResponse() {}

  explicit ListOTAJobByDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOTAJobByDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOTAJobByDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~ListOTAJobByDeviceResponse() = default;
};
class ListOTAJobByFirmwareRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};

  ListOTAJobByFirmwareRequest() {}

  explicit ListOTAJobByFirmwareRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListOTAJobByFirmwareRequest() = default;
};
class ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO() {}

  explicit ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO() = default;
};
class ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags : public Darabonba::Model {
public:
  shared_ptr<vector<ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO>> otaTagDTO{};

  ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags() {}

  explicit ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (otaTagDTO) {
      vector<boost::any> temp1;
      for(auto item1:*otaTagDTO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OtaTagDTO"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OtaTagDTO") != m.end() && !m["OtaTagDTO"].empty()) {
      if (typeid(vector<boost::any>) == m["OtaTagDTO"].type()) {
        vector<ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OtaTagDTO"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        otaTagDTO = make_shared<vector<ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO>>(expect1);
      }
    }
  }


  virtual ~ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags() = default;
};
class ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo : public Darabonba::Model {
public:
  shared_ptr<string> firmwareId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobStatus{};
  shared_ptr<string> jobType{};
  shared_ptr<string> productKey{};
  shared_ptr<string> selectionType{};
  shared_ptr<ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags> tags{};
  shared_ptr<string> targetSelection{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> utcEndTime{};
  shared_ptr<string> utcModified{};
  shared_ptr<string> utcStartTime{};

  ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo() {}

  explicit ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobStatus) {
      res["JobStatus"] = boost::any(*jobStatus);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (selectionType) {
      res["SelectionType"] = boost::any(*selectionType);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (targetSelection) {
      res["TargetSelection"] = boost::any(*targetSelection);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (utcEndTime) {
      res["UtcEndTime"] = boost::any(*utcEndTime);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (utcStartTime) {
      res["UtcStartTime"] = boost::any(*utcStartTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobStatus") != m.end() && !m["JobStatus"].empty()) {
      jobStatus = make_shared<string>(boost::any_cast<string>(m["JobStatus"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("SelectionType") != m.end() && !m["SelectionType"].empty()) {
      selectionType = make_shared<string>(boost::any_cast<string>(m["SelectionType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags>(model1);
      }
    }
    if (m.find("TargetSelection") != m.end() && !m["TargetSelection"].empty()) {
      targetSelection = make_shared<string>(boost::any_cast<string>(m["TargetSelection"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("UtcEndTime") != m.end() && !m["UtcEndTime"].empty()) {
      utcEndTime = make_shared<string>(boost::any_cast<string>(m["UtcEndTime"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("UtcStartTime") != m.end() && !m["UtcStartTime"].empty()) {
      utcStartTime = make_shared<string>(boost::any_cast<string>(m["UtcStartTime"]));
    }
  }


  virtual ~ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo() = default;
};
class ListOTAJobByFirmwareResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo>> simpleOTAJobInfo{};

  ListOTAJobByFirmwareResponseBodyData() {}

  explicit ListOTAJobByFirmwareResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (simpleOTAJobInfo) {
      vector<boost::any> temp1;
      for(auto item1:*simpleOTAJobInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SimpleOTAJobInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SimpleOTAJobInfo") != m.end() && !m["SimpleOTAJobInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SimpleOTAJobInfo"].type()) {
        vector<ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SimpleOTAJobInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        simpleOTAJobInfo = make_shared<vector<ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo>>(expect1);
      }
    }
  }


  virtual ~ListOTAJobByFirmwareResponseBodyData() = default;
};
class ListOTAJobByFirmwareResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> currentPage{};
  shared_ptr<ListOTAJobByFirmwareResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListOTAJobByFirmwareResponseBody() {}

  explicit ListOTAJobByFirmwareResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListOTAJobByFirmwareResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListOTAJobByFirmwareResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListOTAJobByFirmwareResponseBody() = default;
};
class ListOTAJobByFirmwareResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListOTAJobByFirmwareResponseBody> body{};

  ListOTAJobByFirmwareResponse() {}

  explicit ListOTAJobByFirmwareResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOTAJobByFirmwareResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOTAJobByFirmwareResponseBody>(model1);
      }
    }
  }


  virtual ~ListOTAJobByFirmwareResponse() = default;
};
class ListOTAModuleByProductRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  ListOTAModuleByProductRequest() {}

  explicit ListOTAModuleByProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~ListOTAModuleByProductRequest() = default;
};
class ListOTAModuleByProductResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<string> desc{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> moduleName{};
  shared_ptr<string> productKey{};

  ListOTAModuleByProductResponseBodyData() {}

  explicit ListOTAModuleByProductResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~ListOTAModuleByProductResponseBodyData() = default;
};
class ListOTAModuleByProductResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListOTAModuleByProductResponseBodyData>> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListOTAModuleByProductResponseBody() {}

  explicit ListOTAModuleByProductResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListOTAModuleByProductResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOTAModuleByProductResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListOTAModuleByProductResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListOTAModuleByProductResponseBody() = default;
};
class ListOTAModuleByProductResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListOTAModuleByProductResponseBody> body{};

  ListOTAModuleByProductResponse() {}

  explicit ListOTAModuleByProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOTAModuleByProductResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOTAModuleByProductResponseBody>(model1);
      }
    }
  }


  virtual ~ListOTAModuleByProductResponse() = default;
};
class ListOTAModuleVersionsByDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};

  ListOTAModuleVersionsByDeviceRequest() {}

  explicit ListOTAModuleVersionsByDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~ListOTAModuleVersionsByDeviceRequest() = default;
};
class ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> moduleName{};
  shared_ptr<string> moduleVersion{};
  shared_ptr<string> productKey{};

  ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo() {}

  explicit ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    if (moduleVersion) {
      res["ModuleVersion"] = boost::any(*moduleVersion);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
    if (m.find("ModuleVersion") != m.end() && !m["ModuleVersion"].empty()) {
      moduleVersion = make_shared<string>(boost::any_cast<string>(m["ModuleVersion"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo() = default;
};
class ListOTAModuleVersionsByDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo>> simpleOTAModuleInfo{};

  ListOTAModuleVersionsByDeviceResponseBodyData() {}

  explicit ListOTAModuleVersionsByDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (simpleOTAModuleInfo) {
      vector<boost::any> temp1;
      for(auto item1:*simpleOTAModuleInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SimpleOTAModuleInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SimpleOTAModuleInfo") != m.end() && !m["SimpleOTAModuleInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SimpleOTAModuleInfo"].type()) {
        vector<ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SimpleOTAModuleInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        simpleOTAModuleInfo = make_shared<vector<ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo>>(expect1);
      }
    }
  }


  virtual ~ListOTAModuleVersionsByDeviceResponseBodyData() = default;
};
class ListOTAModuleVersionsByDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> currentPage{};
  shared_ptr<ListOTAModuleVersionsByDeviceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListOTAModuleVersionsByDeviceResponseBody() {}

  explicit ListOTAModuleVersionsByDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListOTAModuleVersionsByDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListOTAModuleVersionsByDeviceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListOTAModuleVersionsByDeviceResponseBody() = default;
};
class ListOTAModuleVersionsByDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListOTAModuleVersionsByDeviceResponseBody> body{};

  ListOTAModuleVersionsByDeviceResponse() {}

  explicit ListOTAModuleVersionsByDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOTAModuleVersionsByDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOTAModuleVersionsByDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~ListOTAModuleVersionsByDeviceResponse() = default;
};
class ListOTATaskByJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<string>> deviceNames{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> taskStatus{};

  ListOTATaskByJobRequest() {}

  explicit ListOTATaskByJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (deviceNames) {
      res["DeviceNames"] = boost::any(*deviceNames);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DeviceNames") != m.end() && !m["DeviceNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
  }


  virtual ~ListOTATaskByJobRequest() = default;
};
class ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo : public Darabonba::Model {
public:
  shared_ptr<string> destVersion{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> iotId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};
  shared_ptr<string> progress{};
  shared_ptr<string> srcVersion{};
  shared_ptr<string> taskDesc{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskStatus{};
  shared_ptr<string> timeout{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> utcModified{};

  ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo() {}

  explicit ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destVersion) {
      res["DestVersion"] = boost::any(*destVersion);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (srcVersion) {
      res["SrcVersion"] = boost::any(*srcVersion);
    }
    if (taskDesc) {
      res["TaskDesc"] = boost::any(*taskDesc);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestVersion") != m.end() && !m["DestVersion"].empty()) {
      destVersion = make_shared<string>(boost::any_cast<string>(m["DestVersion"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("SrcVersion") != m.end() && !m["SrcVersion"].empty()) {
      srcVersion = make_shared<string>(boost::any_cast<string>(m["SrcVersion"]));
    }
    if (m.find("TaskDesc") != m.end() && !m["TaskDesc"].empty()) {
      taskDesc = make_shared<string>(boost::any_cast<string>(m["TaskDesc"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<string>(boost::any_cast<string>(m["Timeout"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
  }


  virtual ~ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo() = default;
};
class ListOTATaskByJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo>> simpleOTATaskInfo{};

  ListOTATaskByJobResponseBodyData() {}

  explicit ListOTATaskByJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (simpleOTATaskInfo) {
      vector<boost::any> temp1;
      for(auto item1:*simpleOTATaskInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SimpleOTATaskInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SimpleOTATaskInfo") != m.end() && !m["SimpleOTATaskInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SimpleOTATaskInfo"].type()) {
        vector<ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SimpleOTATaskInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        simpleOTATaskInfo = make_shared<vector<ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo>>(expect1);
      }
    }
  }


  virtual ~ListOTATaskByJobResponseBodyData() = default;
};
class ListOTATaskByJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> currentPage{};
  shared_ptr<ListOTATaskByJobResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListOTATaskByJobResponseBody() {}

  explicit ListOTATaskByJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListOTATaskByJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListOTATaskByJobResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListOTATaskByJobResponseBody() = default;
};
class ListOTATaskByJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListOTATaskByJobResponseBody> body{};

  ListOTATaskByJobResponse() {}

  explicit ListOTATaskByJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOTATaskByJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOTATaskByJobResponseBody>(model1);
      }
    }
  }


  virtual ~ListOTATaskByJobResponse() = default;
};
class ListOTAUnfinishedTaskByDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> moduleName{};
  shared_ptr<string> productKey{};
  shared_ptr<string> taskStatus{};

  ListOTAUnfinishedTaskByDeviceRequest() {}

  explicit ListOTAUnfinishedTaskByDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
  }


  virtual ~ListOTAUnfinishedTaskByDeviceRequest() = default;
};
class ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo : public Darabonba::Model {
public:
  shared_ptr<string> destVersion{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> iotId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> moduleName{};
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};
  shared_ptr<string> srcVersion{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskStatus{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> utcModified{};

  ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo() {}

  explicit ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destVersion) {
      res["DestVersion"] = boost::any(*destVersion);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (srcVersion) {
      res["SrcVersion"] = boost::any(*srcVersion);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestVersion") != m.end() && !m["DestVersion"].empty()) {
      destVersion = make_shared<string>(boost::any_cast<string>(m["DestVersion"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("SrcVersion") != m.end() && !m["SrcVersion"].empty()) {
      srcVersion = make_shared<string>(boost::any_cast<string>(m["SrcVersion"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
  }


  virtual ~ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo() = default;
};
class ListOTAUnfinishedTaskByDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo>> simpleOTATaskInfo{};

  ListOTAUnfinishedTaskByDeviceResponseBodyData() {}

  explicit ListOTAUnfinishedTaskByDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (simpleOTATaskInfo) {
      vector<boost::any> temp1;
      for(auto item1:*simpleOTATaskInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SimpleOTATaskInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SimpleOTATaskInfo") != m.end() && !m["SimpleOTATaskInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SimpleOTATaskInfo"].type()) {
        vector<ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SimpleOTATaskInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        simpleOTATaskInfo = make_shared<vector<ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo>>(expect1);
      }
    }
  }


  virtual ~ListOTAUnfinishedTaskByDeviceResponseBodyData() = default;
};
class ListOTAUnfinishedTaskByDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListOTAUnfinishedTaskByDeviceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListOTAUnfinishedTaskByDeviceResponseBody() {}

  explicit ListOTAUnfinishedTaskByDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListOTAUnfinishedTaskByDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListOTAUnfinishedTaskByDeviceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListOTAUnfinishedTaskByDeviceResponseBody() = default;
};
class ListOTAUnfinishedTaskByDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListOTAUnfinishedTaskByDeviceResponseBody> body{};

  ListOTAUnfinishedTaskByDeviceResponse() {}

  explicit ListOTAUnfinishedTaskByDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOTAUnfinishedTaskByDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOTAUnfinishedTaskByDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~ListOTAUnfinishedTaskByDeviceResponse() = default;
};
class ListParserRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchName{};

  ListParserRequest() {}

  explicit ListParserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
  }


  virtual ~ListParserRequest() = default;
};
class ListParserResponseBodyDataParserList : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<long> parserId{};
  shared_ptr<string> status{};
  shared_ptr<string> utcCreated{};
  shared_ptr<string> utcModified{};

  ListParserResponseBodyDataParserList() {}

  explicit ListParserResponseBodyDataParserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parserId) {
      res["ParserId"] = boost::any(*parserId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (utcCreated) {
      res["UtcCreated"] = boost::any(*utcCreated);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParserId") != m.end() && !m["ParserId"].empty()) {
      parserId = make_shared<long>(boost::any_cast<long>(m["ParserId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UtcCreated") != m.end() && !m["UtcCreated"].empty()) {
      utcCreated = make_shared<string>(boost::any_cast<string>(m["UtcCreated"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
  }


  virtual ~ListParserResponseBodyDataParserList() = default;
};
class ListParserResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListParserResponseBodyDataParserList>> parserList{};

  ListParserResponseBodyData() {}

  explicit ListParserResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parserList) {
      vector<boost::any> temp1;
      for(auto item1:*parserList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ParserList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParserList") != m.end() && !m["ParserList"].empty()) {
      if (typeid(vector<boost::any>) == m["ParserList"].type()) {
        vector<ListParserResponseBodyDataParserList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ParserList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListParserResponseBodyDataParserList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        parserList = make_shared<vector<ListParserResponseBodyDataParserList>>(expect1);
      }
    }
  }


  virtual ~ListParserResponseBodyData() = default;
};
class ListParserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListParserResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListParserResponseBody() {}

  explicit ListParserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListParserResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListParserResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListParserResponseBody() = default;
};
class ListParserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListParserResponseBody> body{};

  ListParserResponse() {}

  explicit ListParserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListParserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListParserResponseBody>(model1);
      }
    }
  }


  virtual ~ListParserResponse() = default;
};
class ListParserDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchName{};

  ListParserDataSourceRequest() {}

  explicit ListParserDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
  }


  virtual ~ListParserDataSourceRequest() = default;
};
class ListParserDataSourceResponseBodyDataDataSource : public Darabonba::Model {
public:
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> utcCreated{};

  ListParserDataSourceResponseBodyDataDataSource() {}

  explicit ListParserDataSourceResponseBodyDataDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (utcCreated) {
      res["UtcCreated"] = boost::any(*utcCreated);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UtcCreated") != m.end() && !m["UtcCreated"].empty()) {
      utcCreated = make_shared<string>(boost::any_cast<string>(m["UtcCreated"]));
    }
  }


  virtual ~ListParserDataSourceResponseBodyDataDataSource() = default;
};
class ListParserDataSourceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListParserDataSourceResponseBodyDataDataSource>> dataSource{};

  ListParserDataSourceResponseBodyData() {}

  explicit ListParserDataSourceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSource) {
      vector<boost::any> temp1;
      for(auto item1:*dataSource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataSource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(vector<boost::any>) == m["DataSource"].type()) {
        vector<ListParserDataSourceResponseBodyDataDataSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataSource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListParserDataSourceResponseBodyDataDataSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataSource = make_shared<vector<ListParserDataSourceResponseBodyDataDataSource>>(expect1);
      }
    }
  }


  virtual ~ListParserDataSourceResponseBodyData() = default;
};
class ListParserDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListParserDataSourceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListParserDataSourceResponseBody() {}

  explicit ListParserDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListParserDataSourceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListParserDataSourceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListParserDataSourceResponseBody() = default;
};
class ListParserDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListParserDataSourceResponseBody> body{};

  ListParserDataSourceResponse() {}

  explicit ListParserDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListParserDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListParserDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~ListParserDataSourceResponse() = default;
};
class ListParserDestinationRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<bool> isFailover{};
  shared_ptr<long> parserId{};

  ListParserDestinationRequest() {}

  explicit ListParserDestinationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (isFailover) {
      res["IsFailover"] = boost::any(*isFailover);
    }
    if (parserId) {
      res["ParserId"] = boost::any(*parserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("IsFailover") != m.end() && !m["IsFailover"].empty()) {
      isFailover = make_shared<bool>(boost::any_cast<bool>(m["IsFailover"]));
    }
    if (m.find("ParserId") != m.end() && !m["ParserId"].empty()) {
      parserId = make_shared<long>(boost::any_cast<long>(m["ParserId"]));
    }
  }


  virtual ~ListParserDestinationRequest() = default;
};
class ListParserDestinationResponseBodyDataDestinations : public Darabonba::Model {
public:
  shared_ptr<string> configuration{};
  shared_ptr<long> destinationId{};
  shared_ptr<bool> isFailover{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> utcCreated{};
  shared_ptr<string> utcModified{};

  ListParserDestinationResponseBodyDataDestinations() {}

  explicit ListParserDestinationResponseBodyDataDestinations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configuration) {
      res["Configuration"] = boost::any(*configuration);
    }
    if (destinationId) {
      res["DestinationId"] = boost::any(*destinationId);
    }
    if (isFailover) {
      res["IsFailover"] = boost::any(*isFailover);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (utcCreated) {
      res["UtcCreated"] = boost::any(*utcCreated);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configuration = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
    if (m.find("DestinationId") != m.end() && !m["DestinationId"].empty()) {
      destinationId = make_shared<long>(boost::any_cast<long>(m["DestinationId"]));
    }
    if (m.find("IsFailover") != m.end() && !m["IsFailover"].empty()) {
      isFailover = make_shared<bool>(boost::any_cast<bool>(m["IsFailover"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UtcCreated") != m.end() && !m["UtcCreated"].empty()) {
      utcCreated = make_shared<string>(boost::any_cast<string>(m["UtcCreated"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
  }


  virtual ~ListParserDestinationResponseBodyDataDestinations() = default;
};
class ListParserDestinationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListParserDestinationResponseBodyDataDestinations>> destinations{};

  ListParserDestinationResponseBodyData() {}

  explicit ListParserDestinationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinations) {
      vector<boost::any> temp1;
      for(auto item1:*destinations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["destinations"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("destinations") != m.end() && !m["destinations"].empty()) {
      if (typeid(vector<boost::any>) == m["destinations"].type()) {
        vector<ListParserDestinationResponseBodyDataDestinations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["destinations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListParserDestinationResponseBodyDataDestinations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        destinations = make_shared<vector<ListParserDestinationResponseBodyDataDestinations>>(expect1);
      }
    }
  }


  virtual ~ListParserDestinationResponseBodyData() = default;
};
class ListParserDestinationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListParserDestinationResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListParserDestinationResponseBody() {}

  explicit ListParserDestinationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListParserDestinationResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListParserDestinationResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListParserDestinationResponseBody() = default;
};
class ListParserDestinationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListParserDestinationResponseBody> body{};

  ListParserDestinationResponse() {}

  explicit ListParserDestinationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListParserDestinationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListParserDestinationResponseBody>(model1);
      }
    }
  }


  virtual ~ListParserDestinationResponse() = default;
};
class ListProductByTagsRequestProductTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListProductByTagsRequestProductTag() {}

  explicit ListProductByTagsRequestProductTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListProductByTagsRequestProductTag() = default;
};
class ListProductByTagsRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListProductByTagsRequestProductTag>> productTag{};

  ListProductByTagsRequest() {}

  explicit ListProductByTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productTag) {
      vector<boost::any> temp1;
      for(auto item1:*productTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProductTag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductTag") != m.end() && !m["ProductTag"].empty()) {
      if (typeid(vector<boost::any>) == m["ProductTag"].type()) {
        vector<ListProductByTagsRequestProductTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProductTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProductByTagsRequestProductTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        productTag = make_shared<vector<ListProductByTagsRequestProductTag>>(expect1);
      }
    }
  }


  virtual ~ListProductByTagsRequest() = default;
};
class ListProductByTagsResponseBodyProductInfosProductInfo : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<long> nodeType{};
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};

  ListProductByTagsResponseBodyProductInfosProductInfo() {}

  explicit ListProductByTagsResponseBodyProductInfosProductInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<long>(boost::any_cast<long>(m["NodeType"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
  }


  virtual ~ListProductByTagsResponseBodyProductInfosProductInfo() = default;
};
class ListProductByTagsResponseBodyProductInfos : public Darabonba::Model {
public:
  shared_ptr<vector<ListProductByTagsResponseBodyProductInfosProductInfo>> productInfo{};

  ListProductByTagsResponseBodyProductInfos() {}

  explicit ListProductByTagsResponseBodyProductInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productInfo) {
      vector<boost::any> temp1;
      for(auto item1:*productInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProductInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductInfo") != m.end() && !m["ProductInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ProductInfo"].type()) {
        vector<ListProductByTagsResponseBodyProductInfosProductInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProductInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProductByTagsResponseBodyProductInfosProductInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        productInfo = make_shared<vector<ListProductByTagsResponseBodyProductInfosProductInfo>>(expect1);
      }
    }
  }


  virtual ~ListProductByTagsResponseBodyProductInfos() = default;
};
class ListProductByTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<ListProductByTagsResponseBodyProductInfos> productInfos{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListProductByTagsResponseBody() {}

  explicit ListProductByTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (productInfos) {
      res["ProductInfos"] = productInfos ? boost::any(productInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ProductInfos") != m.end() && !m["ProductInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProductInfos"].type()) {
        ListProductByTagsResponseBodyProductInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProductInfos"]));
        productInfos = make_shared<ListProductByTagsResponseBodyProductInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListProductByTagsResponseBody() = default;
};
class ListProductByTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListProductByTagsResponseBody> body{};

  ListProductByTagsResponse() {}

  explicit ListProductByTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProductByTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProductByTagsResponseBody>(model1);
      }
    }
  }


  virtual ~ListProductByTagsResponse() = default;
};
class ListProductTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  ListProductTagsRequest() {}

  explicit ListProductTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~ListProductTagsRequest() = default;
};
class ListProductTagsResponseBodyDataProductTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListProductTagsResponseBodyDataProductTag() {}

  explicit ListProductTagsResponseBodyDataProductTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListProductTagsResponseBodyDataProductTag() = default;
};
class ListProductTagsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListProductTagsResponseBodyDataProductTag>> productTag{};

  ListProductTagsResponseBodyData() {}

  explicit ListProductTagsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productTag) {
      vector<boost::any> temp1;
      for(auto item1:*productTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProductTag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductTag") != m.end() && !m["ProductTag"].empty()) {
      if (typeid(vector<boost::any>) == m["ProductTag"].type()) {
        vector<ListProductTagsResponseBodyDataProductTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProductTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProductTagsResponseBodyDataProductTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        productTag = make_shared<vector<ListProductTagsResponseBodyDataProductTag>>(expect1);
      }
    }
  }


  virtual ~ListProductTagsResponseBodyData() = default;
};
class ListProductTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListProductTagsResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListProductTagsResponseBody() {}

  explicit ListProductTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListProductTagsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListProductTagsResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListProductTagsResponseBody() = default;
};
class ListProductTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListProductTagsResponseBody> body{};

  ListProductTagsResponse() {}

  explicit ListProductTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProductTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProductTagsResponseBody>(model1);
      }
    }
  }


  virtual ~ListProductTagsResponse() = default;
};
class ListRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};

  ListRuleRequest() {}

  explicit ListRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListRuleRequest() = default;
};
class ListRuleResponseBodyDataRuleInfo : public Darabonba::Model {
public:
  shared_ptr<long> createUserId{};
  shared_ptr<string> created{};
  shared_ptr<string> dataType{};
  shared_ptr<long> id{};
  shared_ptr<string> modified{};
  shared_ptr<string> name{};
  shared_ptr<string> productKey{};
  shared_ptr<string> ruleDesc{};
  shared_ptr<string> select{};
  shared_ptr<string> shortTopic{};
  shared_ptr<string> status{};
  shared_ptr<string> topic{};
  shared_ptr<string> utcCreated{};
  shared_ptr<string> utcModified{};
  shared_ptr<string> where{};

  ListRuleResponseBodyDataRuleInfo() {}

  explicit ListRuleResponseBodyDataRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createUserId) {
      res["CreateUserId"] = boost::any(*createUserId);
    }
    if (created) {
      res["Created"] = boost::any(*created);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modified) {
      res["Modified"] = boost::any(*modified);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (ruleDesc) {
      res["RuleDesc"] = boost::any(*ruleDesc);
    }
    if (select) {
      res["Select"] = boost::any(*select);
    }
    if (shortTopic) {
      res["ShortTopic"] = boost::any(*shortTopic);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (utcCreated) {
      res["UtcCreated"] = boost::any(*utcCreated);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (where) {
      res["Where"] = boost::any(*where);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateUserId") != m.end() && !m["CreateUserId"].empty()) {
      createUserId = make_shared<long>(boost::any_cast<long>(m["CreateUserId"]));
    }
    if (m.find("Created") != m.end() && !m["Created"].empty()) {
      created = make_shared<string>(boost::any_cast<string>(m["Created"]));
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Modified") != m.end() && !m["Modified"].empty()) {
      modified = make_shared<string>(boost::any_cast<string>(m["Modified"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("RuleDesc") != m.end() && !m["RuleDesc"].empty()) {
      ruleDesc = make_shared<string>(boost::any_cast<string>(m["RuleDesc"]));
    }
    if (m.find("Select") != m.end() && !m["Select"].empty()) {
      select = make_shared<string>(boost::any_cast<string>(m["Select"]));
    }
    if (m.find("ShortTopic") != m.end() && !m["ShortTopic"].empty()) {
      shortTopic = make_shared<string>(boost::any_cast<string>(m["ShortTopic"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("UtcCreated") != m.end() && !m["UtcCreated"].empty()) {
      utcCreated = make_shared<string>(boost::any_cast<string>(m["UtcCreated"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("Where") != m.end() && !m["Where"].empty()) {
      where = make_shared<string>(boost::any_cast<string>(m["Where"]));
    }
  }


  virtual ~ListRuleResponseBodyDataRuleInfo() = default;
};
class ListRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListRuleResponseBodyDataRuleInfo>> ruleInfo{};

  ListRuleResponseBodyData() {}

  explicit ListRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleInfo) {
      vector<boost::any> temp1;
      for(auto item1:*ruleInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleInfo") != m.end() && !m["RuleInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleInfo"].type()) {
        vector<ListRuleResponseBodyDataRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRuleResponseBodyDataRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleInfo = make_shared<vector<ListRuleResponseBodyDataRuleInfo>>(expect1);
      }
    }
  }


  virtual ~ListRuleResponseBodyData() = default;
};
class ListRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListRuleResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListRuleResponseBody() {}

  explicit ListRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListRuleResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListRuleResponseBody() = default;
};
class ListRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRuleResponseBody> body{};

  ListRuleResponse() {}

  explicit ListRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ListRuleResponse() = default;
};
class ListRuleActionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> ruleId{};

  ListRuleActionsRequest() {}

  explicit ListRuleActionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~ListRuleActionsRequest() = default;
};
class ListRuleActionsResponseBodyRuleActionListRuleActionInfo : public Darabonba::Model {
public:
  shared_ptr<string> configuration{};
  shared_ptr<bool> errorActionFlag{};
  shared_ptr<long> id{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  ListRuleActionsResponseBodyRuleActionListRuleActionInfo() {}

  explicit ListRuleActionsResponseBodyRuleActionListRuleActionInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configuration) {
      res["Configuration"] = boost::any(*configuration);
    }
    if (errorActionFlag) {
      res["ErrorActionFlag"] = boost::any(*errorActionFlag);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configuration = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
    if (m.find("ErrorActionFlag") != m.end() && !m["ErrorActionFlag"].empty()) {
      errorActionFlag = make_shared<bool>(boost::any_cast<bool>(m["ErrorActionFlag"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListRuleActionsResponseBodyRuleActionListRuleActionInfo() = default;
};
class ListRuleActionsResponseBodyRuleActionList : public Darabonba::Model {
public:
  shared_ptr<vector<ListRuleActionsResponseBodyRuleActionListRuleActionInfo>> ruleActionInfo{};

  ListRuleActionsResponseBodyRuleActionList() {}

  explicit ListRuleActionsResponseBodyRuleActionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleActionInfo) {
      vector<boost::any> temp1;
      for(auto item1:*ruleActionInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleActionInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleActionInfo") != m.end() && !m["RuleActionInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleActionInfo"].type()) {
        vector<ListRuleActionsResponseBodyRuleActionListRuleActionInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleActionInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRuleActionsResponseBodyRuleActionListRuleActionInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleActionInfo = make_shared<vector<ListRuleActionsResponseBodyRuleActionListRuleActionInfo>>(expect1);
      }
    }
  }


  virtual ~ListRuleActionsResponseBodyRuleActionList() = default;
};
class ListRuleActionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<ListRuleActionsResponseBodyRuleActionList> ruleActionList{};
  shared_ptr<bool> success{};

  ListRuleActionsResponseBody() {}

  explicit ListRuleActionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleActionList) {
      res["RuleActionList"] = ruleActionList ? boost::any(ruleActionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleActionList") != m.end() && !m["RuleActionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuleActionList"].type()) {
        ListRuleActionsResponseBodyRuleActionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuleActionList"]));
        ruleActionList = make_shared<ListRuleActionsResponseBodyRuleActionList>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListRuleActionsResponseBody() = default;
};
class ListRuleActionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRuleActionsResponseBody> body{};

  ListRuleActionsResponse() {}

  explicit ListRuleActionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRuleActionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRuleActionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListRuleActionsResponse() = default;
};
class ListTaskRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> device{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<long> limit{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> status{};

  ListTaskRequest() {}

  explicit ListTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Device"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      device = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListTaskRequest() = default;
};
class ListTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceShrink{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<long> limit{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> status{};

  ListTaskShrinkRequest() {}

  explicit ListTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceShrink) {
      res["Device"] = boost::any(*deviceShrink);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      deviceShrink = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListTaskShrinkRequest() = default;
};
class ListTaskResponseBodyDataData : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobName{};
  shared_ptr<string> productKey{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<string> utcModified{};
  shared_ptr<string> utcQueueTime{};

  ListTaskResponseBodyDataData() {}

  explicit ListTaskResponseBodyDataData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (utcQueueTime) {
      res["UtcQueueTime"] = boost::any(*utcQueueTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("UtcQueueTime") != m.end() && !m["UtcQueueTime"].empty()) {
      utcQueueTime = make_shared<string>(boost::any_cast<string>(m["UtcQueueTime"]));
    }
  }


  virtual ~ListTaskResponseBodyDataData() = default;
};
class ListTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListTaskResponseBodyDataData>> data{};

  ListTaskResponseBodyData() {}

  explicit ListTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListTaskResponseBodyDataData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTaskResponseBodyDataData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListTaskResponseBodyDataData>>(expect1);
      }
    }
  }


  virtual ~ListTaskResponseBodyData() = default;
};
class ListTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListTaskResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListTaskResponseBody() {}

  explicit ListTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListTaskResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListTaskResponseBody() = default;
};
class ListTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTaskResponseBody> body{};

  ListTaskResponse() {}

  explicit ListTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTaskResponseBody>(model1);
      }
    }
  }


  virtual ~ListTaskResponse() = default;
};
class ListThingModelVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  ListThingModelVersionRequest() {}

  explicit ListThingModelVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~ListThingModelVersionRequest() = default;
};
class ListThingModelVersionResponseBodyDataModelVersions : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> modelVersion{};

  ListThingModelVersionResponseBodyDataModelVersions() {}

  explicit ListThingModelVersionResponseBodyDataModelVersions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (modelVersion) {
      res["ModelVersion"] = boost::any(*modelVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("ModelVersion") != m.end() && !m["ModelVersion"].empty()) {
      modelVersion = make_shared<string>(boost::any_cast<string>(m["ModelVersion"]));
    }
  }


  virtual ~ListThingModelVersionResponseBodyDataModelVersions() = default;
};
class ListThingModelVersionResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListThingModelVersionResponseBodyDataModelVersions>> modelVersions{};

  ListThingModelVersionResponseBodyData() {}

  explicit ListThingModelVersionResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (modelVersions) {
      vector<boost::any> temp1;
      for(auto item1:*modelVersions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ModelVersions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModelVersions") != m.end() && !m["ModelVersions"].empty()) {
      if (typeid(vector<boost::any>) == m["ModelVersions"].type()) {
        vector<ListThingModelVersionResponseBodyDataModelVersions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ModelVersions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListThingModelVersionResponseBodyDataModelVersions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        modelVersions = make_shared<vector<ListThingModelVersionResponseBodyDataModelVersions>>(expect1);
      }
    }
  }


  virtual ~ListThingModelVersionResponseBodyData() = default;
};
class ListThingModelVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListThingModelVersionResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListThingModelVersionResponseBody() {}

  explicit ListThingModelVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListThingModelVersionResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListThingModelVersionResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListThingModelVersionResponseBody() = default;
};
class ListThingModelVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListThingModelVersionResponseBody> body{};

  ListThingModelVersionResponse() {}

  explicit ListThingModelVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListThingModelVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListThingModelVersionResponseBody>(model1);
      }
    }
  }


  virtual ~ListThingModelVersionResponse() = default;
};
class ListThingTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};

  ListThingTemplatesRequest() {}

  explicit ListThingTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~ListThingTemplatesRequest() = default;
};
class ListThingTemplatesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> categoryKey{};
  shared_ptr<string> categoryName{};

  ListThingTemplatesResponseBodyData() {}

  explicit ListThingTemplatesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryKey) {
      res["CategoryKey"] = boost::any(*categoryKey);
    }
    if (categoryName) {
      res["CategoryName"] = boost::any(*categoryName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryKey") != m.end() && !m["CategoryKey"].empty()) {
      categoryKey = make_shared<string>(boost::any_cast<string>(m["CategoryKey"]));
    }
    if (m.find("CategoryName") != m.end() && !m["CategoryName"].empty()) {
      categoryName = make_shared<string>(boost::any_cast<string>(m["CategoryName"]));
    }
  }


  virtual ~ListThingTemplatesResponseBodyData() = default;
};
class ListThingTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListThingTemplatesResponseBodyData>> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListThingTemplatesResponseBody() {}

  explicit ListThingTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListThingTemplatesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListThingTemplatesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListThingTemplatesResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListThingTemplatesResponseBody() = default;
};
class ListThingTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListThingTemplatesResponseBody> body{};

  ListThingTemplatesResponse() {}

  explicit ListThingTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListThingTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListThingTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListThingTemplatesResponse() = default;
};
class ModifyOTAFirmwareRequest : public Darabonba::Model {
public:
  shared_ptr<string> firmwareDesc{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> firmwareName{};
  shared_ptr<string> firmwareUdi{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  ModifyOTAFirmwareRequest() {}

  explicit ModifyOTAFirmwareRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (firmwareDesc) {
      res["FirmwareDesc"] = boost::any(*firmwareDesc);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (firmwareName) {
      res["FirmwareName"] = boost::any(*firmwareName);
    }
    if (firmwareUdi) {
      res["FirmwareUdi"] = boost::any(*firmwareUdi);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FirmwareDesc") != m.end() && !m["FirmwareDesc"].empty()) {
      firmwareDesc = make_shared<string>(boost::any_cast<string>(m["FirmwareDesc"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("FirmwareName") != m.end() && !m["FirmwareName"].empty()) {
      firmwareName = make_shared<string>(boost::any_cast<string>(m["FirmwareName"]));
    }
    if (m.find("FirmwareUdi") != m.end() && !m["FirmwareUdi"].empty()) {
      firmwareUdi = make_shared<string>(boost::any_cast<string>(m["FirmwareUdi"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~ModifyOTAFirmwareRequest() = default;
};
class ModifyOTAFirmwareResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyOTAFirmwareResponseBody() {}

  explicit ModifyOTAFirmwareResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyOTAFirmwareResponseBody() = default;
};
class ModifyOTAFirmwareResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyOTAFirmwareResponseBody> body{};

  ModifyOTAFirmwareResponse() {}

  explicit ModifyOTAFirmwareResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyOTAFirmwareResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyOTAFirmwareResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyOTAFirmwareResponse() = default;
};
class NotifyAddThingTopoRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceListStr{};
  shared_ptr<string> gwDeviceName{};
  shared_ptr<string> gwIotId{};
  shared_ptr<string> gwProductKey{};
  shared_ptr<string> iotInstanceId{};

  NotifyAddThingTopoRequest() {}

  explicit NotifyAddThingTopoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceListStr) {
      res["DeviceListStr"] = boost::any(*deviceListStr);
    }
    if (gwDeviceName) {
      res["GwDeviceName"] = boost::any(*gwDeviceName);
    }
    if (gwIotId) {
      res["GwIotId"] = boost::any(*gwIotId);
    }
    if (gwProductKey) {
      res["GwProductKey"] = boost::any(*gwProductKey);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceListStr") != m.end() && !m["DeviceListStr"].empty()) {
      deviceListStr = make_shared<string>(boost::any_cast<string>(m["DeviceListStr"]));
    }
    if (m.find("GwDeviceName") != m.end() && !m["GwDeviceName"].empty()) {
      gwDeviceName = make_shared<string>(boost::any_cast<string>(m["GwDeviceName"]));
    }
    if (m.find("GwIotId") != m.end() && !m["GwIotId"].empty()) {
      gwIotId = make_shared<string>(boost::any_cast<string>(m["GwIotId"]));
    }
    if (m.find("GwProductKey") != m.end() && !m["GwProductKey"].empty()) {
      gwProductKey = make_shared<string>(boost::any_cast<string>(m["GwProductKey"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~NotifyAddThingTopoRequest() = default;
};
class NotifyAddThingTopoResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};

  NotifyAddThingTopoResponseBodyData() {}

  explicit NotifyAddThingTopoResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~NotifyAddThingTopoResponseBodyData() = default;
};
class NotifyAddThingTopoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<NotifyAddThingTopoResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  NotifyAddThingTopoResponseBody() {}

  explicit NotifyAddThingTopoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        NotifyAddThingTopoResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<NotifyAddThingTopoResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~NotifyAddThingTopoResponseBody() = default;
};
class NotifyAddThingTopoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<NotifyAddThingTopoResponseBody> body{};

  NotifyAddThingTopoResponse() {}

  explicit NotifyAddThingTopoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        NotifyAddThingTopoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<NotifyAddThingTopoResponseBody>(model1);
      }
    }
  }


  virtual ~NotifyAddThingTopoResponse() = default;
};
class OpenIotServiceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};

  OpenIotServiceRequest() {}

  explicit OpenIotServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~OpenIotServiceRequest() = default;
};
class OpenIotServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  OpenIotServiceResponseBody() {}

  explicit OpenIotServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OpenIotServiceResponseBody() = default;
};
class OpenIotServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenIotServiceResponseBody> body{};

  OpenIotServiceResponse() {}

  explicit OpenIotServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenIotServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenIotServiceResponseBody>(model1);
      }
    }
  }


  virtual ~OpenIotServiceResponse() = default;
};
class PackageSoundCodeLabelBatchAudioRequest : public Darabonba::Model {
public:
  shared_ptr<string> batchCode{};
  shared_ptr<string> iotInstanceId{};

  PackageSoundCodeLabelBatchAudioRequest() {}

  explicit PackageSoundCodeLabelBatchAudioRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchCode) {
      res["BatchCode"] = boost::any(*batchCode);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchCode") != m.end() && !m["BatchCode"].empty()) {
      batchCode = make_shared<string>(boost::any_cast<string>(m["BatchCode"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~PackageSoundCodeLabelBatchAudioRequest() = default;
};
class PackageSoundCodeLabelBatchAudioResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PackageSoundCodeLabelBatchAudioResponseBody() {}

  explicit PackageSoundCodeLabelBatchAudioResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PackageSoundCodeLabelBatchAudioResponseBody() = default;
};
class PackageSoundCodeLabelBatchAudioResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PackageSoundCodeLabelBatchAudioResponseBody> body{};

  PackageSoundCodeLabelBatchAudioResponse() {}

  explicit PackageSoundCodeLabelBatchAudioResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PackageSoundCodeLabelBatchAudioResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PackageSoundCodeLabelBatchAudioResponseBody>(model1);
      }
    }
  }


  virtual ~PackageSoundCodeLabelBatchAudioResponse() = default;
};
class PageQuerySharedSpeechOpenRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> shareTaskCode{};
  shared_ptr<long> status{};

  PageQuerySharedSpeechOpenRequest() {}

  explicit PageQuerySharedSpeechOpenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (shareTaskCode) {
      res["ShareTaskCode"] = boost::any(*shareTaskCode);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ShareTaskCode") != m.end() && !m["ShareTaskCode"].empty()) {
      shareTaskCode = make_shared<string>(boost::any_cast<string>(m["ShareTaskCode"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~PageQuerySharedSpeechOpenRequest() = default;
};
class PageQuerySharedSpeechOpenResponseBodyDataResultDataData : public Darabonba::Model {
public:
  shared_ptr<string> audioFormat{};
  shared_ptr<string> bizCode{};
  shared_ptr<string> code{};
  shared_ptr<long> speechRate{};
  shared_ptr<long> status{};
  shared_ptr<string> text{};
  shared_ptr<string> voice{};
  shared_ptr<long> volume{};

  PageQuerySharedSpeechOpenResponseBodyDataResultDataData() {}

  explicit PageQuerySharedSpeechOpenResponseBodyDataResultDataData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFormat) {
      res["AudioFormat"] = boost::any(*audioFormat);
    }
    if (bizCode) {
      res["BizCode"] = boost::any(*bizCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (speechRate) {
      res["SpeechRate"] = boost::any(*speechRate);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (voice) {
      res["Voice"] = boost::any(*voice);
    }
    if (volume) {
      res["Volume"] = boost::any(*volume);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFormat") != m.end() && !m["AudioFormat"].empty()) {
      audioFormat = make_shared<string>(boost::any_cast<string>(m["AudioFormat"]));
    }
    if (m.find("BizCode") != m.end() && !m["BizCode"].empty()) {
      bizCode = make_shared<string>(boost::any_cast<string>(m["BizCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("SpeechRate") != m.end() && !m["SpeechRate"].empty()) {
      speechRate = make_shared<long>(boost::any_cast<long>(m["SpeechRate"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Voice") != m.end() && !m["Voice"].empty()) {
      voice = make_shared<string>(boost::any_cast<string>(m["Voice"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      volume = make_shared<long>(boost::any_cast<long>(m["Volume"]));
    }
  }


  virtual ~PageQuerySharedSpeechOpenResponseBodyDataResultDataData() = default;
};
class PageQuerySharedSpeechOpenResponseBodyDataResultData : public Darabonba::Model {
public:
  shared_ptr<vector<PageQuerySharedSpeechOpenResponseBodyDataResultDataData>> data{};

  PageQuerySharedSpeechOpenResponseBodyDataResultData() {}

  explicit PageQuerySharedSpeechOpenResponseBodyDataResultData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<PageQuerySharedSpeechOpenResponseBodyDataResultDataData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PageQuerySharedSpeechOpenResponseBodyDataResultDataData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<PageQuerySharedSpeechOpenResponseBodyDataResultDataData>>(expect1);
      }
    }
  }


  virtual ~PageQuerySharedSpeechOpenResponseBodyDataResultData() = default;
};
class PageQuerySharedSpeechOpenResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<PageQuerySharedSpeechOpenResponseBodyDataResultData> resultData{};
  shared_ptr<long> total{};

  PageQuerySharedSpeechOpenResponseBodyData() {}

  explicit PageQuerySharedSpeechOpenResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resultData) {
      res["ResultData"] = resultData ? boost::any(resultData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResultData") != m.end() && !m["ResultData"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultData"].type()) {
        PageQuerySharedSpeechOpenResponseBodyDataResultData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultData"]));
        resultData = make_shared<PageQuerySharedSpeechOpenResponseBodyDataResultData>(model1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~PageQuerySharedSpeechOpenResponseBodyData() = default;
};
class PageQuerySharedSpeechOpenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<PageQuerySharedSpeechOpenResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PageQuerySharedSpeechOpenResponseBody() {}

  explicit PageQuerySharedSpeechOpenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        PageQuerySharedSpeechOpenResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<PageQuerySharedSpeechOpenResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PageQuerySharedSpeechOpenResponseBody() = default;
};
class PageQuerySharedSpeechOpenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PageQuerySharedSpeechOpenResponseBody> body{};

  PageQuerySharedSpeechOpenResponse() {}

  explicit PageQuerySharedSpeechOpenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PageQuerySharedSpeechOpenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PageQuerySharedSpeechOpenResponseBody>(model1);
      }
    }
  }


  virtual ~PageQuerySharedSpeechOpenResponse() = default;
};
class PageQuerySpeechBroadcastHourRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> pageToken{};
  shared_ptr<string> queryDateTimeHour{};
  shared_ptr<string> shareTaskCode{};

  PageQuerySpeechBroadcastHourRequest() {}

  explicit PageQuerySpeechBroadcastHourRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageToken) {
      res["PageToken"] = boost::any(*pageToken);
    }
    if (queryDateTimeHour) {
      res["QueryDateTimeHour"] = boost::any(*queryDateTimeHour);
    }
    if (shareTaskCode) {
      res["ShareTaskCode"] = boost::any(*shareTaskCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageToken") != m.end() && !m["PageToken"].empty()) {
      pageToken = make_shared<string>(boost::any_cast<string>(m["PageToken"]));
    }
    if (m.find("QueryDateTimeHour") != m.end() && !m["QueryDateTimeHour"].empty()) {
      queryDateTimeHour = make_shared<string>(boost::any_cast<string>(m["QueryDateTimeHour"]));
    }
    if (m.find("ShareTaskCode") != m.end() && !m["ShareTaskCode"].empty()) {
      shareTaskCode = make_shared<string>(boost::any_cast<string>(m["ShareTaskCode"]));
    }
  }


  virtual ~PageQuerySpeechBroadcastHourRequest() = default;
};
class PageQuerySpeechBroadcastHourResponseBodyDataResultDataData : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> msg{};
  shared_ptr<string> productKey{};
  shared_ptr<string> shareTaskCode{};
  shared_ptr<string> speechId{};
  shared_ptr<string> speechs{};
  shared_ptr<long> startTime{};

  PageQuerySpeechBroadcastHourResponseBodyDataResultDataData() {}

  explicit PageQuerySpeechBroadcastHourResponseBodyDataResultDataData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (shareTaskCode) {
      res["ShareTaskCode"] = boost::any(*shareTaskCode);
    }
    if (speechId) {
      res["SpeechId"] = boost::any(*speechId);
    }
    if (speechs) {
      res["Speechs"] = boost::any(*speechs);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ShareTaskCode") != m.end() && !m["ShareTaskCode"].empty()) {
      shareTaskCode = make_shared<string>(boost::any_cast<string>(m["ShareTaskCode"]));
    }
    if (m.find("SpeechId") != m.end() && !m["SpeechId"].empty()) {
      speechId = make_shared<string>(boost::any_cast<string>(m["SpeechId"]));
    }
    if (m.find("Speechs") != m.end() && !m["Speechs"].empty()) {
      speechs = make_shared<string>(boost::any_cast<string>(m["Speechs"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~PageQuerySpeechBroadcastHourResponseBodyDataResultDataData() = default;
};
class PageQuerySpeechBroadcastHourResponseBodyDataResultData : public Darabonba::Model {
public:
  shared_ptr<vector<PageQuerySpeechBroadcastHourResponseBodyDataResultDataData>> data{};

  PageQuerySpeechBroadcastHourResponseBodyDataResultData() {}

  explicit PageQuerySpeechBroadcastHourResponseBodyDataResultData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<PageQuerySpeechBroadcastHourResponseBodyDataResultDataData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PageQuerySpeechBroadcastHourResponseBodyDataResultDataData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<PageQuerySpeechBroadcastHourResponseBodyDataResultDataData>>(expect1);
      }
    }
  }


  virtual ~PageQuerySpeechBroadcastHourResponseBodyDataResultData() = default;
};
class PageQuerySpeechBroadcastHourResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> pageToken{};
  shared_ptr<PageQuerySpeechBroadcastHourResponseBodyDataResultData> resultData{};
  shared_ptr<long> total{};

  PageQuerySpeechBroadcastHourResponseBodyData() {}

  explicit PageQuerySpeechBroadcastHourResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageToken) {
      res["PageToken"] = boost::any(*pageToken);
    }
    if (resultData) {
      res["ResultData"] = resultData ? boost::any(resultData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageToken") != m.end() && !m["PageToken"].empty()) {
      pageToken = make_shared<string>(boost::any_cast<string>(m["PageToken"]));
    }
    if (m.find("ResultData") != m.end() && !m["ResultData"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultData"].type()) {
        PageQuerySpeechBroadcastHourResponseBodyDataResultData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultData"]));
        resultData = make_shared<PageQuerySpeechBroadcastHourResponseBodyDataResultData>(model1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~PageQuerySpeechBroadcastHourResponseBodyData() = default;
};
class PageQuerySpeechBroadcastHourResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<PageQuerySpeechBroadcastHourResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PageQuerySpeechBroadcastHourResponseBody() {}

  explicit PageQuerySpeechBroadcastHourResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        PageQuerySpeechBroadcastHourResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<PageQuerySpeechBroadcastHourResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PageQuerySpeechBroadcastHourResponseBody() = default;
};
class PageQuerySpeechBroadcastHourResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PageQuerySpeechBroadcastHourResponseBody> body{};

  PageQuerySpeechBroadcastHourResponse() {}

  explicit PageQuerySpeechBroadcastHourResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PageQuerySpeechBroadcastHourResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PageQuerySpeechBroadcastHourResponseBody>(model1);
      }
    }
  }


  virtual ~PageQuerySpeechBroadcastHourResponse() = default;
};
class PrintByTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<bool> historyPrintTopic{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> paramsJsonString{};
  shared_ptr<string> productKey{};
  shared_ptr<string> templateBizCode{};

  PrintByTemplateRequest() {}

  explicit PrintByTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (historyPrintTopic) {
      res["HistoryPrintTopic"] = boost::any(*historyPrintTopic);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (paramsJsonString) {
      res["ParamsJsonString"] = boost::any(*paramsJsonString);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (templateBizCode) {
      res["TemplateBizCode"] = boost::any(*templateBizCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("HistoryPrintTopic") != m.end() && !m["HistoryPrintTopic"].empty()) {
      historyPrintTopic = make_shared<bool>(boost::any_cast<bool>(m["HistoryPrintTopic"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ParamsJsonString") != m.end() && !m["ParamsJsonString"].empty()) {
      paramsJsonString = make_shared<string>(boost::any_cast<string>(m["ParamsJsonString"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("TemplateBizCode") != m.end() && !m["TemplateBizCode"].empty()) {
      templateBizCode = make_shared<string>(boost::any_cast<string>(m["TemplateBizCode"]));
    }
  }


  virtual ~PrintByTemplateRequest() = default;
};
class PrintByTemplateResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> deviceErrorCode{};
  shared_ptr<string> deviceErrorMessage{};
  shared_ptr<string> id{};
  shared_ptr<long> maxRetryCount{};
  shared_ptr<long> retryCount{};
  shared_ptr<bool> success{};

  PrintByTemplateResponseBodyData() {}

  explicit PrintByTemplateResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceErrorCode) {
      res["DeviceErrorCode"] = boost::any(*deviceErrorCode);
    }
    if (deviceErrorMessage) {
      res["DeviceErrorMessage"] = boost::any(*deviceErrorMessage);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (maxRetryCount) {
      res["MaxRetryCount"] = boost::any(*maxRetryCount);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceErrorCode") != m.end() && !m["DeviceErrorCode"].empty()) {
      deviceErrorCode = make_shared<string>(boost::any_cast<string>(m["DeviceErrorCode"]));
    }
    if (m.find("DeviceErrorMessage") != m.end() && !m["DeviceErrorMessage"].empty()) {
      deviceErrorMessage = make_shared<string>(boost::any_cast<string>(m["DeviceErrorMessage"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MaxRetryCount") != m.end() && !m["MaxRetryCount"].empty()) {
      maxRetryCount = make_shared<long>(boost::any_cast<long>(m["MaxRetryCount"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<long>(boost::any_cast<long>(m["RetryCount"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PrintByTemplateResponseBodyData() = default;
};
class PrintByTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<PrintByTemplateResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PrintByTemplateResponseBody() {}

  explicit PrintByTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        PrintByTemplateResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<PrintByTemplateResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PrintByTemplateResponseBody() = default;
};
class PrintByTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PrintByTemplateResponseBody> body{};

  PrintByTemplateResponse() {}

  explicit PrintByTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PrintByTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PrintByTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~PrintByTemplateResponse() = default;
};
class PubRequestUserProp : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  PubRequestUserProp() {}

  explicit PubRequestUserProp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~PubRequestUserProp() = default;
};
class PubRequest : public Darabonba::Model {
public:
  shared_ptr<string> contentType{};
  shared_ptr<string> correlationData{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> messageContent{};
  shared_ptr<long> messageExpiryInterval{};
  shared_ptr<long> payloadFormatIndicator{};
  shared_ptr<string> productKey{};
  shared_ptr<long> qos{};
  shared_ptr<string> responseTopic{};
  shared_ptr<bool> retained{};
  shared_ptr<long> topicAlias{};
  shared_ptr<string> topicFullName{};
  shared_ptr<vector<PubRequestUserProp>> userProp{};

  PubRequest() {}

  explicit PubRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (correlationData) {
      res["CorrelationData"] = boost::any(*correlationData);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (messageContent) {
      res["MessageContent"] = boost::any(*messageContent);
    }
    if (messageExpiryInterval) {
      res["MessageExpiryInterval"] = boost::any(*messageExpiryInterval);
    }
    if (payloadFormatIndicator) {
      res["PayloadFormatIndicator"] = boost::any(*payloadFormatIndicator);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (qos) {
      res["Qos"] = boost::any(*qos);
    }
    if (responseTopic) {
      res["ResponseTopic"] = boost::any(*responseTopic);
    }
    if (retained) {
      res["Retained"] = boost::any(*retained);
    }
    if (topicAlias) {
      res["TopicAlias"] = boost::any(*topicAlias);
    }
    if (topicFullName) {
      res["TopicFullName"] = boost::any(*topicFullName);
    }
    if (userProp) {
      vector<boost::any> temp1;
      for(auto item1:*userProp){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserProp"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("CorrelationData") != m.end() && !m["CorrelationData"].empty()) {
      correlationData = make_shared<string>(boost::any_cast<string>(m["CorrelationData"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("MessageContent") != m.end() && !m["MessageContent"].empty()) {
      messageContent = make_shared<string>(boost::any_cast<string>(m["MessageContent"]));
    }
    if (m.find("MessageExpiryInterval") != m.end() && !m["MessageExpiryInterval"].empty()) {
      messageExpiryInterval = make_shared<long>(boost::any_cast<long>(m["MessageExpiryInterval"]));
    }
    if (m.find("PayloadFormatIndicator") != m.end() && !m["PayloadFormatIndicator"].empty()) {
      payloadFormatIndicator = make_shared<long>(boost::any_cast<long>(m["PayloadFormatIndicator"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Qos") != m.end() && !m["Qos"].empty()) {
      qos = make_shared<long>(boost::any_cast<long>(m["Qos"]));
    }
    if (m.find("ResponseTopic") != m.end() && !m["ResponseTopic"].empty()) {
      responseTopic = make_shared<string>(boost::any_cast<string>(m["ResponseTopic"]));
    }
    if (m.find("Retained") != m.end() && !m["Retained"].empty()) {
      retained = make_shared<bool>(boost::any_cast<bool>(m["Retained"]));
    }
    if (m.find("TopicAlias") != m.end() && !m["TopicAlias"].empty()) {
      topicAlias = make_shared<long>(boost::any_cast<long>(m["TopicAlias"]));
    }
    if (m.find("TopicFullName") != m.end() && !m["TopicFullName"].empty()) {
      topicFullName = make_shared<string>(boost::any_cast<string>(m["TopicFullName"]));
    }
    if (m.find("UserProp") != m.end() && !m["UserProp"].empty()) {
      if (typeid(vector<boost::any>) == m["UserProp"].type()) {
        vector<PubRequestUserProp> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserProp"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PubRequestUserProp model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userProp = make_shared<vector<PubRequestUserProp>>(expect1);
      }
    }
  }


  virtual ~PubRequest() = default;
};
class PubResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> messageId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PubResponseBody() {}

  explicit PubResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PubResponseBody() = default;
};
class PubResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PubResponseBody> body{};

  PubResponse() {}

  explicit PubResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PubResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PubResponseBody>(model1);
      }
    }
  }


  virtual ~PubResponse() = default;
};
class PubBroadcastRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> messageContent{};
  shared_ptr<string> productKey{};
  shared_ptr<string> topicFullName{};

  PubBroadcastRequest() {}

  explicit PubBroadcastRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (messageContent) {
      res["MessageContent"] = boost::any(*messageContent);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (topicFullName) {
      res["TopicFullName"] = boost::any(*topicFullName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("MessageContent") != m.end() && !m["MessageContent"].empty()) {
      messageContent = make_shared<string>(boost::any_cast<string>(m["MessageContent"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("TopicFullName") != m.end() && !m["TopicFullName"].empty()) {
      topicFullName = make_shared<string>(boost::any_cast<string>(m["TopicFullName"]));
    }
  }


  virtual ~PubBroadcastRequest() = default;
};
class PubBroadcastResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> messageId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PubBroadcastResponseBody() {}

  explicit PubBroadcastResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<long>(boost::any_cast<long>(m["MessageId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PubBroadcastResponseBody() = default;
};
class PubBroadcastResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PubBroadcastResponseBody> body{};

  PubBroadcastResponse() {}

  explicit PubBroadcastResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PubBroadcastResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PubBroadcastResponseBody>(model1);
      }
    }
  }


  virtual ~PubBroadcastResponse() = default;
};
class PublishScriptRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> parserId{};

  PublishScriptRequest() {}

  explicit PublishScriptRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (parserId) {
      res["ParserId"] = boost::any(*parserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ParserId") != m.end() && !m["ParserId"].empty()) {
      parserId = make_shared<long>(boost::any_cast<long>(m["ParserId"]));
    }
  }


  virtual ~PublishScriptRequest() = default;
};
class PublishScriptResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> syntaxErrorMsg{};

  PublishScriptResponseBody() {}

  explicit PublishScriptResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (syntaxErrorMsg) {
      res["SyntaxErrorMsg"] = boost::any(*syntaxErrorMsg);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("SyntaxErrorMsg") != m.end() && !m["SyntaxErrorMsg"].empty()) {
      syntaxErrorMsg = make_shared<string>(boost::any_cast<string>(m["SyntaxErrorMsg"]));
    }
  }


  virtual ~PublishScriptResponseBody() = default;
};
class PublishScriptResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PublishScriptResponseBody> body{};

  PublishScriptResponse() {}

  explicit PublishScriptResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublishScriptResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublishScriptResponseBody>(model1);
      }
    }
  }


  virtual ~PublishScriptResponse() = default;
};
class PublishStudioAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> description{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> projectId{};

  PublishStudioAppRequest() {}

  explicit PublishStudioAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~PublishStudioAppRequest() = default;
};
class PublishStudioAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PublishStudioAppResponseBody() {}

  explicit PublishStudioAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PublishStudioAppResponseBody() = default;
};
class PublishStudioAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PublishStudioAppResponseBody> body{};

  PublishStudioAppResponse() {}

  explicit PublishStudioAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublishStudioAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublishStudioAppResponseBody>(model1);
      }
    }
  }


  virtual ~PublishStudioAppResponse() = default;
};
class PublishThingModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> modelVersion{};
  shared_ptr<string> productKey{};
  shared_ptr<string> resourceGroupId{};

  PublishThingModelRequest() {}

  explicit PublishThingModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (modelVersion) {
      res["ModelVersion"] = boost::any(*modelVersion);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ModelVersion") != m.end() && !m["ModelVersion"].empty()) {
      modelVersion = make_shared<string>(boost::any_cast<string>(m["ModelVersion"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~PublishThingModelRequest() = default;
};
class PublishThingModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PublishThingModelResponseBody() {}

  explicit PublishThingModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PublishThingModelResponseBody() = default;
};
class PublishThingModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PublishThingModelResponseBody> body{};

  PublishThingModelResponse() {}

  explicit PublishThingModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublishThingModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublishThingModelResponseBody>(model1);
      }
    }
  }


  virtual ~PublishThingModelResponse() = default;
};
class PushSpeechRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> pushMode{};
  shared_ptr<vector<string>> speechCodeList{};

  PushSpeechRequest() {}

  explicit PushSpeechRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (projectCode) {
      res["ProjectCode"] = boost::any(*projectCode);
    }
    if (pushMode) {
      res["PushMode"] = boost::any(*pushMode);
    }
    if (speechCodeList) {
      res["SpeechCodeList"] = boost::any(*speechCodeList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProjectCode") != m.end() && !m["ProjectCode"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["ProjectCode"]));
    }
    if (m.find("PushMode") != m.end() && !m["PushMode"].empty()) {
      pushMode = make_shared<string>(boost::any_cast<string>(m["PushMode"]));
    }
    if (m.find("SpeechCodeList") != m.end() && !m["SpeechCodeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SpeechCodeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SpeechCodeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      speechCodeList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~PushSpeechRequest() = default;
};
class PushSpeechResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PushSpeechResponseBody() {}

  explicit PushSpeechResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PushSpeechResponseBody() = default;
};
class PushSpeechResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PushSpeechResponseBody> body{};

  PushSpeechResponse() {}

  explicit PushSpeechResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PushSpeechResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PushSpeechResponseBody>(model1);
      }
    }
  }


  virtual ~PushSpeechResponse() = default;
};
class QueryBatchRegisterDeviceStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  QueryBatchRegisterDeviceStatusRequest() {}

  explicit QueryBatchRegisterDeviceStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["ApplyId"] = boost::any(*applyId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyId") != m.end() && !m["ApplyId"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["ApplyId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryBatchRegisterDeviceStatusRequest() = default;
};
class QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailListInvalidDetailList : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> nickName{};

  QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailListInvalidDetailList() {}

  explicit QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailListInvalidDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (nickName) {
      res["NickName"] = boost::any(*nickName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("NickName") != m.end() && !m["NickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["NickName"]));
    }
  }


  virtual ~QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailListInvalidDetailList() = default;
};
class QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailListInvalidDetailList>> invalidDetailList{};

  QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailList() {}

  explicit QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invalidDetailList) {
      vector<boost::any> temp1;
      for(auto item1:*invalidDetailList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["invalidDetailList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("invalidDetailList") != m.end() && !m["invalidDetailList"].empty()) {
      if (typeid(vector<boost::any>) == m["invalidDetailList"].type()) {
        vector<QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailListInvalidDetailList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["invalidDetailList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailListInvalidDetailList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        invalidDetailList = make_shared<vector<QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailListInvalidDetailList>>(expect1);
      }
    }
  }


  virtual ~QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailList() = default;
};
class QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> name{};

  QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList() {}

  explicit QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Name"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Name"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      name = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList() = default;
};
class QueryBatchRegisterDeviceStatusResponseBodyDataValidList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> name{};

  QueryBatchRegisterDeviceStatusResponseBodyDataValidList() {}

  explicit QueryBatchRegisterDeviceStatusResponseBodyDataValidList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Name"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Name"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      name = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryBatchRegisterDeviceStatusResponseBodyDataValidList() = default;
};
class QueryBatchRegisterDeviceStatusResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailList> invalidDetailList{};
  shared_ptr<QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList> invalidList{};
  shared_ptr<string> status{};
  shared_ptr<QueryBatchRegisterDeviceStatusResponseBodyDataValidList> validList{};

  QueryBatchRegisterDeviceStatusResponseBodyData() {}

  explicit QueryBatchRegisterDeviceStatusResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invalidDetailList) {
      res["InvalidDetailList"] = invalidDetailList ? boost::any(invalidDetailList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (invalidList) {
      res["InvalidList"] = invalidList ? boost::any(invalidList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (validList) {
      res["ValidList"] = validList ? boost::any(validList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InvalidDetailList") != m.end() && !m["InvalidDetailList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvalidDetailList"].type()) {
        QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvalidDetailList"]));
        invalidDetailList = make_shared<QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailList>(model1);
      }
    }
    if (m.find("InvalidList") != m.end() && !m["InvalidList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvalidList"].type()) {
        QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvalidList"]));
        invalidList = make_shared<QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ValidList") != m.end() && !m["ValidList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ValidList"].type()) {
        QueryBatchRegisterDeviceStatusResponseBodyDataValidList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ValidList"]));
        validList = make_shared<QueryBatchRegisterDeviceStatusResponseBodyDataValidList>(model1);
      }
    }
  }


  virtual ~QueryBatchRegisterDeviceStatusResponseBodyData() = default;
};
class QueryBatchRegisterDeviceStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryBatchRegisterDeviceStatusResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryBatchRegisterDeviceStatusResponseBody() {}

  explicit QueryBatchRegisterDeviceStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryBatchRegisterDeviceStatusResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryBatchRegisterDeviceStatusResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryBatchRegisterDeviceStatusResponseBody() = default;
};
class QueryBatchRegisterDeviceStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryBatchRegisterDeviceStatusResponseBody> body{};

  QueryBatchRegisterDeviceStatusResponse() {}

  explicit QueryBatchRegisterDeviceStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryBatchRegisterDeviceStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryBatchRegisterDeviceStatusResponseBody>(model1);
      }
    }
  }


  virtual ~QueryBatchRegisterDeviceStatusResponse() = default;
};
class QueryCertUrlByApplyIdRequest : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<string> iotInstanceId{};

  QueryCertUrlByApplyIdRequest() {}

  explicit QueryCertUrlByApplyIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["ApplyId"] = boost::any(*applyId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyId") != m.end() && !m["ApplyId"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["ApplyId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~QueryCertUrlByApplyIdRequest() = default;
};
class QueryCertUrlByApplyIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> certUrl{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryCertUrlByApplyIdResponseBody() {}

  explicit QueryCertUrlByApplyIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certUrl) {
      res["CertUrl"] = boost::any(*certUrl);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertUrl") != m.end() && !m["CertUrl"].empty()) {
      certUrl = make_shared<string>(boost::any_cast<string>(m["CertUrl"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryCertUrlByApplyIdResponseBody() = default;
};
class QueryCertUrlByApplyIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryCertUrlByApplyIdResponseBody> body{};

  QueryCertUrlByApplyIdResponse() {}

  explicit QueryCertUrlByApplyIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryCertUrlByApplyIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryCertUrlByApplyIdResponseBody>(model1);
      }
    }
  }


  virtual ~QueryCertUrlByApplyIdResponse() = default;
};
class QueryClientIdsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};

  QueryClientIdsRequest() {}

  explicit QueryClientIdsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~QueryClientIdsRequest() = default;
};
class QueryClientIdsResponseBodyDataDynamicRegClientIds : public Darabonba::Model {
public:
  shared_ptr<string> clientId{};
  shared_ptr<long> createTime{};

  QueryClientIdsResponseBodyDataDynamicRegClientIds() {}

  explicit QueryClientIdsResponseBodyDataDynamicRegClientIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
  }


  virtual ~QueryClientIdsResponseBodyDataDynamicRegClientIds() = default;
};
class QueryClientIdsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryClientIdsResponseBodyDataDynamicRegClientIds>> dynamicRegClientIds{};
  shared_ptr<string> iotId{};

  QueryClientIdsResponseBodyData() {}

  explicit QueryClientIdsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicRegClientIds) {
      vector<boost::any> temp1;
      for(auto item1:*dynamicRegClientIds){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DynamicRegClientIds"] = boost::any(temp1);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicRegClientIds") != m.end() && !m["DynamicRegClientIds"].empty()) {
      if (typeid(vector<boost::any>) == m["DynamicRegClientIds"].type()) {
        vector<QueryClientIdsResponseBodyDataDynamicRegClientIds> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DynamicRegClientIds"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryClientIdsResponseBodyDataDynamicRegClientIds model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dynamicRegClientIds = make_shared<vector<QueryClientIdsResponseBodyDataDynamicRegClientIds>>(expect1);
      }
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~QueryClientIdsResponseBodyData() = default;
};
class QueryClientIdsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryClientIdsResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryClientIdsResponseBody() {}

  explicit QueryClientIdsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryClientIdsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryClientIdsResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryClientIdsResponseBody() = default;
};
class QueryClientIdsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryClientIdsResponseBody> body{};

  QueryClientIdsResponse() {}

  explicit QueryClientIdsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryClientIdsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryClientIdsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryClientIdsResponse() = default;
};
class QueryConsumerGroupByGroupIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> iotInstanceId{};

  QueryConsumerGroupByGroupIdRequest() {}

  explicit QueryConsumerGroupByGroupIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~QueryConsumerGroupByGroupIdRequest() = default;
};
class QueryConsumerGroupByGroupIdResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};

  QueryConsumerGroupByGroupIdResponseBodyData() {}

  explicit QueryConsumerGroupByGroupIdResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~QueryConsumerGroupByGroupIdResponseBodyData() = default;
};
class QueryConsumerGroupByGroupIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryConsumerGroupByGroupIdResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryConsumerGroupByGroupIdResponseBody() {}

  explicit QueryConsumerGroupByGroupIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryConsumerGroupByGroupIdResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryConsumerGroupByGroupIdResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryConsumerGroupByGroupIdResponseBody() = default;
};
class QueryConsumerGroupByGroupIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryConsumerGroupByGroupIdResponseBody> body{};

  QueryConsumerGroupByGroupIdResponse() {}

  explicit QueryConsumerGroupByGroupIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryConsumerGroupByGroupIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryConsumerGroupByGroupIdResponseBody>(model1);
      }
    }
  }


  virtual ~QueryConsumerGroupByGroupIdResponse() = default;
};
class QueryConsumerGroupListRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<bool> fuzzy{};
  shared_ptr<string> groupName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> subBizCode{};
  shared_ptr<string> type{};

  QueryConsumerGroupListRequest() {}

  explicit QueryConsumerGroupListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (fuzzy) {
      res["Fuzzy"] = boost::any(*fuzzy);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (subBizCode) {
      res["SubBizCode"] = boost::any(*subBizCode);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Fuzzy") != m.end() && !m["Fuzzy"].empty()) {
      fuzzy = make_shared<bool>(boost::any_cast<bool>(m["Fuzzy"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SubBizCode") != m.end() && !m["SubBizCode"].empty()) {
      subBizCode = make_shared<string>(boost::any_cast<string>(m["SubBizCode"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryConsumerGroupListRequest() = default;
};
class QueryConsumerGroupListResponseBodyDataConsumerGroupDTO : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};

  QueryConsumerGroupListResponseBodyDataConsumerGroupDTO() {}

  explicit QueryConsumerGroupListResponseBodyDataConsumerGroupDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~QueryConsumerGroupListResponseBodyDataConsumerGroupDTO() = default;
};
class QueryConsumerGroupListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryConsumerGroupListResponseBodyDataConsumerGroupDTO>> consumerGroupDTO{};

  QueryConsumerGroupListResponseBodyData() {}

  explicit QueryConsumerGroupListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consumerGroupDTO) {
      vector<boost::any> temp1;
      for(auto item1:*consumerGroupDTO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConsumerGroupDTO"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsumerGroupDTO") != m.end() && !m["ConsumerGroupDTO"].empty()) {
      if (typeid(vector<boost::any>) == m["ConsumerGroupDTO"].type()) {
        vector<QueryConsumerGroupListResponseBodyDataConsumerGroupDTO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConsumerGroupDTO"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryConsumerGroupListResponseBodyDataConsumerGroupDTO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        consumerGroupDTO = make_shared<vector<QueryConsumerGroupListResponseBodyDataConsumerGroupDTO>>(expect1);
      }
    }
  }


  virtual ~QueryConsumerGroupListResponseBodyData() = default;
};
class QueryConsumerGroupListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> currentPage{};
  shared_ptr<QueryConsumerGroupListResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  QueryConsumerGroupListResponseBody() {}

  explicit QueryConsumerGroupListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryConsumerGroupListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryConsumerGroupListResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryConsumerGroupListResponseBody() = default;
};
class QueryConsumerGroupListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryConsumerGroupListResponseBody> body{};

  QueryConsumerGroupListResponse() {}

  explicit QueryConsumerGroupListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryConsumerGroupListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryConsumerGroupListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryConsumerGroupListResponse() = default;
};
class QueryConsumerGroupStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> iotInstanceId{};

  QueryConsumerGroupStatusRequest() {}

  explicit QueryConsumerGroupStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~QueryConsumerGroupStatusRequest() = default;
};
class QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo : public Darabonba::Model {
public:
  shared_ptr<long> accumulatedConsumeCountPerMinute{};
  shared_ptr<string> clientId{};
  shared_ptr<string> clientIpPort{};
  shared_ptr<long> onlineTime{};
  shared_ptr<long> realTimeConsumeCountPerMinute{};

  QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo() {}

  explicit QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accumulatedConsumeCountPerMinute) {
      res["AccumulatedConsumeCountPerMinute"] = boost::any(*accumulatedConsumeCountPerMinute);
    }
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (clientIpPort) {
      res["ClientIpPort"] = boost::any(*clientIpPort);
    }
    if (onlineTime) {
      res["OnlineTime"] = boost::any(*onlineTime);
    }
    if (realTimeConsumeCountPerMinute) {
      res["RealTimeConsumeCountPerMinute"] = boost::any(*realTimeConsumeCountPerMinute);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccumulatedConsumeCountPerMinute") != m.end() && !m["AccumulatedConsumeCountPerMinute"].empty()) {
      accumulatedConsumeCountPerMinute = make_shared<long>(boost::any_cast<long>(m["AccumulatedConsumeCountPerMinute"]));
    }
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
    if (m.find("ClientIpPort") != m.end() && !m["ClientIpPort"].empty()) {
      clientIpPort = make_shared<string>(boost::any_cast<string>(m["ClientIpPort"]));
    }
    if (m.find("OnlineTime") != m.end() && !m["OnlineTime"].empty()) {
      onlineTime = make_shared<long>(boost::any_cast<long>(m["OnlineTime"]));
    }
    if (m.find("RealTimeConsumeCountPerMinute") != m.end() && !m["RealTimeConsumeCountPerMinute"].empty()) {
      realTimeConsumeCountPerMinute = make_shared<long>(boost::any_cast<long>(m["RealTimeConsumeCountPerMinute"]));
    }
  }


  virtual ~QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo() = default;
};
class QueryConsumerGroupStatusResponseBodyClientConnectionStatusList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo>> consumerGroupClientConnectionInfo{};

  QueryConsumerGroupStatusResponseBodyClientConnectionStatusList() {}

  explicit QueryConsumerGroupStatusResponseBodyClientConnectionStatusList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consumerGroupClientConnectionInfo) {
      vector<boost::any> temp1;
      for(auto item1:*consumerGroupClientConnectionInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConsumerGroupClientConnectionInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsumerGroupClientConnectionInfo") != m.end() && !m["ConsumerGroupClientConnectionInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ConsumerGroupClientConnectionInfo"].type()) {
        vector<QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConsumerGroupClientConnectionInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        consumerGroupClientConnectionInfo = make_shared<vector<QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo>>(expect1);
      }
    }
  }


  virtual ~QueryConsumerGroupStatusResponseBodyClientConnectionStatusList() = default;
};
class QueryConsumerGroupStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> accumulatedConsumeCountPerMinute{};
  shared_ptr<long> accumulationCount{};
  shared_ptr<QueryConsumerGroupStatusResponseBodyClientConnectionStatusList> clientConnectionStatusList{};
  shared_ptr<string> code{};
  shared_ptr<long> consumerSpeed{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> lastConsumerTime{};
  shared_ptr<long> realTimeConsumeCountPerMinute{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryConsumerGroupStatusResponseBody() {}

  explicit QueryConsumerGroupStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accumulatedConsumeCountPerMinute) {
      res["AccumulatedConsumeCountPerMinute"] = boost::any(*accumulatedConsumeCountPerMinute);
    }
    if (accumulationCount) {
      res["AccumulationCount"] = boost::any(*accumulationCount);
    }
    if (clientConnectionStatusList) {
      res["ClientConnectionStatusList"] = clientConnectionStatusList ? boost::any(clientConnectionStatusList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (consumerSpeed) {
      res["ConsumerSpeed"] = boost::any(*consumerSpeed);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (lastConsumerTime) {
      res["LastConsumerTime"] = boost::any(*lastConsumerTime);
    }
    if (realTimeConsumeCountPerMinute) {
      res["RealTimeConsumeCountPerMinute"] = boost::any(*realTimeConsumeCountPerMinute);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccumulatedConsumeCountPerMinute") != m.end() && !m["AccumulatedConsumeCountPerMinute"].empty()) {
      accumulatedConsumeCountPerMinute = make_shared<long>(boost::any_cast<long>(m["AccumulatedConsumeCountPerMinute"]));
    }
    if (m.find("AccumulationCount") != m.end() && !m["AccumulationCount"].empty()) {
      accumulationCount = make_shared<long>(boost::any_cast<long>(m["AccumulationCount"]));
    }
    if (m.find("ClientConnectionStatusList") != m.end() && !m["ClientConnectionStatusList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClientConnectionStatusList"].type()) {
        QueryConsumerGroupStatusResponseBodyClientConnectionStatusList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClientConnectionStatusList"]));
        clientConnectionStatusList = make_shared<QueryConsumerGroupStatusResponseBodyClientConnectionStatusList>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ConsumerSpeed") != m.end() && !m["ConsumerSpeed"].empty()) {
      consumerSpeed = make_shared<long>(boost::any_cast<long>(m["ConsumerSpeed"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("LastConsumerTime") != m.end() && !m["LastConsumerTime"].empty()) {
      lastConsumerTime = make_shared<string>(boost::any_cast<string>(m["LastConsumerTime"]));
    }
    if (m.find("RealTimeConsumeCountPerMinute") != m.end() && !m["RealTimeConsumeCountPerMinute"].empty()) {
      realTimeConsumeCountPerMinute = make_shared<long>(boost::any_cast<long>(m["RealTimeConsumeCountPerMinute"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryConsumerGroupStatusResponseBody() = default;
};
class QueryConsumerGroupStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryConsumerGroupStatusResponseBody> body{};

  QueryConsumerGroupStatusResponse() {}

  explicit QueryConsumerGroupStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryConsumerGroupStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryConsumerGroupStatusResponseBody>(model1);
      }
    }
  }


  virtual ~QueryConsumerGroupStatusResponse() = default;
};
class QueryDetailSceneRuleLogRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> endTime{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> ruleId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> traceId{};

  QueryDetailSceneRuleLogRequest() {}

  explicit QueryDetailSceneRuleLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~QueryDetailSceneRuleLogRequest() = default;
};
class QueryDetailSceneRuleLogResponseBodyDataLogList : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> pkDn{};

  QueryDetailSceneRuleLogResponseBodyDataLogList() {}

  explicit QueryDetailSceneRuleLogResponseBodyDataLogList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pkDn) {
      res["PkDn"] = boost::any(*pkDn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PkDn") != m.end() && !m["PkDn"].empty()) {
      pkDn = make_shared<string>(boost::any_cast<string>(m["PkDn"]));
    }
  }


  virtual ~QueryDetailSceneRuleLogResponseBodyDataLogList() = default;
};
class QueryDetailSceneRuleLogResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<QueryDetailSceneRuleLogResponseBodyDataLogList>> logList{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QueryDetailSceneRuleLogResponseBodyData() {}

  explicit QueryDetailSceneRuleLogResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (logList) {
      vector<boost::any> temp1;
      for(auto item1:*logList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogList"] = boost::any(temp1);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("LogList") != m.end() && !m["LogList"].empty()) {
      if (typeid(vector<boost::any>) == m["LogList"].type()) {
        vector<QueryDetailSceneRuleLogResponseBodyDataLogList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDetailSceneRuleLogResponseBodyDataLogList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logList = make_shared<vector<QueryDetailSceneRuleLogResponseBodyDataLogList>>(expect1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryDetailSceneRuleLogResponseBodyData() = default;
};
class QueryDetailSceneRuleLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryDetailSceneRuleLogResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryDetailSceneRuleLogResponseBody() {}

  explicit QueryDetailSceneRuleLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDetailSceneRuleLogResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDetailSceneRuleLogResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryDetailSceneRuleLogResponseBody() = default;
};
class QueryDetailSceneRuleLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDetailSceneRuleLogResponseBody> body{};

  QueryDetailSceneRuleLogResponse() {}

  explicit QueryDetailSceneRuleLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDetailSceneRuleLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDetailSceneRuleLogResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDetailSceneRuleLogResponse() = default;
};
class QueryDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};

  QueryDeviceRequest() {}

  explicit QueryDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryDeviceRequest() = default;
};
class QueryDeviceResponseBodyDataDeviceInfo : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceSecret{};
  shared_ptr<string> deviceStatus{};
  shared_ptr<string> deviceType{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> iotId{};
  shared_ptr<string> nickname{};
  shared_ptr<string> productKey{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> utcModified{};

  QueryDeviceResponseBodyDataDeviceInfo() {}

  explicit QueryDeviceResponseBodyDataDeviceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceSecret) {
      res["DeviceSecret"] = boost::any(*deviceSecret);
    }
    if (deviceStatus) {
      res["DeviceStatus"] = boost::any(*deviceStatus);
    }
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceSecret") != m.end() && !m["DeviceSecret"].empty()) {
      deviceSecret = make_shared<string>(boost::any_cast<string>(m["DeviceSecret"]));
    }
    if (m.find("DeviceStatus") != m.end() && !m["DeviceStatus"].empty()) {
      deviceStatus = make_shared<string>(boost::any_cast<string>(m["DeviceStatus"]));
    }
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
  }


  virtual ~QueryDeviceResponseBodyDataDeviceInfo() = default;
};
class QueryDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceResponseBodyDataDeviceInfo>> deviceInfo{};

  QueryDeviceResponseBodyData() {}

  explicit QueryDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*deviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceInfo") != m.end() && !m["DeviceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceInfo"].type()) {
        vector<QueryDeviceResponseBodyDataDeviceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceResponseBodyDataDeviceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceInfo = make_shared<vector<QueryDeviceResponseBodyDataDeviceInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceResponseBodyData() = default;
};
class QueryDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryDeviceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> page{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  QueryDeviceResponseBody() {}

  explicit QueryDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryDeviceResponseBody() = default;
};
class QueryDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDeviceResponseBody> body{};

  QueryDeviceResponse() {}

  explicit QueryDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceResponse() = default;
};
class QueryDeviceBySQLRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> SQL{};

  QueryDeviceBySQLRequest() {}

  explicit QueryDeviceBySQLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (SQL) {
      res["SQL"] = boost::any(*SQL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("SQL") != m.end() && !m["SQL"].empty()) {
      SQL = make_shared<string>(boost::any_cast<string>(m["SQL"]));
    }
  }


  virtual ~QueryDeviceBySQLRequest() = default;
};
class QueryDeviceBySQLResponseBodyDataGroups : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};

  QueryDeviceBySQLResponseBodyDataGroups() {}

  explicit QueryDeviceBySQLResponseBodyDataGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~QueryDeviceBySQLResponseBodyDataGroups() = default;
};
class QueryDeviceBySQLResponseBodyDataOTAModules : public Darabonba::Model {
public:
  shared_ptr<string> firmwareVersion{};
  shared_ptr<string> moduleName{};

  QueryDeviceBySQLResponseBodyDataOTAModules() {}

  explicit QueryDeviceBySQLResponseBodyDataOTAModules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (firmwareVersion) {
      res["FirmwareVersion"] = boost::any(*firmwareVersion);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FirmwareVersion") != m.end() && !m["FirmwareVersion"].empty()) {
      firmwareVersion = make_shared<string>(boost::any_cast<string>(m["FirmwareVersion"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
  }


  virtual ~QueryDeviceBySQLResponseBodyDataOTAModules() = default;
};
class QueryDeviceBySQLResponseBodyDataTags : public Darabonba::Model {
public:
  shared_ptr<string> tagName{};
  shared_ptr<string> tagValue{};

  QueryDeviceBySQLResponseBodyDataTags() {}

  explicit QueryDeviceBySQLResponseBodyDataTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~QueryDeviceBySQLResponseBodyDataTags() = default;
};
class QueryDeviceBySQLResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> activeTime{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<vector<QueryDeviceBySQLResponseBodyDataGroups>> groups{};
  shared_ptr<string> iotId{};
  shared_ptr<string> nickname{};
  shared_ptr<vector<QueryDeviceBySQLResponseBodyDataOTAModules>> OTAModules{};
  shared_ptr<string> productKey{};
  shared_ptr<string> status{};
  shared_ptr<vector<QueryDeviceBySQLResponseBodyDataTags>> tags{};

  QueryDeviceBySQLResponseBodyData() {}

  explicit QueryDeviceBySQLResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeTime) {
      res["ActiveTime"] = boost::any(*activeTime);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (groups) {
      vector<boost::any> temp1;
      for(auto item1:*groups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Groups"] = boost::any(temp1);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    if (OTAModules) {
      vector<boost::any> temp1;
      for(auto item1:*OTAModules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OTAModules"] = boost::any(temp1);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveTime") != m.end() && !m["ActiveTime"].empty()) {
      activeTime = make_shared<string>(boost::any_cast<string>(m["ActiveTime"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Groups") != m.end() && !m["Groups"].empty()) {
      if (typeid(vector<boost::any>) == m["Groups"].type()) {
        vector<QueryDeviceBySQLResponseBodyDataGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Groups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceBySQLResponseBodyDataGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groups = make_shared<vector<QueryDeviceBySQLResponseBodyDataGroups>>(expect1);
      }
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
    if (m.find("OTAModules") != m.end() && !m["OTAModules"].empty()) {
      if (typeid(vector<boost::any>) == m["OTAModules"].type()) {
        vector<QueryDeviceBySQLResponseBodyDataOTAModules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OTAModules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceBySQLResponseBodyDataOTAModules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        OTAModules = make_shared<vector<QueryDeviceBySQLResponseBodyDataOTAModules>>(expect1);
      }
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<QueryDeviceBySQLResponseBodyDataTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceBySQLResponseBodyDataTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<QueryDeviceBySQLResponseBodyDataTags>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceBySQLResponseBodyData() = default;
};
class QueryDeviceBySQLResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<QueryDeviceBySQLResponseBodyData>> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  QueryDeviceBySQLResponseBody() {}

  explicit QueryDeviceBySQLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<QueryDeviceBySQLResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceBySQLResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<QueryDeviceBySQLResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryDeviceBySQLResponseBody() = default;
};
class QueryDeviceBySQLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDeviceBySQLResponseBody> body{};

  QueryDeviceBySQLResponse() {}

  explicit QueryDeviceBySQLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceBySQLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceBySQLResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceBySQLResponse() = default;
};
class QueryDeviceByStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> status{};

  QueryDeviceByStatusRequest() {}

  explicit QueryDeviceByStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~QueryDeviceByStatusRequest() = default;
};
class QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceSecret{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> iotId{};
  shared_ptr<string> nickname{};
  shared_ptr<string> productKey{};
  shared_ptr<string> status{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> utcModified{};

  QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo() {}

  explicit QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceSecret) {
      res["DeviceSecret"] = boost::any(*deviceSecret);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceSecret") != m.end() && !m["DeviceSecret"].empty()) {
      deviceSecret = make_shared<string>(boost::any_cast<string>(m["DeviceSecret"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
  }


  virtual ~QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo() = default;
};
class QueryDeviceByStatusResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo>> simpleDeviceInfo{};

  QueryDeviceByStatusResponseBodyData() {}

  explicit QueryDeviceByStatusResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (simpleDeviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*simpleDeviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SimpleDeviceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SimpleDeviceInfo") != m.end() && !m["SimpleDeviceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SimpleDeviceInfo"].type()) {
        vector<QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SimpleDeviceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        simpleDeviceInfo = make_shared<vector<QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceByStatusResponseBodyData() = default;
};
class QueryDeviceByStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryDeviceByStatusResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> page{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  QueryDeviceByStatusResponseBody() {}

  explicit QueryDeviceByStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceByStatusResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceByStatusResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryDeviceByStatusResponseBody() = default;
};
class QueryDeviceByStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDeviceByStatusResponseBody> body{};

  QueryDeviceByStatusResponse() {}

  explicit QueryDeviceByStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceByStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceByStatusResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceByStatusResponse() = default;
};
class QueryDeviceByTagsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  QueryDeviceByTagsRequestTag() {}

  explicit QueryDeviceByTagsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~QueryDeviceByTagsRequestTag() = default;
};
class QueryDeviceByTagsRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<QueryDeviceByTagsRequestTag>> tag{};

  QueryDeviceByTagsRequest() {}

  explicit QueryDeviceByTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<QueryDeviceByTagsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceByTagsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<QueryDeviceByTagsRequestTag>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceByTagsRequest() = default;
};
class QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};

  QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo() {}

  explicit QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
  }


  virtual ~QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo() = default;
};
class QueryDeviceByTagsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo>> simpleDeviceInfo{};

  QueryDeviceByTagsResponseBodyData() {}

  explicit QueryDeviceByTagsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (simpleDeviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*simpleDeviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SimpleDeviceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SimpleDeviceInfo") != m.end() && !m["SimpleDeviceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SimpleDeviceInfo"].type()) {
        vector<QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SimpleDeviceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        simpleDeviceInfo = make_shared<vector<QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceByTagsResponseBodyData() = default;
};
class QueryDeviceByTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryDeviceByTagsResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> page{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  QueryDeviceByTagsResponseBody() {}

  explicit QueryDeviceByTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceByTagsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceByTagsResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryDeviceByTagsResponseBody() = default;
};
class QueryDeviceByTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDeviceByTagsResponseBody> body{};

  QueryDeviceByTagsResponse() {}

  explicit QueryDeviceByTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceByTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceByTagsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceByTagsResponse() = default;
};
class QueryDeviceCertRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  QueryDeviceCertRequest() {}

  explicit QueryDeviceCertRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryDeviceCertRequest() = default;
};
class QueryDeviceCertResponseBodyDeviceCertInfo : public Darabonba::Model {
public:
  shared_ptr<string> certSN{};
  shared_ptr<string> certificate{};
  shared_ptr<string> privateKey{};
  shared_ptr<long> status{};

  QueryDeviceCertResponseBodyDeviceCertInfo() {}

  explicit QueryDeviceCertResponseBodyDeviceCertInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certSN) {
      res["CertSN"] = boost::any(*certSN);
    }
    if (certificate) {
      res["Certificate"] = boost::any(*certificate);
    }
    if (privateKey) {
      res["PrivateKey"] = boost::any(*privateKey);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertSN") != m.end() && !m["CertSN"].empty()) {
      certSN = make_shared<string>(boost::any_cast<string>(m["CertSN"]));
    }
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["Certificate"]));
    }
    if (m.find("PrivateKey") != m.end() && !m["PrivateKey"].empty()) {
      privateKey = make_shared<string>(boost::any_cast<string>(m["PrivateKey"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~QueryDeviceCertResponseBodyDeviceCertInfo() = default;
};
class QueryDeviceCertResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryDeviceCertResponseBodyDeviceCertInfo> deviceCertInfo{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryDeviceCertResponseBody() {}

  explicit QueryDeviceCertResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (deviceCertInfo) {
      res["DeviceCertInfo"] = deviceCertInfo ? boost::any(deviceCertInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DeviceCertInfo") != m.end() && !m["DeviceCertInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeviceCertInfo"].type()) {
        QueryDeviceCertResponseBodyDeviceCertInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeviceCertInfo"]));
        deviceCertInfo = make_shared<QueryDeviceCertResponseBodyDeviceCertInfo>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryDeviceCertResponseBody() = default;
};
class QueryDeviceCertResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDeviceCertResponseBody> body{};

  QueryDeviceCertResponse() {}

  explicit QueryDeviceCertResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceCertResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceCertResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceCertResponse() = default;
};
class QueryDeviceDesiredPropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> functionBlockId{};
  shared_ptr<vector<string>> identifier{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  QueryDeviceDesiredPropertyRequest() {}

  explicit QueryDeviceDesiredPropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Identifier"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Identifier"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      identifier = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryDeviceDesiredPropertyRequest() = default;
};
class QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo : public Darabonba::Model {
public:
  shared_ptr<string> dataType{};
  shared_ptr<string> identifier{};
  shared_ptr<string> name{};
  shared_ptr<string> time{};
  shared_ptr<string> unit{};
  shared_ptr<string> value{};
  shared_ptr<long> version{};

  QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo() {}

  explicit QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo() = default;
};
class QueryDeviceDesiredPropertyResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo>> desiredPropertyInfo{};

  QueryDeviceDesiredPropertyResponseBodyDataList() {}

  explicit QueryDeviceDesiredPropertyResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desiredPropertyInfo) {
      vector<boost::any> temp1;
      for(auto item1:*desiredPropertyInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DesiredPropertyInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesiredPropertyInfo") != m.end() && !m["DesiredPropertyInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["DesiredPropertyInfo"].type()) {
        vector<QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DesiredPropertyInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        desiredPropertyInfo = make_shared<vector<QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceDesiredPropertyResponseBodyDataList() = default;
};
class QueryDeviceDesiredPropertyResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QueryDeviceDesiredPropertyResponseBodyDataList> list{};

  QueryDeviceDesiredPropertyResponseBodyData() {}

  explicit QueryDeviceDesiredPropertyResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDeviceDesiredPropertyResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDeviceDesiredPropertyResponseBodyDataList>(model1);
      }
    }
  }


  virtual ~QueryDeviceDesiredPropertyResponseBodyData() = default;
};
class QueryDeviceDesiredPropertyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryDeviceDesiredPropertyResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryDeviceDesiredPropertyResponseBody() {}

  explicit QueryDeviceDesiredPropertyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceDesiredPropertyResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceDesiredPropertyResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryDeviceDesiredPropertyResponseBody() = default;
};
class QueryDeviceDesiredPropertyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDeviceDesiredPropertyResponseBody> body{};

  QueryDeviceDesiredPropertyResponse() {}

  explicit QueryDeviceDesiredPropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceDesiredPropertyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceDesiredPropertyResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceDesiredPropertyResponse() = default;
};
class QueryDeviceDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  QueryDeviceDetailRequest() {}

  explicit QueryDeviceDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryDeviceDetailRequest() = default;
};
class QueryDeviceDetailResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceSecret{};
  shared_ptr<string> firmwareVersion{};
  shared_ptr<string> gmtActive{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtOnline{};
  shared_ptr<string> iotId{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> nickname{};
  shared_ptr<long> nodeType{};
  shared_ptr<bool> owner{};
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};
  shared_ptr<string> region{};
  shared_ptr<string> status{};
  shared_ptr<string> utcActive{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> utcOnline{};

  QueryDeviceDetailResponseBodyData() {}

  explicit QueryDeviceDetailResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceSecret) {
      res["DeviceSecret"] = boost::any(*deviceSecret);
    }
    if (firmwareVersion) {
      res["FirmwareVersion"] = boost::any(*firmwareVersion);
    }
    if (gmtActive) {
      res["GmtActive"] = boost::any(*gmtActive);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtOnline) {
      res["GmtOnline"] = boost::any(*gmtOnline);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (utcActive) {
      res["UtcActive"] = boost::any(*utcActive);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (utcOnline) {
      res["UtcOnline"] = boost::any(*utcOnline);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceSecret") != m.end() && !m["DeviceSecret"].empty()) {
      deviceSecret = make_shared<string>(boost::any_cast<string>(m["DeviceSecret"]));
    }
    if (m.find("FirmwareVersion") != m.end() && !m["FirmwareVersion"].empty()) {
      firmwareVersion = make_shared<string>(boost::any_cast<string>(m["FirmwareVersion"]));
    }
    if (m.find("GmtActive") != m.end() && !m["GmtActive"].empty()) {
      gmtActive = make_shared<string>(boost::any_cast<string>(m["GmtActive"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtOnline") != m.end() && !m["GmtOnline"].empty()) {
      gmtOnline = make_shared<string>(boost::any_cast<string>(m["GmtOnline"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<long>(boost::any_cast<long>(m["NodeType"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<bool>(boost::any_cast<bool>(m["Owner"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UtcActive") != m.end() && !m["UtcActive"].empty()) {
      utcActive = make_shared<string>(boost::any_cast<string>(m["UtcActive"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("UtcOnline") != m.end() && !m["UtcOnline"].empty()) {
      utcOnline = make_shared<string>(boost::any_cast<string>(m["UtcOnline"]));
    }
  }


  virtual ~QueryDeviceDetailResponseBodyData() = default;
};
class QueryDeviceDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryDeviceDetailResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryDeviceDetailResponseBody() {}

  explicit QueryDeviceDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceDetailResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceDetailResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryDeviceDetailResponseBody() = default;
};
class QueryDeviceDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDeviceDetailResponseBody> body{};

  QueryDeviceDetailResponse() {}

  explicit QueryDeviceDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceDetailResponse() = default;
};
class QueryDeviceDistributeDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  QueryDeviceDistributeDetailRequest() {}

  explicit QueryDeviceDistributeDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~QueryDeviceDistributeDetailRequest() = default;
};
class QueryDeviceDistributeDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> file{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryDeviceDistributeDetailResponseBody() {}

  explicit QueryDeviceDistributeDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (file) {
      res["File"] = boost::any(*file);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      file = make_shared<string>(boost::any_cast<string>(m["File"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryDeviceDistributeDetailResponseBody() = default;
};
class QueryDeviceDistributeDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDeviceDistributeDetailResponseBody> body{};

  QueryDeviceDistributeDetailResponse() {}

  explicit QueryDeviceDistributeDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceDistributeDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceDistributeDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceDistributeDetailResponse() = default;
};
class QueryDeviceDistributeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  QueryDeviceDistributeJobRequest() {}

  explicit QueryDeviceDistributeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~QueryDeviceDistributeJobRequest() = default;
};
class QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs : public Darabonba::Model {
public:
  shared_ptr<string> targetInstanceId{};

  QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs() {}

  explicit QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
  }


  virtual ~QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs() = default;
};
class QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs>> targetInstanceConfigs{};

  QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs() {}

  explicit QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetInstanceConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*targetInstanceConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["targetInstanceConfigs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("targetInstanceConfigs") != m.end() && !m["targetInstanceConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["targetInstanceConfigs"].type()) {
        vector<QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["targetInstanceConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targetInstanceConfigs = make_shared<vector<QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs() = default;
};
class QueryDeviceDistributeJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> jobId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> sourceUid{};
  shared_ptr<long> status{};
  shared_ptr<long> strategy{};
  shared_ptr<QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs> targetInstanceConfigs{};
  shared_ptr<string> targetUid{};
  shared_ptr<long> total{};

  QueryDeviceDistributeJobResponseBodyData() {}

  explicit QueryDeviceDistributeJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (sourceUid) {
      res["SourceUid"] = boost::any(*sourceUid);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (strategy) {
      res["Strategy"] = boost::any(*strategy);
    }
    if (targetInstanceConfigs) {
      res["TargetInstanceConfigs"] = targetInstanceConfigs ? boost::any(targetInstanceConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (targetUid) {
      res["TargetUid"] = boost::any(*targetUid);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("SourceUid") != m.end() && !m["SourceUid"].empty()) {
      sourceUid = make_shared<string>(boost::any_cast<string>(m["SourceUid"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      strategy = make_shared<long>(boost::any_cast<long>(m["Strategy"]));
    }
    if (m.find("TargetInstanceConfigs") != m.end() && !m["TargetInstanceConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["TargetInstanceConfigs"].type()) {
        QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TargetInstanceConfigs"]));
        targetInstanceConfigs = make_shared<QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs>(model1);
      }
    }
    if (m.find("TargetUid") != m.end() && !m["TargetUid"].empty()) {
      targetUid = make_shared<string>(boost::any_cast<string>(m["TargetUid"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryDeviceDistributeJobResponseBodyData() = default;
};
class QueryDeviceDistributeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryDeviceDistributeJobResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryDeviceDistributeJobResponseBody() {}

  explicit QueryDeviceDistributeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceDistributeJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceDistributeJobResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryDeviceDistributeJobResponseBody() = default;
};
class QueryDeviceDistributeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDeviceDistributeJobResponseBody> body{};

  QueryDeviceDistributeJobResponse() {}

  explicit QueryDeviceDistributeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceDistributeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceDistributeJobResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceDistributeJobResponse() = default;
};
class QueryDeviceEventDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> asc{};
  shared_ptr<string> deviceName{};
  shared_ptr<long> endTime{};
  shared_ptr<string> eventType{};
  shared_ptr<string> identifier{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<long> startTime{};

  QueryDeviceEventDataRequest() {}

  explicit QueryDeviceEventDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<long>(boost::any_cast<long>(m["Asc"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~QueryDeviceEventDataRequest() = default;
};
class QueryDeviceEventDataResponseBodyDataListEventInfo : public Darabonba::Model {
public:
  shared_ptr<string> eventType{};
  shared_ptr<string> identifier{};
  shared_ptr<string> name{};
  shared_ptr<string> outputData{};
  shared_ptr<string> time{};

  QueryDeviceEventDataResponseBodyDataListEventInfo() {}

  explicit QueryDeviceEventDataResponseBodyDataListEventInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputData) {
      res["OutputData"] = boost::any(*outputData);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutputData") != m.end() && !m["OutputData"].empty()) {
      outputData = make_shared<string>(boost::any_cast<string>(m["OutputData"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
  }


  virtual ~QueryDeviceEventDataResponseBodyDataListEventInfo() = default;
};
class QueryDeviceEventDataResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceEventDataResponseBodyDataListEventInfo>> eventInfo{};

  QueryDeviceEventDataResponseBodyDataList() {}

  explicit QueryDeviceEventDataResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventInfo) {
      vector<boost::any> temp1;
      for(auto item1:*eventInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventInfo") != m.end() && !m["EventInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["EventInfo"].type()) {
        vector<QueryDeviceEventDataResponseBodyDataListEventInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceEventDataResponseBodyDataListEventInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventInfo = make_shared<vector<QueryDeviceEventDataResponseBodyDataListEventInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceEventDataResponseBodyDataList() = default;
};
class QueryDeviceEventDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QueryDeviceEventDataResponseBodyDataList> list{};
  shared_ptr<long> nextTime{};
  shared_ptr<bool> nextValid{};

  QueryDeviceEventDataResponseBodyData() {}

  explicit QueryDeviceEventDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextTime) {
      res["NextTime"] = boost::any(*nextTime);
    }
    if (nextValid) {
      res["NextValid"] = boost::any(*nextValid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDeviceEventDataResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDeviceEventDataResponseBodyDataList>(model1);
      }
    }
    if (m.find("NextTime") != m.end() && !m["NextTime"].empty()) {
      nextTime = make_shared<long>(boost::any_cast<long>(m["NextTime"]));
    }
    if (m.find("NextValid") != m.end() && !m["NextValid"].empty()) {
      nextValid = make_shared<bool>(boost::any_cast<bool>(m["NextValid"]));
    }
  }


  virtual ~QueryDeviceEventDataResponseBodyData() = default;
};
class QueryDeviceEventDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryDeviceEventDataResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryDeviceEventDataResponseBody() {}

  explicit QueryDeviceEventDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceEventDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceEventDataResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryDeviceEventDataResponseBody() = default;
};
class QueryDeviceEventDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDeviceEventDataResponseBody> body{};

  QueryDeviceEventDataResponse() {}

  explicit QueryDeviceEventDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceEventDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceEventDataResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceEventDataResponse() = default;
};
class QueryDeviceFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> fileId{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  QueryDeviceFileRequest() {}

  explicit QueryDeviceFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryDeviceFileRequest() = default;
};
class QueryDeviceFileResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> downloadUrl{};
  shared_ptr<string> fileId{};
  shared_ptr<string> name{};
  shared_ptr<string> size{};
  shared_ptr<string> utcCreatedOn{};

  QueryDeviceFileResponseBodyData() {}

  explicit QueryDeviceFileResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (utcCreatedOn) {
      res["UtcCreatedOn"] = boost::any(*utcCreatedOn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("UtcCreatedOn") != m.end() && !m["UtcCreatedOn"].empty()) {
      utcCreatedOn = make_shared<string>(boost::any_cast<string>(m["UtcCreatedOn"]));
    }
  }


  virtual ~QueryDeviceFileResponseBodyData() = default;
};
class QueryDeviceFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryDeviceFileResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryDeviceFileResponseBody() {}

  explicit QueryDeviceFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceFileResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceFileResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryDeviceFileResponseBody() = default;
};
class QueryDeviceFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDeviceFileResponseBody> body{};

  QueryDeviceFileResponse() {}

  explicit QueryDeviceFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceFileResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceFileResponse() = default;
};
class QueryDeviceFileListRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};

  QueryDeviceFileListRequest() {}

  explicit QueryDeviceFileListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryDeviceFileListRequest() = default;
};
class QueryDeviceFileListResponseBodyDataFileSummary : public Darabonba::Model {
public:
  shared_ptr<string> fileId{};
  shared_ptr<string> name{};
  shared_ptr<string> size{};
  shared_ptr<string> utcCreatedOn{};

  QueryDeviceFileListResponseBodyDataFileSummary() {}

  explicit QueryDeviceFileListResponseBodyDataFileSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (utcCreatedOn) {
      res["UtcCreatedOn"] = boost::any(*utcCreatedOn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("UtcCreatedOn") != m.end() && !m["UtcCreatedOn"].empty()) {
      utcCreatedOn = make_shared<string>(boost::any_cast<string>(m["UtcCreatedOn"]));
    }
  }


  virtual ~QueryDeviceFileListResponseBodyDataFileSummary() = default;
};
class QueryDeviceFileListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceFileListResponseBodyDataFileSummary>> fileSummary{};

  QueryDeviceFileListResponseBodyData() {}

  explicit QueryDeviceFileListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileSummary) {
      vector<boost::any> temp1;
      for(auto item1:*fileSummary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileSummary"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileSummary") != m.end() && !m["FileSummary"].empty()) {
      if (typeid(vector<boost::any>) == m["FileSummary"].type()) {
        vector<QueryDeviceFileListResponseBodyDataFileSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileSummary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceFileListResponseBodyDataFileSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileSummary = make_shared<vector<QueryDeviceFileListResponseBodyDataFileSummary>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceFileListResponseBodyData() = default;
};
class QueryDeviceFileListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> currentPage{};
  shared_ptr<QueryDeviceFileListResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  QueryDeviceFileListResponseBody() {}

  explicit QueryDeviceFileListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceFileListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceFileListResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryDeviceFileListResponseBody() = default;
};
class QueryDeviceFileListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDeviceFileListResponseBody> body{};

  QueryDeviceFileListResponse() {}

  explicit QueryDeviceFileListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceFileListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceFileListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceFileListResponse() = default;
};
class QueryDeviceGroupByDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  QueryDeviceGroupByDeviceRequest() {}

  explicit QueryDeviceGroupByDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryDeviceGroupByDeviceRequest() = default;
};
class QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo : public Darabonba::Model {
public:
  shared_ptr<string> groupDesc{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> groupType{};
  shared_ptr<string> utcCreate{};

  QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo() {}

  explicit QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupDesc) {
      res["GroupDesc"] = boost::any(*groupDesc);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupDesc") != m.end() && !m["GroupDesc"].empty()) {
      groupDesc = make_shared<string>(boost::any_cast<string>(m["GroupDesc"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<string>(boost::any_cast<string>(m["GroupType"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
  }


  virtual ~QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo() = default;
};
class QueryDeviceGroupByDeviceResponseBodyGroupInfos : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo>> groupInfo{};

  QueryDeviceGroupByDeviceResponseBodyGroupInfos() {}

  explicit QueryDeviceGroupByDeviceResponseBodyGroupInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupInfo) {
      vector<boost::any> temp1;
      for(auto item1:*groupInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupInfo") != m.end() && !m["GroupInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupInfo"].type()) {
        vector<QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupInfo = make_shared<vector<QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceGroupByDeviceResponseBodyGroupInfos() = default;
};
class QueryDeviceGroupByDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceGroupByDeviceResponseBodyGroupInfos> groupInfos{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryDeviceGroupByDeviceResponseBody() {}

  explicit QueryDeviceGroupByDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (groupInfos) {
      res["GroupInfos"] = groupInfos ? boost::any(groupInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("GroupInfos") != m.end() && !m["GroupInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["GroupInfos"].type()) {
        QueryDeviceGroupByDeviceResponseBodyGroupInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GroupInfos"]));
        groupInfos = make_shared<QueryDeviceGroupByDeviceResponseBodyGroupInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryDeviceGroupByDeviceResponseBody() = default;
};
class QueryDeviceGroupByDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDeviceGroupByDeviceResponseBody> body{};

  QueryDeviceGroupByDeviceResponse() {}

  explicit QueryDeviceGroupByDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceGroupByDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceGroupByDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceGroupByDeviceResponse() = default;
};
class QueryDeviceGroupByTagsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  QueryDeviceGroupByTagsRequestTag() {}

  explicit QueryDeviceGroupByTagsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~QueryDeviceGroupByTagsRequestTag() = default;
};
class QueryDeviceGroupByTagsRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<QueryDeviceGroupByTagsRequestTag>> tag{};

  QueryDeviceGroupByTagsRequest() {}

  explicit QueryDeviceGroupByTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<QueryDeviceGroupByTagsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceGroupByTagsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<QueryDeviceGroupByTagsRequestTag>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceGroupByTagsRequest() = default;
};
class QueryDeviceGroupByTagsResponseBodyDataDeviceGroup : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};

  QueryDeviceGroupByTagsResponseBodyDataDeviceGroup() {}

  explicit QueryDeviceGroupByTagsResponseBodyDataDeviceGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~QueryDeviceGroupByTagsResponseBodyDataDeviceGroup() = default;
};
class QueryDeviceGroupByTagsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceGroupByTagsResponseBodyDataDeviceGroup>> deviceGroup{};

  QueryDeviceGroupByTagsResponseBodyData() {}

  explicit QueryDeviceGroupByTagsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceGroup) {
      vector<boost::any> temp1;
      for(auto item1:*deviceGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceGroup") != m.end() && !m["DeviceGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceGroup"].type()) {
        vector<QueryDeviceGroupByTagsResponseBodyDataDeviceGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceGroupByTagsResponseBodyDataDeviceGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceGroup = make_shared<vector<QueryDeviceGroupByTagsResponseBodyDataDeviceGroup>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceGroupByTagsResponseBodyData() = default;
};
class QueryDeviceGroupByTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryDeviceGroupByTagsResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> page{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  QueryDeviceGroupByTagsResponseBody() {}

  explicit QueryDeviceGroupByTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceGroupByTagsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceGroupByTagsResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryDeviceGroupByTagsResponseBody() = default;
};
class QueryDeviceGroupByTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDeviceGroupByTagsResponseBody> body{};

  QueryDeviceGroupByTagsResponse() {}

  explicit QueryDeviceGroupByTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceGroupByTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceGroupByTagsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceGroupByTagsResponse() = default;
};
class QueryDeviceGroupInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> groupType{};
  shared_ptr<string> iotInstanceId{};

  QueryDeviceGroupInfoRequest() {}

  explicit QueryDeviceGroupInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<string>(boost::any_cast<string>(m["GroupType"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~QueryDeviceGroupInfoRequest() = default;
};
class QueryDeviceGroupInfoResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> deviceActive{};
  shared_ptr<long> deviceCount{};
  shared_ptr<long> deviceOnline{};
  shared_ptr<string> dynamicGroupExpression{};
  shared_ptr<string> groupDesc{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> utcCreate{};

  QueryDeviceGroupInfoResponseBodyData() {}

  explicit QueryDeviceGroupInfoResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceActive) {
      res["DeviceActive"] = boost::any(*deviceActive);
    }
    if (deviceCount) {
      res["DeviceCount"] = boost::any(*deviceCount);
    }
    if (deviceOnline) {
      res["DeviceOnline"] = boost::any(*deviceOnline);
    }
    if (dynamicGroupExpression) {
      res["DynamicGroupExpression"] = boost::any(*dynamicGroupExpression);
    }
    if (groupDesc) {
      res["GroupDesc"] = boost::any(*groupDesc);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceActive") != m.end() && !m["DeviceActive"].empty()) {
      deviceActive = make_shared<long>(boost::any_cast<long>(m["DeviceActive"]));
    }
    if (m.find("DeviceCount") != m.end() && !m["DeviceCount"].empty()) {
      deviceCount = make_shared<long>(boost::any_cast<long>(m["DeviceCount"]));
    }
    if (m.find("DeviceOnline") != m.end() && !m["DeviceOnline"].empty()) {
      deviceOnline = make_shared<long>(boost::any_cast<long>(m["DeviceOnline"]));
    }
    if (m.find("DynamicGroupExpression") != m.end() && !m["DynamicGroupExpression"].empty()) {
      dynamicGroupExpression = make_shared<string>(boost::any_cast<string>(m["DynamicGroupExpression"]));
    }
    if (m.find("GroupDesc") != m.end() && !m["GroupDesc"].empty()) {
      groupDesc = make_shared<string>(boost::any_cast<string>(m["GroupDesc"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
  }


  virtual ~QueryDeviceGroupInfoResponseBodyData() = default;
};
class QueryDeviceGroupInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryDeviceGroupInfoResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryDeviceGroupInfoResponseBody() {}

  explicit QueryDeviceGroupInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceGroupInfoResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceGroupInfoResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryDeviceGroupInfoResponseBody() = default;
};
class QueryDeviceGroupInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDeviceGroupInfoResponseBody> body{};

  QueryDeviceGroupInfoResponse() {}

  explicit QueryDeviceGroupInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceGroupInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceGroupInfoResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceGroupInfoResponse() = default;
};
class QueryDeviceGroupListRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> groupName{};
  shared_ptr<vector<string>> groupTypes{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> superGroupId{};

  QueryDeviceGroupListRequest() {}

  explicit QueryDeviceGroupListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupTypes) {
      res["GroupTypes"] = boost::any(*groupTypes);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (superGroupId) {
      res["SuperGroupId"] = boost::any(*superGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupTypes") != m.end() && !m["GroupTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SuperGroupId") != m.end() && !m["SuperGroupId"].empty()) {
      superGroupId = make_shared<string>(boost::any_cast<string>(m["SuperGroupId"]));
    }
  }


  virtual ~QueryDeviceGroupListRequest() = default;
};
class QueryDeviceGroupListResponseBodyDataGroupInfo : public Darabonba::Model {
public:
  shared_ptr<string> groupDesc{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> groupType{};
  shared_ptr<string> utcCreate{};

  QueryDeviceGroupListResponseBodyDataGroupInfo() {}

  explicit QueryDeviceGroupListResponseBodyDataGroupInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupDesc) {
      res["GroupDesc"] = boost::any(*groupDesc);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupDesc") != m.end() && !m["GroupDesc"].empty()) {
      groupDesc = make_shared<string>(boost::any_cast<string>(m["GroupDesc"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<string>(boost::any_cast<string>(m["GroupType"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
  }


  virtual ~QueryDeviceGroupListResponseBodyDataGroupInfo() = default;
};
class QueryDeviceGroupListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceGroupListResponseBodyDataGroupInfo>> groupInfo{};

  QueryDeviceGroupListResponseBodyData() {}

  explicit QueryDeviceGroupListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupInfo) {
      vector<boost::any> temp1;
      for(auto item1:*groupInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupInfo") != m.end() && !m["GroupInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupInfo"].type()) {
        vector<QueryDeviceGroupListResponseBodyDataGroupInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceGroupListResponseBodyDataGroupInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupInfo = make_shared<vector<QueryDeviceGroupListResponseBodyDataGroupInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceGroupListResponseBodyData() = default;
};
class QueryDeviceGroupListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> currentPage{};
  shared_ptr<QueryDeviceGroupListResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  QueryDeviceGroupListResponseBody() {}

  explicit QueryDeviceGroupListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceGroupListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceGroupListResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryDeviceGroupListResponseBody() = default;
};
class QueryDeviceGroupListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDeviceGroupListResponseBody> body{};

  QueryDeviceGroupListResponse() {}

  explicit QueryDeviceGroupListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceGroupListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceGroupListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceGroupListResponse() = default;
};
class QueryDeviceGroupTagListRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> groupType{};
  shared_ptr<string> iotInstanceId{};

  QueryDeviceGroupTagListRequest() {}

  explicit QueryDeviceGroupTagListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<string>(boost::any_cast<string>(m["GroupType"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~QueryDeviceGroupTagListRequest() = default;
};
class QueryDeviceGroupTagListResponseBodyDataGroupTagInfo : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  QueryDeviceGroupTagListResponseBodyDataGroupTagInfo() {}

  explicit QueryDeviceGroupTagListResponseBodyDataGroupTagInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~QueryDeviceGroupTagListResponseBodyDataGroupTagInfo() = default;
};
class QueryDeviceGroupTagListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceGroupTagListResponseBodyDataGroupTagInfo>> groupTagInfo{};

  QueryDeviceGroupTagListResponseBodyData() {}

  explicit QueryDeviceGroupTagListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupTagInfo) {
      vector<boost::any> temp1;
      for(auto item1:*groupTagInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupTagInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupTagInfo") != m.end() && !m["GroupTagInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupTagInfo"].type()) {
        vector<QueryDeviceGroupTagListResponseBodyDataGroupTagInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupTagInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceGroupTagListResponseBodyDataGroupTagInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupTagInfo = make_shared<vector<QueryDeviceGroupTagListResponseBodyDataGroupTagInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceGroupTagListResponseBodyData() = default;
};
class QueryDeviceGroupTagListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryDeviceGroupTagListResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryDeviceGroupTagListResponseBody() {}

  explicit QueryDeviceGroupTagListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceGroupTagListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceGroupTagListResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryDeviceGroupTagListResponseBody() = default;
};
class QueryDeviceGroupTagListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDeviceGroupTagListResponseBody> body{};

  QueryDeviceGroupTagListResponse() {}

  explicit QueryDeviceGroupTagListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceGroupTagListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceGroupTagListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceGroupTagListResponse() = default;
};
class QueryDeviceInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  QueryDeviceInfoRequest() {}

  explicit QueryDeviceInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryDeviceInfoRequest() = default;
};
class QueryDeviceInfoResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceSecret{};
  shared_ptr<string> iotId{};
  shared_ptr<string> nickname{};
  shared_ptr<string> productKey{};

  QueryDeviceInfoResponseBodyData() {}

  explicit QueryDeviceInfoResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceSecret) {
      res["DeviceSecret"] = boost::any(*deviceSecret);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceSecret") != m.end() && !m["DeviceSecret"].empty()) {
      deviceSecret = make_shared<string>(boost::any_cast<string>(m["DeviceSecret"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryDeviceInfoResponseBodyData() = default;
};
class QueryDeviceInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryDeviceInfoResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryDeviceInfoResponseBody() {}

  explicit QueryDeviceInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceInfoResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceInfoResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryDeviceInfoResponseBody() = default;
};
class QueryDeviceInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDeviceInfoResponseBody> body{};

  QueryDeviceInfoResponse() {}

  explicit QueryDeviceInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceInfoResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceInfoResponse() = default;
};
class QueryDeviceListByDeviceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> groupId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};

  QueryDeviceListByDeviceGroupRequest() {}

  explicit QueryDeviceListByDeviceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryDeviceListByDeviceGroupRequest() = default;
};
class QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};

  QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo() {}

  explicit QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
  }


  virtual ~QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo() = default;
};
class QueryDeviceListByDeviceGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo>> simpleDeviceInfo{};

  QueryDeviceListByDeviceGroupResponseBodyData() {}

  explicit QueryDeviceListByDeviceGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (simpleDeviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*simpleDeviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SimpleDeviceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SimpleDeviceInfo") != m.end() && !m["SimpleDeviceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SimpleDeviceInfo"].type()) {
        vector<QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SimpleDeviceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        simpleDeviceInfo = make_shared<vector<QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceListByDeviceGroupResponseBodyData() = default;
};
class QueryDeviceListByDeviceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryDeviceListByDeviceGroupResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> page{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  QueryDeviceListByDeviceGroupResponseBody() {}

  explicit QueryDeviceListByDeviceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceListByDeviceGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceListByDeviceGroupResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryDeviceListByDeviceGroupResponseBody() = default;
};
class QueryDeviceListByDeviceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDeviceListByDeviceGroupResponseBody> body{};

  QueryDeviceListByDeviceGroupResponse() {}

  explicit QueryDeviceListByDeviceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceListByDeviceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceListByDeviceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceListByDeviceGroupResponse() = default;
};
class QueryDeviceOriginalEventDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> asc{};
  shared_ptr<string> deviceName{};
  shared_ptr<long> endTime{};
  shared_ptr<string> identifier{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<long> startTime{};

  QueryDeviceOriginalEventDataRequest() {}

  explicit QueryDeviceOriginalEventDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<long>(boost::any_cast<long>(m["Asc"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~QueryDeviceOriginalEventDataRequest() = default;
};
class QueryDeviceOriginalEventDataResponseBodyDataListEventInfo : public Darabonba::Model {
public:
  shared_ptr<string> eventType{};
  shared_ptr<string> identifier{};
  shared_ptr<string> name{};
  shared_ptr<string> outputData{};
  shared_ptr<string> time{};

  QueryDeviceOriginalEventDataResponseBodyDataListEventInfo() {}

  explicit QueryDeviceOriginalEventDataResponseBodyDataListEventInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputData) {
      res["OutputData"] = boost::any(*outputData);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutputData") != m.end() && !m["OutputData"].empty()) {
      outputData = make_shared<string>(boost::any_cast<string>(m["OutputData"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
  }


  virtual ~QueryDeviceOriginalEventDataResponseBodyDataListEventInfo() = default;
};
class QueryDeviceOriginalEventDataResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceOriginalEventDataResponseBodyDataListEventInfo>> eventInfo{};

  QueryDeviceOriginalEventDataResponseBodyDataList() {}

  explicit QueryDeviceOriginalEventDataResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventInfo) {
      vector<boost::any> temp1;
      for(auto item1:*eventInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventInfo") != m.end() && !m["EventInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["EventInfo"].type()) {
        vector<QueryDeviceOriginalEventDataResponseBodyDataListEventInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceOriginalEventDataResponseBodyDataListEventInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventInfo = make_shared<vector<QueryDeviceOriginalEventDataResponseBodyDataListEventInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceOriginalEventDataResponseBodyDataList() = default;
};
class QueryDeviceOriginalEventDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QueryDeviceOriginalEventDataResponseBodyDataList> list{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<bool> nextValid{};

  QueryDeviceOriginalEventDataResponseBodyData() {}

  explicit QueryDeviceOriginalEventDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (nextValid) {
      res["NextValid"] = boost::any(*nextValid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDeviceOriginalEventDataResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDeviceOriginalEventDataResponseBodyDataList>(model1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("NextValid") != m.end() && !m["NextValid"].empty()) {
      nextValid = make_shared<bool>(boost::any_cast<bool>(m["NextValid"]));
    }
  }


  virtual ~QueryDeviceOriginalEventDataResponseBodyData() = default;
};
class QueryDeviceOriginalEventDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryDeviceOriginalEventDataResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryDeviceOriginalEventDataResponseBody() {}

  explicit QueryDeviceOriginalEventDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceOriginalEventDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceOriginalEventDataResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryDeviceOriginalEventDataResponseBody() = default;
};
class QueryDeviceOriginalEventDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDeviceOriginalEventDataResponseBody> body{};

  QueryDeviceOriginalEventDataResponse() {}

  explicit QueryDeviceOriginalEventDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceOriginalEventDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceOriginalEventDataResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceOriginalEventDataResponse() = default;
};
class QueryDeviceOriginalPropertyDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> asc{};
  shared_ptr<string> deviceName{};
  shared_ptr<long> endTime{};
  shared_ptr<string> identifier{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<long> startTime{};

  QueryDeviceOriginalPropertyDataRequest() {}

  explicit QueryDeviceOriginalPropertyDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<long>(boost::any_cast<long>(m["Asc"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~QueryDeviceOriginalPropertyDataRequest() = default;
};
class QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> value{};

  QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo() {}

  explicit QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo() = default;
};
class QueryDeviceOriginalPropertyDataResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo>> propertyInfo{};

  QueryDeviceOriginalPropertyDataResponseBodyDataList() {}

  explicit QueryDeviceOriginalPropertyDataResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertyInfo) {
      vector<boost::any> temp1;
      for(auto item1:*propertyInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertyInfo") != m.end() && !m["PropertyInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyInfo"].type()) {
        vector<QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyInfo = make_shared<vector<QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceOriginalPropertyDataResponseBodyDataList() = default;
};
class QueryDeviceOriginalPropertyDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QueryDeviceOriginalPropertyDataResponseBodyDataList> list{};
  shared_ptr<bool> nextValid{};
  shared_ptr<string> nextPageToken{};

  QueryDeviceOriginalPropertyDataResponseBodyData() {}

  explicit QueryDeviceOriginalPropertyDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextValid) {
      res["NextValid"] = boost::any(*nextValid);
    }
    if (nextPageToken) {
      res["nextPageToken"] = boost::any(*nextPageToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDeviceOriginalPropertyDataResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDeviceOriginalPropertyDataResponseBodyDataList>(model1);
      }
    }
    if (m.find("NextValid") != m.end() && !m["NextValid"].empty()) {
      nextValid = make_shared<bool>(boost::any_cast<bool>(m["NextValid"]));
    }
    if (m.find("nextPageToken") != m.end() && !m["nextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["nextPageToken"]));
    }
  }


  virtual ~QueryDeviceOriginalPropertyDataResponseBodyData() = default;
};
class QueryDeviceOriginalPropertyDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryDeviceOriginalPropertyDataResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryDeviceOriginalPropertyDataResponseBody() {}

  explicit QueryDeviceOriginalPropertyDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceOriginalPropertyDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceOriginalPropertyDataResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryDeviceOriginalPropertyDataResponseBody() = default;
};
class QueryDeviceOriginalPropertyDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDeviceOriginalPropertyDataResponseBody> body{};

  QueryDeviceOriginalPropertyDataResponse() {}

  explicit QueryDeviceOriginalPropertyDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceOriginalPropertyDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceOriginalPropertyDataResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceOriginalPropertyDataResponse() = default;
};
class QueryDeviceOriginalPropertyStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> asc{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};

  QueryDeviceOriginalPropertyStatusRequest() {}

  explicit QueryDeviceOriginalPropertyStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<long>(boost::any_cast<long>(m["Asc"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryDeviceOriginalPropertyStatusRequest() = default;
};
class QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo : public Darabonba::Model {
public:
  shared_ptr<string> identifier{};
  shared_ptr<long> time{};
  shared_ptr<string> value{};

  QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo() {}

  explicit QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo() = default;
};
class QueryDeviceOriginalPropertyStatusResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo>> propertyStatusDataInfo{};

  QueryDeviceOriginalPropertyStatusResponseBodyDataList() {}

  explicit QueryDeviceOriginalPropertyStatusResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertyStatusDataInfo) {
      vector<boost::any> temp1;
      for(auto item1:*propertyStatusDataInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyStatusDataInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertyStatusDataInfo") != m.end() && !m["PropertyStatusDataInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyStatusDataInfo"].type()) {
        vector<QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyStatusDataInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyStatusDataInfo = make_shared<vector<QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceOriginalPropertyStatusResponseBodyDataList() = default;
};
class QueryDeviceOriginalPropertyStatusResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QueryDeviceOriginalPropertyStatusResponseBodyDataList> list{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<bool> nextValid{};

  QueryDeviceOriginalPropertyStatusResponseBodyData() {}

  explicit QueryDeviceOriginalPropertyStatusResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (nextValid) {
      res["NextValid"] = boost::any(*nextValid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDeviceOriginalPropertyStatusResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDeviceOriginalPropertyStatusResponseBodyDataList>(model1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("NextValid") != m.end() && !m["NextValid"].empty()) {
      nextValid = make_shared<bool>(boost::any_cast<bool>(m["NextValid"]));
    }
  }


  virtual ~QueryDeviceOriginalPropertyStatusResponseBodyData() = default;
};
class QueryDeviceOriginalPropertyStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryDeviceOriginalPropertyStatusResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryDeviceOriginalPropertyStatusResponseBody() {}

  explicit QueryDeviceOriginalPropertyStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceOriginalPropertyStatusResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceOriginalPropertyStatusResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryDeviceOriginalPropertyStatusResponseBody() = default;
};
class QueryDeviceOriginalPropertyStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDeviceOriginalPropertyStatusResponseBody> body{};

  QueryDeviceOriginalPropertyStatusResponse() {}

  explicit QueryDeviceOriginalPropertyStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceOriginalPropertyStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceOriginalPropertyStatusResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceOriginalPropertyStatusResponse() = default;
};
class QueryDeviceOriginalServiceDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> asc{};
  shared_ptr<string> deviceName{};
  shared_ptr<long> endTime{};
  shared_ptr<string> identifier{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<long> startTime{};

  QueryDeviceOriginalServiceDataRequest() {}

  explicit QueryDeviceOriginalServiceDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<long>(boost::any_cast<long>(m["Asc"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~QueryDeviceOriginalServiceDataRequest() = default;
};
class QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo : public Darabonba::Model {
public:
  shared_ptr<string> identifier{};
  shared_ptr<string> inputData{};
  shared_ptr<string> name{};
  shared_ptr<string> outputData{};
  shared_ptr<string> time{};

  QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo() {}

  explicit QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (inputData) {
      res["InputData"] = boost::any(*inputData);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputData) {
      res["OutputData"] = boost::any(*outputData);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("InputData") != m.end() && !m["InputData"].empty()) {
      inputData = make_shared<string>(boost::any_cast<string>(m["InputData"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutputData") != m.end() && !m["OutputData"].empty()) {
      outputData = make_shared<string>(boost::any_cast<string>(m["OutputData"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
  }


  virtual ~QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo() = default;
};
class QueryDeviceOriginalServiceDataResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo>> serviceInfo{};

  QueryDeviceOriginalServiceDataResponseBodyDataList() {}

  explicit QueryDeviceOriginalServiceDataResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*serviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceInfo") != m.end() && !m["ServiceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceInfo"].type()) {
        vector<QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceInfo = make_shared<vector<QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceOriginalServiceDataResponseBodyDataList() = default;
};
class QueryDeviceOriginalServiceDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QueryDeviceOriginalServiceDataResponseBodyDataList> list{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<bool> nextValid{};

  QueryDeviceOriginalServiceDataResponseBodyData() {}

  explicit QueryDeviceOriginalServiceDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (nextValid) {
      res["NextValid"] = boost::any(*nextValid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDeviceOriginalServiceDataResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDeviceOriginalServiceDataResponseBodyDataList>(model1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("NextValid") != m.end() && !m["NextValid"].empty()) {
      nextValid = make_shared<bool>(boost::any_cast<bool>(m["NextValid"]));
    }
  }


  virtual ~QueryDeviceOriginalServiceDataResponseBodyData() = default;
};
class QueryDeviceOriginalServiceDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryDeviceOriginalServiceDataResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryDeviceOriginalServiceDataResponseBody() {}

  explicit QueryDeviceOriginalServiceDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceOriginalServiceDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceOriginalServiceDataResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryDeviceOriginalServiceDataResponseBody() = default;
};
class QueryDeviceOriginalServiceDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDeviceOriginalServiceDataResponseBody> body{};

  QueryDeviceOriginalServiceDataResponse() {}

  explicit QueryDeviceOriginalServiceDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceOriginalServiceDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceOriginalServiceDataResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceOriginalServiceDataResponse() = default;
};
class QueryDevicePropRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  QueryDevicePropRequest() {}

  explicit QueryDevicePropRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryDevicePropRequest() = default;
};
class QueryDevicePropResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> props{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryDevicePropResponseBody() {}

  explicit QueryDevicePropResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (props) {
      res["Props"] = boost::any(*props);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Props") != m.end() && !m["Props"].empty()) {
      props = make_shared<string>(boost::any_cast<string>(m["Props"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryDevicePropResponseBody() = default;
};
class QueryDevicePropResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDevicePropResponseBody> body{};

  QueryDevicePropResponse() {}

  explicit QueryDevicePropResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDevicePropResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDevicePropResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDevicePropResponse() = default;
};
class QueryDevicePropertiesDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> asc{};
  shared_ptr<string> deviceName{};
  shared_ptr<long> endTime{};
  shared_ptr<vector<string>> identifier{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<long> startTime{};

  QueryDevicePropertiesDataRequest() {}

  explicit QueryDevicePropertiesDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<long>(boost::any_cast<long>(m["Asc"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Identifier"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Identifier"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      identifier = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~QueryDevicePropertiesDataRequest() = default;
};
class QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo : public Darabonba::Model {
public:
  shared_ptr<long> time{};
  shared_ptr<string> value{};

  QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo() {}

  explicit QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo() = default;
};
class QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo>> propertyInfo{};

  QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList() {}

  explicit QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertyInfo) {
      vector<boost::any> temp1;
      for(auto item1:*propertyInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertyInfo") != m.end() && !m["PropertyInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyInfo"].type()) {
        vector<QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyInfo = make_shared<vector<QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList() = default;
};
class QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo : public Darabonba::Model {
public:
  shared_ptr<string> identifier{};
  shared_ptr<QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList> list{};

  QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo() {}

  explicit QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList>(model1);
      }
    }
  }


  virtual ~QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo() = default;
};
class QueryDevicePropertiesDataResponseBodyPropertyDataInfos : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo>> propertyDataInfo{};

  QueryDevicePropertiesDataResponseBodyPropertyDataInfos() {}

  explicit QueryDevicePropertiesDataResponseBodyPropertyDataInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertyDataInfo) {
      vector<boost::any> temp1;
      for(auto item1:*propertyDataInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyDataInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertyDataInfo") != m.end() && !m["PropertyDataInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyDataInfo"].type()) {
        vector<QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyDataInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyDataInfo = make_shared<vector<QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDevicePropertiesDataResponseBodyPropertyDataInfos() = default;
};
class QueryDevicePropertiesDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> nextTime{};
  shared_ptr<bool> nextValid{};
  shared_ptr<QueryDevicePropertiesDataResponseBodyPropertyDataInfos> propertyDataInfos{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryDevicePropertiesDataResponseBody() {}

  explicit QueryDevicePropertiesDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (nextTime) {
      res["NextTime"] = boost::any(*nextTime);
    }
    if (nextValid) {
      res["NextValid"] = boost::any(*nextValid);
    }
    if (propertyDataInfos) {
      res["PropertyDataInfos"] = propertyDataInfos ? boost::any(propertyDataInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NextTime") != m.end() && !m["NextTime"].empty()) {
      nextTime = make_shared<long>(boost::any_cast<long>(m["NextTime"]));
    }
    if (m.find("NextValid") != m.end() && !m["NextValid"].empty()) {
      nextValid = make_shared<bool>(boost::any_cast<bool>(m["NextValid"]));
    }
    if (m.find("PropertyDataInfos") != m.end() && !m["PropertyDataInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["PropertyDataInfos"].type()) {
        QueryDevicePropertiesDataResponseBodyPropertyDataInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PropertyDataInfos"]));
        propertyDataInfos = make_shared<QueryDevicePropertiesDataResponseBodyPropertyDataInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryDevicePropertiesDataResponseBody() = default;
};
class QueryDevicePropertiesDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDevicePropertiesDataResponseBody> body{};

  QueryDevicePropertiesDataResponse() {}

  explicit QueryDevicePropertiesDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDevicePropertiesDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDevicePropertiesDataResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDevicePropertiesDataResponse() = default;
};
class QueryDevicePropertyDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> asc{};
  shared_ptr<string> deviceName{};
  shared_ptr<long> endTime{};
  shared_ptr<string> identifier{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<long> startTime{};

  QueryDevicePropertyDataRequest() {}

  explicit QueryDevicePropertyDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<long>(boost::any_cast<long>(m["Asc"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~QueryDevicePropertyDataRequest() = default;
};
class QueryDevicePropertyDataResponseBodyDataListPropertyInfo : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> value{};

  QueryDevicePropertyDataResponseBodyDataListPropertyInfo() {}

  explicit QueryDevicePropertyDataResponseBodyDataListPropertyInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryDevicePropertyDataResponseBodyDataListPropertyInfo() = default;
};
class QueryDevicePropertyDataResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDevicePropertyDataResponseBodyDataListPropertyInfo>> propertyInfo{};

  QueryDevicePropertyDataResponseBodyDataList() {}

  explicit QueryDevicePropertyDataResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertyInfo) {
      vector<boost::any> temp1;
      for(auto item1:*propertyInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertyInfo") != m.end() && !m["PropertyInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyInfo"].type()) {
        vector<QueryDevicePropertyDataResponseBodyDataListPropertyInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDevicePropertyDataResponseBodyDataListPropertyInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyInfo = make_shared<vector<QueryDevicePropertyDataResponseBodyDataListPropertyInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDevicePropertyDataResponseBodyDataList() = default;
};
class QueryDevicePropertyDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QueryDevicePropertyDataResponseBodyDataList> list{};
  shared_ptr<long> nextTime{};
  shared_ptr<bool> nextValid{};

  QueryDevicePropertyDataResponseBodyData() {}

  explicit QueryDevicePropertyDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextTime) {
      res["NextTime"] = boost::any(*nextTime);
    }
    if (nextValid) {
      res["NextValid"] = boost::any(*nextValid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDevicePropertyDataResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDevicePropertyDataResponseBodyDataList>(model1);
      }
    }
    if (m.find("NextTime") != m.end() && !m["NextTime"].empty()) {
      nextTime = make_shared<long>(boost::any_cast<long>(m["NextTime"]));
    }
    if (m.find("NextValid") != m.end() && !m["NextValid"].empty()) {
      nextValid = make_shared<bool>(boost::any_cast<bool>(m["NextValid"]));
    }
  }


  virtual ~QueryDevicePropertyDataResponseBodyData() = default;
};
class QueryDevicePropertyDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryDevicePropertyDataResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryDevicePropertyDataResponseBody() {}

  explicit QueryDevicePropertyDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDevicePropertyDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDevicePropertyDataResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryDevicePropertyDataResponseBody() = default;
};
class QueryDevicePropertyDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDevicePropertyDataResponseBody> body{};

  QueryDevicePropertyDataResponse() {}

  explicit QueryDevicePropertyDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDevicePropertyDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDevicePropertyDataResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDevicePropertyDataResponse() = default;
};
class QueryDevicePropertyStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> functionBlockId{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  QueryDevicePropertyStatusRequest() {}

  explicit QueryDevicePropertyStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryDevicePropertyStatusRequest() = default;
};
class QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo : public Darabonba::Model {
public:
  shared_ptr<string> dataType{};
  shared_ptr<string> identifier{};
  shared_ptr<string> name{};
  shared_ptr<string> time{};
  shared_ptr<string> unit{};
  shared_ptr<string> value{};

  QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo() {}

  explicit QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo() = default;
};
class QueryDevicePropertyStatusResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo>> propertyStatusInfo{};

  QueryDevicePropertyStatusResponseBodyDataList() {}

  explicit QueryDevicePropertyStatusResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertyStatusInfo) {
      vector<boost::any> temp1;
      for(auto item1:*propertyStatusInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyStatusInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertyStatusInfo") != m.end() && !m["PropertyStatusInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyStatusInfo"].type()) {
        vector<QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyStatusInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyStatusInfo = make_shared<vector<QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDevicePropertyStatusResponseBodyDataList() = default;
};
class QueryDevicePropertyStatusResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QueryDevicePropertyStatusResponseBodyDataList> list{};

  QueryDevicePropertyStatusResponseBodyData() {}

  explicit QueryDevicePropertyStatusResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDevicePropertyStatusResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDevicePropertyStatusResponseBodyDataList>(model1);
      }
    }
  }


  virtual ~QueryDevicePropertyStatusResponseBodyData() = default;
};
class QueryDevicePropertyStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryDevicePropertyStatusResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryDevicePropertyStatusResponseBody() {}

  explicit QueryDevicePropertyStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDevicePropertyStatusResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDevicePropertyStatusResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryDevicePropertyStatusResponseBody() = default;
};
class QueryDevicePropertyStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDevicePropertyStatusResponseBody> body{};

  QueryDevicePropertyStatusResponse() {}

  explicit QueryDevicePropertyStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDevicePropertyStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDevicePropertyStatusResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDevicePropertyStatusResponse() = default;
};
class QueryDeviceProvisioningRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> productKey{};

  QueryDeviceProvisioningRequest() {}

  explicit QueryDeviceProvisioningRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryDeviceProvisioningRequest() = default;
};
class QueryDeviceProvisioningResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> aliyunUid{};
  shared_ptr<string> deviceName{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> productKey{};
  shared_ptr<string> sourceIotInstanceId{};
  shared_ptr<string> sourceRegion{};
  shared_ptr<string> targetIotInstanceId{};
  shared_ptr<string> targetRegion{};

  QueryDeviceProvisioningResponseBodyData() {}

  explicit QueryDeviceProvisioningResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunUid) {
      res["AliyunUid"] = boost::any(*aliyunUid);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (sourceIotInstanceId) {
      res["SourceIotInstanceId"] = boost::any(*sourceIotInstanceId);
    }
    if (sourceRegion) {
      res["SourceRegion"] = boost::any(*sourceRegion);
    }
    if (targetIotInstanceId) {
      res["TargetIotInstanceId"] = boost::any(*targetIotInstanceId);
    }
    if (targetRegion) {
      res["TargetRegion"] = boost::any(*targetRegion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunUid") != m.end() && !m["AliyunUid"].empty()) {
      aliyunUid = make_shared<string>(boost::any_cast<string>(m["AliyunUid"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("SourceIotInstanceId") != m.end() && !m["SourceIotInstanceId"].empty()) {
      sourceIotInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceIotInstanceId"]));
    }
    if (m.find("SourceRegion") != m.end() && !m["SourceRegion"].empty()) {
      sourceRegion = make_shared<string>(boost::any_cast<string>(m["SourceRegion"]));
    }
    if (m.find("TargetIotInstanceId") != m.end() && !m["TargetIotInstanceId"].empty()) {
      targetIotInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetIotInstanceId"]));
    }
    if (m.find("TargetRegion") != m.end() && !m["TargetRegion"].empty()) {
      targetRegion = make_shared<string>(boost::any_cast<string>(m["TargetRegion"]));
    }
  }


  virtual ~QueryDeviceProvisioningResponseBodyData() = default;
};
class QueryDeviceProvisioningResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryDeviceProvisioningResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryDeviceProvisioningResponseBody() {}

  explicit QueryDeviceProvisioningResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceProvisioningResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceProvisioningResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryDeviceProvisioningResponseBody() = default;
};
class QueryDeviceProvisioningResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDeviceProvisioningResponseBody> body{};

  QueryDeviceProvisioningResponse() {}

  explicit QueryDeviceProvisioningResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceProvisioningResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceProvisioningResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceProvisioningResponse() = default;
};
class QueryDeviceServiceDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> asc{};
  shared_ptr<string> deviceName{};
  shared_ptr<long> endTime{};
  shared_ptr<string> identifier{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<long> startTime{};

  QueryDeviceServiceDataRequest() {}

  explicit QueryDeviceServiceDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<long>(boost::any_cast<long>(m["Asc"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~QueryDeviceServiceDataRequest() = default;
};
class QueryDeviceServiceDataResponseBodyDataListServiceInfo : public Darabonba::Model {
public:
  shared_ptr<string> identifier{};
  shared_ptr<string> inputData{};
  shared_ptr<string> name{};
  shared_ptr<string> outputData{};
  shared_ptr<string> time{};

  QueryDeviceServiceDataResponseBodyDataListServiceInfo() {}

  explicit QueryDeviceServiceDataResponseBodyDataListServiceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (inputData) {
      res["InputData"] = boost::any(*inputData);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputData) {
      res["OutputData"] = boost::any(*outputData);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("InputData") != m.end() && !m["InputData"].empty()) {
      inputData = make_shared<string>(boost::any_cast<string>(m["InputData"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutputData") != m.end() && !m["OutputData"].empty()) {
      outputData = make_shared<string>(boost::any_cast<string>(m["OutputData"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
  }


  virtual ~QueryDeviceServiceDataResponseBodyDataListServiceInfo() = default;
};
class QueryDeviceServiceDataResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceServiceDataResponseBodyDataListServiceInfo>> serviceInfo{};

  QueryDeviceServiceDataResponseBodyDataList() {}

  explicit QueryDeviceServiceDataResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*serviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceInfo") != m.end() && !m["ServiceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceInfo"].type()) {
        vector<QueryDeviceServiceDataResponseBodyDataListServiceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceServiceDataResponseBodyDataListServiceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceInfo = make_shared<vector<QueryDeviceServiceDataResponseBodyDataListServiceInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceServiceDataResponseBodyDataList() = default;
};
class QueryDeviceServiceDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QueryDeviceServiceDataResponseBodyDataList> list{};
  shared_ptr<long> nextTime{};
  shared_ptr<bool> nextValid{};

  QueryDeviceServiceDataResponseBodyData() {}

  explicit QueryDeviceServiceDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextTime) {
      res["NextTime"] = boost::any(*nextTime);
    }
    if (nextValid) {
      res["NextValid"] = boost::any(*nextValid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDeviceServiceDataResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDeviceServiceDataResponseBodyDataList>(model1);
      }
    }
    if (m.find("NextTime") != m.end() && !m["NextTime"].empty()) {
      nextTime = make_shared<long>(boost::any_cast<long>(m["NextTime"]));
    }
    if (m.find("NextValid") != m.end() && !m["NextValid"].empty()) {
      nextValid = make_shared<bool>(boost::any_cast<bool>(m["NextValid"]));
    }
  }


  virtual ~QueryDeviceServiceDataResponseBodyData() = default;
};
class QueryDeviceServiceDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryDeviceServiceDataResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryDeviceServiceDataResponseBody() {}

  explicit QueryDeviceServiceDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceServiceDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceServiceDataResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryDeviceServiceDataResponseBody() = default;
};
class QueryDeviceServiceDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDeviceServiceDataResponseBody> body{};

  QueryDeviceServiceDataResponse() {}

  explicit QueryDeviceServiceDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceServiceDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceServiceDataResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceServiceDataResponse() = default;
};
class QueryDeviceSpeechRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};

  QueryDeviceSpeechRequest() {}

  explicit QueryDeviceSpeechRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryDeviceSpeechRequest() = default;
};
class QueryDeviceSpeechResponseBodyDataListItems : public Darabonba::Model {
public:
  shared_ptr<string> audioFormat{};
  shared_ptr<string> bizCode{};
  shared_ptr<double> size{};

  QueryDeviceSpeechResponseBodyDataListItems() {}

  explicit QueryDeviceSpeechResponseBodyDataListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFormat) {
      res["AudioFormat"] = boost::any(*audioFormat);
    }
    if (bizCode) {
      res["BizCode"] = boost::any(*bizCode);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFormat") != m.end() && !m["AudioFormat"].empty()) {
      audioFormat = make_shared<string>(boost::any_cast<string>(m["AudioFormat"]));
    }
    if (m.find("BizCode") != m.end() && !m["BizCode"].empty()) {
      bizCode = make_shared<string>(boost::any_cast<string>(m["BizCode"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<double>(boost::any_cast<double>(m["Size"]));
    }
  }


  virtual ~QueryDeviceSpeechResponseBodyDataListItems() = default;
};
class QueryDeviceSpeechResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceSpeechResponseBodyDataListItems>> items{};

  QueryDeviceSpeechResponseBodyDataList() {}

  explicit QueryDeviceSpeechResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<QueryDeviceSpeechResponseBodyDataListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceSpeechResponseBodyDataListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<QueryDeviceSpeechResponseBodyDataListItems>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceSpeechResponseBodyDataList() = default;
};
class QueryDeviceSpeechResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QueryDeviceSpeechResponseBodyDataList> list{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QueryDeviceSpeechResponseBodyData() {}

  explicit QueryDeviceSpeechResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDeviceSpeechResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDeviceSpeechResponseBodyDataList>(model1);
      }
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryDeviceSpeechResponseBodyData() = default;
};
class QueryDeviceSpeechResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryDeviceSpeechResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryDeviceSpeechResponseBody() {}

  explicit QueryDeviceSpeechResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceSpeechResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceSpeechResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryDeviceSpeechResponseBody() = default;
};
class QueryDeviceSpeechResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDeviceSpeechResponseBody> body{};

  QueryDeviceSpeechResponse() {}

  explicit QueryDeviceSpeechResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceSpeechResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceSpeechResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceSpeechResponse() = default;
};
class QueryDeviceStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  QueryDeviceStatisticsRequest() {}

  explicit QueryDeviceStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryDeviceStatisticsRequest() = default;
};
class QueryDeviceStatisticsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> activeCount{};
  shared_ptr<long> deviceCount{};
  shared_ptr<long> onlineCount{};

  QueryDeviceStatisticsResponseBodyData() {}

  explicit QueryDeviceStatisticsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeCount) {
      res["activeCount"] = boost::any(*activeCount);
    }
    if (deviceCount) {
      res["deviceCount"] = boost::any(*deviceCount);
    }
    if (onlineCount) {
      res["onlineCount"] = boost::any(*onlineCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("activeCount") != m.end() && !m["activeCount"].empty()) {
      activeCount = make_shared<long>(boost::any_cast<long>(m["activeCount"]));
    }
    if (m.find("deviceCount") != m.end() && !m["deviceCount"].empty()) {
      deviceCount = make_shared<long>(boost::any_cast<long>(m["deviceCount"]));
    }
    if (m.find("onlineCount") != m.end() && !m["onlineCount"].empty()) {
      onlineCount = make_shared<long>(boost::any_cast<long>(m["onlineCount"]));
    }
  }


  virtual ~QueryDeviceStatisticsResponseBodyData() = default;
};
class QueryDeviceStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryDeviceStatisticsResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryDeviceStatisticsResponseBody() {}

  explicit QueryDeviceStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceStatisticsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceStatisticsResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryDeviceStatisticsResponseBody() = default;
};
class QueryDeviceStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDeviceStatisticsResponseBody> body{};

  QueryDeviceStatisticsResponse() {}

  explicit QueryDeviceStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceStatisticsResponse() = default;
};
class QueryDeviceSubTopicRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  QueryDeviceSubTopicRequest() {}

  explicit QueryDeviceSubTopicRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryDeviceSubTopicRequest() = default;
};
class QueryDeviceSubTopicResponseBodyTopicList : public Darabonba::Model {
public:
  shared_ptr<long> timestamp{};
  shared_ptr<string> topicName{};

  QueryDeviceSubTopicResponseBodyTopicList() {}

  explicit QueryDeviceSubTopicResponseBodyTopicList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (topicName) {
      res["TopicName"] = boost::any(*topicName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("TopicName") != m.end() && !m["TopicName"].empty()) {
      topicName = make_shared<string>(boost::any_cast<string>(m["TopicName"]));
    }
  }


  virtual ~QueryDeviceSubTopicResponseBodyTopicList() = default;
};
class QueryDeviceSubTopicResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<vector<QueryDeviceSubTopicResponseBodyTopicList>> topicList{};

  QueryDeviceSubTopicResponseBody() {}

  explicit QueryDeviceSubTopicResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (topicList) {
      vector<boost::any> temp1;
      for(auto item1:*topicList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TopicList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TopicList") != m.end() && !m["TopicList"].empty()) {
      if (typeid(vector<boost::any>) == m["TopicList"].type()) {
        vector<QueryDeviceSubTopicResponseBodyTopicList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TopicList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceSubTopicResponseBodyTopicList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topicList = make_shared<vector<QueryDeviceSubTopicResponseBodyTopicList>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceSubTopicResponseBody() = default;
};
class QueryDeviceSubTopicResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDeviceSubTopicResponseBody> body{};

  QueryDeviceSubTopicResponse() {}

  explicit QueryDeviceSubTopicResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceSubTopicResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceSubTopicResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceSubTopicResponse() = default;
};
class QueryDeviceTunnelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> tunnelId{};

  QueryDeviceTunnelRequest() {}

  explicit QueryDeviceTunnelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (tunnelId) {
      res["TunnelId"] = boost::any(*tunnelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("TunnelId") != m.end() && !m["TunnelId"].empty()) {
      tunnelId = make_shared<string>(boost::any_cast<string>(m["TunnelId"]));
    }
  }


  virtual ~QueryDeviceTunnelRequest() = default;
};
class QueryDeviceTunnelResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> deviceConnState{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};
  shared_ptr<string> sourceConnState{};
  shared_ptr<string> tunnelId{};
  shared_ptr<string> tunnelState{};
  shared_ptr<string> udi{};
  shared_ptr<string> utcClosed{};
  shared_ptr<string> utcCreated{};

  QueryDeviceTunnelResponseBodyData() {}

  explicit QueryDeviceTunnelResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (deviceConnState) {
      res["DeviceConnState"] = boost::any(*deviceConnState);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (sourceConnState) {
      res["SourceConnState"] = boost::any(*sourceConnState);
    }
    if (tunnelId) {
      res["TunnelId"] = boost::any(*tunnelId);
    }
    if (tunnelState) {
      res["TunnelState"] = boost::any(*tunnelState);
    }
    if (udi) {
      res["Udi"] = boost::any(*udi);
    }
    if (utcClosed) {
      res["UtcClosed"] = boost::any(*utcClosed);
    }
    if (utcCreated) {
      res["UtcCreated"] = boost::any(*utcCreated);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DeviceConnState") != m.end() && !m["DeviceConnState"].empty()) {
      deviceConnState = make_shared<string>(boost::any_cast<string>(m["DeviceConnState"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("SourceConnState") != m.end() && !m["SourceConnState"].empty()) {
      sourceConnState = make_shared<string>(boost::any_cast<string>(m["SourceConnState"]));
    }
    if (m.find("TunnelId") != m.end() && !m["TunnelId"].empty()) {
      tunnelId = make_shared<string>(boost::any_cast<string>(m["TunnelId"]));
    }
    if (m.find("TunnelState") != m.end() && !m["TunnelState"].empty()) {
      tunnelState = make_shared<string>(boost::any_cast<string>(m["TunnelState"]));
    }
    if (m.find("Udi") != m.end() && !m["Udi"].empty()) {
      udi = make_shared<string>(boost::any_cast<string>(m["Udi"]));
    }
    if (m.find("UtcClosed") != m.end() && !m["UtcClosed"].empty()) {
      utcClosed = make_shared<string>(boost::any_cast<string>(m["UtcClosed"]));
    }
    if (m.find("UtcCreated") != m.end() && !m["UtcCreated"].empty()) {
      utcCreated = make_shared<string>(boost::any_cast<string>(m["UtcCreated"]));
    }
  }


  virtual ~QueryDeviceTunnelResponseBodyData() = default;
};
class QueryDeviceTunnelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryDeviceTunnelResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryDeviceTunnelResponseBody() {}

  explicit QueryDeviceTunnelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceTunnelResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceTunnelResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryDeviceTunnelResponseBody() = default;
};
class QueryDeviceTunnelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDeviceTunnelResponseBody> body{};

  QueryDeviceTunnelResponse() {}

  explicit QueryDeviceTunnelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceTunnelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceTunnelResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceTunnelResponse() = default;
};
class QueryDevicesHotStorageDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> asc{};
  shared_ptr<string> deviceName{};
  shared_ptr<long> endTime{};
  shared_ptr<string> identifier{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<long> startTime{};
  shared_ptr<string> userTopic{};

  QueryDevicesHotStorageDataRequest() {}

  explicit QueryDevicesHotStorageDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (userTopic) {
      res["UserTopic"] = boost::any(*userTopic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<long>(boost::any_cast<long>(m["Asc"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("UserTopic") != m.end() && !m["UserTopic"].empty()) {
      userTopic = make_shared<string>(boost::any_cast<string>(m["UserTopic"]));
    }
  }


  virtual ~QueryDevicesHotStorageDataRequest() = default;
};
class QueryDevicesHotStorageDataResponseBodyDataListPropertyInfo : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> value{};

  QueryDevicesHotStorageDataResponseBodyDataListPropertyInfo() {}

  explicit QueryDevicesHotStorageDataResponseBodyDataListPropertyInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryDevicesHotStorageDataResponseBodyDataListPropertyInfo() = default;
};
class QueryDevicesHotStorageDataResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDevicesHotStorageDataResponseBodyDataListPropertyInfo>> propertyInfo{};

  QueryDevicesHotStorageDataResponseBodyDataList() {}

  explicit QueryDevicesHotStorageDataResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertyInfo) {
      vector<boost::any> temp1;
      for(auto item1:*propertyInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertyInfo") != m.end() && !m["PropertyInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyInfo"].type()) {
        vector<QueryDevicesHotStorageDataResponseBodyDataListPropertyInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDevicesHotStorageDataResponseBodyDataListPropertyInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyInfo = make_shared<vector<QueryDevicesHotStorageDataResponseBodyDataListPropertyInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDevicesHotStorageDataResponseBodyDataList() = default;
};
class QueryDevicesHotStorageDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QueryDevicesHotStorageDataResponseBodyDataList> list{};
  shared_ptr<bool> nextValid{};
  shared_ptr<string> nextPageToken{};

  QueryDevicesHotStorageDataResponseBodyData() {}

  explicit QueryDevicesHotStorageDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextValid) {
      res["NextValid"] = boost::any(*nextValid);
    }
    if (nextPageToken) {
      res["nextPageToken"] = boost::any(*nextPageToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDevicesHotStorageDataResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDevicesHotStorageDataResponseBodyDataList>(model1);
      }
    }
    if (m.find("NextValid") != m.end() && !m["NextValid"].empty()) {
      nextValid = make_shared<bool>(boost::any_cast<bool>(m["NextValid"]));
    }
    if (m.find("nextPageToken") != m.end() && !m["nextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["nextPageToken"]));
    }
  }


  virtual ~QueryDevicesHotStorageDataResponseBodyData() = default;
};
class QueryDevicesHotStorageDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryDevicesHotStorageDataResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryDevicesHotStorageDataResponseBody() {}

  explicit QueryDevicesHotStorageDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDevicesHotStorageDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDevicesHotStorageDataResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryDevicesHotStorageDataResponseBody() = default;
};
class QueryDevicesHotStorageDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDevicesHotStorageDataResponseBody> body{};

  QueryDevicesHotStorageDataResponse() {}

  explicit QueryDevicesHotStorageDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDevicesHotStorageDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDevicesHotStorageDataResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDevicesHotStorageDataResponse() = default;
};
class QueryDevicesHotStorageDataStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> asc{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> userTopic{};

  QueryDevicesHotStorageDataStatusRequest() {}

  explicit QueryDevicesHotStorageDataStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (userTopic) {
      res["UserTopic"] = boost::any(*userTopic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<long>(boost::any_cast<long>(m["Asc"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("UserTopic") != m.end() && !m["UserTopic"].empty()) {
      userTopic = make_shared<string>(boost::any_cast<string>(m["UserTopic"]));
    }
  }


  virtual ~QueryDevicesHotStorageDataStatusRequest() = default;
};
class QueryDevicesHotStorageDataStatusResponseBodyDataListPropertyStatusDataInfo : public Darabonba::Model {
public:
  shared_ptr<string> identifier{};
  shared_ptr<long> time{};
  shared_ptr<string> value{};

  QueryDevicesHotStorageDataStatusResponseBodyDataListPropertyStatusDataInfo() {}

  explicit QueryDevicesHotStorageDataStatusResponseBodyDataListPropertyStatusDataInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryDevicesHotStorageDataStatusResponseBodyDataListPropertyStatusDataInfo() = default;
};
class QueryDevicesHotStorageDataStatusResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDevicesHotStorageDataStatusResponseBodyDataListPropertyStatusDataInfo>> propertyStatusDataInfo{};

  QueryDevicesHotStorageDataStatusResponseBodyDataList() {}

  explicit QueryDevicesHotStorageDataStatusResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertyStatusDataInfo) {
      vector<boost::any> temp1;
      for(auto item1:*propertyStatusDataInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyStatusDataInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertyStatusDataInfo") != m.end() && !m["PropertyStatusDataInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyStatusDataInfo"].type()) {
        vector<QueryDevicesHotStorageDataStatusResponseBodyDataListPropertyStatusDataInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyStatusDataInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDevicesHotStorageDataStatusResponseBodyDataListPropertyStatusDataInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyStatusDataInfo = make_shared<vector<QueryDevicesHotStorageDataStatusResponseBodyDataListPropertyStatusDataInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDevicesHotStorageDataStatusResponseBodyDataList() = default;
};
class QueryDevicesHotStorageDataStatusResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QueryDevicesHotStorageDataStatusResponseBodyDataList> list{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<bool> nextValid{};

  QueryDevicesHotStorageDataStatusResponseBodyData() {}

  explicit QueryDevicesHotStorageDataStatusResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (nextValid) {
      res["NextValid"] = boost::any(*nextValid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDevicesHotStorageDataStatusResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDevicesHotStorageDataStatusResponseBodyDataList>(model1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("NextValid") != m.end() && !m["NextValid"].empty()) {
      nextValid = make_shared<bool>(boost::any_cast<bool>(m["NextValid"]));
    }
  }


  virtual ~QueryDevicesHotStorageDataStatusResponseBodyData() = default;
};
class QueryDevicesHotStorageDataStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryDevicesHotStorageDataStatusResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryDevicesHotStorageDataStatusResponseBody() {}

  explicit QueryDevicesHotStorageDataStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDevicesHotStorageDataStatusResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDevicesHotStorageDataStatusResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryDevicesHotStorageDataStatusResponseBody() = default;
};
class QueryDevicesHotStorageDataStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDevicesHotStorageDataStatusResponseBody> body{};

  QueryDevicesHotStorageDataStatusResponse() {}

  explicit QueryDevicesHotStorageDataStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDevicesHotStorageDataStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDevicesHotStorageDataStatusResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDevicesHotStorageDataStatusResponse() = default;
};
class QueryDynamicGroupDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> deviceName{};
  shared_ptr<bool> fuzzyName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> status{};

  QueryDynamicGroupDevicesRequest() {}

  explicit QueryDynamicGroupDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (fuzzyName) {
      res["FuzzyName"] = boost::any(*fuzzyName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("FuzzyName") != m.end() && !m["FuzzyName"].empty()) {
      fuzzyName = make_shared<bool>(boost::any_cast<bool>(m["FuzzyName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~QueryDynamicGroupDevicesRequest() = default;
};
class QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo : public Darabonba::Model {
public:
  shared_ptr<string> activeTime{};
  shared_ptr<string> categoryKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> lastOnlineTime{};
  shared_ptr<string> nickname{};
  shared_ptr<long> nodeType{};
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};
  shared_ptr<string> status{};
  shared_ptr<string> utcActiveTime{};
  shared_ptr<string> utcLastOnlineTime{};

  QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo() {}

  explicit QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeTime) {
      res["ActiveTime"] = boost::any(*activeTime);
    }
    if (categoryKey) {
      res["CategoryKey"] = boost::any(*categoryKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (lastOnlineTime) {
      res["LastOnlineTime"] = boost::any(*lastOnlineTime);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (utcActiveTime) {
      res["UtcActiveTime"] = boost::any(*utcActiveTime);
    }
    if (utcLastOnlineTime) {
      res["UtcLastOnlineTime"] = boost::any(*utcLastOnlineTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveTime") != m.end() && !m["ActiveTime"].empty()) {
      activeTime = make_shared<string>(boost::any_cast<string>(m["ActiveTime"]));
    }
    if (m.find("CategoryKey") != m.end() && !m["CategoryKey"].empty()) {
      categoryKey = make_shared<string>(boost::any_cast<string>(m["CategoryKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("LastOnlineTime") != m.end() && !m["LastOnlineTime"].empty()) {
      lastOnlineTime = make_shared<string>(boost::any_cast<string>(m["LastOnlineTime"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<long>(boost::any_cast<long>(m["NodeType"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UtcActiveTime") != m.end() && !m["UtcActiveTime"].empty()) {
      utcActiveTime = make_shared<string>(boost::any_cast<string>(m["UtcActiveTime"]));
    }
    if (m.find("UtcLastOnlineTime") != m.end() && !m["UtcLastOnlineTime"].empty()) {
      utcLastOnlineTime = make_shared<string>(boost::any_cast<string>(m["UtcLastOnlineTime"]));
    }
  }


  virtual ~QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo() = default;
};
class QueryDynamicGroupDevicesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo>> simpleDeviceInfo{};

  QueryDynamicGroupDevicesResponseBodyData() {}

  explicit QueryDynamicGroupDevicesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (simpleDeviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*simpleDeviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SimpleDeviceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SimpleDeviceInfo") != m.end() && !m["SimpleDeviceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SimpleDeviceInfo"].type()) {
        vector<QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SimpleDeviceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        simpleDeviceInfo = make_shared<vector<QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDynamicGroupDevicesResponseBodyData() = default;
};
class QueryDynamicGroupDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryDynamicGroupDevicesResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> page{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  QueryDynamicGroupDevicesResponseBody() {}

  explicit QueryDynamicGroupDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDynamicGroupDevicesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDynamicGroupDevicesResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryDynamicGroupDevicesResponseBody() = default;
};
class QueryDynamicGroupDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDynamicGroupDevicesResponseBody> body{};

  QueryDynamicGroupDevicesResponse() {}

  explicit QueryDynamicGroupDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDynamicGroupDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDynamicGroupDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDynamicGroupDevicesResponse() = default;
};
class QueryEdgeDriverRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> driverName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> type{};

  QueryEdgeDriverRequest() {}

  explicit QueryEdgeDriverRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (driverName) {
      res["DriverName"] = boost::any(*driverName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DriverName") != m.end() && !m["DriverName"].empty()) {
      driverName = make_shared<string>(boost::any_cast<string>(m["DriverName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~QueryEdgeDriverRequest() = default;
};
class QueryEdgeDriverResponseBodyDataDriverList : public Darabonba::Model {
public:
  shared_ptr<string> cpuArch{};
  shared_ptr<string> driverId{};
  shared_ptr<string> driverName{};
  shared_ptr<string> driverProtocol{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<bool> isApply{};
  shared_ptr<bool> isBuiltIn{};
  shared_ptr<string> runtime{};
  shared_ptr<long> type{};

  QueryEdgeDriverResponseBodyDataDriverList() {}

  explicit QueryEdgeDriverResponseBodyDataDriverList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpuArch) {
      res["CpuArch"] = boost::any(*cpuArch);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverName) {
      res["DriverName"] = boost::any(*driverName);
    }
    if (driverProtocol) {
      res["DriverProtocol"] = boost::any(*driverProtocol);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (isApply) {
      res["IsApply"] = boost::any(*isApply);
    }
    if (isBuiltIn) {
      res["IsBuiltIn"] = boost::any(*isBuiltIn);
    }
    if (runtime) {
      res["Runtime"] = boost::any(*runtime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CpuArch") != m.end() && !m["CpuArch"].empty()) {
      cpuArch = make_shared<string>(boost::any_cast<string>(m["CpuArch"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverName") != m.end() && !m["DriverName"].empty()) {
      driverName = make_shared<string>(boost::any_cast<string>(m["DriverName"]));
    }
    if (m.find("DriverProtocol") != m.end() && !m["DriverProtocol"].empty()) {
      driverProtocol = make_shared<string>(boost::any_cast<string>(m["DriverProtocol"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("IsApply") != m.end() && !m["IsApply"].empty()) {
      isApply = make_shared<bool>(boost::any_cast<bool>(m["IsApply"]));
    }
    if (m.find("IsBuiltIn") != m.end() && !m["IsBuiltIn"].empty()) {
      isBuiltIn = make_shared<bool>(boost::any_cast<bool>(m["IsBuiltIn"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      runtime = make_shared<string>(boost::any_cast<string>(m["Runtime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~QueryEdgeDriverResponseBodyDataDriverList() = default;
};
class QueryEdgeDriverResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<QueryEdgeDriverResponseBodyDataDriverList>> driverList{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QueryEdgeDriverResponseBodyData() {}

  explicit QueryEdgeDriverResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (driverList) {
      vector<boost::any> temp1;
      for(auto item1:*driverList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DriverList"] = boost::any(temp1);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DriverList") != m.end() && !m["DriverList"].empty()) {
      if (typeid(vector<boost::any>) == m["DriverList"].type()) {
        vector<QueryEdgeDriverResponseBodyDataDriverList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DriverList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeDriverResponseBodyDataDriverList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        driverList = make_shared<vector<QueryEdgeDriverResponseBodyDataDriverList>>(expect1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryEdgeDriverResponseBodyData() = default;
};
class QueryEdgeDriverResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryEdgeDriverResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryEdgeDriverResponseBody() {}

  explicit QueryEdgeDriverResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEdgeDriverResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEdgeDriverResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryEdgeDriverResponseBody() = default;
};
class QueryEdgeDriverResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryEdgeDriverResponseBody> body{};

  QueryEdgeDriverResponse() {}

  explicit QueryEdgeDriverResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryEdgeDriverResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryEdgeDriverResponseBody>(model1);
      }
    }
  }


  virtual ~QueryEdgeDriverResponse() = default;
};
class QueryEdgeDriverVersionRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> versionState{};

  QueryEdgeDriverVersionRequest() {}

  explicit QueryEdgeDriverVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (versionState) {
      res["VersionState"] = boost::any(*versionState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("VersionState") != m.end() && !m["VersionState"].empty()) {
      versionState = make_shared<long>(boost::any_cast<long>(m["VersionState"]));
    }
  }


  virtual ~QueryEdgeDriverVersionRequest() = default;
};
class QueryEdgeDriverVersionResponseBodyDataDriverVersionList : public Darabonba::Model {
public:
  shared_ptr<string> argument{};
  shared_ptr<string> configCheckRule{};
  shared_ptr<string> containerConfig{};
  shared_ptr<string> description{};
  shared_ptr<string> driverConfig{};
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};
  shared_ptr<string> edgeVersion{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<string> sourceConfig{};
  shared_ptr<string> versionState{};

  QueryEdgeDriverVersionResponseBodyDataDriverVersionList() {}

  explicit QueryEdgeDriverVersionResponseBodyDataDriverVersionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (argument) {
      res["Argument"] = boost::any(*argument);
    }
    if (configCheckRule) {
      res["ConfigCheckRule"] = boost::any(*configCheckRule);
    }
    if (containerConfig) {
      res["ContainerConfig"] = boost::any(*containerConfig);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (driverConfig) {
      res["DriverConfig"] = boost::any(*driverConfig);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    if (edgeVersion) {
      res["EdgeVersion"] = boost::any(*edgeVersion);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (sourceConfig) {
      res["SourceConfig"] = boost::any(*sourceConfig);
    }
    if (versionState) {
      res["VersionState"] = boost::any(*versionState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Argument") != m.end() && !m["Argument"].empty()) {
      argument = make_shared<string>(boost::any_cast<string>(m["Argument"]));
    }
    if (m.find("ConfigCheckRule") != m.end() && !m["ConfigCheckRule"].empty()) {
      configCheckRule = make_shared<string>(boost::any_cast<string>(m["ConfigCheckRule"]));
    }
    if (m.find("ContainerConfig") != m.end() && !m["ContainerConfig"].empty()) {
      containerConfig = make_shared<string>(boost::any_cast<string>(m["ContainerConfig"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DriverConfig") != m.end() && !m["DriverConfig"].empty()) {
      driverConfig = make_shared<string>(boost::any_cast<string>(m["DriverConfig"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
    if (m.find("EdgeVersion") != m.end() && !m["EdgeVersion"].empty()) {
      edgeVersion = make_shared<string>(boost::any_cast<string>(m["EdgeVersion"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("SourceConfig") != m.end() && !m["SourceConfig"].empty()) {
      sourceConfig = make_shared<string>(boost::any_cast<string>(m["SourceConfig"]));
    }
    if (m.find("VersionState") != m.end() && !m["VersionState"].empty()) {
      versionState = make_shared<string>(boost::any_cast<string>(m["VersionState"]));
    }
  }


  virtual ~QueryEdgeDriverVersionResponseBodyDataDriverVersionList() = default;
};
class QueryEdgeDriverVersionResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<QueryEdgeDriverVersionResponseBodyDataDriverVersionList>> driverVersionList{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QueryEdgeDriverVersionResponseBodyData() {}

  explicit QueryEdgeDriverVersionResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (driverVersionList) {
      vector<boost::any> temp1;
      for(auto item1:*driverVersionList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DriverVersionList"] = boost::any(temp1);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DriverVersionList") != m.end() && !m["DriverVersionList"].empty()) {
      if (typeid(vector<boost::any>) == m["DriverVersionList"].type()) {
        vector<QueryEdgeDriverVersionResponseBodyDataDriverVersionList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DriverVersionList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeDriverVersionResponseBodyDataDriverVersionList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        driverVersionList = make_shared<vector<QueryEdgeDriverVersionResponseBodyDataDriverVersionList>>(expect1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryEdgeDriverVersionResponseBodyData() = default;
};
class QueryEdgeDriverVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryEdgeDriverVersionResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryEdgeDriverVersionResponseBody() {}

  explicit QueryEdgeDriverVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEdgeDriverVersionResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEdgeDriverVersionResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryEdgeDriverVersionResponseBody() = default;
};
class QueryEdgeDriverVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryEdgeDriverVersionResponseBody> body{};

  QueryEdgeDriverVersionResponse() {}

  explicit QueryEdgeDriverVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryEdgeDriverVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryEdgeDriverVersionResponseBody>(model1);
      }
    }
  }


  virtual ~QueryEdgeDriverVersionResponse() = default;
};
class QueryEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> pageSize{};

  QueryEdgeInstanceRequest() {}

  explicit QueryEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryEdgeInstanceRequest() = default;
};
class QueryEdgeInstanceResponseBodyDataInstanceList : public Darabonba::Model {
public:
  shared_ptr<bool> bizEnable{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> latestDeploymentStatus{};
  shared_ptr<string> latestDeploymentType{};
  shared_ptr<string> name{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> roleAttachTime{};
  shared_ptr<long> roleAttachTimestamp{};
  shared_ptr<string> roleName{};
  shared_ptr<long> spec{};
  shared_ptr<string> tags{};
  shared_ptr<long> type{};

  QueryEdgeInstanceResponseBodyDataInstanceList() {}

  explicit QueryEdgeInstanceResponseBodyDataInstanceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizEnable) {
      res["BizEnable"] = boost::any(*bizEnable);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (latestDeploymentStatus) {
      res["LatestDeploymentStatus"] = boost::any(*latestDeploymentStatus);
    }
    if (latestDeploymentType) {
      res["LatestDeploymentType"] = boost::any(*latestDeploymentType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (roleAttachTime) {
      res["RoleAttachTime"] = boost::any(*roleAttachTime);
    }
    if (roleAttachTimestamp) {
      res["RoleAttachTimestamp"] = boost::any(*roleAttachTimestamp);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizEnable") != m.end() && !m["BizEnable"].empty()) {
      bizEnable = make_shared<bool>(boost::any_cast<bool>(m["BizEnable"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LatestDeploymentStatus") != m.end() && !m["LatestDeploymentStatus"].empty()) {
      latestDeploymentStatus = make_shared<long>(boost::any_cast<long>(m["LatestDeploymentStatus"]));
    }
    if (m.find("LatestDeploymentType") != m.end() && !m["LatestDeploymentType"].empty()) {
      latestDeploymentType = make_shared<string>(boost::any_cast<string>(m["LatestDeploymentType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("RoleAttachTime") != m.end() && !m["RoleAttachTime"].empty()) {
      roleAttachTime = make_shared<string>(boost::any_cast<string>(m["RoleAttachTime"]));
    }
    if (m.find("RoleAttachTimestamp") != m.end() && !m["RoleAttachTimestamp"].empty()) {
      roleAttachTimestamp = make_shared<long>(boost::any_cast<long>(m["RoleAttachTimestamp"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<long>(boost::any_cast<long>(m["Spec"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~QueryEdgeInstanceResponseBodyDataInstanceList() = default;
};
class QueryEdgeInstanceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<QueryEdgeInstanceResponseBodyDataInstanceList>> instanceList{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QueryEdgeInstanceResponseBodyData() {}

  explicit QueryEdgeInstanceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (instanceList) {
      vector<boost::any> temp1;
      for(auto item1:*instanceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceList"] = boost::any(temp1);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("InstanceList") != m.end() && !m["InstanceList"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceList"].type()) {
        vector<QueryEdgeInstanceResponseBodyDataInstanceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeInstanceResponseBodyDataInstanceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceList = make_shared<vector<QueryEdgeInstanceResponseBodyDataInstanceList>>(expect1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryEdgeInstanceResponseBodyData() = default;
};
class QueryEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryEdgeInstanceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryEdgeInstanceResponseBody() {}

  explicit QueryEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEdgeInstanceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEdgeInstanceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryEdgeInstanceResponseBody() = default;
};
class QueryEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryEdgeInstanceResponseBody> body{};

  QueryEdgeInstanceResponse() {}

  explicit QueryEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceResponse() = default;
};
class QueryEdgeInstanceChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> driverId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};

  QueryEdgeInstanceChannelRequest() {}

  explicit QueryEdgeInstanceChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryEdgeInstanceChannelRequest() = default;
};
class QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<string> content{};
  shared_ptr<string> format{};
  shared_ptr<string> key{};

  QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig() {}

  explicit QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig() = default;
};
class QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig>> config{};

  QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList() {}

  explicit QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      vector<boost::any> temp1;
      for(auto item1:*config){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Config"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(vector<boost::any>) == m["Config"].type()) {
        vector<QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Config"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        config = make_shared<vector<QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig>>(expect1);
      }
    }
  }


  virtual ~QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList() = default;
};
class QueryEdgeInstanceChannelResponseBodyDataChannelListChannel : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> channelName{};
  shared_ptr<QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList> configList{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> gmtModifiedTimestamp{};

  QueryEdgeInstanceChannelResponseBodyDataChannelListChannel() {}

  explicit QueryEdgeInstanceChannelResponseBodyDataChannelListChannel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (configList) {
      res["ConfigList"] = configList ? boost::any(configList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ConfigList") != m.end() && !m["ConfigList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigList"].type()) {
        QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigList"]));
        configList = make_shared<QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList>(model1);
      }
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
  }


  virtual ~QueryEdgeInstanceChannelResponseBodyDataChannelListChannel() = default;
};
class QueryEdgeInstanceChannelResponseBodyDataChannelList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEdgeInstanceChannelResponseBodyDataChannelListChannel>> channel{};

  QueryEdgeInstanceChannelResponseBodyDataChannelList() {}

  explicit QueryEdgeInstanceChannelResponseBodyDataChannelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channel) {
      vector<boost::any> temp1;
      for(auto item1:*channel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Channel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      if (typeid(vector<boost::any>) == m["Channel"].type()) {
        vector<QueryEdgeInstanceChannelResponseBodyDataChannelListChannel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Channel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeInstanceChannelResponseBodyDataChannelListChannel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channel = make_shared<vector<QueryEdgeInstanceChannelResponseBodyDataChannelListChannel>>(expect1);
      }
    }
  }


  virtual ~QueryEdgeInstanceChannelResponseBodyDataChannelList() = default;
};
class QueryEdgeInstanceChannelResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QueryEdgeInstanceChannelResponseBodyDataChannelList> channelList{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QueryEdgeInstanceChannelResponseBodyData() {}

  explicit QueryEdgeInstanceChannelResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelList) {
      res["ChannelList"] = channelList ? boost::any(channelList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelList") != m.end() && !m["ChannelList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ChannelList"].type()) {
        QueryEdgeInstanceChannelResponseBodyDataChannelList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ChannelList"]));
        channelList = make_shared<QueryEdgeInstanceChannelResponseBodyDataChannelList>(model1);
      }
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryEdgeInstanceChannelResponseBodyData() = default;
};
class QueryEdgeInstanceChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryEdgeInstanceChannelResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryEdgeInstanceChannelResponseBody() {}

  explicit QueryEdgeInstanceChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEdgeInstanceChannelResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEdgeInstanceChannelResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryEdgeInstanceChannelResponseBody() = default;
};
class QueryEdgeInstanceChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryEdgeInstanceChannelResponseBody> body{};

  QueryEdgeInstanceChannelResponse() {}

  explicit QueryEdgeInstanceChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryEdgeInstanceChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryEdgeInstanceChannelResponseBody>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceChannelResponse() = default;
};
class QueryEdgeInstanceDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};

  QueryEdgeInstanceDeviceRequest() {}

  explicit QueryEdgeInstanceDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryEdgeInstanceDeviceRequest() = default;
};
class QueryEdgeInstanceDeviceResponseBodyDataDeviceList : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> driverId{};
  shared_ptr<string> iotId{};
  shared_ptr<string> productKey{};

  QueryEdgeInstanceDeviceResponseBodyDataDeviceList() {}

  explicit QueryEdgeInstanceDeviceResponseBodyDataDeviceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryEdgeInstanceDeviceResponseBodyDataDeviceList() = default;
};
class QueryEdgeInstanceDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<QueryEdgeInstanceDeviceResponseBodyDataDeviceList>> deviceList{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QueryEdgeInstanceDeviceResponseBodyData() {}

  explicit QueryEdgeInstanceDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (deviceList) {
      vector<boost::any> temp1;
      for(auto item1:*deviceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceList"] = boost::any(temp1);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DeviceList") != m.end() && !m["DeviceList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceList"].type()) {
        vector<QueryEdgeInstanceDeviceResponseBodyDataDeviceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeInstanceDeviceResponseBodyDataDeviceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceList = make_shared<vector<QueryEdgeInstanceDeviceResponseBodyDataDeviceList>>(expect1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryEdgeInstanceDeviceResponseBodyData() = default;
};
class QueryEdgeInstanceDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryEdgeInstanceDeviceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryEdgeInstanceDeviceResponseBody() {}

  explicit QueryEdgeInstanceDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEdgeInstanceDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEdgeInstanceDeviceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryEdgeInstanceDeviceResponseBody() = default;
};
class QueryEdgeInstanceDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryEdgeInstanceDeviceResponseBody> body{};

  QueryEdgeInstanceDeviceResponse() {}

  explicit QueryEdgeInstanceDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryEdgeInstanceDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryEdgeInstanceDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceDeviceResponse() = default;
};
class QueryEdgeInstanceDeviceByDriverRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> driverId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};

  QueryEdgeInstanceDeviceByDriverRequest() {}

  explicit QueryEdgeInstanceDeviceByDriverRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryEdgeInstanceDeviceByDriverRequest() = default;
};
class QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList : public Darabonba::Model {
public:
  shared_ptr<string> iotId{};

  QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList() {}

  explicit QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList() = default;
};
class QueryEdgeInstanceDeviceByDriverResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList>> deviceList{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QueryEdgeInstanceDeviceByDriverResponseBodyData() {}

  explicit QueryEdgeInstanceDeviceByDriverResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (deviceList) {
      vector<boost::any> temp1;
      for(auto item1:*deviceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceList"] = boost::any(temp1);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DeviceList") != m.end() && !m["DeviceList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceList"].type()) {
        vector<QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceList = make_shared<vector<QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList>>(expect1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryEdgeInstanceDeviceByDriverResponseBodyData() = default;
};
class QueryEdgeInstanceDeviceByDriverResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryEdgeInstanceDeviceByDriverResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryEdgeInstanceDeviceByDriverResponseBody() {}

  explicit QueryEdgeInstanceDeviceByDriverResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEdgeInstanceDeviceByDriverResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEdgeInstanceDeviceByDriverResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryEdgeInstanceDeviceByDriverResponseBody() = default;
};
class QueryEdgeInstanceDeviceByDriverResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryEdgeInstanceDeviceByDriverResponseBody> body{};

  QueryEdgeInstanceDeviceByDriverResponse() {}

  explicit QueryEdgeInstanceDeviceByDriverResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryEdgeInstanceDeviceByDriverResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryEdgeInstanceDeviceByDriverResponseBody>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceDeviceByDriverResponse() = default;
};
class QueryEdgeInstanceDriverRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};

  QueryEdgeInstanceDriverRequest() {}

  explicit QueryEdgeInstanceDriverRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryEdgeInstanceDriverRequest() = default;
};
class QueryEdgeInstanceDriverResponseBodyDataDriverList : public Darabonba::Model {
public:
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> orderId{};

  QueryEdgeInstanceDriverResponseBodyDataDriverList() {}

  explicit QueryEdgeInstanceDriverResponseBodyDataDriverList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
  }


  virtual ~QueryEdgeInstanceDriverResponseBodyDataDriverList() = default;
};
class QueryEdgeInstanceDriverResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<QueryEdgeInstanceDriverResponseBodyDataDriverList>> driverList{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QueryEdgeInstanceDriverResponseBodyData() {}

  explicit QueryEdgeInstanceDriverResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (driverList) {
      vector<boost::any> temp1;
      for(auto item1:*driverList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DriverList"] = boost::any(temp1);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DriverList") != m.end() && !m["DriverList"].empty()) {
      if (typeid(vector<boost::any>) == m["DriverList"].type()) {
        vector<QueryEdgeInstanceDriverResponseBodyDataDriverList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DriverList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeInstanceDriverResponseBodyDataDriverList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        driverList = make_shared<vector<QueryEdgeInstanceDriverResponseBodyDataDriverList>>(expect1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryEdgeInstanceDriverResponseBodyData() = default;
};
class QueryEdgeInstanceDriverResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryEdgeInstanceDriverResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryEdgeInstanceDriverResponseBody() {}

  explicit QueryEdgeInstanceDriverResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEdgeInstanceDriverResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEdgeInstanceDriverResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryEdgeInstanceDriverResponseBody() = default;
};
class QueryEdgeInstanceDriverResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryEdgeInstanceDriverResponseBody> body{};

  QueryEdgeInstanceDriverResponse() {}

  explicit QueryEdgeInstanceDriverResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryEdgeInstanceDriverResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryEdgeInstanceDriverResponseBody>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceDriverResponse() = default;
};
class QueryEdgeInstanceGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};

  QueryEdgeInstanceGatewayRequest() {}

  explicit QueryEdgeInstanceGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~QueryEdgeInstanceGatewayRequest() = default;
};
class QueryEdgeInstanceGatewayResponseBodyGatewayList : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> edgeVersion{};
  shared_ptr<string> iotId{};
  shared_ptr<string> productKey{};

  QueryEdgeInstanceGatewayResponseBodyGatewayList() {}

  explicit QueryEdgeInstanceGatewayResponseBodyGatewayList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (edgeVersion) {
      res["EdgeVersion"] = boost::any(*edgeVersion);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("EdgeVersion") != m.end() && !m["EdgeVersion"].empty()) {
      edgeVersion = make_shared<string>(boost::any_cast<string>(m["EdgeVersion"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryEdgeInstanceGatewayResponseBodyGatewayList() = default;
};
class QueryEdgeInstanceGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<QueryEdgeInstanceGatewayResponseBodyGatewayList>> gatewayList{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryEdgeInstanceGatewayResponseBody() {}

  explicit QueryEdgeInstanceGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (gatewayList) {
      vector<boost::any> temp1;
      for(auto item1:*gatewayList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GatewayList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("GatewayList") != m.end() && !m["GatewayList"].empty()) {
      if (typeid(vector<boost::any>) == m["GatewayList"].type()) {
        vector<QueryEdgeInstanceGatewayResponseBodyGatewayList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GatewayList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeInstanceGatewayResponseBodyGatewayList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        gatewayList = make_shared<vector<QueryEdgeInstanceGatewayResponseBodyGatewayList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryEdgeInstanceGatewayResponseBody() = default;
};
class QueryEdgeInstanceGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryEdgeInstanceGatewayResponseBody> body{};

  QueryEdgeInstanceGatewayResponse() {}

  explicit QueryEdgeInstanceGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryEdgeInstanceGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryEdgeInstanceGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceGatewayResponse() = default;
};
class QueryEdgeInstanceHistoricDeploymentRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};

  QueryEdgeInstanceHistoricDeploymentRequest() {}

  explicit QueryEdgeInstanceHistoricDeploymentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~QueryEdgeInstanceHistoricDeploymentRequest() = default;
};
class QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList : public Darabonba::Model {
public:
  shared_ptr<string> deploymentId{};
  shared_ptr<string> description{};
  shared_ptr<string> gmtCompleted{};
  shared_ptr<long> gmtCompletedTimestamp{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<long> status{};
  shared_ptr<string> type{};

  QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList() {}

  explicit QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deploymentId) {
      res["DeploymentId"] = boost::any(*deploymentId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCompleted) {
      res["GmtCompleted"] = boost::any(*gmtCompleted);
    }
    if (gmtCompletedTimestamp) {
      res["GmtCompletedTimestamp"] = boost::any(*gmtCompletedTimestamp);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeploymentId") != m.end() && !m["DeploymentId"].empty()) {
      deploymentId = make_shared<string>(boost::any_cast<string>(m["DeploymentId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCompleted") != m.end() && !m["GmtCompleted"].empty()) {
      gmtCompleted = make_shared<string>(boost::any_cast<string>(m["GmtCompleted"]));
    }
    if (m.find("GmtCompletedTimestamp") != m.end() && !m["GmtCompletedTimestamp"].empty()) {
      gmtCompletedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCompletedTimestamp"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList() = default;
};
class QueryEdgeInstanceHistoricDeploymentResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList>> deploymentList{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QueryEdgeInstanceHistoricDeploymentResponseBodyData() {}

  explicit QueryEdgeInstanceHistoricDeploymentResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (deploymentList) {
      vector<boost::any> temp1;
      for(auto item1:*deploymentList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeploymentList"] = boost::any(temp1);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DeploymentList") != m.end() && !m["DeploymentList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeploymentList"].type()) {
        vector<QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeploymentList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deploymentList = make_shared<vector<QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList>>(expect1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryEdgeInstanceHistoricDeploymentResponseBodyData() = default;
};
class QueryEdgeInstanceHistoricDeploymentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryEdgeInstanceHistoricDeploymentResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryEdgeInstanceHistoricDeploymentResponseBody() {}

  explicit QueryEdgeInstanceHistoricDeploymentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEdgeInstanceHistoricDeploymentResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEdgeInstanceHistoricDeploymentResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryEdgeInstanceHistoricDeploymentResponseBody() = default;
};
class QueryEdgeInstanceHistoricDeploymentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryEdgeInstanceHistoricDeploymentResponseBody> body{};

  QueryEdgeInstanceHistoricDeploymentResponse() {}

  explicit QueryEdgeInstanceHistoricDeploymentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryEdgeInstanceHistoricDeploymentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryEdgeInstanceHistoricDeploymentResponseBody>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceHistoricDeploymentResponse() = default;
};
class QueryEdgeInstanceMessageRoutingRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};

  QueryEdgeInstanceMessageRoutingRequest() {}

  explicit QueryEdgeInstanceMessageRoutingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryEdgeInstanceMessageRoutingRequest() = default;
};
class QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext : public Darabonba::Model {
public:
  shared_ptr<string> qos{};
  shared_ptr<string> sourceApplicationName{};
  shared_ptr<string> sourceFcFunctionName{};
  shared_ptr<string> sourceFcServiceName{};
  shared_ptr<string> targetApplicationName{};
  shared_ptr<string> targetFcFunctionName{};
  shared_ptr<string> targetFcServiceName{};

  QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext() {}

  explicit QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qos) {
      res["Qos"] = boost::any(*qos);
    }
    if (sourceApplicationName) {
      res["SourceApplicationName"] = boost::any(*sourceApplicationName);
    }
    if (sourceFcFunctionName) {
      res["SourceFcFunctionName"] = boost::any(*sourceFcFunctionName);
    }
    if (sourceFcServiceName) {
      res["SourceFcServiceName"] = boost::any(*sourceFcServiceName);
    }
    if (targetApplicationName) {
      res["TargetApplicationName"] = boost::any(*targetApplicationName);
    }
    if (targetFcFunctionName) {
      res["TargetFcFunctionName"] = boost::any(*targetFcFunctionName);
    }
    if (targetFcServiceName) {
      res["TargetFcServiceName"] = boost::any(*targetFcServiceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Qos") != m.end() && !m["Qos"].empty()) {
      qos = make_shared<string>(boost::any_cast<string>(m["Qos"]));
    }
    if (m.find("SourceApplicationName") != m.end() && !m["SourceApplicationName"].empty()) {
      sourceApplicationName = make_shared<string>(boost::any_cast<string>(m["SourceApplicationName"]));
    }
    if (m.find("SourceFcFunctionName") != m.end() && !m["SourceFcFunctionName"].empty()) {
      sourceFcFunctionName = make_shared<string>(boost::any_cast<string>(m["SourceFcFunctionName"]));
    }
    if (m.find("SourceFcServiceName") != m.end() && !m["SourceFcServiceName"].empty()) {
      sourceFcServiceName = make_shared<string>(boost::any_cast<string>(m["SourceFcServiceName"]));
    }
    if (m.find("TargetApplicationName") != m.end() && !m["TargetApplicationName"].empty()) {
      targetApplicationName = make_shared<string>(boost::any_cast<string>(m["TargetApplicationName"]));
    }
    if (m.find("TargetFcFunctionName") != m.end() && !m["TargetFcFunctionName"].empty()) {
      targetFcFunctionName = make_shared<string>(boost::any_cast<string>(m["TargetFcFunctionName"]));
    }
    if (m.find("TargetFcServiceName") != m.end() && !m["TargetFcServiceName"].empty()) {
      targetFcServiceName = make_shared<string>(boost::any_cast<string>(m["TargetFcServiceName"]));
    }
  }


  virtual ~QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext() = default;
};
class QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreate{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<string> name{};
  shared_ptr<QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext> routeContext{};
  shared_ptr<long> routeId{};
  shared_ptr<string> sourceData{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> targetData{};
  shared_ptr<string> targetType{};
  shared_ptr<string> topicFilter{};

  QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute() {}

  explicit QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (routeContext) {
      res["RouteContext"] = routeContext ? boost::any(routeContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    if (sourceData) {
      res["SourceData"] = boost::any(*sourceData);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (targetData) {
      res["TargetData"] = boost::any(*targetData);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (topicFilter) {
      res["TopicFilter"] = boost::any(*topicFilter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RouteContext") != m.end() && !m["RouteContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["RouteContext"].type()) {
        QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RouteContext"]));
        routeContext = make_shared<QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext>(model1);
      }
    }
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<long>(boost::any_cast<long>(m["RouteId"]));
    }
    if (m.find("SourceData") != m.end() && !m["SourceData"].empty()) {
      sourceData = make_shared<string>(boost::any_cast<string>(m["SourceData"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("TargetData") != m.end() && !m["TargetData"].empty()) {
      targetData = make_shared<string>(boost::any_cast<string>(m["TargetData"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("TopicFilter") != m.end() && !m["TopicFilter"].empty()) {
      topicFilter = make_shared<string>(boost::any_cast<string>(m["TopicFilter"]));
    }
  }


  virtual ~QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute() = default;
};
class QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute>> messageRoute{};

  QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList() {}

  explicit QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageRoute) {
      vector<boost::any> temp1;
      for(auto item1:*messageRoute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MessageRoute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageRoute") != m.end() && !m["MessageRoute"].empty()) {
      if (typeid(vector<boost::any>) == m["MessageRoute"].type()) {
        vector<QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MessageRoute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        messageRoute = make_shared<vector<QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute>>(expect1);
      }
    }
  }


  virtual ~QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList() = default;
};
class QueryEdgeInstanceMessageRoutingResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList> messageRouteList{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QueryEdgeInstanceMessageRoutingResponseBodyData() {}

  explicit QueryEdgeInstanceMessageRoutingResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (messageRouteList) {
      res["MessageRouteList"] = messageRouteList ? boost::any(messageRouteList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("MessageRouteList") != m.end() && !m["MessageRouteList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MessageRouteList"].type()) {
        QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MessageRouteList"]));
        messageRouteList = make_shared<QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList>(model1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryEdgeInstanceMessageRoutingResponseBodyData() = default;
};
class QueryEdgeInstanceMessageRoutingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryEdgeInstanceMessageRoutingResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryEdgeInstanceMessageRoutingResponseBody() {}

  explicit QueryEdgeInstanceMessageRoutingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEdgeInstanceMessageRoutingResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEdgeInstanceMessageRoutingResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryEdgeInstanceMessageRoutingResponseBody() = default;
};
class QueryEdgeInstanceMessageRoutingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryEdgeInstanceMessageRoutingResponseBody> body{};

  QueryEdgeInstanceMessageRoutingResponse() {}

  explicit QueryEdgeInstanceMessageRoutingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryEdgeInstanceMessageRoutingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryEdgeInstanceMessageRoutingResponseBody>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceMessageRoutingResponse() = default;
};
class QueryEdgeInstanceSceneRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};

  QueryEdgeInstanceSceneRuleRequest() {}

  explicit QueryEdgeInstanceSceneRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryEdgeInstanceSceneRuleRequest() = default;
};
class QueryEdgeInstanceSceneRuleResponseBodyDataRuleList : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> isExisted{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> status{};

  QueryEdgeInstanceSceneRuleResponseBodyDataRuleList() {}

  explicit QueryEdgeInstanceSceneRuleResponseBodyDataRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (isExisted) {
      res["IsExisted"] = boost::any(*isExisted);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("IsExisted") != m.end() && !m["IsExisted"].empty()) {
      isExisted = make_shared<long>(boost::any_cast<long>(m["IsExisted"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~QueryEdgeInstanceSceneRuleResponseBodyDataRuleList() = default;
};
class QueryEdgeInstanceSceneRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<QueryEdgeInstanceSceneRuleResponseBodyDataRuleList>> ruleList{};
  shared_ptr<long> total{};

  QueryEdgeInstanceSceneRuleResponseBodyData() {}

  explicit QueryEdgeInstanceSceneRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ruleList) {
      vector<boost::any> temp1;
      for(auto item1:*ruleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleList"] = boost::any(temp1);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RuleList") != m.end() && !m["RuleList"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleList"].type()) {
        vector<QueryEdgeInstanceSceneRuleResponseBodyDataRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeInstanceSceneRuleResponseBodyDataRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleList = make_shared<vector<QueryEdgeInstanceSceneRuleResponseBodyDataRuleList>>(expect1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryEdgeInstanceSceneRuleResponseBodyData() = default;
};
class QueryEdgeInstanceSceneRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryEdgeInstanceSceneRuleResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryEdgeInstanceSceneRuleResponseBody() {}

  explicit QueryEdgeInstanceSceneRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEdgeInstanceSceneRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEdgeInstanceSceneRuleResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryEdgeInstanceSceneRuleResponseBody() = default;
};
class QueryEdgeInstanceSceneRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryEdgeInstanceSceneRuleResponseBody> body{};

  QueryEdgeInstanceSceneRuleResponse() {}

  explicit QueryEdgeInstanceSceneRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryEdgeInstanceSceneRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryEdgeInstanceSceneRuleResponseBody>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceSceneRuleResponse() = default;
};
class QueryImportedDeviceByApplyIdRequest : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};

  QueryImportedDeviceByApplyIdRequest() {}

  explicit QueryImportedDeviceByApplyIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["ApplyId"] = boost::any(*applyId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyId") != m.end() && !m["ApplyId"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["ApplyId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryImportedDeviceByApplyIdRequest() = default;
};
class QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceSecret{};
  shared_ptr<string> productKey{};
  shared_ptr<string> sn{};

  QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice() {}

  explicit QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceSecret) {
      res["DeviceSecret"] = boost::any(*deviceSecret);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (sn) {
      res["Sn"] = boost::any(*sn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceSecret") != m.end() && !m["DeviceSecret"].empty()) {
      deviceSecret = make_shared<string>(boost::any_cast<string>(m["DeviceSecret"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Sn") != m.end() && !m["Sn"].empty()) {
      sn = make_shared<string>(boost::any_cast<string>(m["Sn"]));
    }
  }


  virtual ~QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice() = default;
};
class QueryImportedDeviceByApplyIdResponseBodyDeviceList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice>> device{};

  QueryImportedDeviceByApplyIdResponseBodyDeviceList() {}

  explicit QueryImportedDeviceByApplyIdResponseBodyDeviceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (device) {
      vector<boost::any> temp1;
      for(auto item1:*device){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["device"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("device") != m.end() && !m["device"].empty()) {
      if (typeid(vector<boost::any>) == m["device"].type()) {
        vector<QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["device"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        device = make_shared<vector<QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice>>(expect1);
      }
    }
  }


  virtual ~QueryImportedDeviceByApplyIdResponseBodyDeviceList() = default;
};
class QueryImportedDeviceByApplyIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryImportedDeviceByApplyIdResponseBodyDeviceList> deviceList{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalPage{};

  QueryImportedDeviceByApplyIdResponseBody() {}

  explicit QueryImportedDeviceByApplyIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (deviceList) {
      res["DeviceList"] = deviceList ? boost::any(deviceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DeviceList") != m.end() && !m["DeviceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeviceList"].type()) {
        QueryImportedDeviceByApplyIdResponseBodyDeviceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeviceList"]));
        deviceList = make_shared<QueryImportedDeviceByApplyIdResponseBodyDeviceList>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~QueryImportedDeviceByApplyIdResponseBody() = default;
};
class QueryImportedDeviceByApplyIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryImportedDeviceByApplyIdResponseBody> body{};

  QueryImportedDeviceByApplyIdResponse() {}

  explicit QueryImportedDeviceByApplyIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryImportedDeviceByApplyIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryImportedDeviceByApplyIdResponseBody>(model1);
      }
    }
  }


  virtual ~QueryImportedDeviceByApplyIdResponse() = default;
};
class QueryJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobId{};

  QueryJobRequest() {}

  explicit QueryJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~QueryJobRequest() = default;
};
class QueryJobResponseBodyDataJobFile : public Darabonba::Model {
public:
  shared_ptr<string> fileUrl{};
  shared_ptr<string> sign{};
  shared_ptr<string> signMethod{};

  QueryJobResponseBodyDataJobFile() {}

  explicit QueryJobResponseBodyDataJobFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (sign) {
      res["Sign"] = boost::any(*sign);
    }
    if (signMethod) {
      res["SignMethod"] = boost::any(*signMethod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("Sign") != m.end() && !m["Sign"].empty()) {
      sign = make_shared<string>(boost::any_cast<string>(m["Sign"]));
    }
    if (m.find("SignMethod") != m.end() && !m["SignMethod"].empty()) {
      signMethod = make_shared<string>(boost::any_cast<string>(m["SignMethod"]));
    }
  }


  virtual ~QueryJobResponseBodyDataJobFile() = default;
};
class QueryJobResponseBodyDataRolloutConfig : public Darabonba::Model {
public:
  shared_ptr<long> maximumPerMinute{};
  shared_ptr<string> messageQoS{};

  QueryJobResponseBodyDataRolloutConfig() {}

  explicit QueryJobResponseBodyDataRolloutConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maximumPerMinute) {
      res["MaximumPerMinute"] = boost::any(*maximumPerMinute);
    }
    if (messageQoS) {
      res["MessageQoS"] = boost::any(*messageQoS);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaximumPerMinute") != m.end() && !m["MaximumPerMinute"].empty()) {
      maximumPerMinute = make_shared<long>(boost::any_cast<long>(m["MaximumPerMinute"]));
    }
    if (m.find("MessageQoS") != m.end() && !m["MessageQoS"].empty()) {
      messageQoS = make_shared<string>(boost::any_cast<string>(m["MessageQoS"]));
    }
  }


  virtual ~QueryJobResponseBodyDataRolloutConfig() = default;
};
class QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> productKey{};

  QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices() {}

  explicit QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices() = default;
};
class QueryJobResponseBodyDataTargetConfigTargetDevices : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices>> targetDevices{};

  QueryJobResponseBodyDataTargetConfigTargetDevices() {}

  explicit QueryJobResponseBodyDataTargetConfigTargetDevices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetDevices) {
      vector<boost::any> temp1;
      for(auto item1:*targetDevices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["targetDevices"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("targetDevices") != m.end() && !m["targetDevices"].empty()) {
      if (typeid(vector<boost::any>) == m["targetDevices"].type()) {
        vector<QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["targetDevices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targetDevices = make_shared<vector<QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices>>(expect1);
      }
    }
  }


  virtual ~QueryJobResponseBodyDataTargetConfigTargetDevices() = default;
};
class QueryJobResponseBodyDataTargetConfig : public Darabonba::Model {
public:
  shared_ptr<QueryJobResponseBodyDataTargetConfigTargetDevices> targetDevices{};
  shared_ptr<string> targetGroup{};
  shared_ptr<string> targetProduct{};
  shared_ptr<string> targetType{};

  QueryJobResponseBodyDataTargetConfig() {}

  explicit QueryJobResponseBodyDataTargetConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetDevices) {
      res["TargetDevices"] = targetDevices ? boost::any(targetDevices->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (targetGroup) {
      res["TargetGroup"] = boost::any(*targetGroup);
    }
    if (targetProduct) {
      res["TargetProduct"] = boost::any(*targetProduct);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetDevices") != m.end() && !m["TargetDevices"].empty()) {
      if (typeid(map<string, boost::any>) == m["TargetDevices"].type()) {
        QueryJobResponseBodyDataTargetConfigTargetDevices model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TargetDevices"]));
        targetDevices = make_shared<QueryJobResponseBodyDataTargetConfigTargetDevices>(model1);
      }
    }
    if (m.find("TargetGroup") != m.end() && !m["TargetGroup"].empty()) {
      targetGroup = make_shared<string>(boost::any_cast<string>(m["TargetGroup"]));
    }
    if (m.find("TargetProduct") != m.end() && !m["TargetProduct"].empty()) {
      targetProduct = make_shared<string>(boost::any_cast<string>(m["TargetProduct"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
  }


  virtual ~QueryJobResponseBodyDataTargetConfig() = default;
};
class QueryJobResponseBodyDataTimeoutConfig : public Darabonba::Model {
public:
  shared_ptr<long> inProgressTimeoutInMinutes{};

  QueryJobResponseBodyDataTimeoutConfig() {}

  explicit QueryJobResponseBodyDataTimeoutConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inProgressTimeoutInMinutes) {
      res["InProgressTimeoutInMinutes"] = boost::any(*inProgressTimeoutInMinutes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InProgressTimeoutInMinutes") != m.end() && !m["InProgressTimeoutInMinutes"].empty()) {
      inProgressTimeoutInMinutes = make_shared<long>(boost::any_cast<long>(m["InProgressTimeoutInMinutes"]));
    }
  }


  virtual ~QueryJobResponseBodyDataTimeoutConfig() = default;
};
class QueryJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> jobDocument{};
  shared_ptr<QueryJobResponseBodyDataJobFile> jobFile{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobName{};
  shared_ptr<QueryJobResponseBodyDataRolloutConfig> rolloutConfig{};
  shared_ptr<long> scheduledTime{};
  shared_ptr<string> status{};
  shared_ptr<QueryJobResponseBodyDataTargetConfig> targetConfig{};
  shared_ptr<QueryJobResponseBodyDataTimeoutConfig> timeoutConfig{};
  shared_ptr<string> type{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> utcModified{};

  QueryJobResponseBodyData() {}

  explicit QueryJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (jobDocument) {
      res["JobDocument"] = boost::any(*jobDocument);
    }
    if (jobFile) {
      res["JobFile"] = jobFile ? boost::any(jobFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (rolloutConfig) {
      res["RolloutConfig"] = rolloutConfig ? boost::any(rolloutConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scheduledTime) {
      res["ScheduledTime"] = boost::any(*scheduledTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (targetConfig) {
      res["TargetConfig"] = targetConfig ? boost::any(targetConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeoutConfig) {
      res["TimeoutConfig"] = timeoutConfig ? boost::any(timeoutConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("JobDocument") != m.end() && !m["JobDocument"].empty()) {
      jobDocument = make_shared<string>(boost::any_cast<string>(m["JobDocument"]));
    }
    if (m.find("JobFile") != m.end() && !m["JobFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobFile"].type()) {
        QueryJobResponseBodyDataJobFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobFile"]));
        jobFile = make_shared<QueryJobResponseBodyDataJobFile>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("RolloutConfig") != m.end() && !m["RolloutConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RolloutConfig"].type()) {
        QueryJobResponseBodyDataRolloutConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RolloutConfig"]));
        rolloutConfig = make_shared<QueryJobResponseBodyDataRolloutConfig>(model1);
      }
    }
    if (m.find("ScheduledTime") != m.end() && !m["ScheduledTime"].empty()) {
      scheduledTime = make_shared<long>(boost::any_cast<long>(m["ScheduledTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TargetConfig") != m.end() && !m["TargetConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TargetConfig"].type()) {
        QueryJobResponseBodyDataTargetConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TargetConfig"]));
        targetConfig = make_shared<QueryJobResponseBodyDataTargetConfig>(model1);
      }
    }
    if (m.find("TimeoutConfig") != m.end() && !m["TimeoutConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeoutConfig"].type()) {
        QueryJobResponseBodyDataTimeoutConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeoutConfig"]));
        timeoutConfig = make_shared<QueryJobResponseBodyDataTimeoutConfig>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
  }


  virtual ~QueryJobResponseBodyData() = default;
};
class QueryJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryJobResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryJobResponseBody() {}

  explicit QueryJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryJobResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryJobResponseBody() = default;
};
class QueryJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryJobResponseBody> body{};

  QueryJobResponse() {}

  explicit QueryJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryJobResponseBody>(model1);
      }
    }
  }


  virtual ~QueryJobResponse() = default;
};
class QueryJobStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobId{};

  QueryJobStatisticsRequest() {}

  explicit QueryJobStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~QueryJobStatisticsRequest() = default;
};
class QueryJobStatisticsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> cancelled{};
  shared_ptr<long> failed{};
  shared_ptr<long> inProgress{};
  shared_ptr<long> queued{};
  shared_ptr<long> rejected{};
  shared_ptr<long> sent{};
  shared_ptr<long> succeeded{};
  shared_ptr<long> timeOut{};
  shared_ptr<long> total{};

  QueryJobStatisticsResponseBodyData() {}

  explicit QueryJobStatisticsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cancelled) {
      res["Cancelled"] = boost::any(*cancelled);
    }
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (inProgress) {
      res["InProgress"] = boost::any(*inProgress);
    }
    if (queued) {
      res["Queued"] = boost::any(*queued);
    }
    if (rejected) {
      res["Rejected"] = boost::any(*rejected);
    }
    if (sent) {
      res["Sent"] = boost::any(*sent);
    }
    if (succeeded) {
      res["Succeeded"] = boost::any(*succeeded);
    }
    if (timeOut) {
      res["TimeOut"] = boost::any(*timeOut);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cancelled") != m.end() && !m["Cancelled"].empty()) {
      cancelled = make_shared<long>(boost::any_cast<long>(m["Cancelled"]));
    }
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("InProgress") != m.end() && !m["InProgress"].empty()) {
      inProgress = make_shared<long>(boost::any_cast<long>(m["InProgress"]));
    }
    if (m.find("Queued") != m.end() && !m["Queued"].empty()) {
      queued = make_shared<long>(boost::any_cast<long>(m["Queued"]));
    }
    if (m.find("Rejected") != m.end() && !m["Rejected"].empty()) {
      rejected = make_shared<long>(boost::any_cast<long>(m["Rejected"]));
    }
    if (m.find("Sent") != m.end() && !m["Sent"].empty()) {
      sent = make_shared<long>(boost::any_cast<long>(m["Sent"]));
    }
    if (m.find("Succeeded") != m.end() && !m["Succeeded"].empty()) {
      succeeded = make_shared<long>(boost::any_cast<long>(m["Succeeded"]));
    }
    if (m.find("TimeOut") != m.end() && !m["TimeOut"].empty()) {
      timeOut = make_shared<long>(boost::any_cast<long>(m["TimeOut"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryJobStatisticsResponseBodyData() = default;
};
class QueryJobStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryJobStatisticsResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryJobStatisticsResponseBody() {}

  explicit QueryJobStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryJobStatisticsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryJobStatisticsResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryJobStatisticsResponseBody() = default;
};
class QueryJobStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryJobStatisticsResponseBody> body{};

  QueryJobStatisticsResponse() {}

  explicit QueryJobStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryJobStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryJobStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryJobStatisticsResponse() = default;
};
class QueryLicenseDeviceListRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> licenseCode{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<long> startTime{};

  QueryLicenseDeviceListRequest() {}

  explicit QueryLicenseDeviceListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (licenseCode) {
      res["LicenseCode"] = boost::any(*licenseCode);
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("LicenseCode") != m.end() && !m["LicenseCode"].empty()) {
      licenseCode = make_shared<string>(boost::any_cast<string>(m["LicenseCode"]));
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~QueryLicenseDeviceListRequest() = default;
};
class QueryLicenseDeviceListResponseBodyDataDeviceListItem : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<long> expiryTime{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> iotId{};
  shared_ptr<string> licenseCode{};
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};

  QueryLicenseDeviceListResponseBodyDataDeviceListItem() {}

  explicit QueryLicenseDeviceListResponseBodyDataDeviceListItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (expiryTime) {
      res["ExpiryTime"] = boost::any(*expiryTime);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (licenseCode) {
      res["LicenseCode"] = boost::any(*licenseCode);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("ExpiryTime") != m.end() && !m["ExpiryTime"].empty()) {
      expiryTime = make_shared<long>(boost::any_cast<long>(m["ExpiryTime"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("LicenseCode") != m.end() && !m["LicenseCode"].empty()) {
      licenseCode = make_shared<string>(boost::any_cast<string>(m["LicenseCode"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
  }


  virtual ~QueryLicenseDeviceListResponseBodyDataDeviceListItem() = default;
};
class QueryLicenseDeviceListResponseBodyDataDeviceList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryLicenseDeviceListResponseBodyDataDeviceListItem>> item{};

  QueryLicenseDeviceListResponseBodyDataDeviceList() {}

  explicit QueryLicenseDeviceListResponseBodyDataDeviceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["item"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("item") != m.end() && !m["item"].empty()) {
      if (typeid(vector<boost::any>) == m["item"].type()) {
        vector<QueryLicenseDeviceListResponseBodyDataDeviceListItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryLicenseDeviceListResponseBodyDataDeviceListItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<QueryLicenseDeviceListResponseBodyDataDeviceListItem>>(expect1);
      }
    }
  }


  virtual ~QueryLicenseDeviceListResponseBodyDataDeviceList() = default;
};
class QueryLicenseDeviceListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QueryLicenseDeviceListResponseBodyDataDeviceList> deviceList{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QueryLicenseDeviceListResponseBodyData() {}

  explicit QueryLicenseDeviceListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceList) {
      res["DeviceList"] = deviceList ? boost::any(deviceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceList") != m.end() && !m["DeviceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeviceList"].type()) {
        QueryLicenseDeviceListResponseBodyDataDeviceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeviceList"]));
        deviceList = make_shared<QueryLicenseDeviceListResponseBodyDataDeviceList>(model1);
      }
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryLicenseDeviceListResponseBodyData() = default;
};
class QueryLicenseDeviceListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryLicenseDeviceListResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryLicenseDeviceListResponseBody() {}

  explicit QueryLicenseDeviceListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryLicenseDeviceListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryLicenseDeviceListResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryLicenseDeviceListResponseBody() = default;
};
class QueryLicenseDeviceListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryLicenseDeviceListResponseBody> body{};

  QueryLicenseDeviceListResponse() {}

  explicit QueryLicenseDeviceListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryLicenseDeviceListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryLicenseDeviceListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryLicenseDeviceListResponse() = default;
};
class QueryLoRaJoinPermissionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};

  QueryLoRaJoinPermissionsRequest() {}

  explicit QueryLoRaJoinPermissionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~QueryLoRaJoinPermissionsRequest() = default;
};
class QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission : public Darabonba::Model {
public:
  shared_ptr<string> classMode{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> joinPermissionId{};
  shared_ptr<string> joinPermissionName{};
  shared_ptr<string> joinPermissionType{};
  shared_ptr<string> ownerAliyunPk{};

  QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission() {}

  explicit QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classMode) {
      res["ClassMode"] = boost::any(*classMode);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (joinPermissionId) {
      res["JoinPermissionId"] = boost::any(*joinPermissionId);
    }
    if (joinPermissionName) {
      res["JoinPermissionName"] = boost::any(*joinPermissionName);
    }
    if (joinPermissionType) {
      res["JoinPermissionType"] = boost::any(*joinPermissionType);
    }
    if (ownerAliyunPk) {
      res["OwnerAliyunPk"] = boost::any(*ownerAliyunPk);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClassMode") != m.end() && !m["ClassMode"].empty()) {
      classMode = make_shared<string>(boost::any_cast<string>(m["ClassMode"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("JoinPermissionId") != m.end() && !m["JoinPermissionId"].empty()) {
      joinPermissionId = make_shared<string>(boost::any_cast<string>(m["JoinPermissionId"]));
    }
    if (m.find("JoinPermissionName") != m.end() && !m["JoinPermissionName"].empty()) {
      joinPermissionName = make_shared<string>(boost::any_cast<string>(m["JoinPermissionName"]));
    }
    if (m.find("JoinPermissionType") != m.end() && !m["JoinPermissionType"].empty()) {
      joinPermissionType = make_shared<string>(boost::any_cast<string>(m["JoinPermissionType"]));
    }
    if (m.find("OwnerAliyunPk") != m.end() && !m["OwnerAliyunPk"].empty()) {
      ownerAliyunPk = make_shared<string>(boost::any_cast<string>(m["OwnerAliyunPk"]));
    }
  }


  virtual ~QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission() = default;
};
class QueryLoRaJoinPermissionsResponseBodyJoinPermissions : public Darabonba::Model {
public:
  shared_ptr<vector<QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission>> joinPermission{};

  QueryLoRaJoinPermissionsResponseBodyJoinPermissions() {}

  explicit QueryLoRaJoinPermissionsResponseBodyJoinPermissions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (joinPermission) {
      vector<boost::any> temp1;
      for(auto item1:*joinPermission){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JoinPermission"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JoinPermission") != m.end() && !m["JoinPermission"].empty()) {
      if (typeid(vector<boost::any>) == m["JoinPermission"].type()) {
        vector<QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JoinPermission"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        joinPermission = make_shared<vector<QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission>>(expect1);
      }
    }
  }


  virtual ~QueryLoRaJoinPermissionsResponseBodyJoinPermissions() = default;
};
class QueryLoRaJoinPermissionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryLoRaJoinPermissionsResponseBodyJoinPermissions> joinPermissions{};
  shared_ptr<string> productKey{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryLoRaJoinPermissionsResponseBody() {}

  explicit QueryLoRaJoinPermissionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (joinPermissions) {
      res["JoinPermissions"] = joinPermissions ? boost::any(joinPermissions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("JoinPermissions") != m.end() && !m["JoinPermissions"].empty()) {
      if (typeid(map<string, boost::any>) == m["JoinPermissions"].type()) {
        QueryLoRaJoinPermissionsResponseBodyJoinPermissions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JoinPermissions"]));
        joinPermissions = make_shared<QueryLoRaJoinPermissionsResponseBodyJoinPermissions>(model1);
      }
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryLoRaJoinPermissionsResponseBody() = default;
};
class QueryLoRaJoinPermissionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryLoRaJoinPermissionsResponseBody> body{};

  QueryLoRaJoinPermissionsResponse() {}

  explicit QueryLoRaJoinPermissionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryLoRaJoinPermissionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryLoRaJoinPermissionsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryLoRaJoinPermissionsResponse() = default;
};
class QueryMessageInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> uniMsgId{};

  QueryMessageInfoRequest() {}

  explicit QueryMessageInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (uniMsgId) {
      res["UniMsgId"] = boost::any(*uniMsgId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("UniMsgId") != m.end() && !m["UniMsgId"].empty()) {
      uniMsgId = make_shared<string>(boost::any_cast<string>(m["UniMsgId"]));
    }
  }


  virtual ~QueryMessageInfoRequest() = default;
};
class QueryMessageInfoResponseBodyMessageUserProperties : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  QueryMessageInfoResponseBodyMessageUserProperties() {}

  explicit QueryMessageInfoResponseBodyMessageUserProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryMessageInfoResponseBodyMessageUserProperties() = default;
};
class QueryMessageInfoResponseBodyMessage : public Darabonba::Model {
public:
  shared_ptr<long> generateTime{};
  shared_ptr<string> messageContent{};
  shared_ptr<string> topicFullName{};
  shared_ptr<string> uniMsgId{};
  shared_ptr<vector<QueryMessageInfoResponseBodyMessageUserProperties>> userProperties{};

  QueryMessageInfoResponseBodyMessage() {}

  explicit QueryMessageInfoResponseBodyMessage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (generateTime) {
      res["GenerateTime"] = boost::any(*generateTime);
    }
    if (messageContent) {
      res["MessageContent"] = boost::any(*messageContent);
    }
    if (topicFullName) {
      res["TopicFullName"] = boost::any(*topicFullName);
    }
    if (uniMsgId) {
      res["UniMsgId"] = boost::any(*uniMsgId);
    }
    if (userProperties) {
      vector<boost::any> temp1;
      for(auto item1:*userProperties){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserProperties"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GenerateTime") != m.end() && !m["GenerateTime"].empty()) {
      generateTime = make_shared<long>(boost::any_cast<long>(m["GenerateTime"]));
    }
    if (m.find("MessageContent") != m.end() && !m["MessageContent"].empty()) {
      messageContent = make_shared<string>(boost::any_cast<string>(m["MessageContent"]));
    }
    if (m.find("TopicFullName") != m.end() && !m["TopicFullName"].empty()) {
      topicFullName = make_shared<string>(boost::any_cast<string>(m["TopicFullName"]));
    }
    if (m.find("UniMsgId") != m.end() && !m["UniMsgId"].empty()) {
      uniMsgId = make_shared<string>(boost::any_cast<string>(m["UniMsgId"]));
    }
    if (m.find("UserProperties") != m.end() && !m["UserProperties"].empty()) {
      if (typeid(vector<boost::any>) == m["UserProperties"].type()) {
        vector<QueryMessageInfoResponseBodyMessageUserProperties> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserProperties"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMessageInfoResponseBodyMessageUserProperties model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userProperties = make_shared<vector<QueryMessageInfoResponseBodyMessageUserProperties>>(expect1);
      }
    }
  }


  virtual ~QueryMessageInfoResponseBodyMessage() = default;
};
class QueryMessageInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryMessageInfoResponseBodyMessage> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryMessageInfoResponseBody() {}

  explicit QueryMessageInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (message) {
      res["Message"] = message ? boost::any(message->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      if (typeid(map<string, boost::any>) == m["Message"].type()) {
        QueryMessageInfoResponseBodyMessage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Message"]));
        message = make_shared<QueryMessageInfoResponseBodyMessage>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryMessageInfoResponseBody() = default;
};
class QueryMessageInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMessageInfoResponseBody> body{};

  QueryMessageInfoResponse() {}

  explicit QueryMessageInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMessageInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMessageInfoResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMessageInfoResponse() = default;
};
class QueryOTAFirmwareRequest : public Darabonba::Model {
public:
  shared_ptr<string> firmwareId{};
  shared_ptr<string> iotInstanceId{};

  QueryOTAFirmwareRequest() {}

  explicit QueryOTAFirmwareRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~QueryOTAFirmwareRequest() = default;
};
class QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles : public Darabonba::Model {
public:
  shared_ptr<string> fileMd5{};
  shared_ptr<string> name{};
  shared_ptr<string> signValue{};
  shared_ptr<long> size{};
  shared_ptr<string> url{};

  QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles() {}

  explicit QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileMd5) {
      res["FileMd5"] = boost::any(*fileMd5);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (signValue) {
      res["SignValue"] = boost::any(*signValue);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileMd5") != m.end() && !m["FileMd5"].empty()) {
      fileMd5 = make_shared<string>(boost::any_cast<string>(m["FileMd5"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SignValue") != m.end() && !m["SignValue"].empty()) {
      signValue = make_shared<string>(boost::any_cast<string>(m["SignValue"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles() = default;
};
class QueryOTAFirmwareResponseBodyFirmwareInfo : public Darabonba::Model {
public:
  shared_ptr<string> destVersion{};
  shared_ptr<string> firmwareDesc{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> firmwareName{};
  shared_ptr<string> firmwareSign{};
  shared_ptr<long> firmwareSize{};
  shared_ptr<string> firmwareUrl{};
  shared_ptr<string> moduleName{};
  shared_ptr<vector<QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles>> multiFiles{};
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};
  shared_ptr<string> signMethod{};
  shared_ptr<string> srcVersion{};
  shared_ptr<long> status{};
  shared_ptr<long> type{};
  shared_ptr<string> udi{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> utcModified{};
  shared_ptr<long> verifyProgress{};

  QueryOTAFirmwareResponseBodyFirmwareInfo() {}

  explicit QueryOTAFirmwareResponseBodyFirmwareInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destVersion) {
      res["DestVersion"] = boost::any(*destVersion);
    }
    if (firmwareDesc) {
      res["FirmwareDesc"] = boost::any(*firmwareDesc);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (firmwareName) {
      res["FirmwareName"] = boost::any(*firmwareName);
    }
    if (firmwareSign) {
      res["FirmwareSign"] = boost::any(*firmwareSign);
    }
    if (firmwareSize) {
      res["FirmwareSize"] = boost::any(*firmwareSize);
    }
    if (firmwareUrl) {
      res["FirmwareUrl"] = boost::any(*firmwareUrl);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    if (multiFiles) {
      vector<boost::any> temp1;
      for(auto item1:*multiFiles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MultiFiles"] = boost::any(temp1);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (signMethod) {
      res["SignMethod"] = boost::any(*signMethod);
    }
    if (srcVersion) {
      res["SrcVersion"] = boost::any(*srcVersion);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (udi) {
      res["Udi"] = boost::any(*udi);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (verifyProgress) {
      res["VerifyProgress"] = boost::any(*verifyProgress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestVersion") != m.end() && !m["DestVersion"].empty()) {
      destVersion = make_shared<string>(boost::any_cast<string>(m["DestVersion"]));
    }
    if (m.find("FirmwareDesc") != m.end() && !m["FirmwareDesc"].empty()) {
      firmwareDesc = make_shared<string>(boost::any_cast<string>(m["FirmwareDesc"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("FirmwareName") != m.end() && !m["FirmwareName"].empty()) {
      firmwareName = make_shared<string>(boost::any_cast<string>(m["FirmwareName"]));
    }
    if (m.find("FirmwareSign") != m.end() && !m["FirmwareSign"].empty()) {
      firmwareSign = make_shared<string>(boost::any_cast<string>(m["FirmwareSign"]));
    }
    if (m.find("FirmwareSize") != m.end() && !m["FirmwareSize"].empty()) {
      firmwareSize = make_shared<long>(boost::any_cast<long>(m["FirmwareSize"]));
    }
    if (m.find("FirmwareUrl") != m.end() && !m["FirmwareUrl"].empty()) {
      firmwareUrl = make_shared<string>(boost::any_cast<string>(m["FirmwareUrl"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
    if (m.find("MultiFiles") != m.end() && !m["MultiFiles"].empty()) {
      if (typeid(vector<boost::any>) == m["MultiFiles"].type()) {
        vector<QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MultiFiles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        multiFiles = make_shared<vector<QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles>>(expect1);
      }
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("SignMethod") != m.end() && !m["SignMethod"].empty()) {
      signMethod = make_shared<string>(boost::any_cast<string>(m["SignMethod"]));
    }
    if (m.find("SrcVersion") != m.end() && !m["SrcVersion"].empty()) {
      srcVersion = make_shared<string>(boost::any_cast<string>(m["SrcVersion"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Udi") != m.end() && !m["Udi"].empty()) {
      udi = make_shared<string>(boost::any_cast<string>(m["Udi"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("VerifyProgress") != m.end() && !m["VerifyProgress"].empty()) {
      verifyProgress = make_shared<long>(boost::any_cast<long>(m["VerifyProgress"]));
    }
  }


  virtual ~QueryOTAFirmwareResponseBodyFirmwareInfo() = default;
};
class QueryOTAFirmwareResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryOTAFirmwareResponseBodyFirmwareInfo> firmwareInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryOTAFirmwareResponseBody() {}

  explicit QueryOTAFirmwareResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (firmwareInfo) {
      res["FirmwareInfo"] = firmwareInfo ? boost::any(firmwareInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("FirmwareInfo") != m.end() && !m["FirmwareInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FirmwareInfo"].type()) {
        QueryOTAFirmwareResponseBodyFirmwareInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FirmwareInfo"]));
        firmwareInfo = make_shared<QueryOTAFirmwareResponseBodyFirmwareInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryOTAFirmwareResponseBody() = default;
};
class QueryOTAFirmwareResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryOTAFirmwareResponseBody> body{};

  QueryOTAFirmwareResponse() {}

  explicit QueryOTAFirmwareResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryOTAFirmwareResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryOTAFirmwareResponseBody>(model1);
      }
    }
  }


  virtual ~QueryOTAFirmwareResponse() = default;
};
class QueryOTAJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobId{};

  QueryOTAJobRequest() {}

  explicit QueryOTAJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~QueryOTAJobRequest() = default;
};
class QueryOTAJobResponseBodyDataSrcVersions : public Darabonba::Model {
public:
  shared_ptr<vector<string>> srcVersion{};

  QueryOTAJobResponseBodyDataSrcVersions() {}

  explicit QueryOTAJobResponseBodyDataSrcVersions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (srcVersion) {
      res["SrcVersion"] = boost::any(*srcVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SrcVersion") != m.end() && !m["SrcVersion"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SrcVersion"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SrcVersion"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      srcVersion = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryOTAJobResponseBodyDataSrcVersions() = default;
};
class QueryOTAJobResponseBodyDataTagsOtaTagDTO : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  QueryOTAJobResponseBodyDataTagsOtaTagDTO() {}

  explicit QueryOTAJobResponseBodyDataTagsOtaTagDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryOTAJobResponseBodyDataTagsOtaTagDTO() = default;
};
class QueryOTAJobResponseBodyDataTags : public Darabonba::Model {
public:
  shared_ptr<vector<QueryOTAJobResponseBodyDataTagsOtaTagDTO>> otaTagDTO{};

  QueryOTAJobResponseBodyDataTags() {}

  explicit QueryOTAJobResponseBodyDataTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (otaTagDTO) {
      vector<boost::any> temp1;
      for(auto item1:*otaTagDTO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OtaTagDTO"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OtaTagDTO") != m.end() && !m["OtaTagDTO"].empty()) {
      if (typeid(vector<boost::any>) == m["OtaTagDTO"].type()) {
        vector<QueryOTAJobResponseBodyDataTagsOtaTagDTO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OtaTagDTO"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOTAJobResponseBodyDataTagsOtaTagDTO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        otaTagDTO = make_shared<vector<QueryOTAJobResponseBodyDataTagsOtaTagDTO>>(expect1);
      }
    }
  }


  virtual ~QueryOTAJobResponseBodyDataTags() = default;
};
class QueryOTAJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> destVersion{};
  shared_ptr<string> downloadProtocol{};
  shared_ptr<long> dynamicMode{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> grayPercent{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> jobDesc{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobStatus{};
  shared_ptr<string> jobType{};
  shared_ptr<long> maximumPerMinute{};
  shared_ptr<bool> multiModuleMode{};
  shared_ptr<string> name{};
  shared_ptr<bool> needConfirm{};
  shared_ptr<bool> needPush{};
  shared_ptr<long> overwriteMode{};
  shared_ptr<string> productKey{};
  shared_ptr<long> retryCount{};
  shared_ptr<long> retryInterval{};
  shared_ptr<string> selectionType{};
  shared_ptr<QueryOTAJobResponseBodyDataSrcVersions> srcVersions{};
  shared_ptr<QueryOTAJobResponseBodyDataTags> tags{};
  shared_ptr<string> targetSelection{};
  shared_ptr<long> timeoutInMinutes{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> utcEndTime{};
  shared_ptr<string> utcModified{};
  shared_ptr<string> utcScheduleFinishTime{};
  shared_ptr<string> utcScheduleTime{};
  shared_ptr<string> utcStartTime{};

  QueryOTAJobResponseBodyData() {}

  explicit QueryOTAJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destVersion) {
      res["DestVersion"] = boost::any(*destVersion);
    }
    if (downloadProtocol) {
      res["DownloadProtocol"] = boost::any(*downloadProtocol);
    }
    if (dynamicMode) {
      res["DynamicMode"] = boost::any(*dynamicMode);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (grayPercent) {
      res["GrayPercent"] = boost::any(*grayPercent);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (jobDesc) {
      res["JobDesc"] = boost::any(*jobDesc);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobStatus) {
      res["JobStatus"] = boost::any(*jobStatus);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (maximumPerMinute) {
      res["MaximumPerMinute"] = boost::any(*maximumPerMinute);
    }
    if (multiModuleMode) {
      res["MultiModuleMode"] = boost::any(*multiModuleMode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (needConfirm) {
      res["NeedConfirm"] = boost::any(*needConfirm);
    }
    if (needPush) {
      res["NeedPush"] = boost::any(*needPush);
    }
    if (overwriteMode) {
      res["OverwriteMode"] = boost::any(*overwriteMode);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (retryInterval) {
      res["RetryInterval"] = boost::any(*retryInterval);
    }
    if (selectionType) {
      res["SelectionType"] = boost::any(*selectionType);
    }
    if (srcVersions) {
      res["SrcVersions"] = srcVersions ? boost::any(srcVersions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (targetSelection) {
      res["TargetSelection"] = boost::any(*targetSelection);
    }
    if (timeoutInMinutes) {
      res["TimeoutInMinutes"] = boost::any(*timeoutInMinutes);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (utcEndTime) {
      res["UtcEndTime"] = boost::any(*utcEndTime);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (utcScheduleFinishTime) {
      res["UtcScheduleFinishTime"] = boost::any(*utcScheduleFinishTime);
    }
    if (utcScheduleTime) {
      res["UtcScheduleTime"] = boost::any(*utcScheduleTime);
    }
    if (utcStartTime) {
      res["UtcStartTime"] = boost::any(*utcStartTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestVersion") != m.end() && !m["DestVersion"].empty()) {
      destVersion = make_shared<string>(boost::any_cast<string>(m["DestVersion"]));
    }
    if (m.find("DownloadProtocol") != m.end() && !m["DownloadProtocol"].empty()) {
      downloadProtocol = make_shared<string>(boost::any_cast<string>(m["DownloadProtocol"]));
    }
    if (m.find("DynamicMode") != m.end() && !m["DynamicMode"].empty()) {
      dynamicMode = make_shared<long>(boost::any_cast<long>(m["DynamicMode"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("GrayPercent") != m.end() && !m["GrayPercent"].empty()) {
      grayPercent = make_shared<string>(boost::any_cast<string>(m["GrayPercent"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("JobDesc") != m.end() && !m["JobDesc"].empty()) {
      jobDesc = make_shared<string>(boost::any_cast<string>(m["JobDesc"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobStatus") != m.end() && !m["JobStatus"].empty()) {
      jobStatus = make_shared<string>(boost::any_cast<string>(m["JobStatus"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("MaximumPerMinute") != m.end() && !m["MaximumPerMinute"].empty()) {
      maximumPerMinute = make_shared<long>(boost::any_cast<long>(m["MaximumPerMinute"]));
    }
    if (m.find("MultiModuleMode") != m.end() && !m["MultiModuleMode"].empty()) {
      multiModuleMode = make_shared<bool>(boost::any_cast<bool>(m["MultiModuleMode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NeedConfirm") != m.end() && !m["NeedConfirm"].empty()) {
      needConfirm = make_shared<bool>(boost::any_cast<bool>(m["NeedConfirm"]));
    }
    if (m.find("NeedPush") != m.end() && !m["NeedPush"].empty()) {
      needPush = make_shared<bool>(boost::any_cast<bool>(m["NeedPush"]));
    }
    if (m.find("OverwriteMode") != m.end() && !m["OverwriteMode"].empty()) {
      overwriteMode = make_shared<long>(boost::any_cast<long>(m["OverwriteMode"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<long>(boost::any_cast<long>(m["RetryCount"]));
    }
    if (m.find("RetryInterval") != m.end() && !m["RetryInterval"].empty()) {
      retryInterval = make_shared<long>(boost::any_cast<long>(m["RetryInterval"]));
    }
    if (m.find("SelectionType") != m.end() && !m["SelectionType"].empty()) {
      selectionType = make_shared<string>(boost::any_cast<string>(m["SelectionType"]));
    }
    if (m.find("SrcVersions") != m.end() && !m["SrcVersions"].empty()) {
      if (typeid(map<string, boost::any>) == m["SrcVersions"].type()) {
        QueryOTAJobResponseBodyDataSrcVersions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SrcVersions"]));
        srcVersions = make_shared<QueryOTAJobResponseBodyDataSrcVersions>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        QueryOTAJobResponseBodyDataTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<QueryOTAJobResponseBodyDataTags>(model1);
      }
    }
    if (m.find("TargetSelection") != m.end() && !m["TargetSelection"].empty()) {
      targetSelection = make_shared<string>(boost::any_cast<string>(m["TargetSelection"]));
    }
    if (m.find("TimeoutInMinutes") != m.end() && !m["TimeoutInMinutes"].empty()) {
      timeoutInMinutes = make_shared<long>(boost::any_cast<long>(m["TimeoutInMinutes"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("UtcEndTime") != m.end() && !m["UtcEndTime"].empty()) {
      utcEndTime = make_shared<string>(boost::any_cast<string>(m["UtcEndTime"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("UtcScheduleFinishTime") != m.end() && !m["UtcScheduleFinishTime"].empty()) {
      utcScheduleFinishTime = make_shared<string>(boost::any_cast<string>(m["UtcScheduleFinishTime"]));
    }
    if (m.find("UtcScheduleTime") != m.end() && !m["UtcScheduleTime"].empty()) {
      utcScheduleTime = make_shared<string>(boost::any_cast<string>(m["UtcScheduleTime"]));
    }
    if (m.find("UtcStartTime") != m.end() && !m["UtcStartTime"].empty()) {
      utcStartTime = make_shared<string>(boost::any_cast<string>(m["UtcStartTime"]));
    }
  }


  virtual ~QueryOTAJobResponseBodyData() = default;
};
class QueryOTAJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryOTAJobResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryOTAJobResponseBody() {}

  explicit QueryOTAJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryOTAJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryOTAJobResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryOTAJobResponseBody() = default;
};
class QueryOTAJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryOTAJobResponseBody> body{};

  QueryOTAJobResponse() {}

  explicit QueryOTAJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryOTAJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryOTAJobResponseBody>(model1);
      }
    }
  }


  virtual ~QueryOTAJobResponse() = default;
};
class QueryPageByApplyIdRequest : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};

  QueryPageByApplyIdRequest() {}

  explicit QueryPageByApplyIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["ApplyId"] = boost::any(*applyId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyId") != m.end() && !m["ApplyId"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["ApplyId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryPageByApplyIdRequest() = default;
};
class QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceSecret{};
  shared_ptr<string> iotId{};

  QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo() {}

  explicit QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceSecret) {
      res["DeviceSecret"] = boost::any(*deviceSecret);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceSecret") != m.end() && !m["DeviceSecret"].empty()) {
      deviceSecret = make_shared<string>(boost::any_cast<string>(m["DeviceSecret"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo() = default;
};
class QueryPageByApplyIdResponseBodyApplyDeviceList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo>> applyDeviceInfo{};

  QueryPageByApplyIdResponseBodyApplyDeviceList() {}

  explicit QueryPageByApplyIdResponseBodyApplyDeviceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyDeviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*applyDeviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApplyDeviceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyDeviceInfo") != m.end() && !m["ApplyDeviceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ApplyDeviceInfo"].type()) {
        vector<QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApplyDeviceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applyDeviceInfo = make_shared<vector<QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo>>(expect1);
      }
    }
  }


  virtual ~QueryPageByApplyIdResponseBodyApplyDeviceList() = default;
};
class QueryPageByApplyIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryPageByApplyIdResponseBodyApplyDeviceList> applyDeviceList{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> page{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  QueryPageByApplyIdResponseBody() {}

  explicit QueryPageByApplyIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyDeviceList) {
      res["ApplyDeviceList"] = applyDeviceList ? boost::any(applyDeviceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyDeviceList") != m.end() && !m["ApplyDeviceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApplyDeviceList"].type()) {
        QueryPageByApplyIdResponseBodyApplyDeviceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApplyDeviceList"]));
        applyDeviceList = make_shared<QueryPageByApplyIdResponseBodyApplyDeviceList>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryPageByApplyIdResponseBody() = default;
};
class QueryPageByApplyIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryPageByApplyIdResponseBody> body{};

  QueryPageByApplyIdResponse() {}

  explicit QueryPageByApplyIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryPageByApplyIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryPageByApplyIdResponseBody>(model1);
      }
    }
  }


  virtual ~QueryPageByApplyIdResponse() = default;
};
class QueryProductRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  QueryProductRequest() {}

  explicit QueryProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryProductRequest() = default;
};
class QueryProductResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> aliyunCommodityCode{};
  shared_ptr<string> authType{};
  shared_ptr<string> categoryKey{};
  shared_ptr<string> categoryName{};
  shared_ptr<long> dataFormat{};
  shared_ptr<string> description{};
  shared_ptr<long> deviceCount{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<bool> id2{};
  shared_ptr<long> netType{};
  shared_ptr<long> nodeType{};
  shared_ptr<bool> owner{};
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};
  shared_ptr<string> productSecret{};
  shared_ptr<string> productStatus{};
  shared_ptr<string> protocolType{};
  shared_ptr<long> validateType{};

  QueryProductResponseBodyData() {}

  explicit QueryProductResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunCommodityCode) {
      res["AliyunCommodityCode"] = boost::any(*aliyunCommodityCode);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (categoryKey) {
      res["CategoryKey"] = boost::any(*categoryKey);
    }
    if (categoryName) {
      res["CategoryName"] = boost::any(*categoryName);
    }
    if (dataFormat) {
      res["DataFormat"] = boost::any(*dataFormat);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (deviceCount) {
      res["DeviceCount"] = boost::any(*deviceCount);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (id2) {
      res["Id2"] = boost::any(*id2);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (productSecret) {
      res["ProductSecret"] = boost::any(*productSecret);
    }
    if (productStatus) {
      res["ProductStatus"] = boost::any(*productStatus);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (validateType) {
      res["ValidateType"] = boost::any(*validateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunCommodityCode") != m.end() && !m["AliyunCommodityCode"].empty()) {
      aliyunCommodityCode = make_shared<string>(boost::any_cast<string>(m["AliyunCommodityCode"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("CategoryKey") != m.end() && !m["CategoryKey"].empty()) {
      categoryKey = make_shared<string>(boost::any_cast<string>(m["CategoryKey"]));
    }
    if (m.find("CategoryName") != m.end() && !m["CategoryName"].empty()) {
      categoryName = make_shared<string>(boost::any_cast<string>(m["CategoryName"]));
    }
    if (m.find("DataFormat") != m.end() && !m["DataFormat"].empty()) {
      dataFormat = make_shared<long>(boost::any_cast<long>(m["DataFormat"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DeviceCount") != m.end() && !m["DeviceCount"].empty()) {
      deviceCount = make_shared<long>(boost::any_cast<long>(m["DeviceCount"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("Id2") != m.end() && !m["Id2"].empty()) {
      id2 = make_shared<bool>(boost::any_cast<bool>(m["Id2"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<long>(boost::any_cast<long>(m["NetType"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<long>(boost::any_cast<long>(m["NodeType"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<bool>(boost::any_cast<bool>(m["Owner"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("ProductSecret") != m.end() && !m["ProductSecret"].empty()) {
      productSecret = make_shared<string>(boost::any_cast<string>(m["ProductSecret"]));
    }
    if (m.find("ProductStatus") != m.end() && !m["ProductStatus"].empty()) {
      productStatus = make_shared<string>(boost::any_cast<string>(m["ProductStatus"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("ValidateType") != m.end() && !m["ValidateType"].empty()) {
      validateType = make_shared<long>(boost::any_cast<long>(m["ValidateType"]));
    }
  }


  virtual ~QueryProductResponseBodyData() = default;
};
class QueryProductResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryProductResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryProductResponseBody() {}

  explicit QueryProductResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryProductResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryProductResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryProductResponseBody() = default;
};
class QueryProductResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryProductResponseBody> body{};

  QueryProductResponse() {}

  explicit QueryProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryProductResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryProductResponseBody>(model1);
      }
    }
  }


  virtual ~QueryProductResponse() = default;
};
class QueryProductCertInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  QueryProductCertInfoRequest() {}

  explicit QueryProductCertInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryProductCertInfoRequest() = default;
};
class QueryProductCertInfoResponseBodyProductCertInfo : public Darabonba::Model {
public:
  shared_ptr<long> issueModel{};

  QueryProductCertInfoResponseBodyProductCertInfo() {}

  explicit QueryProductCertInfoResponseBodyProductCertInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (issueModel) {
      res["IssueModel"] = boost::any(*issueModel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IssueModel") != m.end() && !m["IssueModel"].empty()) {
      issueModel = make_shared<long>(boost::any_cast<long>(m["IssueModel"]));
    }
  }


  virtual ~QueryProductCertInfoResponseBodyProductCertInfo() = default;
};
class QueryProductCertInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryProductCertInfoResponseBodyProductCertInfo> productCertInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryProductCertInfoResponseBody() {}

  explicit QueryProductCertInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (productCertInfo) {
      res["ProductCertInfo"] = productCertInfo ? boost::any(productCertInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ProductCertInfo") != m.end() && !m["ProductCertInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProductCertInfo"].type()) {
        QueryProductCertInfoResponseBodyProductCertInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProductCertInfo"]));
        productCertInfo = make_shared<QueryProductCertInfoResponseBodyProductCertInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryProductCertInfoResponseBody() = default;
};
class QueryProductCertInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryProductCertInfoResponseBody> body{};

  QueryProductCertInfoResponse() {}

  explicit QueryProductCertInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryProductCertInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryProductCertInfoResponseBody>(model1);
      }
    }
  }


  virtual ~QueryProductCertInfoResponse() = default;
};
class QueryProductListRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunCommodityCode{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};

  QueryProductListRequest() {}

  explicit QueryProductListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunCommodityCode) {
      res["AliyunCommodityCode"] = boost::any(*aliyunCommodityCode);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunCommodityCode") != m.end() && !m["AliyunCommodityCode"].empty()) {
      aliyunCommodityCode = make_shared<string>(boost::any_cast<string>(m["AliyunCommodityCode"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~QueryProductListRequest() = default;
};
class QueryProductListResponseBodyDataListProductInfo : public Darabonba::Model {
public:
  shared_ptr<string> authType{};
  shared_ptr<long> dataFormat{};
  shared_ptr<string> description{};
  shared_ptr<long> deviceCount{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> nodeType{};
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};

  QueryProductListResponseBodyDataListProductInfo() {}

  explicit QueryProductListResponseBodyDataListProductInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (dataFormat) {
      res["DataFormat"] = boost::any(*dataFormat);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (deviceCount) {
      res["DeviceCount"] = boost::any(*deviceCount);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("DataFormat") != m.end() && !m["DataFormat"].empty()) {
      dataFormat = make_shared<long>(boost::any_cast<long>(m["DataFormat"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DeviceCount") != m.end() && !m["DeviceCount"].empty()) {
      deviceCount = make_shared<long>(boost::any_cast<long>(m["DeviceCount"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<long>(boost::any_cast<long>(m["NodeType"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
  }


  virtual ~QueryProductListResponseBodyDataListProductInfo() = default;
};
class QueryProductListResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryProductListResponseBodyDataListProductInfo>> productInfo{};

  QueryProductListResponseBodyDataList() {}

  explicit QueryProductListResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productInfo) {
      vector<boost::any> temp1;
      for(auto item1:*productInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProductInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductInfo") != m.end() && !m["ProductInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ProductInfo"].type()) {
        vector<QueryProductListResponseBodyDataListProductInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProductInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryProductListResponseBodyDataListProductInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        productInfo = make_shared<vector<QueryProductListResponseBodyDataListProductInfo>>(expect1);
      }
    }
  }


  virtual ~QueryProductListResponseBodyDataList() = default;
};
class QueryProductListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<QueryProductListResponseBodyDataList> list{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QueryProductListResponseBodyData() {}

  explicit QueryProductListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryProductListResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryProductListResponseBodyDataList>(model1);
      }
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryProductListResponseBodyData() = default;
};
class QueryProductListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryProductListResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryProductListResponseBody() {}

  explicit QueryProductListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryProductListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryProductListResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryProductListResponseBody() = default;
};
class QueryProductListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryProductListResponseBody> body{};

  QueryProductListResponse() {}

  explicit QueryProductListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryProductListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryProductListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryProductListResponse() = default;
};
class QueryProductTopicRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  QueryProductTopicRequest() {}

  explicit QueryProductTopicRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryProductTopicRequest() = default;
};
class QueryProductTopicResponseBodyDataProductTopicInfo : public Darabonba::Model {
public:
  shared_ptr<string> codec{};
  shared_ptr<string> desc{};
  shared_ptr<bool> enableProxySubscribe{};
  shared_ptr<string> id{};
  shared_ptr<string> operation{};
  shared_ptr<string> productKey{};
  shared_ptr<string> topicShortName{};

  QueryProductTopicResponseBodyDataProductTopicInfo() {}

  explicit QueryProductTopicResponseBodyDataProductTopicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (enableProxySubscribe) {
      res["EnableProxySubscribe"] = boost::any(*enableProxySubscribe);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (topicShortName) {
      res["TopicShortName"] = boost::any(*topicShortName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("EnableProxySubscribe") != m.end() && !m["EnableProxySubscribe"].empty()) {
      enableProxySubscribe = make_shared<bool>(boost::any_cast<bool>(m["EnableProxySubscribe"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("TopicShortName") != m.end() && !m["TopicShortName"].empty()) {
      topicShortName = make_shared<string>(boost::any_cast<string>(m["TopicShortName"]));
    }
  }


  virtual ~QueryProductTopicResponseBodyDataProductTopicInfo() = default;
};
class QueryProductTopicResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryProductTopicResponseBodyDataProductTopicInfo>> productTopicInfo{};

  QueryProductTopicResponseBodyData() {}

  explicit QueryProductTopicResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productTopicInfo) {
      vector<boost::any> temp1;
      for(auto item1:*productTopicInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProductTopicInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductTopicInfo") != m.end() && !m["ProductTopicInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ProductTopicInfo"].type()) {
        vector<QueryProductTopicResponseBodyDataProductTopicInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProductTopicInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryProductTopicResponseBodyDataProductTopicInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        productTopicInfo = make_shared<vector<QueryProductTopicResponseBodyDataProductTopicInfo>>(expect1);
      }
    }
  }


  virtual ~QueryProductTopicResponseBodyData() = default;
};
class QueryProductTopicResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryProductTopicResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryProductTopicResponseBody() {}

  explicit QueryProductTopicResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryProductTopicResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryProductTopicResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryProductTopicResponseBody() = default;
};
class QueryProductTopicResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryProductTopicResponseBody> body{};

  QueryProductTopicResponse() {}

  explicit QueryProductTopicResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryProductTopicResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryProductTopicResponseBody>(model1);
      }
    }
  }


  virtual ~QueryProductTopicResponse() = default;
};
class QueryProjectShareDeviceListRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};

  QueryProjectShareDeviceListRequest() {}

  explicit QueryProjectShareDeviceListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryProjectShareDeviceListRequest() = default;
};
class QueryProjectShareDeviceListResponseBodyDataDeviceListItems : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> productKey{};
  shared_ptr<long> sharable{};

  QueryProjectShareDeviceListResponseBodyDataDeviceListItems() {}

  explicit QueryProjectShareDeviceListResponseBodyDataDeviceListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (sharable) {
      res["Sharable"] = boost::any(*sharable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Sharable") != m.end() && !m["Sharable"].empty()) {
      sharable = make_shared<long>(boost::any_cast<long>(m["Sharable"]));
    }
  }


  virtual ~QueryProjectShareDeviceListResponseBodyDataDeviceListItems() = default;
};
class QueryProjectShareDeviceListResponseBodyDataDeviceList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryProjectShareDeviceListResponseBodyDataDeviceListItems>> items{};

  QueryProjectShareDeviceListResponseBodyDataDeviceList() {}

  explicit QueryProjectShareDeviceListResponseBodyDataDeviceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<QueryProjectShareDeviceListResponseBodyDataDeviceListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryProjectShareDeviceListResponseBodyDataDeviceListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<QueryProjectShareDeviceListResponseBodyDataDeviceListItems>>(expect1);
      }
    }
  }


  virtual ~QueryProjectShareDeviceListResponseBodyDataDeviceList() = default;
};
class QueryProjectShareDeviceListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QueryProjectShareDeviceListResponseBodyDataDeviceList> deviceList{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QueryProjectShareDeviceListResponseBodyData() {}

  explicit QueryProjectShareDeviceListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceList) {
      res["DeviceList"] = deviceList ? boost::any(deviceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceList") != m.end() && !m["DeviceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeviceList"].type()) {
        QueryProjectShareDeviceListResponseBodyDataDeviceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeviceList"]));
        deviceList = make_shared<QueryProjectShareDeviceListResponseBodyDataDeviceList>(model1);
      }
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryProjectShareDeviceListResponseBodyData() = default;
};
class QueryProjectShareDeviceListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryProjectShareDeviceListResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryProjectShareDeviceListResponseBody() {}

  explicit QueryProjectShareDeviceListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryProjectShareDeviceListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryProjectShareDeviceListResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryProjectShareDeviceListResponseBody() = default;
};
class QueryProjectShareDeviceListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryProjectShareDeviceListResponseBody> body{};

  QueryProjectShareDeviceListResponse() {}

  explicit QueryProjectShareDeviceListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryProjectShareDeviceListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryProjectShareDeviceListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryProjectShareDeviceListResponse() = default;
};
class QuerySceneRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> ruleName{};

  QuerySceneRuleRequest() {}

  explicit QuerySceneRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~QuerySceneRuleRequest() = default;
};
class QuerySceneRuleResponseBodyDataRuleList : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> ruleDescription{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> ruleStatus{};

  QuerySceneRuleResponseBodyDataRuleList() {}

  explicit QuerySceneRuleResponseBodyDataRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (ruleDescription) {
      res["RuleDescription"] = boost::any(*ruleDescription);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleStatus) {
      res["RuleStatus"] = boost::any(*ruleStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("RuleDescription") != m.end() && !m["RuleDescription"].empty()) {
      ruleDescription = make_shared<string>(boost::any_cast<string>(m["RuleDescription"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleStatus") != m.end() && !m["RuleStatus"].empty()) {
      ruleStatus = make_shared<long>(boost::any_cast<long>(m["RuleStatus"]));
    }
  }


  virtual ~QuerySceneRuleResponseBodyDataRuleList() = default;
};
class QuerySceneRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<QuerySceneRuleResponseBodyDataRuleList>> ruleList{};
  shared_ptr<long> total{};

  QuerySceneRuleResponseBodyData() {}

  explicit QuerySceneRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ruleList) {
      vector<boost::any> temp1;
      for(auto item1:*ruleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleList"] = boost::any(temp1);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RuleList") != m.end() && !m["RuleList"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleList"].type()) {
        vector<QuerySceneRuleResponseBodyDataRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySceneRuleResponseBodyDataRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleList = make_shared<vector<QuerySceneRuleResponseBodyDataRuleList>>(expect1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QuerySceneRuleResponseBodyData() = default;
};
class QuerySceneRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QuerySceneRuleResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QuerySceneRuleResponseBody() {}

  explicit QuerySceneRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QuerySceneRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QuerySceneRuleResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QuerySceneRuleResponseBody() = default;
};
class QuerySceneRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySceneRuleResponseBody> body{};

  QuerySceneRuleResponse() {}

  explicit QuerySceneRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySceneRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySceneRuleResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySceneRuleResponse() = default;
};
class QuerySchedulePeriodListRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> scheduleCode{};

  QuerySchedulePeriodListRequest() {}

  explicit QuerySchedulePeriodListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (scheduleCode) {
      res["ScheduleCode"] = boost::any(*scheduleCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ScheduleCode") != m.end() && !m["ScheduleCode"].empty()) {
      scheduleCode = make_shared<string>(boost::any_cast<string>(m["ScheduleCode"]));
    }
  }


  virtual ~QuerySchedulePeriodListRequest() = default;
};
class QuerySchedulePeriodListResponseBodyDataListItems : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> endTime{};
  shared_ptr<string> periodCode{};
  shared_ptr<string> soundCodeContent{};
  shared_ptr<string> startTime{};

  QuerySchedulePeriodListResponseBodyDataListItems() {}

  explicit QuerySchedulePeriodListResponseBodyDataListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (periodCode) {
      res["PeriodCode"] = boost::any(*periodCode);
    }
    if (soundCodeContent) {
      res["SoundCodeContent"] = boost::any(*soundCodeContent);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PeriodCode") != m.end() && !m["PeriodCode"].empty()) {
      periodCode = make_shared<string>(boost::any_cast<string>(m["PeriodCode"]));
    }
    if (m.find("SoundCodeContent") != m.end() && !m["SoundCodeContent"].empty()) {
      soundCodeContent = make_shared<string>(boost::any_cast<string>(m["SoundCodeContent"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~QuerySchedulePeriodListResponseBodyDataListItems() = default;
};
class QuerySchedulePeriodListResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySchedulePeriodListResponseBodyDataListItems>> items{};

  QuerySchedulePeriodListResponseBodyDataList() {}

  explicit QuerySchedulePeriodListResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<QuerySchedulePeriodListResponseBodyDataListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySchedulePeriodListResponseBodyDataListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<QuerySchedulePeriodListResponseBodyDataListItems>>(expect1);
      }
    }
  }


  virtual ~QuerySchedulePeriodListResponseBodyDataList() = default;
};
class QuerySchedulePeriodListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QuerySchedulePeriodListResponseBodyDataList> list{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QuerySchedulePeriodListResponseBodyData() {}

  explicit QuerySchedulePeriodListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QuerySchedulePeriodListResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QuerySchedulePeriodListResponseBodyDataList>(model1);
      }
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QuerySchedulePeriodListResponseBodyData() = default;
};
class QuerySchedulePeriodListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QuerySchedulePeriodListResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QuerySchedulePeriodListResponseBody() {}

  explicit QuerySchedulePeriodListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QuerySchedulePeriodListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QuerySchedulePeriodListResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QuerySchedulePeriodListResponseBody() = default;
};
class QuerySchedulePeriodListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySchedulePeriodListResponseBody> body{};

  QuerySchedulePeriodListResponse() {}

  explicit QuerySchedulePeriodListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySchedulePeriodListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySchedulePeriodListResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySchedulePeriodListResponse() = default;
};
class QuerySharePromotionActivityAuditResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> sharePromotionActivityId{};
  shared_ptr<string> shareTaskCode{};

  QuerySharePromotionActivityAuditResultRequest() {}

  explicit QuerySharePromotionActivityAuditResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (sharePromotionActivityId) {
      res["SharePromotionActivityId"] = boost::any(*sharePromotionActivityId);
    }
    if (shareTaskCode) {
      res["ShareTaskCode"] = boost::any(*shareTaskCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("SharePromotionActivityId") != m.end() && !m["SharePromotionActivityId"].empty()) {
      sharePromotionActivityId = make_shared<string>(boost::any_cast<string>(m["SharePromotionActivityId"]));
    }
    if (m.find("ShareTaskCode") != m.end() && !m["ShareTaskCode"].empty()) {
      shareTaskCode = make_shared<string>(boost::any_cast<string>(m["ShareTaskCode"]));
    }
  }


  virtual ~QuerySharePromotionActivityAuditResultRequest() = default;
};
class QuerySharePromotionActivityAuditResultResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> auditResult{};

  QuerySharePromotionActivityAuditResultResponseBodyData() {}

  explicit QuerySharePromotionActivityAuditResultResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditResult) {
      res["AuditResult"] = boost::any(*auditResult);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditResult") != m.end() && !m["AuditResult"].empty()) {
      auditResult = make_shared<long>(boost::any_cast<long>(m["AuditResult"]));
    }
  }


  virtual ~QuerySharePromotionActivityAuditResultResponseBodyData() = default;
};
class QuerySharePromotionActivityAuditResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QuerySharePromotionActivityAuditResultResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QuerySharePromotionActivityAuditResultResponseBody() {}

  explicit QuerySharePromotionActivityAuditResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QuerySharePromotionActivityAuditResultResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QuerySharePromotionActivityAuditResultResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QuerySharePromotionActivityAuditResultResponseBody() = default;
};
class QuerySharePromotionActivityAuditResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySharePromotionActivityAuditResultResponseBody> body{};

  QuerySharePromotionActivityAuditResultResponse() {}

  explicit QuerySharePromotionActivityAuditResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySharePromotionActivityAuditResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySharePromotionActivityAuditResultResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySharePromotionActivityAuditResultResponse() = default;
};
class QueryShareTaskDeviceListRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> shareTaskId{};

  QueryShareTaskDeviceListRequest() {}

  explicit QueryShareTaskDeviceListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (shareTaskId) {
      res["ShareTaskId"] = boost::any(*shareTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ShareTaskId") != m.end() && !m["ShareTaskId"].empty()) {
      shareTaskId = make_shared<string>(boost::any_cast<string>(m["ShareTaskId"]));
    }
  }


  virtual ~QueryShareTaskDeviceListRequest() = default;
};
class QueryShareTaskDeviceListResponseBodyDataDeviceListItems : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<long> gmtAdded{};
  shared_ptr<string> iotId{};
  shared_ptr<string> productKey{};

  QueryShareTaskDeviceListResponseBodyDataDeviceListItems() {}

  explicit QueryShareTaskDeviceListResponseBodyDataDeviceListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (gmtAdded) {
      res["GmtAdded"] = boost::any(*gmtAdded);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("GmtAdded") != m.end() && !m["GmtAdded"].empty()) {
      gmtAdded = make_shared<long>(boost::any_cast<long>(m["GmtAdded"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryShareTaskDeviceListResponseBodyDataDeviceListItems() = default;
};
class QueryShareTaskDeviceListResponseBodyDataDeviceList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryShareTaskDeviceListResponseBodyDataDeviceListItems>> items{};

  QueryShareTaskDeviceListResponseBodyDataDeviceList() {}

  explicit QueryShareTaskDeviceListResponseBodyDataDeviceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<QueryShareTaskDeviceListResponseBodyDataDeviceListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryShareTaskDeviceListResponseBodyDataDeviceListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<QueryShareTaskDeviceListResponseBodyDataDeviceListItems>>(expect1);
      }
    }
  }


  virtual ~QueryShareTaskDeviceListResponseBodyDataDeviceList() = default;
};
class QueryShareTaskDeviceListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QueryShareTaskDeviceListResponseBodyDataDeviceList> deviceList{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QueryShareTaskDeviceListResponseBodyData() {}

  explicit QueryShareTaskDeviceListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceList) {
      res["DeviceList"] = deviceList ? boost::any(deviceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceList") != m.end() && !m["DeviceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeviceList"].type()) {
        QueryShareTaskDeviceListResponseBodyDataDeviceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeviceList"]));
        deviceList = make_shared<QueryShareTaskDeviceListResponseBodyDataDeviceList>(model1);
      }
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryShareTaskDeviceListResponseBodyData() = default;
};
class QueryShareTaskDeviceListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryShareTaskDeviceListResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryShareTaskDeviceListResponseBody() {}

  explicit QueryShareTaskDeviceListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryShareTaskDeviceListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryShareTaskDeviceListResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryShareTaskDeviceListResponseBody() = default;
};
class QueryShareTaskDeviceListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryShareTaskDeviceListResponseBody> body{};

  QueryShareTaskDeviceListResponse() {}

  explicit QueryShareTaskDeviceListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryShareTaskDeviceListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryShareTaskDeviceListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryShareTaskDeviceListResponse() = default;
};
class QuerySolutionDeviceGroupPageRequest : public Darabonba::Model {
public:
  shared_ptr<string> fuzzyGroupName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectCode{};

  QuerySolutionDeviceGroupPageRequest() {}

  explicit QuerySolutionDeviceGroupPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fuzzyGroupName) {
      res["FuzzyGroupName"] = boost::any(*fuzzyGroupName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectCode) {
      res["ProjectCode"] = boost::any(*projectCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FuzzyGroupName") != m.end() && !m["FuzzyGroupName"].empty()) {
      fuzzyGroupName = make_shared<string>(boost::any_cast<string>(m["FuzzyGroupName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectCode") != m.end() && !m["ProjectCode"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["ProjectCode"]));
    }
  }


  virtual ~QuerySolutionDeviceGroupPageRequest() = default;
};
class QuerySolutionDeviceGroupPageResponseBodyDataListItemName : public Darabonba::Model {
public:
  shared_ptr<long> deviceCount{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> groupDesc{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};

  QuerySolutionDeviceGroupPageResponseBodyDataListItemName() {}

  explicit QuerySolutionDeviceGroupPageResponseBodyDataListItemName(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceCount) {
      res["DeviceCount"] = boost::any(*deviceCount);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (groupDesc) {
      res["GroupDesc"] = boost::any(*groupDesc);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceCount") != m.end() && !m["DeviceCount"].empty()) {
      deviceCount = make_shared<long>(boost::any_cast<long>(m["DeviceCount"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("GroupDesc") != m.end() && !m["GroupDesc"].empty()) {
      groupDesc = make_shared<string>(boost::any_cast<string>(m["GroupDesc"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~QuerySolutionDeviceGroupPageResponseBodyDataListItemName() = default;
};
class QuerySolutionDeviceGroupPageResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySolutionDeviceGroupPageResponseBodyDataListItemName>> itemName{};

  QuerySolutionDeviceGroupPageResponseBodyDataList() {}

  explicit QuerySolutionDeviceGroupPageResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemName) {
      vector<boost::any> temp1;
      for(auto item1:*itemName){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["itemName"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("itemName") != m.end() && !m["itemName"].empty()) {
      if (typeid(vector<boost::any>) == m["itemName"].type()) {
        vector<QuerySolutionDeviceGroupPageResponseBodyDataListItemName> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["itemName"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySolutionDeviceGroupPageResponseBodyDataListItemName model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itemName = make_shared<vector<QuerySolutionDeviceGroupPageResponseBodyDataListItemName>>(expect1);
      }
    }
  }


  virtual ~QuerySolutionDeviceGroupPageResponseBodyDataList() = default;
};
class QuerySolutionDeviceGroupPageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QuerySolutionDeviceGroupPageResponseBodyDataList> list{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QuerySolutionDeviceGroupPageResponseBodyData() {}

  explicit QuerySolutionDeviceGroupPageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QuerySolutionDeviceGroupPageResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QuerySolutionDeviceGroupPageResponseBodyDataList>(model1);
      }
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QuerySolutionDeviceGroupPageResponseBodyData() = default;
};
class QuerySolutionDeviceGroupPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QuerySolutionDeviceGroupPageResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QuerySolutionDeviceGroupPageResponseBody() {}

  explicit QuerySolutionDeviceGroupPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QuerySolutionDeviceGroupPageResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QuerySolutionDeviceGroupPageResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QuerySolutionDeviceGroupPageResponseBody() = default;
};
class QuerySolutionDeviceGroupPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySolutionDeviceGroupPageResponseBody> body{};

  QuerySolutionDeviceGroupPageResponse() {}

  explicit QuerySolutionDeviceGroupPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySolutionDeviceGroupPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySolutionDeviceGroupPageResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySolutionDeviceGroupPageResponse() = default;
};
class QuerySoundCodeLabelBatchFailedResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> batchCode{};
  shared_ptr<string> iotInstanceId{};

  QuerySoundCodeLabelBatchFailedResultRequest() {}

  explicit QuerySoundCodeLabelBatchFailedResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchCode) {
      res["BatchCode"] = boost::any(*batchCode);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchCode") != m.end() && !m["BatchCode"].empty()) {
      batchCode = make_shared<string>(boost::any_cast<string>(m["BatchCode"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~QuerySoundCodeLabelBatchFailedResultRequest() = default;
};
class QuerySoundCodeLabelBatchFailedResultResponseBodyDataItems : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> label{};
  shared_ptr<string> resultCode{};

  QuerySoundCodeLabelBatchFailedResultResponseBodyDataItems() {}

  explicit QuerySoundCodeLabelBatchFailedResultResponseBodyDataItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
  }


  virtual ~QuerySoundCodeLabelBatchFailedResultResponseBodyDataItems() = default;
};
class QuerySoundCodeLabelBatchFailedResultResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySoundCodeLabelBatchFailedResultResponseBodyDataItems>> items{};

  QuerySoundCodeLabelBatchFailedResultResponseBodyData() {}

  explicit QuerySoundCodeLabelBatchFailedResultResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<QuerySoundCodeLabelBatchFailedResultResponseBodyDataItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySoundCodeLabelBatchFailedResultResponseBodyDataItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<QuerySoundCodeLabelBatchFailedResultResponseBodyDataItems>>(expect1);
      }
    }
  }


  virtual ~QuerySoundCodeLabelBatchFailedResultResponseBodyData() = default;
};
class QuerySoundCodeLabelBatchFailedResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QuerySoundCodeLabelBatchFailedResultResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QuerySoundCodeLabelBatchFailedResultResponseBody() {}

  explicit QuerySoundCodeLabelBatchFailedResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QuerySoundCodeLabelBatchFailedResultResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QuerySoundCodeLabelBatchFailedResultResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QuerySoundCodeLabelBatchFailedResultResponseBody() = default;
};
class QuerySoundCodeLabelBatchFailedResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySoundCodeLabelBatchFailedResultResponseBody> body{};

  QuerySoundCodeLabelBatchFailedResultResponse() {}

  explicit QuerySoundCodeLabelBatchFailedResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySoundCodeLabelBatchFailedResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySoundCodeLabelBatchFailedResultResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySoundCodeLabelBatchFailedResultResponse() = default;
};
class QuerySoundCodeLabelBatchListRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> scheduleCode{};

  QuerySoundCodeLabelBatchListRequest() {}

  explicit QuerySoundCodeLabelBatchListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (scheduleCode) {
      res["ScheduleCode"] = boost::any(*scheduleCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ScheduleCode") != m.end() && !m["ScheduleCode"].empty()) {
      scheduleCode = make_shared<string>(boost::any_cast<string>(m["ScheduleCode"]));
    }
  }


  virtual ~QuerySoundCodeLabelBatchListRequest() = default;
};
class QuerySoundCodeLabelBatchListResponseBodyDataListItems : public Darabonba::Model {
public:
  shared_ptr<string> batchCode{};
  shared_ptr<string> description{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> status{};
  shared_ptr<long> successNum{};
  shared_ptr<long> total{};

  QuerySoundCodeLabelBatchListResponseBodyDataListItems() {}

  explicit QuerySoundCodeLabelBatchListResponseBodyDataListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchCode) {
      res["BatchCode"] = boost::any(*batchCode);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (successNum) {
      res["SuccessNum"] = boost::any(*successNum);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchCode") != m.end() && !m["BatchCode"].empty()) {
      batchCode = make_shared<string>(boost::any_cast<string>(m["BatchCode"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SuccessNum") != m.end() && !m["SuccessNum"].empty()) {
      successNum = make_shared<long>(boost::any_cast<long>(m["SuccessNum"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QuerySoundCodeLabelBatchListResponseBodyDataListItems() = default;
};
class QuerySoundCodeLabelBatchListResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySoundCodeLabelBatchListResponseBodyDataListItems>> items{};

  QuerySoundCodeLabelBatchListResponseBodyDataList() {}

  explicit QuerySoundCodeLabelBatchListResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<QuerySoundCodeLabelBatchListResponseBodyDataListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySoundCodeLabelBatchListResponseBodyDataListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<QuerySoundCodeLabelBatchListResponseBodyDataListItems>>(expect1);
      }
    }
  }


  virtual ~QuerySoundCodeLabelBatchListResponseBodyDataList() = default;
};
class QuerySoundCodeLabelBatchListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QuerySoundCodeLabelBatchListResponseBodyDataList> list{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QuerySoundCodeLabelBatchListResponseBodyData() {}

  explicit QuerySoundCodeLabelBatchListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QuerySoundCodeLabelBatchListResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QuerySoundCodeLabelBatchListResponseBodyDataList>(model1);
      }
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QuerySoundCodeLabelBatchListResponseBodyData() = default;
};
class QuerySoundCodeLabelBatchListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QuerySoundCodeLabelBatchListResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QuerySoundCodeLabelBatchListResponseBody() {}

  explicit QuerySoundCodeLabelBatchListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QuerySoundCodeLabelBatchListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QuerySoundCodeLabelBatchListResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QuerySoundCodeLabelBatchListResponseBody() = default;
};
class QuerySoundCodeLabelBatchListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySoundCodeLabelBatchListResponseBody> body{};

  QuerySoundCodeLabelBatchListResponse() {}

  explicit QuerySoundCodeLabelBatchListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySoundCodeLabelBatchListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySoundCodeLabelBatchListResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySoundCodeLabelBatchListResponse() = default;
};
class QuerySoundCodeLabelListRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> scheduleCode{};

  QuerySoundCodeLabelListRequest() {}

  explicit QuerySoundCodeLabelListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (scheduleCode) {
      res["ScheduleCode"] = boost::any(*scheduleCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ScheduleCode") != m.end() && !m["ScheduleCode"].empty()) {
      scheduleCode = make_shared<string>(boost::any_cast<string>(m["ScheduleCode"]));
    }
  }


  virtual ~QuerySoundCodeLabelListRequest() = default;
};
class QuerySoundCodeLabelListResponseBodyDataListItems : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> soundCode{};

  QuerySoundCodeLabelListResponseBodyDataListItems() {}

  explicit QuerySoundCodeLabelListResponseBodyDataListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (soundCode) {
      res["SoundCode"] = boost::any(*soundCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("SoundCode") != m.end() && !m["SoundCode"].empty()) {
      soundCode = make_shared<string>(boost::any_cast<string>(m["SoundCode"]));
    }
  }


  virtual ~QuerySoundCodeLabelListResponseBodyDataListItems() = default;
};
class QuerySoundCodeLabelListResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySoundCodeLabelListResponseBodyDataListItems>> items{};

  QuerySoundCodeLabelListResponseBodyDataList() {}

  explicit QuerySoundCodeLabelListResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<QuerySoundCodeLabelListResponseBodyDataListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySoundCodeLabelListResponseBodyDataListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<QuerySoundCodeLabelListResponseBodyDataListItems>>(expect1);
      }
    }
  }


  virtual ~QuerySoundCodeLabelListResponseBodyDataList() = default;
};
class QuerySoundCodeLabelListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QuerySoundCodeLabelListResponseBodyDataList> list{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QuerySoundCodeLabelListResponseBodyData() {}

  explicit QuerySoundCodeLabelListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QuerySoundCodeLabelListResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QuerySoundCodeLabelListResponseBodyDataList>(model1);
      }
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QuerySoundCodeLabelListResponseBodyData() = default;
};
class QuerySoundCodeLabelListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QuerySoundCodeLabelListResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QuerySoundCodeLabelListResponseBody() {}

  explicit QuerySoundCodeLabelListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QuerySoundCodeLabelListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QuerySoundCodeLabelListResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QuerySoundCodeLabelListResponseBody() = default;
};
class QuerySoundCodeLabelListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySoundCodeLabelListResponseBody> body{};

  QuerySoundCodeLabelListResponse() {}

  explicit QuerySoundCodeLabelListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySoundCodeLabelListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySoundCodeLabelListResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySoundCodeLabelListResponse() = default;
};
class QuerySoundCodeListRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};

  QuerySoundCodeListRequest() {}

  explicit QuerySoundCodeListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QuerySoundCodeListRequest() = default;
};
class QuerySoundCodeListResponseBodyDataListItems : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> name{};
  shared_ptr<string> openType{};
  shared_ptr<string> soundCode{};
  shared_ptr<string> soundCodeContent{};

  QuerySoundCodeListResponseBodyDataListItems() {}

  explicit QuerySoundCodeListResponseBodyDataListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (openType) {
      res["OpenType"] = boost::any(*openType);
    }
    if (soundCode) {
      res["SoundCode"] = boost::any(*soundCode);
    }
    if (soundCodeContent) {
      res["SoundCodeContent"] = boost::any(*soundCodeContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OpenType") != m.end() && !m["OpenType"].empty()) {
      openType = make_shared<string>(boost::any_cast<string>(m["OpenType"]));
    }
    if (m.find("SoundCode") != m.end() && !m["SoundCode"].empty()) {
      soundCode = make_shared<string>(boost::any_cast<string>(m["SoundCode"]));
    }
    if (m.find("SoundCodeContent") != m.end() && !m["SoundCodeContent"].empty()) {
      soundCodeContent = make_shared<string>(boost::any_cast<string>(m["SoundCodeContent"]));
    }
  }


  virtual ~QuerySoundCodeListResponseBodyDataListItems() = default;
};
class QuerySoundCodeListResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySoundCodeListResponseBodyDataListItems>> items{};

  QuerySoundCodeListResponseBodyDataList() {}

  explicit QuerySoundCodeListResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<QuerySoundCodeListResponseBodyDataListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySoundCodeListResponseBodyDataListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<QuerySoundCodeListResponseBodyDataListItems>>(expect1);
      }
    }
  }


  virtual ~QuerySoundCodeListResponseBodyDataList() = default;
};
class QuerySoundCodeListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QuerySoundCodeListResponseBodyDataList> list{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QuerySoundCodeListResponseBodyData() {}

  explicit QuerySoundCodeListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QuerySoundCodeListResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QuerySoundCodeListResponseBodyDataList>(model1);
      }
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QuerySoundCodeListResponseBodyData() = default;
};
class QuerySoundCodeListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QuerySoundCodeListResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QuerySoundCodeListResponseBody() {}

  explicit QuerySoundCodeListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QuerySoundCodeListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QuerySoundCodeListResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QuerySoundCodeListResponseBody() = default;
};
class QuerySoundCodeListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySoundCodeListResponseBody> body{};

  QuerySoundCodeListResponse() {}

  explicit QuerySoundCodeListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySoundCodeListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySoundCodeListResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySoundCodeListResponse() = default;
};
class QuerySoundCodeScheduleListRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};

  QuerySoundCodeScheduleListRequest() {}

  explicit QuerySoundCodeScheduleListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QuerySoundCodeScheduleListRequest() = default;
};
class QuerySoundCodeScheduleListResponseBodyDataListItems : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> endDate{};
  shared_ptr<string> endTime{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> name{};
  shared_ptr<string> openType{};
  shared_ptr<string> scheduleCode{};
  shared_ptr<string> startDate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  QuerySoundCodeScheduleListResponseBodyDataListItems() {}

  explicit QuerySoundCodeScheduleListResponseBodyDataListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (openType) {
      res["OpenType"] = boost::any(*openType);
    }
    if (scheduleCode) {
      res["ScheduleCode"] = boost::any(*scheduleCode);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OpenType") != m.end() && !m["OpenType"].empty()) {
      openType = make_shared<string>(boost::any_cast<string>(m["OpenType"]));
    }
    if (m.find("ScheduleCode") != m.end() && !m["ScheduleCode"].empty()) {
      scheduleCode = make_shared<string>(boost::any_cast<string>(m["ScheduleCode"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~QuerySoundCodeScheduleListResponseBodyDataListItems() = default;
};
class QuerySoundCodeScheduleListResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySoundCodeScheduleListResponseBodyDataListItems>> items{};

  QuerySoundCodeScheduleListResponseBodyDataList() {}

  explicit QuerySoundCodeScheduleListResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<QuerySoundCodeScheduleListResponseBodyDataListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySoundCodeScheduleListResponseBodyDataListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<QuerySoundCodeScheduleListResponseBodyDataListItems>>(expect1);
      }
    }
  }


  virtual ~QuerySoundCodeScheduleListResponseBodyDataList() = default;
};
class QuerySoundCodeScheduleListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QuerySoundCodeScheduleListResponseBodyDataList> list{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QuerySoundCodeScheduleListResponseBodyData() {}

  explicit QuerySoundCodeScheduleListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QuerySoundCodeScheduleListResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QuerySoundCodeScheduleListResponseBodyDataList>(model1);
      }
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QuerySoundCodeScheduleListResponseBodyData() = default;
};
class QuerySoundCodeScheduleListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QuerySoundCodeScheduleListResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QuerySoundCodeScheduleListResponseBody() {}

  explicit QuerySoundCodeScheduleListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QuerySoundCodeScheduleListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QuerySoundCodeScheduleListResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QuerySoundCodeScheduleListResponseBody() = default;
};
class QuerySoundCodeScheduleListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySoundCodeScheduleListResponseBody> body{};

  QuerySoundCodeScheduleListResponse() {}

  explicit QuerySoundCodeScheduleListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySoundCodeScheduleListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySoundCodeScheduleListResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySoundCodeScheduleListResponse() = default;
};
class QuerySpeechRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> speechCode{};

  QuerySpeechRequest() {}

  explicit QuerySpeechRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (speechCode) {
      res["SpeechCode"] = boost::any(*speechCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("SpeechCode") != m.end() && !m["SpeechCode"].empty()) {
      speechCode = make_shared<string>(boost::any_cast<string>(m["SpeechCode"]));
    }
  }


  virtual ~QuerySpeechRequest() = default;
};
class QuerySpeechResponseBodyDataSoundCodeConfig : public Darabonba::Model {
public:
  shared_ptr<long> additionalDuration{};
  shared_ptr<string> soundCodeContent{};

  QuerySpeechResponseBodyDataSoundCodeConfig() {}

  explicit QuerySpeechResponseBodyDataSoundCodeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (additionalDuration) {
      res["AdditionalDuration"] = boost::any(*additionalDuration);
    }
    if (soundCodeContent) {
      res["SoundCodeContent"] = boost::any(*soundCodeContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdditionalDuration") != m.end() && !m["AdditionalDuration"].empty()) {
      additionalDuration = make_shared<long>(boost::any_cast<long>(m["AdditionalDuration"]));
    }
    if (m.find("SoundCodeContent") != m.end() && !m["SoundCodeContent"].empty()) {
      soundCodeContent = make_shared<string>(boost::any_cast<string>(m["SoundCodeContent"]));
    }
  }


  virtual ~QuerySpeechResponseBodyDataSoundCodeConfig() = default;
};
class QuerySpeechResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> audioFormat{};
  shared_ptr<string> bizCode{};
  shared_ptr<bool> enableSoundCode{};
  shared_ptr<QuerySpeechResponseBodyDataSoundCodeConfig> soundCodeConfig{};
  shared_ptr<string> speechCode{};
  shared_ptr<long> speechRate{};
  shared_ptr<string> speechType{};
  shared_ptr<string> text{};
  shared_ptr<string> voice{};
  shared_ptr<long> volume{};

  QuerySpeechResponseBodyData() {}

  explicit QuerySpeechResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFormat) {
      res["AudioFormat"] = boost::any(*audioFormat);
    }
    if (bizCode) {
      res["BizCode"] = boost::any(*bizCode);
    }
    if (enableSoundCode) {
      res["EnableSoundCode"] = boost::any(*enableSoundCode);
    }
    if (soundCodeConfig) {
      res["SoundCodeConfig"] = soundCodeConfig ? boost::any(soundCodeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (speechCode) {
      res["SpeechCode"] = boost::any(*speechCode);
    }
    if (speechRate) {
      res["SpeechRate"] = boost::any(*speechRate);
    }
    if (speechType) {
      res["SpeechType"] = boost::any(*speechType);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (voice) {
      res["Voice"] = boost::any(*voice);
    }
    if (volume) {
      res["Volume"] = boost::any(*volume);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFormat") != m.end() && !m["AudioFormat"].empty()) {
      audioFormat = make_shared<string>(boost::any_cast<string>(m["AudioFormat"]));
    }
    if (m.find("BizCode") != m.end() && !m["BizCode"].empty()) {
      bizCode = make_shared<string>(boost::any_cast<string>(m["BizCode"]));
    }
    if (m.find("EnableSoundCode") != m.end() && !m["EnableSoundCode"].empty()) {
      enableSoundCode = make_shared<bool>(boost::any_cast<bool>(m["EnableSoundCode"]));
    }
    if (m.find("SoundCodeConfig") != m.end() && !m["SoundCodeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SoundCodeConfig"].type()) {
        QuerySpeechResponseBodyDataSoundCodeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SoundCodeConfig"]));
        soundCodeConfig = make_shared<QuerySpeechResponseBodyDataSoundCodeConfig>(model1);
      }
    }
    if (m.find("SpeechCode") != m.end() && !m["SpeechCode"].empty()) {
      speechCode = make_shared<string>(boost::any_cast<string>(m["SpeechCode"]));
    }
    if (m.find("SpeechRate") != m.end() && !m["SpeechRate"].empty()) {
      speechRate = make_shared<long>(boost::any_cast<long>(m["SpeechRate"]));
    }
    if (m.find("SpeechType") != m.end() && !m["SpeechType"].empty()) {
      speechType = make_shared<string>(boost::any_cast<string>(m["SpeechType"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Voice") != m.end() && !m["Voice"].empty()) {
      voice = make_shared<string>(boost::any_cast<string>(m["Voice"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      volume = make_shared<long>(boost::any_cast<long>(m["Volume"]));
    }
  }


  virtual ~QuerySpeechResponseBodyData() = default;
};
class QuerySpeechResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QuerySpeechResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QuerySpeechResponseBody() {}

  explicit QuerySpeechResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QuerySpeechResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QuerySpeechResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QuerySpeechResponseBody() = default;
};
class QuerySpeechResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySpeechResponseBody> body{};

  QuerySpeechResponse() {}

  explicit QuerySpeechResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySpeechResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySpeechResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySpeechResponse() = default;
};
class QuerySpeechDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> availableSpace{};
  shared_ptr<string> availableSpaceScope{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectCode{};

  QuerySpeechDeviceRequest() {}

  explicit QuerySpeechDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableSpace) {
      res["AvailableSpace"] = boost::any(*availableSpace);
    }
    if (availableSpaceScope) {
      res["AvailableSpaceScope"] = boost::any(*availableSpaceScope);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectCode) {
      res["ProjectCode"] = boost::any(*projectCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableSpace") != m.end() && !m["AvailableSpace"].empty()) {
      availableSpace = make_shared<string>(boost::any_cast<string>(m["AvailableSpace"]));
    }
    if (m.find("AvailableSpaceScope") != m.end() && !m["AvailableSpaceScope"].empty()) {
      availableSpaceScope = make_shared<string>(boost::any_cast<string>(m["AvailableSpaceScope"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectCode") != m.end() && !m["ProjectCode"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["ProjectCode"]));
    }
  }


  virtual ~QuerySpeechDeviceRequest() = default;
};
class QuerySpeechDeviceResponseBodyDataListItems : public Darabonba::Model {
public:
  shared_ptr<double> availableSpace{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> productKey{};

  QuerySpeechDeviceResponseBodyDataListItems() {}

  explicit QuerySpeechDeviceResponseBodyDataListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableSpace) {
      res["AvailableSpace"] = boost::any(*availableSpace);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableSpace") != m.end() && !m["AvailableSpace"].empty()) {
      availableSpace = make_shared<double>(boost::any_cast<double>(m["AvailableSpace"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QuerySpeechDeviceResponseBodyDataListItems() = default;
};
class QuerySpeechDeviceResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySpeechDeviceResponseBodyDataListItems>> items{};

  QuerySpeechDeviceResponseBodyDataList() {}

  explicit QuerySpeechDeviceResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<QuerySpeechDeviceResponseBodyDataListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySpeechDeviceResponseBodyDataListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<QuerySpeechDeviceResponseBodyDataListItems>>(expect1);
      }
    }
  }


  virtual ~QuerySpeechDeviceResponseBodyDataList() = default;
};
class QuerySpeechDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QuerySpeechDeviceResponseBodyDataList> list{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QuerySpeechDeviceResponseBodyData() {}

  explicit QuerySpeechDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QuerySpeechDeviceResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QuerySpeechDeviceResponseBodyDataList>(model1);
      }
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QuerySpeechDeviceResponseBodyData() = default;
};
class QuerySpeechDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QuerySpeechDeviceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QuerySpeechDeviceResponseBody() {}

  explicit QuerySpeechDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QuerySpeechDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QuerySpeechDeviceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QuerySpeechDeviceResponseBody() = default;
};
class QuerySpeechDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySpeechDeviceResponseBody> body{};

  QuerySpeechDeviceResponse() {}

  explicit QuerySpeechDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySpeechDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySpeechDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySpeechDeviceResponse() = default;
};
class QuerySpeechLicenseAvailableQuotaRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};

  QuerySpeechLicenseAvailableQuotaRequest() {}

  explicit QuerySpeechLicenseAvailableQuotaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~QuerySpeechLicenseAvailableQuotaRequest() = default;
};
class QuerySpeechLicenseAvailableQuotaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QuerySpeechLicenseAvailableQuotaResponseBody() {}

  explicit QuerySpeechLicenseAvailableQuotaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QuerySpeechLicenseAvailableQuotaResponseBody() = default;
};
class QuerySpeechLicenseAvailableQuotaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySpeechLicenseAvailableQuotaResponseBody> body{};

  QuerySpeechLicenseAvailableQuotaResponse() {}

  explicit QuerySpeechLicenseAvailableQuotaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySpeechLicenseAvailableQuotaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySpeechLicenseAvailableQuotaResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySpeechLicenseAvailableQuotaResponse() = default;
};
class QuerySpeechLicenseDeviceListRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkGroupId{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<string>> licenseStatusList{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};

  QuerySpeechLicenseDeviceListRequest() {}

  explicit QuerySpeechLicenseDeviceListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkGroupId) {
      res["CheckGroupId"] = boost::any(*checkGroupId);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (licenseStatusList) {
      res["LicenseStatusList"] = boost::any(*licenseStatusList);
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckGroupId") != m.end() && !m["CheckGroupId"].empty()) {
      checkGroupId = make_shared<string>(boost::any_cast<string>(m["CheckGroupId"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("LicenseStatusList") != m.end() && !m["LicenseStatusList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LicenseStatusList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LicenseStatusList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      licenseStatusList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QuerySpeechLicenseDeviceListRequest() = default;
};
class QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceStatus{};
  shared_ptr<long> expiryTime{};
  shared_ptr<bool> inSpecifiedGroup{};
  shared_ptr<string> iotId{};
  shared_ptr<string> licenseStatus{};
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};

  QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem() {}

  explicit QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceStatus) {
      res["DeviceStatus"] = boost::any(*deviceStatus);
    }
    if (expiryTime) {
      res["ExpiryTime"] = boost::any(*expiryTime);
    }
    if (inSpecifiedGroup) {
      res["InSpecifiedGroup"] = boost::any(*inSpecifiedGroup);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (licenseStatus) {
      res["LicenseStatus"] = boost::any(*licenseStatus);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceStatus") != m.end() && !m["DeviceStatus"].empty()) {
      deviceStatus = make_shared<string>(boost::any_cast<string>(m["DeviceStatus"]));
    }
    if (m.find("ExpiryTime") != m.end() && !m["ExpiryTime"].empty()) {
      expiryTime = make_shared<long>(boost::any_cast<long>(m["ExpiryTime"]));
    }
    if (m.find("InSpecifiedGroup") != m.end() && !m["InSpecifiedGroup"].empty()) {
      inSpecifiedGroup = make_shared<bool>(boost::any_cast<bool>(m["InSpecifiedGroup"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("LicenseStatus") != m.end() && !m["LicenseStatus"].empty()) {
      licenseStatus = make_shared<string>(boost::any_cast<string>(m["LicenseStatus"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
  }


  virtual ~QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem() = default;
};
class QuerySpeechLicenseDeviceListResponseBodyDataDeviceList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem>> item{};

  QuerySpeechLicenseDeviceListResponseBodyDataDeviceList() {}

  explicit QuerySpeechLicenseDeviceListResponseBodyDataDeviceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["item"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("item") != m.end() && !m["item"].empty()) {
      if (typeid(vector<boost::any>) == m["item"].type()) {
        vector<QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem>>(expect1);
      }
    }
  }


  virtual ~QuerySpeechLicenseDeviceListResponseBodyDataDeviceList() = default;
};
class QuerySpeechLicenseDeviceListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QuerySpeechLicenseDeviceListResponseBodyDataDeviceList> deviceList{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QuerySpeechLicenseDeviceListResponseBodyData() {}

  explicit QuerySpeechLicenseDeviceListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceList) {
      res["DeviceList"] = deviceList ? boost::any(deviceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceList") != m.end() && !m["DeviceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeviceList"].type()) {
        QuerySpeechLicenseDeviceListResponseBodyDataDeviceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeviceList"]));
        deviceList = make_shared<QuerySpeechLicenseDeviceListResponseBodyDataDeviceList>(model1);
      }
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QuerySpeechLicenseDeviceListResponseBodyData() = default;
};
class QuerySpeechLicenseDeviceListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QuerySpeechLicenseDeviceListResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QuerySpeechLicenseDeviceListResponseBody() {}

  explicit QuerySpeechLicenseDeviceListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QuerySpeechLicenseDeviceListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QuerySpeechLicenseDeviceListResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QuerySpeechLicenseDeviceListResponseBody() = default;
};
class QuerySpeechLicenseDeviceListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySpeechLicenseDeviceListResponseBody> body{};

  QuerySpeechLicenseDeviceListResponse() {}

  explicit QuerySpeechLicenseDeviceListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySpeechLicenseDeviceListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySpeechLicenseDeviceListResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySpeechLicenseDeviceListResponse() = default;
};
class QuerySpeechListRequest : public Darabonba::Model {
public:
  shared_ptr<string> audioFormat{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectCode{};

  QuerySpeechListRequest() {}

  explicit QuerySpeechListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFormat) {
      res["AudioFormat"] = boost::any(*audioFormat);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectCode) {
      res["ProjectCode"] = boost::any(*projectCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFormat") != m.end() && !m["AudioFormat"].empty()) {
      audioFormat = make_shared<string>(boost::any_cast<string>(m["AudioFormat"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectCode") != m.end() && !m["ProjectCode"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["ProjectCode"]));
    }
  }


  virtual ~QuerySpeechListRequest() = default;
};
class QuerySpeechListResponseBodyDataListItemsSpeechListItems : public Darabonba::Model {
public:
  shared_ptr<string> bizCode{};
  shared_ptr<string> speechCode{};
  shared_ptr<string> text{};
  shared_ptr<string> voice{};

  QuerySpeechListResponseBodyDataListItemsSpeechListItems() {}

  explicit QuerySpeechListResponseBodyDataListItemsSpeechListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizCode) {
      res["BizCode"] = boost::any(*bizCode);
    }
    if (speechCode) {
      res["SpeechCode"] = boost::any(*speechCode);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (voice) {
      res["Voice"] = boost::any(*voice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizCode") != m.end() && !m["BizCode"].empty()) {
      bizCode = make_shared<string>(boost::any_cast<string>(m["BizCode"]));
    }
    if (m.find("SpeechCode") != m.end() && !m["SpeechCode"].empty()) {
      speechCode = make_shared<string>(boost::any_cast<string>(m["SpeechCode"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Voice") != m.end() && !m["Voice"].empty()) {
      voice = make_shared<string>(boost::any_cast<string>(m["Voice"]));
    }
  }


  virtual ~QuerySpeechListResponseBodyDataListItemsSpeechListItems() = default;
};
class QuerySpeechListResponseBodyDataListItemsSpeechList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySpeechListResponseBodyDataListItemsSpeechListItems>> items{};

  QuerySpeechListResponseBodyDataListItemsSpeechList() {}

  explicit QuerySpeechListResponseBodyDataListItemsSpeechList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<QuerySpeechListResponseBodyDataListItemsSpeechListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySpeechListResponseBodyDataListItemsSpeechListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<QuerySpeechListResponseBodyDataListItemsSpeechListItems>>(expect1);
      }
    }
  }


  virtual ~QuerySpeechListResponseBodyDataListItemsSpeechList() = default;
};
class QuerySpeechListResponseBodyDataListItems : public Darabonba::Model {
public:
  shared_ptr<string> audioFormat{};
  shared_ptr<string> bizCode{};
  shared_ptr<string> speechCode{};
  shared_ptr<QuerySpeechListResponseBodyDataListItemsSpeechList> speechList{};
  shared_ptr<string> speechType{};
  shared_ptr<string> text{};
  shared_ptr<string> voice{};

  QuerySpeechListResponseBodyDataListItems() {}

  explicit QuerySpeechListResponseBodyDataListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFormat) {
      res["AudioFormat"] = boost::any(*audioFormat);
    }
    if (bizCode) {
      res["BizCode"] = boost::any(*bizCode);
    }
    if (speechCode) {
      res["SpeechCode"] = boost::any(*speechCode);
    }
    if (speechList) {
      res["SpeechList"] = speechList ? boost::any(speechList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (speechType) {
      res["SpeechType"] = boost::any(*speechType);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (voice) {
      res["Voice"] = boost::any(*voice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFormat") != m.end() && !m["AudioFormat"].empty()) {
      audioFormat = make_shared<string>(boost::any_cast<string>(m["AudioFormat"]));
    }
    if (m.find("BizCode") != m.end() && !m["BizCode"].empty()) {
      bizCode = make_shared<string>(boost::any_cast<string>(m["BizCode"]));
    }
    if (m.find("SpeechCode") != m.end() && !m["SpeechCode"].empty()) {
      speechCode = make_shared<string>(boost::any_cast<string>(m["SpeechCode"]));
    }
    if (m.find("SpeechList") != m.end() && !m["SpeechList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SpeechList"].type()) {
        QuerySpeechListResponseBodyDataListItemsSpeechList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SpeechList"]));
        speechList = make_shared<QuerySpeechListResponseBodyDataListItemsSpeechList>(model1);
      }
    }
    if (m.find("SpeechType") != m.end() && !m["SpeechType"].empty()) {
      speechType = make_shared<string>(boost::any_cast<string>(m["SpeechType"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Voice") != m.end() && !m["Voice"].empty()) {
      voice = make_shared<string>(boost::any_cast<string>(m["Voice"]));
    }
  }


  virtual ~QuerySpeechListResponseBodyDataListItems() = default;
};
class QuerySpeechListResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySpeechListResponseBodyDataListItems>> items{};

  QuerySpeechListResponseBodyDataList() {}

  explicit QuerySpeechListResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<QuerySpeechListResponseBodyDataListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySpeechListResponseBodyDataListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<QuerySpeechListResponseBodyDataListItems>>(expect1);
      }
    }
  }


  virtual ~QuerySpeechListResponseBodyDataList() = default;
};
class QuerySpeechListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QuerySpeechListResponseBodyDataList> list{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QuerySpeechListResponseBodyData() {}

  explicit QuerySpeechListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QuerySpeechListResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QuerySpeechListResponseBodyDataList>(model1);
      }
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QuerySpeechListResponseBodyData() = default;
};
class QuerySpeechListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QuerySpeechListResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QuerySpeechListResponseBody() {}

  explicit QuerySpeechListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QuerySpeechListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QuerySpeechListResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QuerySpeechListResponseBody() = default;
};
class QuerySpeechListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySpeechListResponseBody> body{};

  QuerySpeechListResponse() {}

  explicit QuerySpeechListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySpeechListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySpeechListResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySpeechListResponse() = default;
};
class QuerySpeechPushJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobCode{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> pushMode{};
  shared_ptr<vector<string>> statusList{};

  QuerySpeechPushJobRequest() {}

  explicit QuerySpeechPushJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobCode) {
      res["JobCode"] = boost::any(*jobCode);
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectCode) {
      res["ProjectCode"] = boost::any(*projectCode);
    }
    if (pushMode) {
      res["PushMode"] = boost::any(*pushMode);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobCode") != m.end() && !m["JobCode"].empty()) {
      jobCode = make_shared<string>(boost::any_cast<string>(m["JobCode"]));
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectCode") != m.end() && !m["ProjectCode"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["ProjectCode"]));
    }
    if (m.find("PushMode") != m.end() && !m["PushMode"].empty()) {
      pushMode = make_shared<string>(boost::any_cast<string>(m["PushMode"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["StatusList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StatusList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      statusList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QuerySpeechPushJobRequest() = default;
};
class QuerySpeechPushJobResponseBodyDataListItems : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> createdTime{};
  shared_ptr<string> deviceName{};
  shared_ptr<long> expiredTime{};
  shared_ptr<long> failDeviceNum{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> pushMode{};
  shared_ptr<long> runningDeviceNum{};
  shared_ptr<long> speechNum{};
  shared_ptr<bool> speechStatus{};
  shared_ptr<string> status{};
  shared_ptr<long> successDeviceNum{};
  shared_ptr<long> totalDeviceNum{};

  QuerySpeechPushJobResponseBodyDataListItems() {}

  explicit QuerySpeechPushJobResponseBodyDataListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (failDeviceNum) {
      res["FailDeviceNum"] = boost::any(*failDeviceNum);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (pushMode) {
      res["PushMode"] = boost::any(*pushMode);
    }
    if (runningDeviceNum) {
      res["RunningDeviceNum"] = boost::any(*runningDeviceNum);
    }
    if (speechNum) {
      res["SpeechNum"] = boost::any(*speechNum);
    }
    if (speechStatus) {
      res["SpeechStatus"] = boost::any(*speechStatus);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (successDeviceNum) {
      res["SuccessDeviceNum"] = boost::any(*successDeviceNum);
    }
    if (totalDeviceNum) {
      res["TotalDeviceNum"] = boost::any(*totalDeviceNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<long>(boost::any_cast<long>(m["ExpiredTime"]));
    }
    if (m.find("FailDeviceNum") != m.end() && !m["FailDeviceNum"].empty()) {
      failDeviceNum = make_shared<long>(boost::any_cast<long>(m["FailDeviceNum"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("PushMode") != m.end() && !m["PushMode"].empty()) {
      pushMode = make_shared<string>(boost::any_cast<string>(m["PushMode"]));
    }
    if (m.find("RunningDeviceNum") != m.end() && !m["RunningDeviceNum"].empty()) {
      runningDeviceNum = make_shared<long>(boost::any_cast<long>(m["RunningDeviceNum"]));
    }
    if (m.find("SpeechNum") != m.end() && !m["SpeechNum"].empty()) {
      speechNum = make_shared<long>(boost::any_cast<long>(m["SpeechNum"]));
    }
    if (m.find("SpeechStatus") != m.end() && !m["SpeechStatus"].empty()) {
      speechStatus = make_shared<bool>(boost::any_cast<bool>(m["SpeechStatus"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SuccessDeviceNum") != m.end() && !m["SuccessDeviceNum"].empty()) {
      successDeviceNum = make_shared<long>(boost::any_cast<long>(m["SuccessDeviceNum"]));
    }
    if (m.find("TotalDeviceNum") != m.end() && !m["TotalDeviceNum"].empty()) {
      totalDeviceNum = make_shared<long>(boost::any_cast<long>(m["TotalDeviceNum"]));
    }
  }


  virtual ~QuerySpeechPushJobResponseBodyDataListItems() = default;
};
class QuerySpeechPushJobResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySpeechPushJobResponseBodyDataListItems>> items{};

  QuerySpeechPushJobResponseBodyDataList() {}

  explicit QuerySpeechPushJobResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<QuerySpeechPushJobResponseBodyDataListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySpeechPushJobResponseBodyDataListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<QuerySpeechPushJobResponseBodyDataListItems>>(expect1);
      }
    }
  }


  virtual ~QuerySpeechPushJobResponseBodyDataList() = default;
};
class QuerySpeechPushJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QuerySpeechPushJobResponseBodyDataList> list{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QuerySpeechPushJobResponseBodyData() {}

  explicit QuerySpeechPushJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QuerySpeechPushJobResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QuerySpeechPushJobResponseBodyDataList>(model1);
      }
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QuerySpeechPushJobResponseBodyData() = default;
};
class QuerySpeechPushJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QuerySpeechPushJobResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QuerySpeechPushJobResponseBody() {}

  explicit QuerySpeechPushJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QuerySpeechPushJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QuerySpeechPushJobResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QuerySpeechPushJobResponseBody() = default;
};
class QuerySpeechPushJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySpeechPushJobResponseBody> body{};

  QuerySpeechPushJobResponse() {}

  explicit QuerySpeechPushJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySpeechPushJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySpeechPushJobResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySpeechPushJobResponse() = default;
};
class QuerySpeechPushJobDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobCode{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> status{};

  QuerySpeechPushJobDeviceRequest() {}

  explicit QuerySpeechPushJobDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobCode) {
      res["JobCode"] = boost::any(*jobCode);
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobCode") != m.end() && !m["JobCode"].empty()) {
      jobCode = make_shared<string>(boost::any_cast<string>(m["JobCode"]));
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~QuerySpeechPushJobDeviceRequest() = default;
};
class QuerySpeechPushJobDeviceResponseBodyDataListItems : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> status{};

  QuerySpeechPushJobDeviceResponseBodyDataListItems() {}

  explicit QuerySpeechPushJobDeviceResponseBodyDataListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~QuerySpeechPushJobDeviceResponseBodyDataListItems() = default;
};
class QuerySpeechPushJobDeviceResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySpeechPushJobDeviceResponseBodyDataListItems>> items{};

  QuerySpeechPushJobDeviceResponseBodyDataList() {}

  explicit QuerySpeechPushJobDeviceResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<QuerySpeechPushJobDeviceResponseBodyDataListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySpeechPushJobDeviceResponseBodyDataListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<QuerySpeechPushJobDeviceResponseBodyDataListItems>>(expect1);
      }
    }
  }


  virtual ~QuerySpeechPushJobDeviceResponseBodyDataList() = default;
};
class QuerySpeechPushJobDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QuerySpeechPushJobDeviceResponseBodyDataList> list{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QuerySpeechPushJobDeviceResponseBodyData() {}

  explicit QuerySpeechPushJobDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QuerySpeechPushJobDeviceResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QuerySpeechPushJobDeviceResponseBodyDataList>(model1);
      }
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QuerySpeechPushJobDeviceResponseBodyData() = default;
};
class QuerySpeechPushJobDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QuerySpeechPushJobDeviceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QuerySpeechPushJobDeviceResponseBody() {}

  explicit QuerySpeechPushJobDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QuerySpeechPushJobDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QuerySpeechPushJobDeviceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QuerySpeechPushJobDeviceResponseBody() = default;
};
class QuerySpeechPushJobDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySpeechPushJobDeviceResponseBody> body{};

  QuerySpeechPushJobDeviceResponse() {}

  explicit QuerySpeechPushJobDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySpeechPushJobDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySpeechPushJobDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySpeechPushJobDeviceResponse() = default;
};
class QuerySpeechPushJobSpeechRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobCode{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};

  QuerySpeechPushJobSpeechRequest() {}

  explicit QuerySpeechPushJobSpeechRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobCode) {
      res["JobCode"] = boost::any(*jobCode);
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobCode") != m.end() && !m["JobCode"].empty()) {
      jobCode = make_shared<string>(boost::any_cast<string>(m["JobCode"]));
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QuerySpeechPushJobSpeechRequest() = default;
};
class QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems : public Darabonba::Model {
public:
  shared_ptr<string> bizCode{};
  shared_ptr<string> text{};
  shared_ptr<string> voice{};

  QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems() {}

  explicit QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizCode) {
      res["BizCode"] = boost::any(*bizCode);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (voice) {
      res["Voice"] = boost::any(*voice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizCode") != m.end() && !m["BizCode"].empty()) {
      bizCode = make_shared<string>(boost::any_cast<string>(m["BizCode"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Voice") != m.end() && !m["Voice"].empty()) {
      voice = make_shared<string>(boost::any_cast<string>(m["Voice"]));
    }
  }


  virtual ~QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems() = default;
};
class QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems>> items{};

  QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechList() {}

  explicit QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems>>(expect1);
      }
    }
  }


  virtual ~QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechList() = default;
};
class QuerySpeechPushJobSpeechResponseBodyDataListItems : public Darabonba::Model {
public:
  shared_ptr<string> bizCode{};
  shared_ptr<QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechList> speechList{};
  shared_ptr<string> speechType{};
  shared_ptr<string> text{};
  shared_ptr<string> voice{};

  QuerySpeechPushJobSpeechResponseBodyDataListItems() {}

  explicit QuerySpeechPushJobSpeechResponseBodyDataListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizCode) {
      res["BizCode"] = boost::any(*bizCode);
    }
    if (speechList) {
      res["SpeechList"] = speechList ? boost::any(speechList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (speechType) {
      res["SpeechType"] = boost::any(*speechType);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (voice) {
      res["Voice"] = boost::any(*voice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizCode") != m.end() && !m["BizCode"].empty()) {
      bizCode = make_shared<string>(boost::any_cast<string>(m["BizCode"]));
    }
    if (m.find("SpeechList") != m.end() && !m["SpeechList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SpeechList"].type()) {
        QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SpeechList"]));
        speechList = make_shared<QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechList>(model1);
      }
    }
    if (m.find("SpeechType") != m.end() && !m["SpeechType"].empty()) {
      speechType = make_shared<string>(boost::any_cast<string>(m["SpeechType"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Voice") != m.end() && !m["Voice"].empty()) {
      voice = make_shared<string>(boost::any_cast<string>(m["Voice"]));
    }
  }


  virtual ~QuerySpeechPushJobSpeechResponseBodyDataListItems() = default;
};
class QuerySpeechPushJobSpeechResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySpeechPushJobSpeechResponseBodyDataListItems>> items{};

  QuerySpeechPushJobSpeechResponseBodyDataList() {}

  explicit QuerySpeechPushJobSpeechResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<QuerySpeechPushJobSpeechResponseBodyDataListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySpeechPushJobSpeechResponseBodyDataListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<QuerySpeechPushJobSpeechResponseBodyDataListItems>>(expect1);
      }
    }
  }


  virtual ~QuerySpeechPushJobSpeechResponseBodyDataList() = default;
};
class QuerySpeechPushJobSpeechResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QuerySpeechPushJobSpeechResponseBodyDataList> list{};
  shared_ptr<long> pageId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QuerySpeechPushJobSpeechResponseBodyData() {}

  explicit QuerySpeechPushJobSpeechResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QuerySpeechPushJobSpeechResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QuerySpeechPushJobSpeechResponseBodyDataList>(model1);
      }
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QuerySpeechPushJobSpeechResponseBodyData() = default;
};
class QuerySpeechPushJobSpeechResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QuerySpeechPushJobSpeechResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QuerySpeechPushJobSpeechResponseBody() {}

  explicit QuerySpeechPushJobSpeechResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QuerySpeechPushJobSpeechResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QuerySpeechPushJobSpeechResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QuerySpeechPushJobSpeechResponseBody() = default;
};
class QuerySpeechPushJobSpeechResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySpeechPushJobSpeechResponseBody> body{};

  QuerySpeechPushJobSpeechResponse() {}

  explicit QuerySpeechPushJobSpeechResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySpeechPushJobSpeechResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySpeechPushJobSpeechResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySpeechPushJobSpeechResponse() = default;
};
class QueryStudioAppDomainListOpenRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> projectId{};

  QueryStudioAppDomainListOpenRequest() {}

  explicit QueryStudioAppDomainListOpenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~QueryStudioAppDomainListOpenRequest() = default;
};
class QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> host{};
  shared_ptr<long> id{};
  shared_ptr<string> isBeian{};
  shared_ptr<string> projectId{};
  shared_ptr<string> protocol{};
  shared_ptr<string> tenantId{};

  QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo() {}

  explicit QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isBeian) {
      res["IsBeian"] = boost::any(*isBeian);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsBeian") != m.end() && !m["IsBeian"].empty()) {
      isBeian = make_shared<string>(boost::any_cast<string>(m["IsBeian"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo() = default;
};
class QueryStudioAppDomainListOpenResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo>> domainInfo{};

  QueryStudioAppDomainListOpenResponseBodyDataList() {}

  explicit QueryStudioAppDomainListOpenResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainInfo) {
      vector<boost::any> temp1;
      for(auto item1:*domainInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainInfo") != m.end() && !m["DomainInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainInfo"].type()) {
        vector<QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainInfo = make_shared<vector<QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo>>(expect1);
      }
    }
  }


  virtual ~QueryStudioAppDomainListOpenResponseBodyDataList() = default;
};
class QueryStudioAppDomainListOpenResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QueryStudioAppDomainListOpenResponseBodyDataList> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};
  shared_ptr<long> totalPage{};

  QueryStudioAppDomainListOpenResponseBodyData() {}

  explicit QueryStudioAppDomainListOpenResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryStudioAppDomainListOpenResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryStudioAppDomainListOpenResponseBodyDataList>(model1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~QueryStudioAppDomainListOpenResponseBodyData() = default;
};
class QueryStudioAppDomainListOpenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryStudioAppDomainListOpenResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryStudioAppDomainListOpenResponseBody() {}

  explicit QueryStudioAppDomainListOpenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryStudioAppDomainListOpenResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryStudioAppDomainListOpenResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryStudioAppDomainListOpenResponseBody() = default;
};
class QueryStudioAppDomainListOpenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryStudioAppDomainListOpenResponseBody> body{};

  QueryStudioAppDomainListOpenResponse() {}

  explicit QueryStudioAppDomainListOpenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryStudioAppDomainListOpenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryStudioAppDomainListOpenResponseBody>(model1);
      }
    }
  }


  virtual ~QueryStudioAppDomainListOpenResponse() = default;
};
class QueryStudioAppListRequest : public Darabonba::Model {
public:
  shared_ptr<string> fuzzyName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectId{};
  shared_ptr<vector<string>> types{};

  QueryStudioAppListRequest() {}

  explicit QueryStudioAppListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fuzzyName) {
      res["FuzzyName"] = boost::any(*fuzzyName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (types) {
      res["Types"] = boost::any(*types);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FuzzyName") != m.end() && !m["FuzzyName"].empty()) {
      fuzzyName = make_shared<string>(boost::any_cast<string>(m["FuzzyName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      types = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryStudioAppListRequest() = default;
};
class QueryStudioAppListResponseBodyDataListAppInfo : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appKey{};
  shared_ptr<string> appSecret{};
  shared_ptr<string> description{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> gmtRelease{};
  shared_ptr<string> name{};
  shared_ptr<string> projectId{};
  shared_ptr<string> type{};

  QueryStudioAppListResponseBodyDataListAppInfo() {}

  explicit QueryStudioAppListResponseBodyDataListAppInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (appSecret) {
      res["AppSecret"] = boost::any(*appSecret);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtRelease) {
      res["GmtRelease"] = boost::any(*gmtRelease);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("AppSecret") != m.end() && !m["AppSecret"].empty()) {
      appSecret = make_shared<string>(boost::any_cast<string>(m["AppSecret"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtRelease") != m.end() && !m["GmtRelease"].empty()) {
      gmtRelease = make_shared<string>(boost::any_cast<string>(m["GmtRelease"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryStudioAppListResponseBodyDataListAppInfo() = default;
};
class QueryStudioAppListResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryStudioAppListResponseBodyDataListAppInfo>> appInfo{};

  QueryStudioAppListResponseBodyDataList() {}

  explicit QueryStudioAppListResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appInfo) {
      vector<boost::any> temp1;
      for(auto item1:*appInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AppInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppInfo") != m.end() && !m["AppInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["AppInfo"].type()) {
        vector<QueryStudioAppListResponseBodyDataListAppInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AppInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryStudioAppListResponseBodyDataListAppInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        appInfo = make_shared<vector<QueryStudioAppListResponseBodyDataListAppInfo>>(expect1);
      }
    }
  }


  virtual ~QueryStudioAppListResponseBodyDataList() = default;
};
class QueryStudioAppListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QueryStudioAppListResponseBodyDataList> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};
  shared_ptr<long> totalPage{};

  QueryStudioAppListResponseBodyData() {}

  explicit QueryStudioAppListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryStudioAppListResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryStudioAppListResponseBodyDataList>(model1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~QueryStudioAppListResponseBodyData() = default;
};
class QueryStudioAppListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryStudioAppListResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryStudioAppListResponseBody() {}

  explicit QueryStudioAppListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryStudioAppListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryStudioAppListResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryStudioAppListResponseBody() = default;
};
class QueryStudioAppListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryStudioAppListResponseBody> body{};

  QueryStudioAppListResponse() {}

  explicit QueryStudioAppListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryStudioAppListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryStudioAppListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryStudioAppListResponse() = default;
};
class QueryStudioAppPageListOpenRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<bool> isRelease{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectId{};

  QueryStudioAppPageListOpenRequest() {}

  explicit QueryStudioAppPageListOpenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (isRelease) {
      res["IsRelease"] = boost::any(*isRelease);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("IsRelease") != m.end() && !m["IsRelease"].empty()) {
      isRelease = make_shared<bool>(boost::any_cast<bool>(m["IsRelease"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~QueryStudioAppPageListOpenRequest() = default;
};
class QueryStudioAppPageListOpenResponseBodyDataListPageInfo : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<long> isHidden{};
  shared_ptr<long> isHome{};
  shared_ptr<long> isLoginPage{};
  shared_ptr<string> name{};
  shared_ptr<string> pageId{};
  shared_ptr<string> path{};

  QueryStudioAppPageListOpenResponseBodyDataListPageInfo() {}

  explicit QueryStudioAppPageListOpenResponseBodyDataListPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isHidden) {
      res["IsHidden"] = boost::any(*isHidden);
    }
    if (isHome) {
      res["IsHome"] = boost::any(*isHome);
    }
    if (isLoginPage) {
      res["IsLoginPage"] = boost::any(*isLoginPage);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsHidden") != m.end() && !m["IsHidden"].empty()) {
      isHidden = make_shared<long>(boost::any_cast<long>(m["IsHidden"]));
    }
    if (m.find("IsHome") != m.end() && !m["IsHome"].empty()) {
      isHome = make_shared<long>(boost::any_cast<long>(m["IsHome"]));
    }
    if (m.find("IsLoginPage") != m.end() && !m["IsLoginPage"].empty()) {
      isLoginPage = make_shared<long>(boost::any_cast<long>(m["IsLoginPage"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<string>(boost::any_cast<string>(m["PageId"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~QueryStudioAppPageListOpenResponseBodyDataListPageInfo() = default;
};
class QueryStudioAppPageListOpenResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryStudioAppPageListOpenResponseBodyDataListPageInfo>> pageInfo{};

  QueryStudioAppPageListOpenResponseBodyDataList() {}

  explicit QueryStudioAppPageListOpenResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      vector<boost::any> temp1;
      for(auto item1:*pageInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PageInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PageInfo"].type()) {
        vector<QueryStudioAppPageListOpenResponseBodyDataListPageInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PageInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryStudioAppPageListOpenResponseBodyDataListPageInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pageInfo = make_shared<vector<QueryStudioAppPageListOpenResponseBodyDataListPageInfo>>(expect1);
      }
    }
  }


  virtual ~QueryStudioAppPageListOpenResponseBodyDataList() = default;
};
class QueryStudioAppPageListOpenResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QueryStudioAppPageListOpenResponseBodyDataList> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};
  shared_ptr<long> totalPage{};

  QueryStudioAppPageListOpenResponseBodyData() {}

  explicit QueryStudioAppPageListOpenResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryStudioAppPageListOpenResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryStudioAppPageListOpenResponseBodyDataList>(model1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~QueryStudioAppPageListOpenResponseBodyData() = default;
};
class QueryStudioAppPageListOpenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryStudioAppPageListOpenResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryStudioAppPageListOpenResponseBody() {}

  explicit QueryStudioAppPageListOpenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryStudioAppPageListOpenResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryStudioAppPageListOpenResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryStudioAppPageListOpenResponseBody() = default;
};
class QueryStudioAppPageListOpenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryStudioAppPageListOpenResponseBody> body{};

  QueryStudioAppPageListOpenResponse() {}

  explicit QueryStudioAppPageListOpenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryStudioAppPageListOpenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryStudioAppPageListOpenResponseBody>(model1);
      }
    }
  }


  virtual ~QueryStudioAppPageListOpenResponse() = default;
};
class QueryStudioProjectListRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};

  QueryStudioProjectListRequest() {}

  explicit QueryStudioProjectListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryStudioProjectListRequest() = default;
};
class QueryStudioProjectListResponseBodyDataListProjectInfo : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> name{};
  shared_ptr<string> projectId{};

  QueryStudioProjectListResponseBodyDataListProjectInfo() {}

  explicit QueryStudioProjectListResponseBodyDataListProjectInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~QueryStudioProjectListResponseBodyDataListProjectInfo() = default;
};
class QueryStudioProjectListResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryStudioProjectListResponseBodyDataListProjectInfo>> projectInfo{};

  QueryStudioProjectListResponseBodyDataList() {}

  explicit QueryStudioProjectListResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectInfo) {
      vector<boost::any> temp1;
      for(auto item1:*projectInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProjectInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectInfo") != m.end() && !m["ProjectInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ProjectInfo"].type()) {
        vector<QueryStudioProjectListResponseBodyDataListProjectInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProjectInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryStudioProjectListResponseBodyDataListProjectInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        projectInfo = make_shared<vector<QueryStudioProjectListResponseBodyDataListProjectInfo>>(expect1);
      }
    }
  }


  virtual ~QueryStudioProjectListResponseBodyDataList() = default;
};
class QueryStudioProjectListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QueryStudioProjectListResponseBodyDataList> list{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};
  shared_ptr<long> totalPage{};

  QueryStudioProjectListResponseBodyData() {}

  explicit QueryStudioProjectListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryStudioProjectListResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryStudioProjectListResponseBodyDataList>(model1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~QueryStudioProjectListResponseBodyData() = default;
};
class QueryStudioProjectListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryStudioProjectListResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryStudioProjectListResponseBody() {}

  explicit QueryStudioProjectListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryStudioProjectListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryStudioProjectListResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryStudioProjectListResponseBody() = default;
};
class QueryStudioProjectListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryStudioProjectListResponseBody> body{};

  QueryStudioProjectListResponse() {}

  explicit QueryStudioProjectListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryStudioProjectListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryStudioProjectListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryStudioProjectListResponse() = default;
};
class QuerySubscribeRelationRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> type{};

  QuerySubscribeRelationRequest() {}

  explicit QuerySubscribeRelationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QuerySubscribeRelationRequest() = default;
};
class QuerySubscribeRelationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<string>> consumerGroupIds{};
  shared_ptr<bool> deviceDataFlag{};
  shared_ptr<bool> deviceLifeCycleFlag{};
  shared_ptr<bool> deviceStatusChangeFlag{};
  shared_ptr<bool> deviceTagFlag{};
  shared_ptr<bool> deviceTopoLifeCycleFlag{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> foundDeviceListFlag{};
  shared_ptr<string> mnsConfiguration{};
  shared_ptr<bool> otaEventFlag{};
  shared_ptr<bool> otaJobFlag{};
  shared_ptr<bool> otaVersionFlag{};
  shared_ptr<string> productKey{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subscribeFlags{};
  shared_ptr<bool> success{};
  shared_ptr<bool> thingHistoryFlag{};
  shared_ptr<string> type{};

  QuerySubscribeRelationResponseBody() {}

  explicit QuerySubscribeRelationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (consumerGroupIds) {
      res["ConsumerGroupIds"] = boost::any(*consumerGroupIds);
    }
    if (deviceDataFlag) {
      res["DeviceDataFlag"] = boost::any(*deviceDataFlag);
    }
    if (deviceLifeCycleFlag) {
      res["DeviceLifeCycleFlag"] = boost::any(*deviceLifeCycleFlag);
    }
    if (deviceStatusChangeFlag) {
      res["DeviceStatusChangeFlag"] = boost::any(*deviceStatusChangeFlag);
    }
    if (deviceTagFlag) {
      res["DeviceTagFlag"] = boost::any(*deviceTagFlag);
    }
    if (deviceTopoLifeCycleFlag) {
      res["DeviceTopoLifeCycleFlag"] = boost::any(*deviceTopoLifeCycleFlag);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (foundDeviceListFlag) {
      res["FoundDeviceListFlag"] = boost::any(*foundDeviceListFlag);
    }
    if (mnsConfiguration) {
      res["MnsConfiguration"] = boost::any(*mnsConfiguration);
    }
    if (otaEventFlag) {
      res["OtaEventFlag"] = boost::any(*otaEventFlag);
    }
    if (otaJobFlag) {
      res["OtaJobFlag"] = boost::any(*otaJobFlag);
    }
    if (otaVersionFlag) {
      res["OtaVersionFlag"] = boost::any(*otaVersionFlag);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subscribeFlags) {
      res["SubscribeFlags"] = boost::any(*subscribeFlags);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (thingHistoryFlag) {
      res["ThingHistoryFlag"] = boost::any(*thingHistoryFlag);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ConsumerGroupIds") != m.end() && !m["ConsumerGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ConsumerGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ConsumerGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      consumerGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DeviceDataFlag") != m.end() && !m["DeviceDataFlag"].empty()) {
      deviceDataFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceDataFlag"]));
    }
    if (m.find("DeviceLifeCycleFlag") != m.end() && !m["DeviceLifeCycleFlag"].empty()) {
      deviceLifeCycleFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceLifeCycleFlag"]));
    }
    if (m.find("DeviceStatusChangeFlag") != m.end() && !m["DeviceStatusChangeFlag"].empty()) {
      deviceStatusChangeFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceStatusChangeFlag"]));
    }
    if (m.find("DeviceTagFlag") != m.end() && !m["DeviceTagFlag"].empty()) {
      deviceTagFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceTagFlag"]));
    }
    if (m.find("DeviceTopoLifeCycleFlag") != m.end() && !m["DeviceTopoLifeCycleFlag"].empty()) {
      deviceTopoLifeCycleFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceTopoLifeCycleFlag"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("FoundDeviceListFlag") != m.end() && !m["FoundDeviceListFlag"].empty()) {
      foundDeviceListFlag = make_shared<bool>(boost::any_cast<bool>(m["FoundDeviceListFlag"]));
    }
    if (m.find("MnsConfiguration") != m.end() && !m["MnsConfiguration"].empty()) {
      mnsConfiguration = make_shared<string>(boost::any_cast<string>(m["MnsConfiguration"]));
    }
    if (m.find("OtaEventFlag") != m.end() && !m["OtaEventFlag"].empty()) {
      otaEventFlag = make_shared<bool>(boost::any_cast<bool>(m["OtaEventFlag"]));
    }
    if (m.find("OtaJobFlag") != m.end() && !m["OtaJobFlag"].empty()) {
      otaJobFlag = make_shared<bool>(boost::any_cast<bool>(m["OtaJobFlag"]));
    }
    if (m.find("OtaVersionFlag") != m.end() && !m["OtaVersionFlag"].empty()) {
      otaVersionFlag = make_shared<bool>(boost::any_cast<bool>(m["OtaVersionFlag"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubscribeFlags") != m.end() && !m["SubscribeFlags"].empty()) {
      subscribeFlags = make_shared<string>(boost::any_cast<string>(m["SubscribeFlags"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ThingHistoryFlag") != m.end() && !m["ThingHistoryFlag"].empty()) {
      thingHistoryFlag = make_shared<bool>(boost::any_cast<bool>(m["ThingHistoryFlag"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QuerySubscribeRelationResponseBody() = default;
};
class QuerySubscribeRelationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySubscribeRelationResponseBody> body{};

  QuerySubscribeRelationResponse() {}

  explicit QuerySubscribeRelationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySubscribeRelationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySubscribeRelationResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySubscribeRelationResponse() = default;
};
class QuerySummarySceneRuleLogRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> endTime{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> ruleId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};

  QuerySummarySceneRuleLogRequest() {}

  explicit QuerySummarySceneRuleLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~QuerySummarySceneRuleLogRequest() = default;
};
class QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo : public Darabonba::Model {
public:
  shared_ptr<long> logTime{};
  shared_ptr<string> result{};
  shared_ptr<string> traceId{};

  QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo() {}

  explicit QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logTime) {
      res["LogTime"] = boost::any(*logTime);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogTime") != m.end() && !m["LogTime"].empty()) {
      logTime = make_shared<long>(boost::any_cast<long>(m["LogTime"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo() = default;
};
class QuerySummarySceneRuleLogResponseBodyDataLogList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo>> logInfo{};

  QuerySummarySceneRuleLogResponseBodyDataLogList() {}

  explicit QuerySummarySceneRuleLogResponseBodyDataLogList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logInfo) {
      vector<boost::any> temp1;
      for(auto item1:*logInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogInfo") != m.end() && !m["LogInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["LogInfo"].type()) {
        vector<QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logInfo = make_shared<vector<QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo>>(expect1);
      }
    }
  }


  virtual ~QuerySummarySceneRuleLogResponseBodyDataLogList() = default;
};
class QuerySummarySceneRuleLogResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<QuerySummarySceneRuleLogResponseBodyDataLogList> logList{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QuerySummarySceneRuleLogResponseBodyData() {}

  explicit QuerySummarySceneRuleLogResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (logList) {
      res["LogList"] = logList ? boost::any(logList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("LogList") != m.end() && !m["LogList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogList"].type()) {
        QuerySummarySceneRuleLogResponseBodyDataLogList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogList"]));
        logList = make_shared<QuerySummarySceneRuleLogResponseBodyDataLogList>(model1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QuerySummarySceneRuleLogResponseBodyData() = default;
};
class QuerySummarySceneRuleLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QuerySummarySceneRuleLogResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QuerySummarySceneRuleLogResponseBody() {}

  explicit QuerySummarySceneRuleLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QuerySummarySceneRuleLogResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QuerySummarySceneRuleLogResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QuerySummarySceneRuleLogResponseBody() = default;
};
class QuerySummarySceneRuleLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySummarySceneRuleLogResponseBody> body{};

  QuerySummarySceneRuleLogResponse() {}

  explicit QuerySummarySceneRuleLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySummarySceneRuleLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySummarySceneRuleLogResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySummarySceneRuleLogResponse() = default;
};
class QuerySuperDeviceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> iotInstanceId{};

  QuerySuperDeviceGroupRequest() {}

  explicit QuerySuperDeviceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~QuerySuperDeviceGroupRequest() = default;
};
class QuerySuperDeviceGroupResponseBodyDataGroupInfo : public Darabonba::Model {
public:
  shared_ptr<string> groupDesc{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};

  QuerySuperDeviceGroupResponseBodyDataGroupInfo() {}

  explicit QuerySuperDeviceGroupResponseBodyDataGroupInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupDesc) {
      res["GroupDesc"] = boost::any(*groupDesc);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupDesc") != m.end() && !m["GroupDesc"].empty()) {
      groupDesc = make_shared<string>(boost::any_cast<string>(m["GroupDesc"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~QuerySuperDeviceGroupResponseBodyDataGroupInfo() = default;
};
class QuerySuperDeviceGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySuperDeviceGroupResponseBodyDataGroupInfo>> groupInfo{};

  QuerySuperDeviceGroupResponseBodyData() {}

  explicit QuerySuperDeviceGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupInfo) {
      vector<boost::any> temp1;
      for(auto item1:*groupInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupInfo") != m.end() && !m["GroupInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupInfo"].type()) {
        vector<QuerySuperDeviceGroupResponseBodyDataGroupInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySuperDeviceGroupResponseBodyDataGroupInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupInfo = make_shared<vector<QuerySuperDeviceGroupResponseBodyDataGroupInfo>>(expect1);
      }
    }
  }


  virtual ~QuerySuperDeviceGroupResponseBodyData() = default;
};
class QuerySuperDeviceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QuerySuperDeviceGroupResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QuerySuperDeviceGroupResponseBody() {}

  explicit QuerySuperDeviceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QuerySuperDeviceGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QuerySuperDeviceGroupResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QuerySuperDeviceGroupResponseBody() = default;
};
class QuerySuperDeviceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySuperDeviceGroupResponseBody> body{};

  QuerySuperDeviceGroupResponse() {}

  explicit QuerySuperDeviceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySuperDeviceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySuperDeviceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySuperDeviceGroupResponse() = default;
};
class QueryTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> taskId{};

  QueryTaskRequest() {}

  explicit QueryTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~QueryTaskRequest() = default;
};
class QueryTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobName{};
  shared_ptr<string> message{};
  shared_ptr<string> productKey{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};
  shared_ptr<string> statusDetail{};
  shared_ptr<string> taskId{};
  shared_ptr<string> utcModified{};
  shared_ptr<string> utcQueueTime{};

  QueryTaskResponseBodyData() {}

  explicit QueryTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statusDetail) {
      res["StatusDetail"] = boost::any(*statusDetail);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (utcQueueTime) {
      res["UtcQueueTime"] = boost::any(*utcQueueTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StatusDetail") != m.end() && !m["StatusDetail"].empty()) {
      statusDetail = make_shared<string>(boost::any_cast<string>(m["StatusDetail"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("UtcQueueTime") != m.end() && !m["UtcQueueTime"].empty()) {
      utcQueueTime = make_shared<string>(boost::any_cast<string>(m["UtcQueueTime"]));
    }
  }


  virtual ~QueryTaskResponseBodyData() = default;
};
class QueryTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryTaskResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryTaskResponseBody() {}

  explicit QueryTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryTaskResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryTaskResponseBody() = default;
};
class QueryTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTaskResponseBody> body{};

  QueryTaskResponse() {}

  explicit QueryTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTaskResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTaskResponse() = default;
};
class QueryThingModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> functionBlockId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> modelVersion{};
  shared_ptr<string> productKey{};
  shared_ptr<string> resourceGroupId{};

  QueryThingModelRequest() {}

  explicit QueryThingModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (modelVersion) {
      res["ModelVersion"] = boost::any(*modelVersion);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ModelVersion") != m.end() && !m["ModelVersion"].empty()) {
      modelVersion = make_shared<string>(boost::any_cast<string>(m["ModelVersion"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~QueryThingModelRequest() = default;
};
class QueryThingModelResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> thingModelJson{};

  QueryThingModelResponseBodyData() {}

  explicit QueryThingModelResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (thingModelJson) {
      res["ThingModelJson"] = boost::any(*thingModelJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ThingModelJson") != m.end() && !m["ThingModelJson"].empty()) {
      thingModelJson = make_shared<string>(boost::any_cast<string>(m["ThingModelJson"]));
    }
  }


  virtual ~QueryThingModelResponseBodyData() = default;
};
class QueryThingModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryThingModelResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> productKey{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryThingModelResponseBody() {}

  explicit QueryThingModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryThingModelResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryThingModelResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryThingModelResponseBody() = default;
};
class QueryThingModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryThingModelResponseBody> body{};

  QueryThingModelResponse() {}

  explicit QueryThingModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryThingModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryThingModelResponseBody>(model1);
      }
    }
  }


  virtual ~QueryThingModelResponse() = default;
};
class QueryThingModelExtendConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> functionBlockId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> modelVersion{};
  shared_ptr<string> productKey{};
  shared_ptr<string> resourceGroupId{};

  QueryThingModelExtendConfigRequest() {}

  explicit QueryThingModelExtendConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (modelVersion) {
      res["ModelVersion"] = boost::any(*modelVersion);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ModelVersion") != m.end() && !m["ModelVersion"].empty()) {
      modelVersion = make_shared<string>(boost::any_cast<string>(m["ModelVersion"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~QueryThingModelExtendConfigRequest() = default;
};
class QueryThingModelExtendConfigResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> configuration{};

  QueryThingModelExtendConfigResponseBodyData() {}

  explicit QueryThingModelExtendConfigResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configuration) {
      res["Configuration"] = boost::any(*configuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configuration = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
  }


  virtual ~QueryThingModelExtendConfigResponseBodyData() = default;
};
class QueryThingModelExtendConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryThingModelExtendConfigResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryThingModelExtendConfigResponseBody() {}

  explicit QueryThingModelExtendConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryThingModelExtendConfigResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryThingModelExtendConfigResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryThingModelExtendConfigResponseBody() = default;
};
class QueryThingModelExtendConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryThingModelExtendConfigResponseBody> body{};

  QueryThingModelExtendConfigResponse() {}

  explicit QueryThingModelExtendConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryThingModelExtendConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryThingModelExtendConfigResponseBody>(model1);
      }
    }
  }


  virtual ~QueryThingModelExtendConfigResponse() = default;
};
class QueryThingModelExtendConfigPublishedRequest : public Darabonba::Model {
public:
  shared_ptr<string> functionBlockId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> modelVersion{};
  shared_ptr<string> productKey{};

  QueryThingModelExtendConfigPublishedRequest() {}

  explicit QueryThingModelExtendConfigPublishedRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (modelVersion) {
      res["ModelVersion"] = boost::any(*modelVersion);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ModelVersion") != m.end() && !m["ModelVersion"].empty()) {
      modelVersion = make_shared<string>(boost::any_cast<string>(m["ModelVersion"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryThingModelExtendConfigPublishedRequest() = default;
};
class QueryThingModelExtendConfigPublishedResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> configuration{};

  QueryThingModelExtendConfigPublishedResponseBodyData() {}

  explicit QueryThingModelExtendConfigPublishedResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configuration) {
      res["Configuration"] = boost::any(*configuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configuration = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
  }


  virtual ~QueryThingModelExtendConfigPublishedResponseBodyData() = default;
};
class QueryThingModelExtendConfigPublishedResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryThingModelExtendConfigPublishedResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryThingModelExtendConfigPublishedResponseBody() {}

  explicit QueryThingModelExtendConfigPublishedResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryThingModelExtendConfigPublishedResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryThingModelExtendConfigPublishedResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryThingModelExtendConfigPublishedResponseBody() = default;
};
class QueryThingModelExtendConfigPublishedResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryThingModelExtendConfigPublishedResponseBody> body{};

  QueryThingModelExtendConfigPublishedResponse() {}

  explicit QueryThingModelExtendConfigPublishedResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryThingModelExtendConfigPublishedResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryThingModelExtendConfigPublishedResponseBody>(model1);
      }
    }
  }


  virtual ~QueryThingModelExtendConfigPublishedResponse() = default;
};
class QueryThingModelPublishedRequest : public Darabonba::Model {
public:
  shared_ptr<string> functionBlockId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> modelVersion{};
  shared_ptr<string> productKey{};
  shared_ptr<string> resourceGroupId{};

  QueryThingModelPublishedRequest() {}

  explicit QueryThingModelPublishedRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (modelVersion) {
      res["ModelVersion"] = boost::any(*modelVersion);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ModelVersion") != m.end() && !m["ModelVersion"].empty()) {
      modelVersion = make_shared<string>(boost::any_cast<string>(m["ModelVersion"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~QueryThingModelPublishedRequest() = default;
};
class QueryThingModelPublishedResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> thingModelJson{};

  QueryThingModelPublishedResponseBodyData() {}

  explicit QueryThingModelPublishedResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (thingModelJson) {
      res["ThingModelJson"] = boost::any(*thingModelJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ThingModelJson") != m.end() && !m["ThingModelJson"].empty()) {
      thingModelJson = make_shared<string>(boost::any_cast<string>(m["ThingModelJson"]));
    }
  }


  virtual ~QueryThingModelPublishedResponseBodyData() = default;
};
class QueryThingModelPublishedResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryThingModelPublishedResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> productKey{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryThingModelPublishedResponseBody() {}

  explicit QueryThingModelPublishedResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryThingModelPublishedResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryThingModelPublishedResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryThingModelPublishedResponseBody() = default;
};
class QueryThingModelPublishedResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryThingModelPublishedResponseBody> body{};

  QueryThingModelPublishedResponse() {}

  explicit QueryThingModelPublishedResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryThingModelPublishedResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryThingModelPublishedResponseBody>(model1);
      }
    }
  }


  virtual ~QueryThingModelPublishedResponse() = default;
};
class QueryTopicConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  QueryTopicConfigRequest() {}

  explicit QueryTopicConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryTopicConfigRequest() = default;
};
class QueryTopicConfigResponseBodyDataTopicConfigInfo : public Darabonba::Model {
public:
  shared_ptr<string> codec{};
  shared_ptr<string> description{};
  shared_ptr<bool> enableBroadcast{};
  shared_ptr<bool> enableProxySubscribe{};
  shared_ptr<string> operation{};
  shared_ptr<string> productKey{};
  shared_ptr<string> topicFullName{};

  QueryTopicConfigResponseBodyDataTopicConfigInfo() {}

  explicit QueryTopicConfigResponseBodyDataTopicConfigInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enableBroadcast) {
      res["EnableBroadcast"] = boost::any(*enableBroadcast);
    }
    if (enableProxySubscribe) {
      res["EnableProxySubscribe"] = boost::any(*enableProxySubscribe);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (topicFullName) {
      res["TopicFullName"] = boost::any(*topicFullName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnableBroadcast") != m.end() && !m["EnableBroadcast"].empty()) {
      enableBroadcast = make_shared<bool>(boost::any_cast<bool>(m["EnableBroadcast"]));
    }
    if (m.find("EnableProxySubscribe") != m.end() && !m["EnableProxySubscribe"].empty()) {
      enableProxySubscribe = make_shared<bool>(boost::any_cast<bool>(m["EnableProxySubscribe"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("TopicFullName") != m.end() && !m["TopicFullName"].empty()) {
      topicFullName = make_shared<string>(boost::any_cast<string>(m["TopicFullName"]));
    }
  }


  virtual ~QueryTopicConfigResponseBodyDataTopicConfigInfo() = default;
};
class QueryTopicConfigResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTopicConfigResponseBodyDataTopicConfigInfo>> topicConfigInfo{};

  QueryTopicConfigResponseBodyData() {}

  explicit QueryTopicConfigResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topicConfigInfo) {
      vector<boost::any> temp1;
      for(auto item1:*topicConfigInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TopicConfigInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TopicConfigInfo") != m.end() && !m["TopicConfigInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["TopicConfigInfo"].type()) {
        vector<QueryTopicConfigResponseBodyDataTopicConfigInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TopicConfigInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTopicConfigResponseBodyDataTopicConfigInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topicConfigInfo = make_shared<vector<QueryTopicConfigResponseBodyDataTopicConfigInfo>>(expect1);
      }
    }
  }


  virtual ~QueryTopicConfigResponseBodyData() = default;
};
class QueryTopicConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryTopicConfigResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryTopicConfigResponseBody() {}

  explicit QueryTopicConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryTopicConfigResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryTopicConfigResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryTopicConfigResponseBody() = default;
};
class QueryTopicConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTopicConfigResponseBody> body{};

  QueryTopicConfigResponse() {}

  explicit QueryTopicConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTopicConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTopicConfigResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTopicConfigResponse() = default;
};
class QueryTopicReverseRouteTableRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> topic{};

  QueryTopicReverseRouteTableRequest() {}

  explicit QueryTopicReverseRouteTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~QueryTopicReverseRouteTableRequest() = default;
};
class QueryTopicReverseRouteTableResponseBodySrcTopics : public Darabonba::Model {
public:
  shared_ptr<vector<map<string, boost::any>>> topic{};

  QueryTopicReverseRouteTableResponseBodySrcTopics() {}

  explicit QueryTopicReverseRouteTableResponseBodySrcTopics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Topic"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Topic"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      topic = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
  }


  virtual ~QueryTopicReverseRouteTableResponseBodySrcTopics() = default;
};
class QueryTopicReverseRouteTableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryTopicReverseRouteTableResponseBodySrcTopics> srcTopics{};
  shared_ptr<bool> success{};

  QueryTopicReverseRouteTableResponseBody() {}

  explicit QueryTopicReverseRouteTableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (srcTopics) {
      res["SrcTopics"] = srcTopics ? boost::any(srcTopics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SrcTopics") != m.end() && !m["SrcTopics"].empty()) {
      if (typeid(map<string, boost::any>) == m["SrcTopics"].type()) {
        QueryTopicReverseRouteTableResponseBodySrcTopics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SrcTopics"]));
        srcTopics = make_shared<QueryTopicReverseRouteTableResponseBodySrcTopics>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryTopicReverseRouteTableResponseBody() = default;
};
class QueryTopicReverseRouteTableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTopicReverseRouteTableResponseBody> body{};

  QueryTopicReverseRouteTableResponse() {}

  explicit QueryTopicReverseRouteTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTopicReverseRouteTableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTopicReverseRouteTableResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTopicReverseRouteTableResponse() = default;
};
class QueryTopicRouteTableRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> topic{};

  QueryTopicRouteTableRequest() {}

  explicit QueryTopicRouteTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~QueryTopicRouteTableRequest() = default;
};
class QueryTopicRouteTableResponseBodyDstTopics : public Darabonba::Model {
public:
  shared_ptr<vector<map<string, boost::any>>> topic{};

  QueryTopicRouteTableResponseBodyDstTopics() {}

  explicit QueryTopicRouteTableResponseBodyDstTopics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Topic"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Topic"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      topic = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
  }


  virtual ~QueryTopicRouteTableResponseBodyDstTopics() = default;
};
class QueryTopicRouteTableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryTopicRouteTableResponseBodyDstTopics> dstTopics{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryTopicRouteTableResponseBody() {}

  explicit QueryTopicRouteTableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dstTopics) {
      res["DstTopics"] = dstTopics ? boost::any(dstTopics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DstTopics") != m.end() && !m["DstTopics"].empty()) {
      if (typeid(map<string, boost::any>) == m["DstTopics"].type()) {
        QueryTopicRouteTableResponseBodyDstTopics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DstTopics"]));
        dstTopics = make_shared<QueryTopicRouteTableResponseBodyDstTopics>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryTopicRouteTableResponseBody() = default;
};
class QueryTopicRouteTableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTopicRouteTableResponseBody> body{};

  QueryTopicRouteTableResponse() {}

  explicit QueryTopicRouteTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTopicRouteTableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTopicRouteTableResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTopicRouteTableResponse() = default;
};
class QueryVehicleDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  QueryVehicleDeviceRequest() {}

  explicit QueryVehicleDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryVehicleDeviceRequest() = default;
};
class QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData : public Darabonba::Model {
public:
  shared_ptr<string> authCode{};
  shared_ptr<string> city{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceModel{};
  shared_ptr<string> manufacturer{};
  shared_ptr<string> province{};
  shared_ptr<string> registerTime{};
  shared_ptr<string> status{};
  shared_ptr<string> vehicleColour{};
  shared_ptr<string> vehicleNumber{};

  QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData() {}

  explicit QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authCode) {
      res["AuthCode"] = boost::any(*authCode);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    if (manufacturer) {
      res["Manufacturer"] = boost::any(*manufacturer);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (registerTime) {
      res["RegisterTime"] = boost::any(*registerTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vehicleColour) {
      res["VehicleColour"] = boost::any(*vehicleColour);
    }
    if (vehicleNumber) {
      res["VehicleNumber"] = boost::any(*vehicleNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthCode") != m.end() && !m["AuthCode"].empty()) {
      authCode = make_shared<string>(boost::any_cast<string>(m["AuthCode"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
    if (m.find("Manufacturer") != m.end() && !m["Manufacturer"].empty()) {
      manufacturer = make_shared<string>(boost::any_cast<string>(m["Manufacturer"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("RegisterTime") != m.end() && !m["RegisterTime"].empty()) {
      registerTime = make_shared<string>(boost::any_cast<string>(m["RegisterTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VehicleColour") != m.end() && !m["VehicleColour"].empty()) {
      vehicleColour = make_shared<string>(boost::any_cast<string>(m["VehicleColour"]));
    }
    if (m.find("VehicleNumber") != m.end() && !m["VehicleNumber"].empty()) {
      vehicleNumber = make_shared<string>(boost::any_cast<string>(m["VehicleNumber"]));
    }
  }


  virtual ~QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData() = default;
};
class QueryVehicleDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData> jtProtocolDeviceData{};
  shared_ptr<long> modifiedTime{};
  shared_ptr<string> productKey{};
  shared_ptr<string> protocol{};

  QueryVehicleDeviceResponseBodyData() {}

  explicit QueryVehicleDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (jtProtocolDeviceData) {
      res["JtProtocolDeviceData"] = jtProtocolDeviceData ? boost::any(jtProtocolDeviceData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("JtProtocolDeviceData") != m.end() && !m["JtProtocolDeviceData"].empty()) {
      if (typeid(map<string, boost::any>) == m["JtProtocolDeviceData"].type()) {
        QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JtProtocolDeviceData"]));
        jtProtocolDeviceData = make_shared<QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData>(model1);
      }
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["ModifiedTime"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~QueryVehicleDeviceResponseBodyData() = default;
};
class QueryVehicleDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryVehicleDeviceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryVehicleDeviceResponseBody() {}

  explicit QueryVehicleDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryVehicleDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryVehicleDeviceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryVehicleDeviceResponseBody() = default;
};
class QueryVehicleDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryVehicleDeviceResponseBody> body{};

  QueryVehicleDeviceResponse() {}

  explicit QueryVehicleDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryVehicleDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryVehicleDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~QueryVehicleDeviceResponse() = default;
};
class RRpcRequest : public Darabonba::Model {
public:
  shared_ptr<string> contentType{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> requestBase64Byte{};
  shared_ptr<long> timeout{};
  shared_ptr<string> topic{};

  RRpcRequest() {}

  explicit RRpcRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (requestBase64Byte) {
      res["RequestBase64Byte"] = boost::any(*requestBase64Byte);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("RequestBase64Byte") != m.end() && !m["RequestBase64Byte"].empty()) {
      requestBase64Byte = make_shared<string>(boost::any_cast<string>(m["RequestBase64Byte"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~RRpcRequest() = default;
};
class RRpcResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> messageId{};
  shared_ptr<string> payloadBase64Byte{};
  shared_ptr<string> requestId{};
  shared_ptr<string> rrpcCode{};
  shared_ptr<bool> success{};

  RRpcResponseBody() {}

  explicit RRpcResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (payloadBase64Byte) {
      res["PayloadBase64Byte"] = boost::any(*payloadBase64Byte);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rrpcCode) {
      res["RrpcCode"] = boost::any(*rrpcCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<long>(boost::any_cast<long>(m["MessageId"]));
    }
    if (m.find("PayloadBase64Byte") != m.end() && !m["PayloadBase64Byte"].empty()) {
      payloadBase64Byte = make_shared<string>(boost::any_cast<string>(m["PayloadBase64Byte"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RrpcCode") != m.end() && !m["RrpcCode"].empty()) {
      rrpcCode = make_shared<string>(boost::any_cast<string>(m["RrpcCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RRpcResponseBody() = default;
};
class RRpcResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RRpcResponseBody> body{};

  RRpcResponse() {}

  explicit RRpcResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RRpcResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RRpcResponseBody>(model1);
      }
    }
  }


  virtual ~RRpcResponse() = default;
};
class ReBindLicenseDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> deviceNameList{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> licenseCode{};
  shared_ptr<string> productKey{};

  ReBindLicenseDeviceRequest() {}

  explicit ReBindLicenseDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceNameList) {
      res["DeviceNameList"] = boost::any(*deviceNameList);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (licenseCode) {
      res["LicenseCode"] = boost::any(*licenseCode);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceNameList") != m.end() && !m["DeviceNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("LicenseCode") != m.end() && !m["LicenseCode"].empty()) {
      licenseCode = make_shared<string>(boost::any_cast<string>(m["LicenseCode"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~ReBindLicenseDeviceRequest() = default;
};
class ReBindLicenseDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> checkProgressId{};
  shared_ptr<long> failSum{};
  shared_ptr<long> progress{};
  shared_ptr<string> resultCsvFile{};
  shared_ptr<long> successSum{};

  ReBindLicenseDeviceResponseBodyData() {}

  explicit ReBindLicenseDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkProgressId) {
      res["CheckProgressId"] = boost::any(*checkProgressId);
    }
    if (failSum) {
      res["FailSum"] = boost::any(*failSum);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (resultCsvFile) {
      res["ResultCsvFile"] = boost::any(*resultCsvFile);
    }
    if (successSum) {
      res["SuccessSum"] = boost::any(*successSum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckProgressId") != m.end() && !m["CheckProgressId"].empty()) {
      checkProgressId = make_shared<string>(boost::any_cast<string>(m["CheckProgressId"]));
    }
    if (m.find("FailSum") != m.end() && !m["FailSum"].empty()) {
      failSum = make_shared<long>(boost::any_cast<long>(m["FailSum"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("ResultCsvFile") != m.end() && !m["ResultCsvFile"].empty()) {
      resultCsvFile = make_shared<string>(boost::any_cast<string>(m["ResultCsvFile"]));
    }
    if (m.find("SuccessSum") != m.end() && !m["SuccessSum"].empty()) {
      successSum = make_shared<long>(boost::any_cast<long>(m["SuccessSum"]));
    }
  }


  virtual ~ReBindLicenseDeviceResponseBodyData() = default;
};
class ReBindLicenseDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ReBindLicenseDeviceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ReBindLicenseDeviceResponseBody() {}

  explicit ReBindLicenseDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ReBindLicenseDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ReBindLicenseDeviceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ReBindLicenseDeviceResponseBody() = default;
};
class ReBindLicenseDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReBindLicenseDeviceResponseBody> body{};

  ReBindLicenseDeviceResponse() {}

  explicit ReBindLicenseDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReBindLicenseDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReBindLicenseDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~ReBindLicenseDeviceResponse() = default;
};
class RecognizeCarNumRequest : public Darabonba::Model {
public:
  shared_ptr<string> url{};

  RecognizeCarNumRequest() {}

  explicit RecognizeCarNumRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~RecognizeCarNumRequest() = default;
};
class RecognizeCarNumResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RecognizeCarNumResponseBody() {}

  explicit RecognizeCarNumResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RecognizeCarNumResponseBody() = default;
};
class RecognizeCarNumResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RecognizeCarNumResponseBody> body{};

  RecognizeCarNumResponse() {}

  explicit RecognizeCarNumResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RecognizeCarNumResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RecognizeCarNumResponseBody>(model1);
      }
    }
  }


  virtual ~RecognizeCarNumResponse() = default;
};
class RecognizePictureGeneralRequest : public Darabonba::Model {
public:
  shared_ptr<string> url{};

  RecognizePictureGeneralRequest() {}

  explicit RecognizePictureGeneralRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~RecognizePictureGeneralRequest() = default;
};
class RecognizePictureGeneralResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RecognizePictureGeneralResponseBody() {}

  explicit RecognizePictureGeneralResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RecognizePictureGeneralResponseBody() = default;
};
class RecognizePictureGeneralResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RecognizePictureGeneralResponseBody> body{};

  RecognizePictureGeneralResponse() {}

  explicit RecognizePictureGeneralResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RecognizePictureGeneralResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RecognizePictureGeneralResponseBody>(model1);
      }
    }
  }


  virtual ~RecognizePictureGeneralResponse() = default;
};
class RefreshDeviceTunnelSharePasswordRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  RefreshDeviceTunnelSharePasswordRequest() {}

  explicit RefreshDeviceTunnelSharePasswordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~RefreshDeviceTunnelSharePasswordRequest() = default;
};
class RefreshDeviceTunnelSharePasswordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> password{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RefreshDeviceTunnelSharePasswordResponseBody() {}

  explicit RefreshDeviceTunnelSharePasswordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RefreshDeviceTunnelSharePasswordResponseBody() = default;
};
class RefreshDeviceTunnelSharePasswordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RefreshDeviceTunnelSharePasswordResponseBody> body{};

  RefreshDeviceTunnelSharePasswordResponse() {}

  explicit RefreshDeviceTunnelSharePasswordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefreshDeviceTunnelSharePasswordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefreshDeviceTunnelSharePasswordResponseBody>(model1);
      }
    }
  }


  virtual ~RefreshDeviceTunnelSharePasswordResponse() = default;
};
class RefreshStudioAppTokenOpenRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> projectId{};

  RefreshStudioAppTokenOpenRequest() {}

  explicit RefreshStudioAppTokenOpenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~RefreshStudioAppTokenOpenRequest() = default;
};
class RefreshStudioAppTokenOpenResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> bizType{};
  shared_ptr<string> isEnable{};
  shared_ptr<string> token{};
  shared_ptr<string> type{};

  RefreshStudioAppTokenOpenResponseBodyData() {}

  explicit RefreshStudioAppTokenOpenResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (isEnable) {
      res["IsEnable"] = boost::any(*isEnable);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("IsEnable") != m.end() && !m["IsEnable"].empty()) {
      isEnable = make_shared<string>(boost::any_cast<string>(m["IsEnable"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~RefreshStudioAppTokenOpenResponseBodyData() = default;
};
class RefreshStudioAppTokenOpenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<RefreshStudioAppTokenOpenResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RefreshStudioAppTokenOpenResponseBody() {}

  explicit RefreshStudioAppTokenOpenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        RefreshStudioAppTokenOpenResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<RefreshStudioAppTokenOpenResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RefreshStudioAppTokenOpenResponseBody() = default;
};
class RefreshStudioAppTokenOpenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RefreshStudioAppTokenOpenResponseBody> body{};

  RefreshStudioAppTokenOpenResponse() {}

  explicit RefreshStudioAppTokenOpenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefreshStudioAppTokenOpenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefreshStudioAppTokenOpenResponseBody>(model1);
      }
    }
  }


  virtual ~RefreshStudioAppTokenOpenResponse() = default;
};
class RegisterDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> appKey{};
  shared_ptr<string> devEui{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> joinEui{};
  shared_ptr<string> loraNodeType{};
  shared_ptr<string> nickname{};
  shared_ptr<string> pinCode{};
  shared_ptr<string> productKey{};

  RegisterDeviceRequest() {}

  explicit RegisterDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (devEui) {
      res["DevEui"] = boost::any(*devEui);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (joinEui) {
      res["JoinEui"] = boost::any(*joinEui);
    }
    if (loraNodeType) {
      res["LoraNodeType"] = boost::any(*loraNodeType);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    if (pinCode) {
      res["PinCode"] = boost::any(*pinCode);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("DevEui") != m.end() && !m["DevEui"].empty()) {
      devEui = make_shared<string>(boost::any_cast<string>(m["DevEui"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JoinEui") != m.end() && !m["JoinEui"].empty()) {
      joinEui = make_shared<string>(boost::any_cast<string>(m["JoinEui"]));
    }
    if (m.find("LoraNodeType") != m.end() && !m["LoraNodeType"].empty()) {
      loraNodeType = make_shared<string>(boost::any_cast<string>(m["LoraNodeType"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
    if (m.find("PinCode") != m.end() && !m["PinCode"].empty()) {
      pinCode = make_shared<string>(boost::any_cast<string>(m["PinCode"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~RegisterDeviceRequest() = default;
};
class RegisterDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> devEui{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceSecret{};
  shared_ptr<string> iotId{};
  shared_ptr<string> joinEui{};
  shared_ptr<string> nickname{};
  shared_ptr<string> productKey{};

  RegisterDeviceResponseBodyData() {}

  explicit RegisterDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (devEui) {
      res["DevEui"] = boost::any(*devEui);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceSecret) {
      res["DeviceSecret"] = boost::any(*deviceSecret);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (joinEui) {
      res["JoinEui"] = boost::any(*joinEui);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DevEui") != m.end() && !m["DevEui"].empty()) {
      devEui = make_shared<string>(boost::any_cast<string>(m["DevEui"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceSecret") != m.end() && !m["DeviceSecret"].empty()) {
      deviceSecret = make_shared<string>(boost::any_cast<string>(m["DeviceSecret"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("JoinEui") != m.end() && !m["JoinEui"].empty()) {
      joinEui = make_shared<string>(boost::any_cast<string>(m["JoinEui"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~RegisterDeviceResponseBodyData() = default;
};
class RegisterDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<RegisterDeviceResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RegisterDeviceResponseBody() {}

  explicit RegisterDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        RegisterDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<RegisterDeviceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RegisterDeviceResponseBody() = default;
};
class RegisterDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RegisterDeviceResponseBody> body{};

  RegisterDeviceResponse() {}

  explicit RegisterDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RegisterDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RegisterDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~RegisterDeviceResponse() = default;
};
class ReleaseEdgeDriverVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};
  shared_ptr<string> iotInstanceId{};

  ReleaseEdgeDriverVersionRequest() {}

  explicit ReleaseEdgeDriverVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~ReleaseEdgeDriverVersionRequest() = default;
};
class ReleaseEdgeDriverVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ReleaseEdgeDriverVersionResponseBody() {}

  explicit ReleaseEdgeDriverVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ReleaseEdgeDriverVersionResponseBody() = default;
};
class ReleaseEdgeDriverVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReleaseEdgeDriverVersionResponseBody> body{};

  ReleaseEdgeDriverVersionResponse() {}

  explicit ReleaseEdgeDriverVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseEdgeDriverVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseEdgeDriverVersionResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseEdgeDriverVersionResponse() = default;
};
class ReleaseProductRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  ReleaseProductRequest() {}

  explicit ReleaseProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~ReleaseProductRequest() = default;
};
class ReleaseProductResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ReleaseProductResponseBody() {}

  explicit ReleaseProductResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ReleaseProductResponseBody() = default;
};
class ReleaseProductResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReleaseProductResponseBody> body{};

  ReleaseProductResponse() {}

  explicit ReleaseProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseProductResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseProductResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseProductResponse() = default;
};
class RemoveThingTopoRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  RemoveThingTopoRequest() {}

  explicit RemoveThingTopoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~RemoveThingTopoRequest() = default;
};
class RemoveThingTopoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RemoveThingTopoResponseBody() {}

  explicit RemoveThingTopoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RemoveThingTopoResponseBody() = default;
};
class RemoveThingTopoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveThingTopoResponseBody> body{};

  RemoveThingTopoResponse() {}

  explicit RemoveThingTopoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveThingTopoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveThingTopoResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveThingTopoResponse() = default;
};
class ReplaceEdgeInstanceGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> currentGatewayId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> newGatewayId{};

  ReplaceEdgeInstanceGatewayRequest() {}

  explicit ReplaceEdgeInstanceGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentGatewayId) {
      res["CurrentGatewayId"] = boost::any(*currentGatewayId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (newGatewayId) {
      res["NewGatewayId"] = boost::any(*newGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentGatewayId") != m.end() && !m["CurrentGatewayId"].empty()) {
      currentGatewayId = make_shared<string>(boost::any_cast<string>(m["CurrentGatewayId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("NewGatewayId") != m.end() && !m["NewGatewayId"].empty()) {
      newGatewayId = make_shared<string>(boost::any_cast<string>(m["NewGatewayId"]));
    }
  }


  virtual ~ReplaceEdgeInstanceGatewayRequest() = default;
};
class ReplaceEdgeInstanceGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ReplaceEdgeInstanceGatewayResponseBody() {}

  explicit ReplaceEdgeInstanceGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ReplaceEdgeInstanceGatewayResponseBody() = default;
};
class ReplaceEdgeInstanceGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReplaceEdgeInstanceGatewayResponseBody> body{};

  ReplaceEdgeInstanceGatewayResponse() {}

  explicit ReplaceEdgeInstanceGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReplaceEdgeInstanceGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReplaceEdgeInstanceGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~ReplaceEdgeInstanceGatewayResponse() = default;
};
class RerunJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobId{};

  RerunJobRequest() {}

  explicit RerunJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~RerunJobRequest() = default;
};
class RerunJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RerunJobResponseBody() {}

  explicit RerunJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RerunJobResponseBody() = default;
};
class RerunJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RerunJobResponseBody> body{};

  RerunJobResponse() {}

  explicit RerunJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RerunJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RerunJobResponseBody>(model1);
      }
    }
  }


  virtual ~RerunJobResponse() = default;
};
class ResetConsumerGroupPositionRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> iotInstanceId{};

  ResetConsumerGroupPositionRequest() {}

  explicit ResetConsumerGroupPositionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~ResetConsumerGroupPositionRequest() = default;
};
class ResetConsumerGroupPositionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ResetConsumerGroupPositionResponseBody() {}

  explicit ResetConsumerGroupPositionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ResetConsumerGroupPositionResponseBody() = default;
};
class ResetConsumerGroupPositionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetConsumerGroupPositionResponseBody> body{};

  ResetConsumerGroupPositionResponse() {}

  explicit ResetConsumerGroupPositionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetConsumerGroupPositionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetConsumerGroupPositionResponseBody>(model1);
      }
    }
  }


  virtual ~ResetConsumerGroupPositionResponse() = default;
};
class ResetThingRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  ResetThingRequest() {}

  explicit ResetThingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~ResetThingRequest() = default;
};
class ResetThingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ResetThingResponseBody() {}

  explicit ResetThingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ResetThingResponseBody() = default;
};
class ResetThingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetThingResponseBody> body{};

  ResetThingResponse() {}

  explicit ResetThingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetThingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetThingResponseBody>(model1);
      }
    }
  }


  virtual ~ResetThingResponse() = default;
};
class RetrySoundCodeLabelBatchRequest : public Darabonba::Model {
public:
  shared_ptr<string> batchCode{};
  shared_ptr<string> iotInstanceId{};

  RetrySoundCodeLabelBatchRequest() {}

  explicit RetrySoundCodeLabelBatchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchCode) {
      res["BatchCode"] = boost::any(*batchCode);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchCode") != m.end() && !m["BatchCode"].empty()) {
      batchCode = make_shared<string>(boost::any_cast<string>(m["BatchCode"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~RetrySoundCodeLabelBatchRequest() = default;
};
class RetrySoundCodeLabelBatchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RetrySoundCodeLabelBatchResponseBody() {}

  explicit RetrySoundCodeLabelBatchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RetrySoundCodeLabelBatchResponseBody() = default;
};
class RetrySoundCodeLabelBatchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RetrySoundCodeLabelBatchResponseBody> body{};

  RetrySoundCodeLabelBatchResponse() {}

  explicit RetrySoundCodeLabelBatchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RetrySoundCodeLabelBatchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RetrySoundCodeLabelBatchResponseBody>(model1);
      }
    }
  }


  virtual ~RetrySoundCodeLabelBatchResponse() = default;
};
class ReupgradeOTATaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<vector<string>> taskId{};

  ReupgradeOTATaskRequest() {}

  explicit ReupgradeOTATaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TaskId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      taskId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ReupgradeOTATaskRequest() = default;
};
class ReupgradeOTATaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ReupgradeOTATaskResponseBody() {}

  explicit ReupgradeOTATaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ReupgradeOTATaskResponseBody() = default;
};
class ReupgradeOTATaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReupgradeOTATaskResponseBody> body{};

  ReupgradeOTATaskResponse() {}

  explicit ReupgradeOTATaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReupgradeOTATaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReupgradeOTATaskResponseBody>(model1);
      }
    }
  }


  virtual ~ReupgradeOTATaskResponse() = default;
};
class SaveDevicePropRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> props{};

  SaveDevicePropRequest() {}

  explicit SaveDevicePropRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (props) {
      res["Props"] = boost::any(*props);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Props") != m.end() && !m["Props"].empty()) {
      props = make_shared<string>(boost::any_cast<string>(m["Props"]));
    }
  }


  virtual ~SaveDevicePropRequest() = default;
};
class SaveDevicePropResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SaveDevicePropResponseBody() {}

  explicit SaveDevicePropResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SaveDevicePropResponseBody() = default;
};
class SaveDevicePropResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveDevicePropResponseBody> body{};

  SaveDevicePropResponse() {}

  explicit SaveDevicePropResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveDevicePropResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveDevicePropResponseBody>(model1);
      }
    }
  }


  virtual ~SaveDevicePropResponse() = default;
};
class SaveScriptRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> parserId{};
  shared_ptr<string> scriptDraft{};

  SaveScriptRequest() {}

  explicit SaveScriptRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (parserId) {
      res["ParserId"] = boost::any(*parserId);
    }
    if (scriptDraft) {
      res["ScriptDraft"] = boost::any(*scriptDraft);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ParserId") != m.end() && !m["ParserId"].empty()) {
      parserId = make_shared<long>(boost::any_cast<long>(m["ParserId"]));
    }
    if (m.find("ScriptDraft") != m.end() && !m["ScriptDraft"].empty()) {
      scriptDraft = make_shared<string>(boost::any_cast<string>(m["ScriptDraft"]));
    }
  }


  virtual ~SaveScriptRequest() = default;
};
class SaveScriptResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SaveScriptResponseBody() {}

  explicit SaveScriptResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SaveScriptResponseBody() = default;
};
class SaveScriptResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveScriptResponseBody> body{};

  SaveScriptResponse() {}

  explicit SaveScriptResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveScriptResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveScriptResponseBody>(model1);
      }
    }
  }


  virtual ~SaveScriptResponse() = default;
};
class SetDeviceDesiredPropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> items{};
  shared_ptr<string> productKey{};
  shared_ptr<string> versions{};

  SetDeviceDesiredPropertyRequest() {}

  explicit SetDeviceDesiredPropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (items) {
      res["Items"] = boost::any(*items);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (versions) {
      res["Versions"] = boost::any(*versions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      items = make_shared<string>(boost::any_cast<string>(m["Items"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Versions") != m.end() && !m["Versions"].empty()) {
      versions = make_shared<string>(boost::any_cast<string>(m["Versions"]));
    }
  }


  virtual ~SetDeviceDesiredPropertyRequest() = default;
};
class SetDeviceDesiredPropertyResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};
  shared_ptr<string> versions{};

  SetDeviceDesiredPropertyResponseBodyData() {}

  explicit SetDeviceDesiredPropertyResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (versions) {
      res["Versions"] = boost::any(*versions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("Versions") != m.end() && !m["Versions"].empty()) {
      versions = make_shared<string>(boost::any_cast<string>(m["Versions"]));
    }
  }


  virtual ~SetDeviceDesiredPropertyResponseBodyData() = default;
};
class SetDeviceDesiredPropertyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<SetDeviceDesiredPropertyResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SetDeviceDesiredPropertyResponseBody() {}

  explicit SetDeviceDesiredPropertyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SetDeviceDesiredPropertyResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SetDeviceDesiredPropertyResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SetDeviceDesiredPropertyResponseBody() = default;
};
class SetDeviceDesiredPropertyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDeviceDesiredPropertyResponseBody> body{};

  SetDeviceDesiredPropertyResponse() {}

  explicit SetDeviceDesiredPropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDeviceDesiredPropertyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDeviceDesiredPropertyResponseBody>(model1);
      }
    }
  }


  virtual ~SetDeviceDesiredPropertyResponse() = default;
};
class SetDeviceGroupTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> groupType{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> tagString{};

  SetDeviceGroupTagsRequest() {}

  explicit SetDeviceGroupTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (tagString) {
      res["TagString"] = boost::any(*tagString);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<string>(boost::any_cast<string>(m["GroupType"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("TagString") != m.end() && !m["TagString"].empty()) {
      tagString = make_shared<string>(boost::any_cast<string>(m["TagString"]));
    }
  }


  virtual ~SetDeviceGroupTagsRequest() = default;
};
class SetDeviceGroupTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SetDeviceGroupTagsResponseBody() {}

  explicit SetDeviceGroupTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SetDeviceGroupTagsResponseBody() = default;
};
class SetDeviceGroupTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDeviceGroupTagsResponseBody> body{};

  SetDeviceGroupTagsResponse() {}

  explicit SetDeviceGroupTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDeviceGroupTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDeviceGroupTagsResponseBody>(model1);
      }
    }
  }


  virtual ~SetDeviceGroupTagsResponse() = default;
};
class SetDevicePropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> items{};
  shared_ptr<string> productKey{};
  shared_ptr<long> qos{};

  SetDevicePropertyRequest() {}

  explicit SetDevicePropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (items) {
      res["Items"] = boost::any(*items);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (qos) {
      res["Qos"] = boost::any(*qos);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      items = make_shared<string>(boost::any_cast<string>(m["Items"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Qos") != m.end() && !m["Qos"].empty()) {
      qos = make_shared<long>(boost::any_cast<long>(m["Qos"]));
    }
  }


  virtual ~SetDevicePropertyRequest() = default;
};
class SetDevicePropertyResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};

  SetDevicePropertyResponseBodyData() {}

  explicit SetDevicePropertyResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~SetDevicePropertyResponseBodyData() = default;
};
class SetDevicePropertyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<SetDevicePropertyResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SetDevicePropertyResponseBody() {}

  explicit SetDevicePropertyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SetDevicePropertyResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SetDevicePropertyResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SetDevicePropertyResponseBody() = default;
};
class SetDevicePropertyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDevicePropertyResponseBody> body{};

  SetDevicePropertyResponse() {}

  explicit SetDevicePropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDevicePropertyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDevicePropertyResponseBody>(model1);
      }
    }
  }


  virtual ~SetDevicePropertyResponse() = default;
};
class SetDevicesPropertyRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> items{};
  shared_ptr<string> productKey{};

  SetDevicesPropertyRequest() {}

  explicit SetDevicesPropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (items) {
      res["Items"] = boost::any(*items);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      items = make_shared<string>(boost::any_cast<string>(m["Items"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~SetDevicesPropertyRequest() = default;
};
class SetDevicesPropertyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SetDevicesPropertyResponseBody() {}

  explicit SetDevicesPropertyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SetDevicesPropertyResponseBody() = default;
};
class SetDevicesPropertyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDevicesPropertyResponseBody> body{};

  SetDevicesPropertyResponse() {}

  explicit SetDevicesPropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDevicesPropertyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDevicesPropertyResponseBody>(model1);
      }
    }
  }


  virtual ~SetDevicesPropertyResponse() = default;
};
class SetEdgeInstanceDriverConfigsRequestConfigs : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> format{};
  shared_ptr<string> key{};

  SetEdgeInstanceDriverConfigsRequestConfigs() {}

  explicit SetEdgeInstanceDriverConfigsRequestConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~SetEdgeInstanceDriverConfigsRequestConfigs() = default;
};
class SetEdgeInstanceDriverConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<SetEdgeInstanceDriverConfigsRequestConfigs>> configs{};
  shared_ptr<string> driverId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};

  SetEdgeInstanceDriverConfigsRequest() {}

  explicit SetEdgeInstanceDriverConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configs) {
      vector<boost::any> temp1;
      for(auto item1:*configs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Configs"] = boost::any(temp1);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configs") != m.end() && !m["Configs"].empty()) {
      if (typeid(vector<boost::any>) == m["Configs"].type()) {
        vector<SetEdgeInstanceDriverConfigsRequestConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Configs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SetEdgeInstanceDriverConfigsRequestConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configs = make_shared<vector<SetEdgeInstanceDriverConfigsRequestConfigs>>(expect1);
      }
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~SetEdgeInstanceDriverConfigsRequest() = default;
};
class SetEdgeInstanceDriverConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SetEdgeInstanceDriverConfigsResponseBody() {}

  explicit SetEdgeInstanceDriverConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SetEdgeInstanceDriverConfigsResponseBody() = default;
};
class SetEdgeInstanceDriverConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetEdgeInstanceDriverConfigsResponseBody> body{};

  SetEdgeInstanceDriverConfigsResponse() {}

  explicit SetEdgeInstanceDriverConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetEdgeInstanceDriverConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetEdgeInstanceDriverConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~SetEdgeInstanceDriverConfigsResponse() = default;
};
class SetProductCertInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> issueModel{};
  shared_ptr<string> productKey{};

  SetProductCertInfoRequest() {}

  explicit SetProductCertInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (issueModel) {
      res["IssueModel"] = boost::any(*issueModel);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("IssueModel") != m.end() && !m["IssueModel"].empty()) {
      issueModel = make_shared<long>(boost::any_cast<long>(m["IssueModel"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~SetProductCertInfoRequest() = default;
};
class SetProductCertInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SetProductCertInfoResponseBody() {}

  explicit SetProductCertInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SetProductCertInfoResponseBody() = default;
};
class SetProductCertInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetProductCertInfoResponseBody> body{};

  SetProductCertInfoResponse() {}

  explicit SetProductCertInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetProductCertInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetProductCertInfoResponseBody>(model1);
      }
    }
  }


  virtual ~SetProductCertInfoResponse() = default;
};
class SetStudioProjectCooperationRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> status{};

  SetStudioProjectCooperationRequest() {}

  explicit SetStudioProjectCooperationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~SetStudioProjectCooperationRequest() = default;
};
class SetStudioProjectCooperationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SetStudioProjectCooperationResponseBody() {}

  explicit SetStudioProjectCooperationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SetStudioProjectCooperationResponseBody() = default;
};
class SetStudioProjectCooperationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetStudioProjectCooperationResponseBody> body{};

  SetStudioProjectCooperationResponse() {}

  explicit SetStudioProjectCooperationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetStudioProjectCooperationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetStudioProjectCooperationResponseBody>(model1);
      }
    }
  }


  virtual ~SetStudioProjectCooperationResponse() = default;
};
class SetupStudioAppAuthModeOpenRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> authMode{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> projectId{};

  SetupStudioAppAuthModeOpenRequest() {}

  explicit SetupStudioAppAuthModeOpenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (authMode) {
      res["AuthMode"] = boost::any(*authMode);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AuthMode") != m.end() && !m["AuthMode"].empty()) {
      authMode = make_shared<long>(boost::any_cast<long>(m["AuthMode"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~SetupStudioAppAuthModeOpenRequest() = default;
};
class SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> bizType{};
  shared_ptr<string> isEnable{};
  shared_ptr<string> token{};
  shared_ptr<string> type{};

  SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo() {}

  explicit SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (isEnable) {
      res["IsEnable"] = boost::any(*isEnable);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("IsEnable") != m.end() && !m["IsEnable"].empty()) {
      isEnable = make_shared<string>(boost::any_cast<string>(m["IsEnable"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo() = default;
};
class SetupStudioAppAuthModeOpenResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> authMode{};
  shared_ptr<SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo> tokenInfo{};

  SetupStudioAppAuthModeOpenResponseBodyData() {}

  explicit SetupStudioAppAuthModeOpenResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authMode) {
      res["AuthMode"] = boost::any(*authMode);
    }
    if (tokenInfo) {
      res["TokenInfo"] = tokenInfo ? boost::any(tokenInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthMode") != m.end() && !m["AuthMode"].empty()) {
      authMode = make_shared<long>(boost::any_cast<long>(m["AuthMode"]));
    }
    if (m.find("TokenInfo") != m.end() && !m["TokenInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TokenInfo"].type()) {
        SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TokenInfo"]));
        tokenInfo = make_shared<SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo>(model1);
      }
    }
  }


  virtual ~SetupStudioAppAuthModeOpenResponseBodyData() = default;
};
class SetupStudioAppAuthModeOpenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<SetupStudioAppAuthModeOpenResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SetupStudioAppAuthModeOpenResponseBody() {}

  explicit SetupStudioAppAuthModeOpenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SetupStudioAppAuthModeOpenResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SetupStudioAppAuthModeOpenResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SetupStudioAppAuthModeOpenResponseBody() = default;
};
class SetupStudioAppAuthModeOpenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetupStudioAppAuthModeOpenResponseBody> body{};

  SetupStudioAppAuthModeOpenResponse() {}

  explicit SetupStudioAppAuthModeOpenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetupStudioAppAuthModeOpenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetupStudioAppAuthModeOpenResponseBody>(model1);
      }
    }
  }


  virtual ~SetupStudioAppAuthModeOpenResponse() = default;
};
class ShareSpeechByCombinationRequest : public Darabonba::Model {
public:
  shared_ptr<string> audioFormat{};
  shared_ptr<vector<string>> combinationList{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> speechId{};

  ShareSpeechByCombinationRequest() {}

  explicit ShareSpeechByCombinationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFormat) {
      res["AudioFormat"] = boost::any(*audioFormat);
    }
    if (combinationList) {
      res["CombinationList"] = boost::any(*combinationList);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (speechId) {
      res["SpeechId"] = boost::any(*speechId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFormat") != m.end() && !m["AudioFormat"].empty()) {
      audioFormat = make_shared<string>(boost::any_cast<string>(m["AudioFormat"]));
    }
    if (m.find("CombinationList") != m.end() && !m["CombinationList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CombinationList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CombinationList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      combinationList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("SpeechId") != m.end() && !m["SpeechId"].empty()) {
      speechId = make_shared<string>(boost::any_cast<string>(m["SpeechId"]));
    }
  }


  virtual ~ShareSpeechByCombinationRequest() = default;
};
class ShareSpeechByCombinationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ShareSpeechByCombinationResponseBody() {}

  explicit ShareSpeechByCombinationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ShareSpeechByCombinationResponseBody() = default;
};
class ShareSpeechByCombinationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ShareSpeechByCombinationResponseBody> body{};

  ShareSpeechByCombinationResponse() {}

  explicit ShareSpeechByCombinationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ShareSpeechByCombinationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ShareSpeechByCombinationResponseBody>(model1);
      }
    }
  }


  virtual ~ShareSpeechByCombinationResponse() = default;
};
class SpeechByCombinationRequest : public Darabonba::Model {
public:
  shared_ptr<string> audioFormat{};
  shared_ptr<vector<string>> combinationList{};
  shared_ptr<string> deviceName{};
  shared_ptr<bool> enforceFlag{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> speechId{};

  SpeechByCombinationRequest() {}

  explicit SpeechByCombinationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFormat) {
      res["AudioFormat"] = boost::any(*audioFormat);
    }
    if (combinationList) {
      res["CombinationList"] = boost::any(*combinationList);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (enforceFlag) {
      res["EnforceFlag"] = boost::any(*enforceFlag);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (speechId) {
      res["SpeechId"] = boost::any(*speechId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFormat") != m.end() && !m["AudioFormat"].empty()) {
      audioFormat = make_shared<string>(boost::any_cast<string>(m["AudioFormat"]));
    }
    if (m.find("CombinationList") != m.end() && !m["CombinationList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CombinationList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CombinationList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      combinationList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("EnforceFlag") != m.end() && !m["EnforceFlag"].empty()) {
      enforceFlag = make_shared<bool>(boost::any_cast<bool>(m["EnforceFlag"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("SpeechId") != m.end() && !m["SpeechId"].empty()) {
      speechId = make_shared<string>(boost::any_cast<string>(m["SpeechId"]));
    }
  }


  virtual ~SpeechByCombinationRequest() = default;
};
class SpeechByCombinationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SpeechByCombinationResponseBody() {}

  explicit SpeechByCombinationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SpeechByCombinationResponseBody() = default;
};
class SpeechByCombinationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SpeechByCombinationResponseBody> body{};

  SpeechByCombinationResponse() {}

  explicit SpeechByCombinationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SpeechByCombinationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SpeechByCombinationResponseBody>(model1);
      }
    }
  }


  virtual ~SpeechByCombinationResponse() = default;
};
class SpeechBySynthesisRequest : public Darabonba::Model {
public:
  shared_ptr<string> audioFormat{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> speechId{};
  shared_ptr<long> speechRate{};
  shared_ptr<string> text{};
  shared_ptr<string> voice{};
  shared_ptr<long> volume{};

  SpeechBySynthesisRequest() {}

  explicit SpeechBySynthesisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFormat) {
      res["AudioFormat"] = boost::any(*audioFormat);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (speechId) {
      res["SpeechId"] = boost::any(*speechId);
    }
    if (speechRate) {
      res["SpeechRate"] = boost::any(*speechRate);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (voice) {
      res["Voice"] = boost::any(*voice);
    }
    if (volume) {
      res["Volume"] = boost::any(*volume);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFormat") != m.end() && !m["AudioFormat"].empty()) {
      audioFormat = make_shared<string>(boost::any_cast<string>(m["AudioFormat"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("SpeechId") != m.end() && !m["SpeechId"].empty()) {
      speechId = make_shared<string>(boost::any_cast<string>(m["SpeechId"]));
    }
    if (m.find("SpeechRate") != m.end() && !m["SpeechRate"].empty()) {
      speechRate = make_shared<long>(boost::any_cast<long>(m["SpeechRate"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Voice") != m.end() && !m["Voice"].empty()) {
      voice = make_shared<string>(boost::any_cast<string>(m["Voice"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      volume = make_shared<long>(boost::any_cast<long>(m["Volume"]));
    }
  }


  virtual ~SpeechBySynthesisRequest() = default;
};
class SpeechBySynthesisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SpeechBySynthesisResponseBody() {}

  explicit SpeechBySynthesisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SpeechBySynthesisResponseBody() = default;
};
class SpeechBySynthesisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SpeechBySynthesisResponseBody> body{};

  SpeechBySynthesisResponse() {}

  explicit SpeechBySynthesisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SpeechBySynthesisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SpeechBySynthesisResponseBody>(model1);
      }
    }
  }


  virtual ~SpeechBySynthesisResponse() = default;
};
class StartParserRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> parserId{};

  StartParserRequest() {}

  explicit StartParserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (parserId) {
      res["ParserId"] = boost::any(*parserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ParserId") != m.end() && !m["ParserId"].empty()) {
      parserId = make_shared<long>(boost::any_cast<long>(m["ParserId"]));
    }
  }


  virtual ~StartParserRequest() = default;
};
class StartParserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  StartParserResponseBody() {}

  explicit StartParserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~StartParserResponseBody() = default;
};
class StartParserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartParserResponseBody> body{};

  StartParserResponse() {}

  explicit StartParserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartParserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartParserResponseBody>(model1);
      }
    }
  }


  virtual ~StartParserResponse() = default;
};
class StartRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> ruleId{};

  StartRuleRequest() {}

  explicit StartRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~StartRuleRequest() = default;
};
class StartRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  StartRuleResponseBody() {}

  explicit StartRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~StartRuleResponseBody() = default;
};
class StartRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartRuleResponseBody> body{};

  StartRuleResponse() {}

  explicit StartRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartRuleResponseBody>(model1);
      }
    }
  }


  virtual ~StartRuleResponse() = default;
};
class StopParserRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> parserId{};

  StopParserRequest() {}

  explicit StopParserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (parserId) {
      res["ParserId"] = boost::any(*parserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ParserId") != m.end() && !m["ParserId"].empty()) {
      parserId = make_shared<long>(boost::any_cast<long>(m["ParserId"]));
    }
  }


  virtual ~StopParserRequest() = default;
};
class StopParserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  StopParserResponseBody() {}

  explicit StopParserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~StopParserResponseBody() = default;
};
class StopParserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopParserResponseBody> body{};

  StopParserResponse() {}

  explicit StopParserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopParserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopParserResponseBody>(model1);
      }
    }
  }


  virtual ~StopParserResponse() = default;
};
class StopRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> ruleId{};

  StopRuleRequest() {}

  explicit StopRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~StopRuleRequest() = default;
};
class StopRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  StopRuleResponseBody() {}

  explicit StopRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~StopRuleResponseBody() = default;
};
class StopRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopRuleResponseBody> body{};

  StopRuleResponse() {}

  explicit StopRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopRuleResponseBody>(model1);
      }
    }
  }


  virtual ~StopRuleResponse() = default;
};
class SubscribeTopicRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<vector<string>> topic{};

  SubscribeTopicRequest() {}

  explicit SubscribeTopicRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Topic"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Topic"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      topic = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~SubscribeTopicRequest() = default;
};
class SubscribeTopicResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SubscribeTopicResponseBody() {}

  explicit SubscribeTopicResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SubscribeTopicResponseBody() = default;
};
class SubscribeTopicResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubscribeTopicResponseBody> body{};

  SubscribeTopicResponse() {}

  explicit SubscribeTopicResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubscribeTopicResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubscribeTopicResponseBody>(model1);
      }
    }
  }


  virtual ~SubscribeTopicResponse() = default;
};
class SyncSpeechByCombinationRequest : public Darabonba::Model {
public:
  shared_ptr<string> audioFormat{};
  shared_ptr<vector<string>> combinationList{};
  shared_ptr<string> deviceName{};
  shared_ptr<bool> enforceFlag{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> speechId{};

  SyncSpeechByCombinationRequest() {}

  explicit SyncSpeechByCombinationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFormat) {
      res["AudioFormat"] = boost::any(*audioFormat);
    }
    if (combinationList) {
      res["CombinationList"] = boost::any(*combinationList);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (enforceFlag) {
      res["EnforceFlag"] = boost::any(*enforceFlag);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (speechId) {
      res["SpeechId"] = boost::any(*speechId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFormat") != m.end() && !m["AudioFormat"].empty()) {
      audioFormat = make_shared<string>(boost::any_cast<string>(m["AudioFormat"]));
    }
    if (m.find("CombinationList") != m.end() && !m["CombinationList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CombinationList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CombinationList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      combinationList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("EnforceFlag") != m.end() && !m["EnforceFlag"].empty()) {
      enforceFlag = make_shared<bool>(boost::any_cast<bool>(m["EnforceFlag"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("SpeechId") != m.end() && !m["SpeechId"].empty()) {
      speechId = make_shared<string>(boost::any_cast<string>(m["SpeechId"]));
    }
  }


  virtual ~SyncSpeechByCombinationRequest() = default;
};
class SyncSpeechByCombinationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> detail{};
  shared_ptr<string> deviceErrorCode{};
  shared_ptr<string> deviceErrorMessage{};
  shared_ptr<string> id{};
  shared_ptr<long> maxRetryCount{};
  shared_ptr<long> retryCount{};
  shared_ptr<bool> success{};

  SyncSpeechByCombinationResponseBodyData() {}

  explicit SyncSpeechByCombinationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (deviceErrorCode) {
      res["DeviceErrorCode"] = boost::any(*deviceErrorCode);
    }
    if (deviceErrorMessage) {
      res["DeviceErrorMessage"] = boost::any(*deviceErrorMessage);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (maxRetryCount) {
      res["MaxRetryCount"] = boost::any(*maxRetryCount);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["Detail"]));
    }
    if (m.find("DeviceErrorCode") != m.end() && !m["DeviceErrorCode"].empty()) {
      deviceErrorCode = make_shared<string>(boost::any_cast<string>(m["DeviceErrorCode"]));
    }
    if (m.find("DeviceErrorMessage") != m.end() && !m["DeviceErrorMessage"].empty()) {
      deviceErrorMessage = make_shared<string>(boost::any_cast<string>(m["DeviceErrorMessage"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MaxRetryCount") != m.end() && !m["MaxRetryCount"].empty()) {
      maxRetryCount = make_shared<long>(boost::any_cast<long>(m["MaxRetryCount"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<long>(boost::any_cast<long>(m["RetryCount"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SyncSpeechByCombinationResponseBodyData() = default;
};
class SyncSpeechByCombinationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<SyncSpeechByCombinationResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SyncSpeechByCombinationResponseBody() {}

  explicit SyncSpeechByCombinationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SyncSpeechByCombinationResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SyncSpeechByCombinationResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SyncSpeechByCombinationResponseBody() = default;
};
class SyncSpeechByCombinationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SyncSpeechByCombinationResponseBody> body{};

  SyncSpeechByCombinationResponse() {}

  explicit SyncSpeechByCombinationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SyncSpeechByCombinationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SyncSpeechByCombinationResponseBody>(model1);
      }
    }
  }


  virtual ~SyncSpeechByCombinationResponse() = default;
};
class TestSpeechRequest : public Darabonba::Model {
public:
  shared_ptr<string> audioFormat{};
  shared_ptr<bool> enableSoundCode{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> projectCode{};
  shared_ptr<map<string, boost::any>> soundCodeConfig{};
  shared_ptr<long> speechRate{};
  shared_ptr<string> speechType{};
  shared_ptr<string> text{};
  shared_ptr<string> voice{};
  shared_ptr<long> volume{};

  TestSpeechRequest() {}

  explicit TestSpeechRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFormat) {
      res["AudioFormat"] = boost::any(*audioFormat);
    }
    if (enableSoundCode) {
      res["EnableSoundCode"] = boost::any(*enableSoundCode);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (projectCode) {
      res["ProjectCode"] = boost::any(*projectCode);
    }
    if (soundCodeConfig) {
      res["SoundCodeConfig"] = boost::any(*soundCodeConfig);
    }
    if (speechRate) {
      res["SpeechRate"] = boost::any(*speechRate);
    }
    if (speechType) {
      res["SpeechType"] = boost::any(*speechType);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (voice) {
      res["Voice"] = boost::any(*voice);
    }
    if (volume) {
      res["Volume"] = boost::any(*volume);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFormat") != m.end() && !m["AudioFormat"].empty()) {
      audioFormat = make_shared<string>(boost::any_cast<string>(m["AudioFormat"]));
    }
    if (m.find("EnableSoundCode") != m.end() && !m["EnableSoundCode"].empty()) {
      enableSoundCode = make_shared<bool>(boost::any_cast<bool>(m["EnableSoundCode"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProjectCode") != m.end() && !m["ProjectCode"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["ProjectCode"]));
    }
    if (m.find("SoundCodeConfig") != m.end() && !m["SoundCodeConfig"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["SoundCodeConfig"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      soundCodeConfig = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("SpeechRate") != m.end() && !m["SpeechRate"].empty()) {
      speechRate = make_shared<long>(boost::any_cast<long>(m["SpeechRate"]));
    }
    if (m.find("SpeechType") != m.end() && !m["SpeechType"].empty()) {
      speechType = make_shared<string>(boost::any_cast<string>(m["SpeechType"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Voice") != m.end() && !m["Voice"].empty()) {
      voice = make_shared<string>(boost::any_cast<string>(m["Voice"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      volume = make_shared<long>(boost::any_cast<long>(m["Volume"]));
    }
  }


  virtual ~TestSpeechRequest() = default;
};
class TestSpeechShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> audioFormat{};
  shared_ptr<bool> enableSoundCode{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> soundCodeConfigShrink{};
  shared_ptr<long> speechRate{};
  shared_ptr<string> speechType{};
  shared_ptr<string> text{};
  shared_ptr<string> voice{};
  shared_ptr<long> volume{};

  TestSpeechShrinkRequest() {}

  explicit TestSpeechShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFormat) {
      res["AudioFormat"] = boost::any(*audioFormat);
    }
    if (enableSoundCode) {
      res["EnableSoundCode"] = boost::any(*enableSoundCode);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (projectCode) {
      res["ProjectCode"] = boost::any(*projectCode);
    }
    if (soundCodeConfigShrink) {
      res["SoundCodeConfig"] = boost::any(*soundCodeConfigShrink);
    }
    if (speechRate) {
      res["SpeechRate"] = boost::any(*speechRate);
    }
    if (speechType) {
      res["SpeechType"] = boost::any(*speechType);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (voice) {
      res["Voice"] = boost::any(*voice);
    }
    if (volume) {
      res["Volume"] = boost::any(*volume);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFormat") != m.end() && !m["AudioFormat"].empty()) {
      audioFormat = make_shared<string>(boost::any_cast<string>(m["AudioFormat"]));
    }
    if (m.find("EnableSoundCode") != m.end() && !m["EnableSoundCode"].empty()) {
      enableSoundCode = make_shared<bool>(boost::any_cast<bool>(m["EnableSoundCode"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProjectCode") != m.end() && !m["ProjectCode"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["ProjectCode"]));
    }
    if (m.find("SoundCodeConfig") != m.end() && !m["SoundCodeConfig"].empty()) {
      soundCodeConfigShrink = make_shared<string>(boost::any_cast<string>(m["SoundCodeConfig"]));
    }
    if (m.find("SpeechRate") != m.end() && !m["SpeechRate"].empty()) {
      speechRate = make_shared<long>(boost::any_cast<long>(m["SpeechRate"]));
    }
    if (m.find("SpeechType") != m.end() && !m["SpeechType"].empty()) {
      speechType = make_shared<string>(boost::any_cast<string>(m["SpeechType"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Voice") != m.end() && !m["Voice"].empty()) {
      voice = make_shared<string>(boost::any_cast<string>(m["Voice"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      volume = make_shared<long>(boost::any_cast<long>(m["Volume"]));
    }
  }


  virtual ~TestSpeechShrinkRequest() = default;
};
class TestSpeechResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> items{};

  TestSpeechResponseBodyData() {}

  explicit TestSpeechResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      res["items"] = boost::any(*items);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("items") != m.end() && !m["items"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["items"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      items = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~TestSpeechResponseBodyData() = default;
};
class TestSpeechResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<TestSpeechResponseBodyData> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  TestSpeechResponseBody() {}

  explicit TestSpeechResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        TestSpeechResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<TestSpeechResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~TestSpeechResponseBody() = default;
};
class TestSpeechResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TestSpeechResponseBody> body{};

  TestSpeechResponse() {}

  explicit TestSpeechResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TestSpeechResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TestSpeechResponseBody>(model1);
      }
    }
  }


  virtual ~TestSpeechResponse() = default;
};
class TestSwitchRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  TestSwitchRequest() {}

  explicit TestSwitchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~TestSwitchRequest() = default;
};
class TestSwitchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> iotId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  TestSwitchResponseBody() {}

  explicit TestSwitchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~TestSwitchResponseBody() = default;
};
class TestSwitchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TestSwitchResponseBody> body{};

  TestSwitchResponse() {}

  explicit TestSwitchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TestSwitchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TestSwitchResponseBody>(model1);
      }
    }
  }


  virtual ~TestSwitchResponse() = default;
};
class TransformClientIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientId{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};

  TransformClientIdRequest() {}

  explicit TransformClientIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~TransformClientIdRequest() = default;
};
class TransformClientIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  TransformClientIdResponseBody() {}

  explicit TransformClientIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~TransformClientIdResponseBody() = default;
};
class TransformClientIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TransformClientIdResponseBody> body{};

  TransformClientIdResponse() {}

  explicit TransformClientIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TransformClientIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TransformClientIdResponseBody>(model1);
      }
    }
  }


  virtual ~TransformClientIdResponse() = default;
};
class TriggerSceneRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> ruleId{};

  TriggerSceneRuleRequest() {}

  explicit TriggerSceneRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~TriggerSceneRuleRequest() = default;
};
class TriggerSceneRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  TriggerSceneRuleResponseBody() {}

  explicit TriggerSceneRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~TriggerSceneRuleResponseBody() = default;
};
class TriggerSceneRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TriggerSceneRuleResponseBody> body{};

  TriggerSceneRuleResponse() {}

  explicit TriggerSceneRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TriggerSceneRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TriggerSceneRuleResponseBody>(model1);
      }
    }
  }


  virtual ~TriggerSceneRuleResponse() = default;
};
class UnbindApplicationFromEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};

  UnbindApplicationFromEdgeInstanceRequest() {}

  explicit UnbindApplicationFromEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~UnbindApplicationFromEdgeInstanceRequest() = default;
};
class UnbindApplicationFromEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UnbindApplicationFromEdgeInstanceResponseBody() {}

  explicit UnbindApplicationFromEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UnbindApplicationFromEdgeInstanceResponseBody() = default;
};
class UnbindApplicationFromEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnbindApplicationFromEdgeInstanceResponseBody> body{};

  UnbindApplicationFromEdgeInstanceResponse() {}

  explicit UnbindApplicationFromEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindApplicationFromEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindApplicationFromEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindApplicationFromEdgeInstanceResponse() = default;
};
class UnbindDriverFromEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> driverId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};

  UnbindDriverFromEdgeInstanceRequest() {}

  explicit UnbindDriverFromEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~UnbindDriverFromEdgeInstanceRequest() = default;
};
class UnbindDriverFromEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UnbindDriverFromEdgeInstanceResponseBody() {}

  explicit UnbindDriverFromEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UnbindDriverFromEdgeInstanceResponseBody() = default;
};
class UnbindDriverFromEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnbindDriverFromEdgeInstanceResponseBody> body{};

  UnbindDriverFromEdgeInstanceResponse() {}

  explicit UnbindDriverFromEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindDriverFromEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindDriverFromEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindDriverFromEdgeInstanceResponse() = default;
};
class UnbindLicenseProductRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> licenseCode{};
  shared_ptr<string> productKey{};

  UnbindLicenseProductRequest() {}

  explicit UnbindLicenseProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (licenseCode) {
      res["LicenseCode"] = boost::any(*licenseCode);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("LicenseCode") != m.end() && !m["LicenseCode"].empty()) {
      licenseCode = make_shared<string>(boost::any_cast<string>(m["LicenseCode"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~UnbindLicenseProductRequest() = default;
};
class UnbindLicenseProductResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UnbindLicenseProductResponseBody() {}

  explicit UnbindLicenseProductResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UnbindLicenseProductResponseBody() = default;
};
class UnbindLicenseProductResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnbindLicenseProductResponseBody> body{};

  UnbindLicenseProductResponse() {}

  explicit UnbindLicenseProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindLicenseProductResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindLicenseProductResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindLicenseProductResponse() = default;
};
class UnbindRoleFromEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};

  UnbindRoleFromEdgeInstanceRequest() {}

  explicit UnbindRoleFromEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~UnbindRoleFromEdgeInstanceRequest() = default;
};
class UnbindRoleFromEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UnbindRoleFromEdgeInstanceResponseBody() {}

  explicit UnbindRoleFromEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UnbindRoleFromEdgeInstanceResponseBody() = default;
};
class UnbindRoleFromEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnbindRoleFromEdgeInstanceResponseBody> body{};

  UnbindRoleFromEdgeInstanceResponse() {}

  explicit UnbindRoleFromEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindRoleFromEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindRoleFromEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindRoleFromEdgeInstanceResponse() = default;
};
class UnbindSceneRuleFromEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> ruleId{};

  UnbindSceneRuleFromEdgeInstanceRequest() {}

  explicit UnbindSceneRuleFromEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~UnbindSceneRuleFromEdgeInstanceRequest() = default;
};
class UnbindSceneRuleFromEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UnbindSceneRuleFromEdgeInstanceResponseBody() {}

  explicit UnbindSceneRuleFromEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UnbindSceneRuleFromEdgeInstanceResponseBody() = default;
};
class UnbindSceneRuleFromEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnbindSceneRuleFromEdgeInstanceResponseBody> body{};

  UnbindSceneRuleFromEdgeInstanceResponse() {}

  explicit UnbindSceneRuleFromEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindSceneRuleFromEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindSceneRuleFromEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindSceneRuleFromEdgeInstanceResponse() = default;
};
class UpdateConsumerGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> newGroupName{};

  UpdateConsumerGroupRequest() {}

  explicit UpdateConsumerGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (newGroupName) {
      res["NewGroupName"] = boost::any(*newGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("NewGroupName") != m.end() && !m["NewGroupName"].empty()) {
      newGroupName = make_shared<string>(boost::any_cast<string>(m["NewGroupName"]));
    }
  }


  virtual ~UpdateConsumerGroupRequest() = default;
};
class UpdateConsumerGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateConsumerGroupResponseBody() {}

  explicit UpdateConsumerGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateConsumerGroupResponseBody() = default;
};
class UpdateConsumerGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateConsumerGroupResponseBody> body{};

  UpdateConsumerGroupResponse() {}

  explicit UpdateConsumerGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateConsumerGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateConsumerGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateConsumerGroupResponse() = default;
};
class UpdateDestinationRequest : public Darabonba::Model {
public:
  shared_ptr<string> configuration{};
  shared_ptr<string> description{};
  shared_ptr<long> destinationId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  UpdateDestinationRequest() {}

  explicit UpdateDestinationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configuration) {
      res["Configuration"] = boost::any(*configuration);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destinationId) {
      res["DestinationId"] = boost::any(*destinationId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configuration = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestinationId") != m.end() && !m["DestinationId"].empty()) {
      destinationId = make_shared<long>(boost::any_cast<long>(m["DestinationId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateDestinationRequest() = default;
};
class UpdateDestinationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateDestinationResponseBody() {}

  explicit UpdateDestinationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateDestinationResponseBody() = default;
};
class UpdateDestinationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDestinationResponseBody> body{};

  UpdateDestinationResponse() {}

  explicit UpdateDestinationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDestinationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDestinationResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDestinationResponse() = default;
};
class UpdateDeviceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupDesc{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupType{};
  shared_ptr<string> iotInstanceId{};

  UpdateDeviceGroupRequest() {}

  explicit UpdateDeviceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupDesc) {
      res["GroupDesc"] = boost::any(*groupDesc);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupDesc") != m.end() && !m["GroupDesc"].empty()) {
      groupDesc = make_shared<string>(boost::any_cast<string>(m["GroupDesc"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<string>(boost::any_cast<string>(m["GroupType"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~UpdateDeviceGroupRequest() = default;
};
class UpdateDeviceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateDeviceGroupResponseBody() {}

  explicit UpdateDeviceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateDeviceGroupResponseBody() = default;
};
class UpdateDeviceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDeviceGroupResponseBody> body{};

  UpdateDeviceGroupResponse() {}

  explicit UpdateDeviceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDeviceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDeviceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDeviceGroupResponse() = default;
};
class UpdateDeviceShadowRequest : public Darabonba::Model {
public:
  shared_ptr<bool> deltaUpdate{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> shadowMessage{};

  UpdateDeviceShadowRequest() {}

  explicit UpdateDeviceShadowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deltaUpdate) {
      res["DeltaUpdate"] = boost::any(*deltaUpdate);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (shadowMessage) {
      res["ShadowMessage"] = boost::any(*shadowMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeltaUpdate") != m.end() && !m["DeltaUpdate"].empty()) {
      deltaUpdate = make_shared<bool>(boost::any_cast<bool>(m["DeltaUpdate"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ShadowMessage") != m.end() && !m["ShadowMessage"].empty()) {
      shadowMessage = make_shared<string>(boost::any_cast<string>(m["ShadowMessage"]));
    }
  }


  virtual ~UpdateDeviceShadowRequest() = default;
};
class UpdateDeviceShadowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateDeviceShadowResponseBody() {}

  explicit UpdateDeviceShadowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateDeviceShadowResponseBody() = default;
};
class UpdateDeviceShadowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDeviceShadowResponseBody> body{};

  UpdateDeviceShadowResponse() {}

  explicit UpdateDeviceShadowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDeviceShadowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDeviceShadowResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDeviceShadowResponse() = default;
};
class UpdateEdgeDriverVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> argument{};
  shared_ptr<string> configCheckRule{};
  shared_ptr<string> containerConfig{};
  shared_ptr<string> description{};
  shared_ptr<string> driverConfig{};
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};
  shared_ptr<string> edgeVersion{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> sourceConfig{};

  UpdateEdgeDriverVersionRequest() {}

  explicit UpdateEdgeDriverVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (argument) {
      res["Argument"] = boost::any(*argument);
    }
    if (configCheckRule) {
      res["ConfigCheckRule"] = boost::any(*configCheckRule);
    }
    if (containerConfig) {
      res["ContainerConfig"] = boost::any(*containerConfig);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (driverConfig) {
      res["DriverConfig"] = boost::any(*driverConfig);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    if (edgeVersion) {
      res["EdgeVersion"] = boost::any(*edgeVersion);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (sourceConfig) {
      res["SourceConfig"] = boost::any(*sourceConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Argument") != m.end() && !m["Argument"].empty()) {
      argument = make_shared<string>(boost::any_cast<string>(m["Argument"]));
    }
    if (m.find("ConfigCheckRule") != m.end() && !m["ConfigCheckRule"].empty()) {
      configCheckRule = make_shared<string>(boost::any_cast<string>(m["ConfigCheckRule"]));
    }
    if (m.find("ContainerConfig") != m.end() && !m["ContainerConfig"].empty()) {
      containerConfig = make_shared<string>(boost::any_cast<string>(m["ContainerConfig"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DriverConfig") != m.end() && !m["DriverConfig"].empty()) {
      driverConfig = make_shared<string>(boost::any_cast<string>(m["DriverConfig"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
    if (m.find("EdgeVersion") != m.end() && !m["EdgeVersion"].empty()) {
      edgeVersion = make_shared<string>(boost::any_cast<string>(m["EdgeVersion"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("SourceConfig") != m.end() && !m["SourceConfig"].empty()) {
      sourceConfig = make_shared<string>(boost::any_cast<string>(m["SourceConfig"]));
    }
  }


  virtual ~UpdateEdgeDriverVersionRequest() = default;
};
class UpdateEdgeDriverVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateEdgeDriverVersionResponseBody() {}

  explicit UpdateEdgeDriverVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateEdgeDriverVersionResponseBody() = default;
};
class UpdateEdgeDriverVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateEdgeDriverVersionResponseBody> body{};

  UpdateEdgeDriverVersionResponse() {}

  explicit UpdateEdgeDriverVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateEdgeDriverVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateEdgeDriverVersionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateEdgeDriverVersionResponse() = default;
};
class UpdateEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<bool> bizEnable{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> spec{};
  shared_ptr<string> tags{};

  UpdateEdgeInstanceRequest() {}

  explicit UpdateEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizEnable) {
      res["BizEnable"] = boost::any(*bizEnable);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizEnable") != m.end() && !m["BizEnable"].empty()) {
      bizEnable = make_shared<bool>(boost::any_cast<bool>(m["BizEnable"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<long>(boost::any_cast<long>(m["Spec"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~UpdateEdgeInstanceRequest() = default;
};
class UpdateEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateEdgeInstanceResponseBody() {}

  explicit UpdateEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateEdgeInstanceResponseBody() = default;
};
class UpdateEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateEdgeInstanceResponseBody> body{};

  UpdateEdgeInstanceResponse() {}

  explicit UpdateEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateEdgeInstanceResponse() = default;
};
class UpdateEdgeInstanceChannelRequestConfigs : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> format{};
  shared_ptr<string> key{};

  UpdateEdgeInstanceChannelRequestConfigs() {}

  explicit UpdateEdgeInstanceChannelRequestConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~UpdateEdgeInstanceChannelRequestConfigs() = default;
};
class UpdateEdgeInstanceChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> channelName{};
  shared_ptr<vector<UpdateEdgeInstanceChannelRequestConfigs>> configs{};
  shared_ptr<string> driverId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};

  UpdateEdgeInstanceChannelRequest() {}

  explicit UpdateEdgeInstanceChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (configs) {
      vector<boost::any> temp1;
      for(auto item1:*configs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Configs"] = boost::any(temp1);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("Configs") != m.end() && !m["Configs"].empty()) {
      if (typeid(vector<boost::any>) == m["Configs"].type()) {
        vector<UpdateEdgeInstanceChannelRequestConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Configs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateEdgeInstanceChannelRequestConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configs = make_shared<vector<UpdateEdgeInstanceChannelRequestConfigs>>(expect1);
      }
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~UpdateEdgeInstanceChannelRequest() = default;
};
class UpdateEdgeInstanceChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateEdgeInstanceChannelResponseBody() {}

  explicit UpdateEdgeInstanceChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateEdgeInstanceChannelResponseBody() = default;
};
class UpdateEdgeInstanceChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateEdgeInstanceChannelResponseBody> body{};

  UpdateEdgeInstanceChannelResponse() {}

  explicit UpdateEdgeInstanceChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateEdgeInstanceChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateEdgeInstanceChannelResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateEdgeInstanceChannelResponse() = default;
};
class UpdateEdgeInstanceMessageRoutingRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> routeId{};
  shared_ptr<string> sourceData{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> targetData{};
  shared_ptr<long> targetIotHubQos{};
  shared_ptr<string> targetType{};
  shared_ptr<string> topicFilter{};

  UpdateEdgeInstanceMessageRoutingRequest() {}

  explicit UpdateEdgeInstanceMessageRoutingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    if (sourceData) {
      res["SourceData"] = boost::any(*sourceData);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (targetData) {
      res["TargetData"] = boost::any(*targetData);
    }
    if (targetIotHubQos) {
      res["TargetIotHubQos"] = boost::any(*targetIotHubQos);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (topicFilter) {
      res["TopicFilter"] = boost::any(*topicFilter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<long>(boost::any_cast<long>(m["RouteId"]));
    }
    if (m.find("SourceData") != m.end() && !m["SourceData"].empty()) {
      sourceData = make_shared<string>(boost::any_cast<string>(m["SourceData"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("TargetData") != m.end() && !m["TargetData"].empty()) {
      targetData = make_shared<string>(boost::any_cast<string>(m["TargetData"]));
    }
    if (m.find("TargetIotHubQos") != m.end() && !m["TargetIotHubQos"].empty()) {
      targetIotHubQos = make_shared<long>(boost::any_cast<long>(m["TargetIotHubQos"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("TopicFilter") != m.end() && !m["TopicFilter"].empty()) {
      topicFilter = make_shared<string>(boost::any_cast<string>(m["TopicFilter"]));
    }
  }


  virtual ~UpdateEdgeInstanceMessageRoutingRequest() = default;
};
class UpdateEdgeInstanceMessageRoutingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateEdgeInstanceMessageRoutingResponseBody() {}

  explicit UpdateEdgeInstanceMessageRoutingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateEdgeInstanceMessageRoutingResponseBody() = default;
};
class UpdateEdgeInstanceMessageRoutingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateEdgeInstanceMessageRoutingResponseBody> body{};

  UpdateEdgeInstanceMessageRoutingResponse() {}

  explicit UpdateEdgeInstanceMessageRoutingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateEdgeInstanceMessageRoutingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateEdgeInstanceMessageRoutingResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateEdgeInstanceMessageRoutingResponse() = default;
};
class UpdateJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<map<string, boost::any>> rolloutConfig{};
  shared_ptr<map<string, boost::any>> timeoutConfig{};

  UpdateJobRequest() {}

  explicit UpdateJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (rolloutConfig) {
      res["RolloutConfig"] = boost::any(*rolloutConfig);
    }
    if (timeoutConfig) {
      res["TimeoutConfig"] = boost::any(*timeoutConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RolloutConfig") != m.end() && !m["RolloutConfig"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["RolloutConfig"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      rolloutConfig = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("TimeoutConfig") != m.end() && !m["TimeoutConfig"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["TimeoutConfig"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      timeoutConfig = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~UpdateJobRequest() = default;
};
class UpdateJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> rolloutConfigShrink{};
  shared_ptr<string> timeoutConfigShrink{};

  UpdateJobShrinkRequest() {}

  explicit UpdateJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (rolloutConfigShrink) {
      res["RolloutConfig"] = boost::any(*rolloutConfigShrink);
    }
    if (timeoutConfigShrink) {
      res["TimeoutConfig"] = boost::any(*timeoutConfigShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RolloutConfig") != m.end() && !m["RolloutConfig"].empty()) {
      rolloutConfigShrink = make_shared<string>(boost::any_cast<string>(m["RolloutConfig"]));
    }
    if (m.find("TimeoutConfig") != m.end() && !m["TimeoutConfig"].empty()) {
      timeoutConfigShrink = make_shared<string>(boost::any_cast<string>(m["TimeoutConfig"]));
    }
  }


  virtual ~UpdateJobShrinkRequest() = default;
};
class UpdateJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateJobResponseBody() {}

  explicit UpdateJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateJobResponseBody() = default;
};
class UpdateJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateJobResponseBody> body{};

  UpdateJobResponse() {}

  explicit UpdateJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateJobResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateJobResponse() = default;
};
class UpdateOTAModuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<string> desc{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> moduleName{};
  shared_ptr<string> productKey{};

  UpdateOTAModuleRequest() {}

  explicit UpdateOTAModuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~UpdateOTAModuleRequest() = default;
};
class UpdateOTAModuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateOTAModuleResponseBody() {}

  explicit UpdateOTAModuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateOTAModuleResponseBody() = default;
};
class UpdateOTAModuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateOTAModuleResponseBody> body{};

  UpdateOTAModuleResponse() {}

  explicit UpdateOTAModuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateOTAModuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateOTAModuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateOTAModuleResponse() = default;
};
class UpdateParserRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> parserId{};

  UpdateParserRequest() {}

  explicit UpdateParserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parserId) {
      res["ParserId"] = boost::any(*parserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParserId") != m.end() && !m["ParserId"].empty()) {
      parserId = make_shared<long>(boost::any_cast<long>(m["ParserId"]));
    }
  }


  virtual ~UpdateParserRequest() = default;
};
class UpdateParserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateParserResponseBody() {}

  explicit UpdateParserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateParserResponseBody() = default;
};
class UpdateParserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateParserResponseBody> body{};

  UpdateParserResponse() {}

  explicit UpdateParserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateParserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateParserResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateParserResponse() = default;
};
class UpdateParserDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> description{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> name{};

  UpdateParserDataSourceRequest() {}

  explicit UpdateParserDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UpdateParserDataSourceRequest() = default;
};
class UpdateParserDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateParserDataSourceResponseBody() {}

  explicit UpdateParserDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateParserDataSourceResponseBody() = default;
};
class UpdateParserDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateParserDataSourceResponseBody> body{};

  UpdateParserDataSourceResponse() {}

  explicit UpdateParserDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateParserDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateParserDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateParserDataSourceResponse() = default;
};
class UpdateProductRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};

  UpdateProductRequest() {}

  explicit UpdateProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
  }


  virtual ~UpdateProductRequest() = default;
};
class UpdateProductResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateProductResponseBody() {}

  explicit UpdateProductResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateProductResponseBody() = default;
};
class UpdateProductResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateProductResponseBody> body{};

  UpdateProductResponse() {}

  explicit UpdateProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateProductResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateProductResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateProductResponse() = default;
};
class UpdateProductFilterConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<bool> propertyTimestampFilter{};
  shared_ptr<bool> propertyValueFilter{};

  UpdateProductFilterConfigRequest() {}

  explicit UpdateProductFilterConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (propertyTimestampFilter) {
      res["PropertyTimestampFilter"] = boost::any(*propertyTimestampFilter);
    }
    if (propertyValueFilter) {
      res["PropertyValueFilter"] = boost::any(*propertyValueFilter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("PropertyTimestampFilter") != m.end() && !m["PropertyTimestampFilter"].empty()) {
      propertyTimestampFilter = make_shared<bool>(boost::any_cast<bool>(m["PropertyTimestampFilter"]));
    }
    if (m.find("PropertyValueFilter") != m.end() && !m["PropertyValueFilter"].empty()) {
      propertyValueFilter = make_shared<bool>(boost::any_cast<bool>(m["PropertyValueFilter"]));
    }
  }


  virtual ~UpdateProductFilterConfigRequest() = default;
};
class UpdateProductFilterConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateProductFilterConfigResponseBody() {}

  explicit UpdateProductFilterConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateProductFilterConfigResponseBody() = default;
};
class UpdateProductFilterConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateProductFilterConfigResponseBody> body{};

  UpdateProductFilterConfigResponse() {}

  explicit UpdateProductFilterConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateProductFilterConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateProductFilterConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateProductFilterConfigResponse() = default;
};
class UpdateProductTagsRequestProductTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  UpdateProductTagsRequestProductTag() {}

  explicit UpdateProductTagsRequestProductTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~UpdateProductTagsRequestProductTag() = default;
};
class UpdateProductTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<vector<UpdateProductTagsRequestProductTag>> productTag{};

  UpdateProductTagsRequest() {}

  explicit UpdateProductTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productTag) {
      vector<boost::any> temp1;
      for(auto item1:*productTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProductTag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductTag") != m.end() && !m["ProductTag"].empty()) {
      if (typeid(vector<boost::any>) == m["ProductTag"].type()) {
        vector<UpdateProductTagsRequestProductTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProductTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateProductTagsRequestProductTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        productTag = make_shared<vector<UpdateProductTagsRequestProductTag>>(expect1);
      }
    }
  }


  virtual ~UpdateProductTagsRequest() = default;
};
class UpdateProductTagsResponseBodyInvalidProductTagsProductTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  UpdateProductTagsResponseBodyInvalidProductTagsProductTag() {}

  explicit UpdateProductTagsResponseBodyInvalidProductTagsProductTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~UpdateProductTagsResponseBodyInvalidProductTagsProductTag() = default;
};
class UpdateProductTagsResponseBodyInvalidProductTags : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateProductTagsResponseBodyInvalidProductTagsProductTag>> productTag{};

  UpdateProductTagsResponseBodyInvalidProductTags() {}

  explicit UpdateProductTagsResponseBodyInvalidProductTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productTag) {
      vector<boost::any> temp1;
      for(auto item1:*productTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProductTag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductTag") != m.end() && !m["ProductTag"].empty()) {
      if (typeid(vector<boost::any>) == m["ProductTag"].type()) {
        vector<UpdateProductTagsResponseBodyInvalidProductTagsProductTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProductTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateProductTagsResponseBodyInvalidProductTagsProductTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        productTag = make_shared<vector<UpdateProductTagsResponseBodyInvalidProductTagsProductTag>>(expect1);
      }
    }
  }


  virtual ~UpdateProductTagsResponseBodyInvalidProductTags() = default;
};
class UpdateProductTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<UpdateProductTagsResponseBodyInvalidProductTags> invalidProductTags{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateProductTagsResponseBody() {}

  explicit UpdateProductTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (invalidProductTags) {
      res["InvalidProductTags"] = invalidProductTags ? boost::any(invalidProductTags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("InvalidProductTags") != m.end() && !m["InvalidProductTags"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvalidProductTags"].type()) {
        UpdateProductTagsResponseBodyInvalidProductTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvalidProductTags"]));
        invalidProductTags = make_shared<UpdateProductTagsResponseBodyInvalidProductTags>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateProductTagsResponseBody() = default;
};
class UpdateProductTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateProductTagsResponseBody> body{};

  UpdateProductTagsResponse() {}

  explicit UpdateProductTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateProductTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateProductTagsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateProductTagsResponse() = default;
};
class UpdateProductTopicRequest : public Darabonba::Model {
public:
  shared_ptr<string> codec{};
  shared_ptr<string> desc{};
  shared_ptr<bool> enableProxySubscribe{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> operation{};
  shared_ptr<string> topicId{};
  shared_ptr<string> topicShortName{};

  UpdateProductTopicRequest() {}

  explicit UpdateProductTopicRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (enableProxySubscribe) {
      res["EnableProxySubscribe"] = boost::any(*enableProxySubscribe);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    if (topicShortName) {
      res["TopicShortName"] = boost::any(*topicShortName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("EnableProxySubscribe") != m.end() && !m["EnableProxySubscribe"].empty()) {
      enableProxySubscribe = make_shared<bool>(boost::any_cast<bool>(m["EnableProxySubscribe"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<string>(boost::any_cast<string>(m["TopicId"]));
    }
    if (m.find("TopicShortName") != m.end() && !m["TopicShortName"].empty()) {
      topicShortName = make_shared<string>(boost::any_cast<string>(m["TopicShortName"]));
    }
  }


  virtual ~UpdateProductTopicRequest() = default;
};
class UpdateProductTopicResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateProductTopicResponseBody() {}

  explicit UpdateProductTopicResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateProductTopicResponseBody() = default;
};
class UpdateProductTopicResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateProductTopicResponseBody> body{};

  UpdateProductTopicResponse() {}

  explicit UpdateProductTopicResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateProductTopicResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateProductTopicResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateProductTopicResponse() = default;
};
class UpdateRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> productKey{};
  shared_ptr<string> ruleDesc{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> select{};
  shared_ptr<string> shortTopic{};
  shared_ptr<string> topic{};
  shared_ptr<long> topicType{};
  shared_ptr<string> where{};

  UpdateRuleRequest() {}

  explicit UpdateRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (ruleDesc) {
      res["RuleDesc"] = boost::any(*ruleDesc);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (select) {
      res["Select"] = boost::any(*select);
    }
    if (shortTopic) {
      res["ShortTopic"] = boost::any(*shortTopic);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (topicType) {
      res["TopicType"] = boost::any(*topicType);
    }
    if (where) {
      res["Where"] = boost::any(*where);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("RuleDesc") != m.end() && !m["RuleDesc"].empty()) {
      ruleDesc = make_shared<string>(boost::any_cast<string>(m["RuleDesc"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("Select") != m.end() && !m["Select"].empty()) {
      select = make_shared<string>(boost::any_cast<string>(m["Select"]));
    }
    if (m.find("ShortTopic") != m.end() && !m["ShortTopic"].empty()) {
      shortTopic = make_shared<string>(boost::any_cast<string>(m["ShortTopic"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("TopicType") != m.end() && !m["TopicType"].empty()) {
      topicType = make_shared<long>(boost::any_cast<long>(m["TopicType"]));
    }
    if (m.find("Where") != m.end() && !m["Where"].empty()) {
      where = make_shared<string>(boost::any_cast<string>(m["Where"]));
    }
  }


  virtual ~UpdateRuleRequest() = default;
};
class UpdateRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateRuleResponseBody() {}

  explicit UpdateRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateRuleResponseBody() = default;
};
class UpdateRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateRuleResponseBody> body{};

  UpdateRuleResponse() {}

  explicit UpdateRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateRuleResponse() = default;
};
class UpdateRuleActionRequest : public Darabonba::Model {
public:
  shared_ptr<long> actionId{};
  shared_ptr<string> configuration{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> type{};

  UpdateRuleActionRequest() {}

  explicit UpdateRuleActionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionId) {
      res["ActionId"] = boost::any(*actionId);
    }
    if (configuration) {
      res["Configuration"] = boost::any(*configuration);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionId") != m.end() && !m["ActionId"].empty()) {
      actionId = make_shared<long>(boost::any_cast<long>(m["ActionId"]));
    }
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configuration = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateRuleActionRequest() = default;
};
class UpdateRuleActionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateRuleActionResponseBody() {}

  explicit UpdateRuleActionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateRuleActionResponseBody() = default;
};
class UpdateRuleActionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateRuleActionResponseBody> body{};

  UpdateRuleActionResponse() {}

  explicit UpdateRuleActionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateRuleActionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateRuleActionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateRuleActionResponse() = default;
};
class UpdateSceneRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> ruleContent{};
  shared_ptr<string> ruleDescription{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};

  UpdateSceneRuleRequest() {}

  explicit UpdateSceneRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleContent) {
      res["RuleContent"] = boost::any(*ruleContent);
    }
    if (ruleDescription) {
      res["RuleDescription"] = boost::any(*ruleDescription);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleContent") != m.end() && !m["RuleContent"].empty()) {
      ruleContent = make_shared<string>(boost::any_cast<string>(m["RuleContent"]));
    }
    if (m.find("RuleDescription") != m.end() && !m["RuleDescription"].empty()) {
      ruleDescription = make_shared<string>(boost::any_cast<string>(m["RuleDescription"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~UpdateSceneRuleRequest() = default;
};
class UpdateSceneRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateSceneRuleResponseBody() {}

  explicit UpdateSceneRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateSceneRuleResponseBody() = default;
};
class UpdateSceneRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSceneRuleResponseBody> body{};

  UpdateSceneRuleResponse() {}

  explicit UpdateSceneRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSceneRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSceneRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSceneRuleResponse() = default;
};
class UpdateSchedulePeriodRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> endTime{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> periodCode{};
  shared_ptr<string> soundCodeContent{};
  shared_ptr<string> startTime{};

  UpdateSchedulePeriodRequest() {}

  explicit UpdateSchedulePeriodRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (periodCode) {
      res["PeriodCode"] = boost::any(*periodCode);
    }
    if (soundCodeContent) {
      res["SoundCodeContent"] = boost::any(*soundCodeContent);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PeriodCode") != m.end() && !m["PeriodCode"].empty()) {
      periodCode = make_shared<string>(boost::any_cast<string>(m["PeriodCode"]));
    }
    if (m.find("SoundCodeContent") != m.end() && !m["SoundCodeContent"].empty()) {
      soundCodeContent = make_shared<string>(boost::any_cast<string>(m["SoundCodeContent"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~UpdateSchedulePeriodRequest() = default;
};
class UpdateSchedulePeriodResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateSchedulePeriodResponseBody() {}

  explicit UpdateSchedulePeriodResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateSchedulePeriodResponseBody() = default;
};
class UpdateSchedulePeriodResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSchedulePeriodResponseBody> body{};

  UpdateSchedulePeriodResponse() {}

  explicit UpdateSchedulePeriodResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSchedulePeriodResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSchedulePeriodResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSchedulePeriodResponse() = default;
};
class UpdateSoundCodeRequest : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> soundCode{};
  shared_ptr<string> soundCodeContent{};

  UpdateSoundCodeRequest() {}

  explicit UpdateSoundCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (soundCode) {
      res["SoundCode"] = boost::any(*soundCode);
    }
    if (soundCodeContent) {
      res["SoundCodeContent"] = boost::any(*soundCodeContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SoundCode") != m.end() && !m["SoundCode"].empty()) {
      soundCode = make_shared<string>(boost::any_cast<string>(m["SoundCode"]));
    }
    if (m.find("SoundCodeContent") != m.end() && !m["SoundCodeContent"].empty()) {
      soundCodeContent = make_shared<string>(boost::any_cast<string>(m["SoundCodeContent"]));
    }
  }


  virtual ~UpdateSoundCodeRequest() = default;
};
class UpdateSoundCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateSoundCodeResponseBody() {}

  explicit UpdateSoundCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateSoundCodeResponseBody() = default;
};
class UpdateSoundCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSoundCodeResponseBody> body{};

  UpdateSoundCodeResponse() {}

  explicit UpdateSoundCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSoundCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSoundCodeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSoundCodeResponse() = default;
};
class UpdateSoundCodeLabelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> label{};
  shared_ptr<string> soundCode{};

  UpdateSoundCodeLabelRequest() {}

  explicit UpdateSoundCodeLabelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (soundCode) {
      res["SoundCode"] = boost::any(*soundCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("SoundCode") != m.end() && !m["SoundCode"].empty()) {
      soundCode = make_shared<string>(boost::any_cast<string>(m["SoundCode"]));
    }
  }


  virtual ~UpdateSoundCodeLabelRequest() = default;
};
class UpdateSoundCodeLabelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateSoundCodeLabelResponseBody() {}

  explicit UpdateSoundCodeLabelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateSoundCodeLabelResponseBody() = default;
};
class UpdateSoundCodeLabelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSoundCodeLabelResponseBody> body{};

  UpdateSoundCodeLabelResponse() {}

  explicit UpdateSoundCodeLabelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSoundCodeLabelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSoundCodeLabelResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSoundCodeLabelResponse() = default;
};
class UpdateSoundCodeScheduleRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> endDate{};
  shared_ptr<string> endTime{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> scheduleCode{};
  shared_ptr<string> startDate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  UpdateSoundCodeScheduleRequest() {}

  explicit UpdateSoundCodeScheduleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (scheduleCode) {
      res["ScheduleCode"] = boost::any(*scheduleCode);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ScheduleCode") != m.end() && !m["ScheduleCode"].empty()) {
      scheduleCode = make_shared<string>(boost::any_cast<string>(m["ScheduleCode"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~UpdateSoundCodeScheduleRequest() = default;
};
class UpdateSoundCodeScheduleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateSoundCodeScheduleResponseBody() {}

  explicit UpdateSoundCodeScheduleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateSoundCodeScheduleResponseBody() = default;
};
class UpdateSoundCodeScheduleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSoundCodeScheduleResponseBody> body{};

  UpdateSoundCodeScheduleResponse() {}

  explicit UpdateSoundCodeScheduleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSoundCodeScheduleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSoundCodeScheduleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSoundCodeScheduleResponse() = default;
};
class UpdateSpeechRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enableSoundCode{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> projectCode{};
  shared_ptr<map<string, boost::any>> soundCodeConfig{};
  shared_ptr<string> speechCode{};
  shared_ptr<long> speechRate{};
  shared_ptr<string> voice{};
  shared_ptr<long> volume{};

  UpdateSpeechRequest() {}

  explicit UpdateSpeechRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableSoundCode) {
      res["EnableSoundCode"] = boost::any(*enableSoundCode);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (projectCode) {
      res["ProjectCode"] = boost::any(*projectCode);
    }
    if (soundCodeConfig) {
      res["SoundCodeConfig"] = boost::any(*soundCodeConfig);
    }
    if (speechCode) {
      res["SpeechCode"] = boost::any(*speechCode);
    }
    if (speechRate) {
      res["SpeechRate"] = boost::any(*speechRate);
    }
    if (voice) {
      res["Voice"] = boost::any(*voice);
    }
    if (volume) {
      res["Volume"] = boost::any(*volume);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableSoundCode") != m.end() && !m["EnableSoundCode"].empty()) {
      enableSoundCode = make_shared<bool>(boost::any_cast<bool>(m["EnableSoundCode"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProjectCode") != m.end() && !m["ProjectCode"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["ProjectCode"]));
    }
    if (m.find("SoundCodeConfig") != m.end() && !m["SoundCodeConfig"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["SoundCodeConfig"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      soundCodeConfig = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("SpeechCode") != m.end() && !m["SpeechCode"].empty()) {
      speechCode = make_shared<string>(boost::any_cast<string>(m["SpeechCode"]));
    }
    if (m.find("SpeechRate") != m.end() && !m["SpeechRate"].empty()) {
      speechRate = make_shared<long>(boost::any_cast<long>(m["SpeechRate"]));
    }
    if (m.find("Voice") != m.end() && !m["Voice"].empty()) {
      voice = make_shared<string>(boost::any_cast<string>(m["Voice"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      volume = make_shared<long>(boost::any_cast<long>(m["Volume"]));
    }
  }


  virtual ~UpdateSpeechRequest() = default;
};
class UpdateSpeechShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enableSoundCode{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> soundCodeConfigShrink{};
  shared_ptr<string> speechCode{};
  shared_ptr<long> speechRate{};
  shared_ptr<string> voice{};
  shared_ptr<long> volume{};

  UpdateSpeechShrinkRequest() {}

  explicit UpdateSpeechShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableSoundCode) {
      res["EnableSoundCode"] = boost::any(*enableSoundCode);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (projectCode) {
      res["ProjectCode"] = boost::any(*projectCode);
    }
    if (soundCodeConfigShrink) {
      res["SoundCodeConfig"] = boost::any(*soundCodeConfigShrink);
    }
    if (speechCode) {
      res["SpeechCode"] = boost::any(*speechCode);
    }
    if (speechRate) {
      res["SpeechRate"] = boost::any(*speechRate);
    }
    if (voice) {
      res["Voice"] = boost::any(*voice);
    }
    if (volume) {
      res["Volume"] = boost::any(*volume);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableSoundCode") != m.end() && !m["EnableSoundCode"].empty()) {
      enableSoundCode = make_shared<bool>(boost::any_cast<bool>(m["EnableSoundCode"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProjectCode") != m.end() && !m["ProjectCode"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["ProjectCode"]));
    }
    if (m.find("SoundCodeConfig") != m.end() && !m["SoundCodeConfig"].empty()) {
      soundCodeConfigShrink = make_shared<string>(boost::any_cast<string>(m["SoundCodeConfig"]));
    }
    if (m.find("SpeechCode") != m.end() && !m["SpeechCode"].empty()) {
      speechCode = make_shared<string>(boost::any_cast<string>(m["SpeechCode"]));
    }
    if (m.find("SpeechRate") != m.end() && !m["SpeechRate"].empty()) {
      speechRate = make_shared<long>(boost::any_cast<long>(m["SpeechRate"]));
    }
    if (m.find("Voice") != m.end() && !m["Voice"].empty()) {
      voice = make_shared<string>(boost::any_cast<string>(m["Voice"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      volume = make_shared<long>(boost::any_cast<long>(m["Volume"]));
    }
  }


  virtual ~UpdateSpeechShrinkRequest() = default;
};
class UpdateSpeechResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateSpeechResponseBody() {}

  explicit UpdateSpeechResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateSpeechResponseBody() = default;
};
class UpdateSpeechResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSpeechResponseBody> body{};

  UpdateSpeechResponse() {}

  explicit UpdateSpeechResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSpeechResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSpeechResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSpeechResponse() = default;
};
class UpdateSubscribeRelationRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> consumerGroupIds{};
  shared_ptr<bool> deviceDataFlag{};
  shared_ptr<bool> deviceLifeCycleFlag{};
  shared_ptr<bool> deviceStatusChangeFlag{};
  shared_ptr<bool> deviceTagFlag{};
  shared_ptr<bool> deviceTopoLifeCycleFlag{};
  shared_ptr<bool> foundDeviceListFlag{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> mnsConfiguration{};
  shared_ptr<bool> otaEventFlag{};
  shared_ptr<bool> otaJobFlag{};
  shared_ptr<bool> otaVersionFlag{};
  shared_ptr<string> productKey{};
  shared_ptr<string> subscribeFlags{};
  shared_ptr<bool> thingHistoryFlag{};
  shared_ptr<string> type{};

  UpdateSubscribeRelationRequest() {}

  explicit UpdateSubscribeRelationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consumerGroupIds) {
      res["ConsumerGroupIds"] = boost::any(*consumerGroupIds);
    }
    if (deviceDataFlag) {
      res["DeviceDataFlag"] = boost::any(*deviceDataFlag);
    }
    if (deviceLifeCycleFlag) {
      res["DeviceLifeCycleFlag"] = boost::any(*deviceLifeCycleFlag);
    }
    if (deviceStatusChangeFlag) {
      res["DeviceStatusChangeFlag"] = boost::any(*deviceStatusChangeFlag);
    }
    if (deviceTagFlag) {
      res["DeviceTagFlag"] = boost::any(*deviceTagFlag);
    }
    if (deviceTopoLifeCycleFlag) {
      res["DeviceTopoLifeCycleFlag"] = boost::any(*deviceTopoLifeCycleFlag);
    }
    if (foundDeviceListFlag) {
      res["FoundDeviceListFlag"] = boost::any(*foundDeviceListFlag);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (mnsConfiguration) {
      res["MnsConfiguration"] = boost::any(*mnsConfiguration);
    }
    if (otaEventFlag) {
      res["OtaEventFlag"] = boost::any(*otaEventFlag);
    }
    if (otaJobFlag) {
      res["OtaJobFlag"] = boost::any(*otaJobFlag);
    }
    if (otaVersionFlag) {
      res["OtaVersionFlag"] = boost::any(*otaVersionFlag);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (subscribeFlags) {
      res["SubscribeFlags"] = boost::any(*subscribeFlags);
    }
    if (thingHistoryFlag) {
      res["ThingHistoryFlag"] = boost::any(*thingHistoryFlag);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsumerGroupIds") != m.end() && !m["ConsumerGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ConsumerGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ConsumerGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      consumerGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DeviceDataFlag") != m.end() && !m["DeviceDataFlag"].empty()) {
      deviceDataFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceDataFlag"]));
    }
    if (m.find("DeviceLifeCycleFlag") != m.end() && !m["DeviceLifeCycleFlag"].empty()) {
      deviceLifeCycleFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceLifeCycleFlag"]));
    }
    if (m.find("DeviceStatusChangeFlag") != m.end() && !m["DeviceStatusChangeFlag"].empty()) {
      deviceStatusChangeFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceStatusChangeFlag"]));
    }
    if (m.find("DeviceTagFlag") != m.end() && !m["DeviceTagFlag"].empty()) {
      deviceTagFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceTagFlag"]));
    }
    if (m.find("DeviceTopoLifeCycleFlag") != m.end() && !m["DeviceTopoLifeCycleFlag"].empty()) {
      deviceTopoLifeCycleFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceTopoLifeCycleFlag"]));
    }
    if (m.find("FoundDeviceListFlag") != m.end() && !m["FoundDeviceListFlag"].empty()) {
      foundDeviceListFlag = make_shared<bool>(boost::any_cast<bool>(m["FoundDeviceListFlag"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("MnsConfiguration") != m.end() && !m["MnsConfiguration"].empty()) {
      mnsConfiguration = make_shared<string>(boost::any_cast<string>(m["MnsConfiguration"]));
    }
    if (m.find("OtaEventFlag") != m.end() && !m["OtaEventFlag"].empty()) {
      otaEventFlag = make_shared<bool>(boost::any_cast<bool>(m["OtaEventFlag"]));
    }
    if (m.find("OtaJobFlag") != m.end() && !m["OtaJobFlag"].empty()) {
      otaJobFlag = make_shared<bool>(boost::any_cast<bool>(m["OtaJobFlag"]));
    }
    if (m.find("OtaVersionFlag") != m.end() && !m["OtaVersionFlag"].empty()) {
      otaVersionFlag = make_shared<bool>(boost::any_cast<bool>(m["OtaVersionFlag"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("SubscribeFlags") != m.end() && !m["SubscribeFlags"].empty()) {
      subscribeFlags = make_shared<string>(boost::any_cast<string>(m["SubscribeFlags"]));
    }
    if (m.find("ThingHistoryFlag") != m.end() && !m["ThingHistoryFlag"].empty()) {
      thingHistoryFlag = make_shared<bool>(boost::any_cast<bool>(m["ThingHistoryFlag"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateSubscribeRelationRequest() = default;
};
class UpdateSubscribeRelationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateSubscribeRelationResponseBody() {}

  explicit UpdateSubscribeRelationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateSubscribeRelationResponseBody() = default;
};
class UpdateSubscribeRelationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSubscribeRelationResponseBody> body{};

  UpdateSubscribeRelationResponse() {}

  explicit UpdateSubscribeRelationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSubscribeRelationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSubscribeRelationResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSubscribeRelationResponse() = default;
};
class UpdateThingModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> functionBlockId{};
  shared_ptr<string> functionBlockName{};
  shared_ptr<string> identifier{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> thingModelJson{};

  UpdateThingModelRequest() {}

  explicit UpdateThingModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    if (functionBlockName) {
      res["FunctionBlockName"] = boost::any(*functionBlockName);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (thingModelJson) {
      res["ThingModelJson"] = boost::any(*thingModelJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
    if (m.find("FunctionBlockName") != m.end() && !m["FunctionBlockName"].empty()) {
      functionBlockName = make_shared<string>(boost::any_cast<string>(m["FunctionBlockName"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ThingModelJson") != m.end() && !m["ThingModelJson"].empty()) {
      thingModelJson = make_shared<string>(boost::any_cast<string>(m["ThingModelJson"]));
    }
  }


  virtual ~UpdateThingModelRequest() = default;
};
class UpdateThingModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateThingModelResponseBody() {}

  explicit UpdateThingModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateThingModelResponseBody() = default;
};
class UpdateThingModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateThingModelResponseBody> body{};

  UpdateThingModelResponse() {}

  explicit UpdateThingModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateThingModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateThingModelResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateThingModelResponse() = default;
};
class UpdateThingScriptRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> scriptContent{};
  shared_ptr<string> scriptType{};

  UpdateThingScriptRequest() {}

  explicit UpdateThingScriptRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (scriptContent) {
      res["ScriptContent"] = boost::any(*scriptContent);
    }
    if (scriptType) {
      res["ScriptType"] = boost::any(*scriptType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ScriptContent") != m.end() && !m["ScriptContent"].empty()) {
      scriptContent = make_shared<string>(boost::any_cast<string>(m["ScriptContent"]));
    }
    if (m.find("ScriptType") != m.end() && !m["ScriptType"].empty()) {
      scriptType = make_shared<string>(boost::any_cast<string>(m["ScriptType"]));
    }
  }


  virtual ~UpdateThingScriptRequest() = default;
};
class UpdateThingScriptResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateThingScriptResponseBody() {}

  explicit UpdateThingScriptResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateThingScriptResponseBody() = default;
};
class UpdateThingScriptResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateThingScriptResponseBody> body{};

  UpdateThingScriptResponse() {}

  explicit UpdateThingScriptResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateThingScriptResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateThingScriptResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateThingScriptResponse() = default;
};
class UpdateTopicConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> codec{};
  shared_ptr<string> description{};
  shared_ptr<bool> enableBroadcast{};
  shared_ptr<bool> enableProxySubscribe{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> operation{};
  shared_ptr<string> productKey{};
  shared_ptr<string> topicFullName{};

  UpdateTopicConfigRequest() {}

  explicit UpdateTopicConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enableBroadcast) {
      res["EnableBroadcast"] = boost::any(*enableBroadcast);
    }
    if (enableProxySubscribe) {
      res["EnableProxySubscribe"] = boost::any(*enableProxySubscribe);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (topicFullName) {
      res["TopicFullName"] = boost::any(*topicFullName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnableBroadcast") != m.end() && !m["EnableBroadcast"].empty()) {
      enableBroadcast = make_shared<bool>(boost::any_cast<bool>(m["EnableBroadcast"]));
    }
    if (m.find("EnableProxySubscribe") != m.end() && !m["EnableProxySubscribe"].empty()) {
      enableProxySubscribe = make_shared<bool>(boost::any_cast<bool>(m["EnableProxySubscribe"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("TopicFullName") != m.end() && !m["TopicFullName"].empty()) {
      topicFullName = make_shared<string>(boost::any_cast<string>(m["TopicFullName"]));
    }
  }


  virtual ~UpdateTopicConfigRequest() = default;
};
class UpdateTopicConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateTopicConfigResponseBody() {}

  explicit UpdateTopicConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateTopicConfigResponseBody() = default;
};
class UpdateTopicConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTopicConfigResponseBody> body{};

  UpdateTopicConfigResponse() {}

  explicit UpdateTopicConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTopicConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTopicConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTopicConfigResponse() = default;
};
class WriteDevicesHotStorageDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> items{};
  shared_ptr<string> productKey{};
  shared_ptr<string> userTopic{};

  WriteDevicesHotStorageDataRequest() {}

  explicit WriteDevicesHotStorageDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (items) {
      res["Items"] = boost::any(*items);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (userTopic) {
      res["UserTopic"] = boost::any(*userTopic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      items = make_shared<string>(boost::any_cast<string>(m["Items"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("UserTopic") != m.end() && !m["UserTopic"].empty()) {
      userTopic = make_shared<string>(boost::any_cast<string>(m["UserTopic"]));
    }
  }


  virtual ~WriteDevicesHotStorageDataRequest() = default;
};
class WriteDevicesHotStorageDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  WriteDevicesHotStorageDataResponseBody() {}

  explicit WriteDevicesHotStorageDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~WriteDevicesHotStorageDataResponseBody() = default;
};
class WriteDevicesHotStorageDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WriteDevicesHotStorageDataResponseBody> body{};

  WriteDevicesHotStorageDataResponse() {}

  explicit WriteDevicesHotStorageDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WriteDevicesHotStorageDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WriteDevicesHotStorageDataResponseBody>(model1);
      }
    }
  }


  virtual ~WriteDevicesHotStorageDataResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddDataForApiSourceResponse addDataForApiSourceWithOptions(shared_ptr<AddDataForApiSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddDataForApiSourceResponse addDataForApiSource(shared_ptr<AddDataForApiSourceRequest> request);
  AddDeviceToSharePromotionResponse addDeviceToSharePromotionWithOptions(shared_ptr<AddDeviceToSharePromotionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddDeviceToSharePromotionResponse addDeviceToSharePromotion(shared_ptr<AddDeviceToSharePromotionRequest> request);
  AddShareTaskDeviceResponse addShareTaskDeviceWithOptions(shared_ptr<AddShareTaskDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddShareTaskDeviceResponse addShareTaskDevice(shared_ptr<AddShareTaskDeviceRequest> request);
  AsyncRRpcResponse asyncRRpcWithOptions(shared_ptr<AsyncRRpcRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AsyncRRpcResponse asyncRRpc(shared_ptr<AsyncRRpcRequest> request);
  AttachDestinationResponse attachDestinationWithOptions(shared_ptr<AttachDestinationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachDestinationResponse attachDestination(shared_ptr<AttachDestinationRequest> request);
  AttachParserDataSourceResponse attachParserDataSourceWithOptions(shared_ptr<AttachParserDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachParserDataSourceResponse attachParserDataSource(shared_ptr<AttachParserDataSourceRequest> request);
  BatchAddDataForApiSourceResponse batchAddDataForApiSourceWithOptions(shared_ptr<BatchAddDataForApiSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchAddDataForApiSourceResponse batchAddDataForApiSource(shared_ptr<BatchAddDataForApiSourceRequest> request);
  BatchAddDeviceGroupRelationsResponse batchAddDeviceGroupRelationsWithOptions(shared_ptr<BatchAddDeviceGroupRelationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchAddDeviceGroupRelationsResponse batchAddDeviceGroupRelations(shared_ptr<BatchAddDeviceGroupRelationsRequest> request);
  BatchAddThingTopoResponse batchAddThingTopoWithOptions(shared_ptr<BatchAddThingTopoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchAddThingTopoResponse batchAddThingTopo(shared_ptr<BatchAddThingTopoRequest> request);
  BatchBindDeviceToEdgeInstanceWithDriverResponse batchBindDeviceToEdgeInstanceWithDriverWithOptions(shared_ptr<BatchBindDeviceToEdgeInstanceWithDriverRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchBindDeviceToEdgeInstanceWithDriverResponse batchBindDeviceToEdgeInstanceWithDriver(shared_ptr<BatchBindDeviceToEdgeInstanceWithDriverRequest> request);
  BatchBindDevicesIntoProjectResponse batchBindDevicesIntoProjectWithOptions(shared_ptr<BatchBindDevicesIntoProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchBindDevicesIntoProjectResponse batchBindDevicesIntoProject(shared_ptr<BatchBindDevicesIntoProjectRequest> request);
  BatchBindProductsIntoProjectResponse batchBindProductsIntoProjectWithOptions(shared_ptr<BatchBindProductsIntoProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchBindProductsIntoProjectResponse batchBindProductsIntoProject(shared_ptr<BatchBindProductsIntoProjectRequest> request);
  BatchCheckDeviceNamesResponse batchCheckDeviceNamesWithOptions(shared_ptr<BatchCheckDeviceNamesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchCheckDeviceNamesResponse batchCheckDeviceNames(shared_ptr<BatchCheckDeviceNamesRequest> request);
  BatchCheckImportDeviceResponse batchCheckImportDeviceWithOptions(shared_ptr<BatchCheckImportDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchCheckImportDeviceResponse batchCheckImportDevice(shared_ptr<BatchCheckImportDeviceRequest> request);
  BatchCheckVehicleDeviceResponse batchCheckVehicleDeviceWithOptions(shared_ptr<BatchCheckVehicleDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchCheckVehicleDeviceResponse batchCheckVehicleDevice(shared_ptr<BatchCheckVehicleDeviceRequest> request);
  BatchClearEdgeInstanceDeviceConfigResponse batchClearEdgeInstanceDeviceConfigWithOptions(shared_ptr<BatchClearEdgeInstanceDeviceConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchClearEdgeInstanceDeviceConfigResponse batchClearEdgeInstanceDeviceConfig(shared_ptr<BatchClearEdgeInstanceDeviceConfigRequest> request);
  BatchCreateSoundCodeLabelResponse batchCreateSoundCodeLabelWithOptions(shared_ptr<BatchCreateSoundCodeLabelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchCreateSoundCodeLabelResponse batchCreateSoundCodeLabel(shared_ptr<BatchCreateSoundCodeLabelRequest> request);
  BatchCreateSoundCodeLabelWithLabelsResponse batchCreateSoundCodeLabelWithLabelsWithOptions(shared_ptr<BatchCreateSoundCodeLabelWithLabelsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchCreateSoundCodeLabelWithLabelsResponse batchCreateSoundCodeLabelWithLabels(shared_ptr<BatchCreateSoundCodeLabelWithLabelsRequest> request);
  BatchDeleteDeviceGroupRelationsResponse batchDeleteDeviceGroupRelationsWithOptions(shared_ptr<BatchDeleteDeviceGroupRelationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchDeleteDeviceGroupRelationsResponse batchDeleteDeviceGroupRelations(shared_ptr<BatchDeleteDeviceGroupRelationsRequest> request);
  BatchDeleteEdgeInstanceChannelResponse batchDeleteEdgeInstanceChannelWithOptions(shared_ptr<BatchDeleteEdgeInstanceChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchDeleteEdgeInstanceChannelResponse batchDeleteEdgeInstanceChannel(shared_ptr<BatchDeleteEdgeInstanceChannelRequest> request);
  BatchGetDeviceBindStatusResponse batchGetDeviceBindStatusWithOptions(shared_ptr<BatchGetDeviceBindStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetDeviceBindStatusResponse batchGetDeviceBindStatus(shared_ptr<BatchGetDeviceBindStatusRequest> request);
  BatchGetDeviceStateResponse batchGetDeviceStateWithOptions(shared_ptr<BatchGetDeviceStateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetDeviceStateResponse batchGetDeviceState(shared_ptr<BatchGetDeviceStateRequest> request);
  BatchGetEdgeDriverResponse batchGetEdgeDriverWithOptions(shared_ptr<BatchGetEdgeDriverRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetEdgeDriverResponse batchGetEdgeDriver(shared_ptr<BatchGetEdgeDriverRequest> request);
  BatchGetEdgeInstanceChannelResponse batchGetEdgeInstanceChannelWithOptions(shared_ptr<BatchGetEdgeInstanceChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetEdgeInstanceChannelResponse batchGetEdgeInstanceChannel(shared_ptr<BatchGetEdgeInstanceChannelRequest> request);
  BatchGetEdgeInstanceDeviceChannelResponse batchGetEdgeInstanceDeviceChannelWithOptions(shared_ptr<BatchGetEdgeInstanceDeviceChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetEdgeInstanceDeviceChannelResponse batchGetEdgeInstanceDeviceChannel(shared_ptr<BatchGetEdgeInstanceDeviceChannelRequest> request);
  BatchGetEdgeInstanceDeviceConfigResponse batchGetEdgeInstanceDeviceConfigWithOptions(shared_ptr<BatchGetEdgeInstanceDeviceConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetEdgeInstanceDeviceConfigResponse batchGetEdgeInstanceDeviceConfig(shared_ptr<BatchGetEdgeInstanceDeviceConfigRequest> request);
  BatchGetEdgeInstanceDeviceDriverResponse batchGetEdgeInstanceDeviceDriverWithOptions(shared_ptr<BatchGetEdgeInstanceDeviceDriverRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetEdgeInstanceDeviceDriverResponse batchGetEdgeInstanceDeviceDriver(shared_ptr<BatchGetEdgeInstanceDeviceDriverRequest> request);
  BatchGetEdgeInstanceDriverConfigsResponse batchGetEdgeInstanceDriverConfigsWithOptions(shared_ptr<BatchGetEdgeInstanceDriverConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetEdgeInstanceDriverConfigsResponse batchGetEdgeInstanceDriverConfigs(shared_ptr<BatchGetEdgeInstanceDriverConfigsRequest> request);
  BatchGrayMigrationDeviceResponse batchGrayMigrationDeviceWithOptions(shared_ptr<BatchGrayMigrationDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGrayMigrationDeviceResponse batchGrayMigrationDevice(shared_ptr<BatchGrayMigrationDeviceRequest> request);
  BatchImportDeviceResponse batchImportDeviceWithOptions(shared_ptr<BatchImportDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchImportDeviceResponse batchImportDevice(shared_ptr<BatchImportDeviceRequest> request);
  BatchImportVehicleDeviceResponse batchImportVehicleDeviceWithOptions(shared_ptr<BatchImportVehicleDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchImportVehicleDeviceResponse batchImportVehicleDevice(shared_ptr<BatchImportVehicleDeviceRequest> request);
  BatchPubResponse batchPubWithOptions(shared_ptr<BatchPubRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchPubResponse batchPub(shared_ptr<BatchPubRequest> request);
  BatchQueryDeviceDetailResponse batchQueryDeviceDetailWithOptions(shared_ptr<BatchQueryDeviceDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchQueryDeviceDetailResponse batchQueryDeviceDetail(shared_ptr<BatchQueryDeviceDetailRequest> request);
  BatchRegisterDeviceResponse batchRegisterDeviceWithOptions(shared_ptr<BatchRegisterDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchRegisterDeviceResponse batchRegisterDevice(shared_ptr<BatchRegisterDeviceRequest> request);
  BatchRegisterDeviceWithApplyIdResponse batchRegisterDeviceWithApplyIdWithOptions(shared_ptr<BatchRegisterDeviceWithApplyIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchRegisterDeviceWithApplyIdResponse batchRegisterDeviceWithApplyId(shared_ptr<BatchRegisterDeviceWithApplyIdRequest> request);
  BatchSetEdgeInstanceDeviceChannelResponse batchSetEdgeInstanceDeviceChannelWithOptions(shared_ptr<BatchSetEdgeInstanceDeviceChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchSetEdgeInstanceDeviceChannelResponse batchSetEdgeInstanceDeviceChannel(shared_ptr<BatchSetEdgeInstanceDeviceChannelRequest> request);
  BatchSetEdgeInstanceDeviceConfigResponse batchSetEdgeInstanceDeviceConfigWithOptions(shared_ptr<BatchSetEdgeInstanceDeviceConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchSetEdgeInstanceDeviceConfigResponse batchSetEdgeInstanceDeviceConfig(shared_ptr<BatchSetEdgeInstanceDeviceConfigRequest> request);
  BatchUnbindDeviceFromEdgeInstanceResponse batchUnbindDeviceFromEdgeInstanceWithOptions(shared_ptr<BatchUnbindDeviceFromEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchUnbindDeviceFromEdgeInstanceResponse batchUnbindDeviceFromEdgeInstance(shared_ptr<BatchUnbindDeviceFromEdgeInstanceRequest> request);
  BatchUnbindProjectDevicesResponse batchUnbindProjectDevicesWithOptions(shared_ptr<BatchUnbindProjectDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchUnbindProjectDevicesResponse batchUnbindProjectDevices(shared_ptr<BatchUnbindProjectDevicesRequest> request);
  BatchUnbindProjectProductsResponse batchUnbindProjectProductsWithOptions(shared_ptr<BatchUnbindProjectProductsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchUnbindProjectProductsResponse batchUnbindProjectProducts(shared_ptr<BatchUnbindProjectProductsRequest> request);
  BatchUpdateDeviceNicknameResponse batchUpdateDeviceNicknameWithOptions(shared_ptr<BatchUpdateDeviceNicknameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchUpdateDeviceNicknameResponse batchUpdateDeviceNickname(shared_ptr<BatchUpdateDeviceNicknameRequest> request);
  BindApplicationToEdgeInstanceResponse bindApplicationToEdgeInstanceWithOptions(shared_ptr<BindApplicationToEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindApplicationToEdgeInstanceResponse bindApplicationToEdgeInstance(shared_ptr<BindApplicationToEdgeInstanceRequest> request);
  BindDriverToEdgeInstanceResponse bindDriverToEdgeInstanceWithOptions(shared_ptr<BindDriverToEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindDriverToEdgeInstanceResponse bindDriverToEdgeInstance(shared_ptr<BindDriverToEdgeInstanceRequest> request);
  BindGatewayToEdgeInstanceResponse bindGatewayToEdgeInstanceWithOptions(shared_ptr<BindGatewayToEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindGatewayToEdgeInstanceResponse bindGatewayToEdgeInstance(shared_ptr<BindGatewayToEdgeInstanceRequest> request);
  BindLicenseDeviceResponse bindLicenseDeviceWithOptions(shared_ptr<BindLicenseDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindLicenseDeviceResponse bindLicenseDevice(shared_ptr<BindLicenseDeviceRequest> request);
  BindLicenseProductResponse bindLicenseProductWithOptions(shared_ptr<BindLicenseProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindLicenseProductResponse bindLicenseProduct(shared_ptr<BindLicenseProductRequest> request);
  BindRoleToEdgeInstanceResponse bindRoleToEdgeInstanceWithOptions(shared_ptr<BindRoleToEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindRoleToEdgeInstanceResponse bindRoleToEdgeInstance(shared_ptr<BindRoleToEdgeInstanceRequest> request);
  BindSceneRuleToEdgeInstanceResponse bindSceneRuleToEdgeInstanceWithOptions(shared_ptr<BindSceneRuleToEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindSceneRuleToEdgeInstanceResponse bindSceneRuleToEdgeInstance(shared_ptr<BindSceneRuleToEdgeInstanceRequest> request);
  CancelJobResponse cancelJobWithOptions(shared_ptr<CancelJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelJobResponse cancelJob(shared_ptr<CancelJobRequest> request);
  CancelOTAStrategyByJobResponse cancelOTAStrategyByJobWithOptions(shared_ptr<CancelOTAStrategyByJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelOTAStrategyByJobResponse cancelOTAStrategyByJob(shared_ptr<CancelOTAStrategyByJobRequest> request);
  CancelOTATaskByDeviceResponse cancelOTATaskByDeviceWithOptions(shared_ptr<CancelOTATaskByDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelOTATaskByDeviceResponse cancelOTATaskByDevice(shared_ptr<CancelOTATaskByDeviceRequest> request);
  CancelOTATaskByJobResponse cancelOTATaskByJobWithOptions(shared_ptr<CancelOTATaskByJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelOTATaskByJobResponse cancelOTATaskByJob(shared_ptr<CancelOTATaskByJobRequest> request);
  CancelReleaseProductResponse cancelReleaseProductWithOptions(shared_ptr<CancelReleaseProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelReleaseProductResponse cancelReleaseProduct(shared_ptr<CancelReleaseProductRequest> request);
  CheckBindLicenseDeviceProgressResponse checkBindLicenseDeviceProgressWithOptions(shared_ptr<CheckBindLicenseDeviceProgressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckBindLicenseDeviceProgressResponse checkBindLicenseDeviceProgress(shared_ptr<CheckBindLicenseDeviceProgressRequest> request);
  ClearDeviceDesiredPropertyResponse clearDeviceDesiredPropertyWithOptions(shared_ptr<ClearDeviceDesiredPropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ClearDeviceDesiredPropertyResponse clearDeviceDesiredProperty(shared_ptr<ClearDeviceDesiredPropertyRequest> request);
  ClearEdgeInstanceDriverConfigsResponse clearEdgeInstanceDriverConfigsWithOptions(shared_ptr<ClearEdgeInstanceDriverConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ClearEdgeInstanceDriverConfigsResponse clearEdgeInstanceDriverConfigs(shared_ptr<ClearEdgeInstanceDriverConfigsRequest> request);
  CloseDeviceTunnelResponse closeDeviceTunnelWithOptions(shared_ptr<CloseDeviceTunnelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CloseDeviceTunnelResponse closeDeviceTunnel(shared_ptr<CloseDeviceTunnelRequest> request);
  CloseEdgeInstanceDeploymentResponse closeEdgeInstanceDeploymentWithOptions(shared_ptr<CloseEdgeInstanceDeploymentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CloseEdgeInstanceDeploymentResponse closeEdgeInstanceDeployment(shared_ptr<CloseEdgeInstanceDeploymentRequest> request);
  ConfirmOTATaskResponse confirmOTATaskWithOptions(shared_ptr<ConfirmOTATaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfirmOTATaskResponse confirmOTATask(shared_ptr<ConfirmOTATaskRequest> request);
  CopyThingModelResponse copyThingModelWithOptions(shared_ptr<CopyThingModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CopyThingModelResponse copyThingModel(shared_ptr<CopyThingModelRequest> request);
  CountSpeechBroadcastHourResponse countSpeechBroadcastHourWithOptions(shared_ptr<CountSpeechBroadcastHourRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CountSpeechBroadcastHourResponse countSpeechBroadcastHour(shared_ptr<CountSpeechBroadcastHourRequest> request);
  CreateConsumerGroupResponse createConsumerGroupWithOptions(shared_ptr<CreateConsumerGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateConsumerGroupResponse createConsumerGroup(shared_ptr<CreateConsumerGroupRequest> request);
  CreateConsumerGroupSubscribeRelationResponse createConsumerGroupSubscribeRelationWithOptions(shared_ptr<CreateConsumerGroupSubscribeRelationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateConsumerGroupSubscribeRelationResponse createConsumerGroupSubscribeRelation(shared_ptr<CreateConsumerGroupSubscribeRelationRequest> request);
  CreateDataAPIServiceResponse createDataAPIServiceWithOptions(shared_ptr<CreateDataAPIServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataAPIServiceResponse createDataAPIService(shared_ptr<CreateDataAPIServiceRequest> request);
  CreateDataSourceItemResponse createDataSourceItemWithOptions(shared_ptr<CreateDataSourceItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataSourceItemResponse createDataSourceItem(shared_ptr<CreateDataSourceItemRequest> request);
  CreateDestinationResponse createDestinationWithOptions(shared_ptr<CreateDestinationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDestinationResponse createDestination(shared_ptr<CreateDestinationRequest> request);
  CreateDeviceDistributeJobResponse createDeviceDistributeJobWithOptions(shared_ptr<CreateDeviceDistributeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDeviceDistributeJobResponse createDeviceDistributeJob(shared_ptr<CreateDeviceDistributeJobRequest> request);
  CreateDeviceDynamicGroupResponse createDeviceDynamicGroupWithOptions(shared_ptr<CreateDeviceDynamicGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDeviceDynamicGroupResponse createDeviceDynamicGroup(shared_ptr<CreateDeviceDynamicGroupRequest> request);
  CreateDeviceGroupResponse createDeviceGroupWithOptions(shared_ptr<CreateDeviceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDeviceGroupResponse createDeviceGroup(shared_ptr<CreateDeviceGroupRequest> request);
  CreateDeviceTunnelResponse createDeviceTunnelWithOptions(shared_ptr<CreateDeviceTunnelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDeviceTunnelResponse createDeviceTunnel(shared_ptr<CreateDeviceTunnelRequest> request);
  CreateDownloadDataJobResponse createDownloadDataJobWithOptions(shared_ptr<CreateDownloadDataJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDownloadDataJobResponse createDownloadDataJob(shared_ptr<CreateDownloadDataJobRequest> request);
  CreateEdgeDriverResponse createEdgeDriverWithOptions(shared_ptr<CreateEdgeDriverRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEdgeDriverResponse createEdgeDriver(shared_ptr<CreateEdgeDriverRequest> request);
  CreateEdgeDriverVersionResponse createEdgeDriverVersionWithOptions(shared_ptr<CreateEdgeDriverVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEdgeDriverVersionResponse createEdgeDriverVersion(shared_ptr<CreateEdgeDriverVersionRequest> request);
  CreateEdgeInstanceResponse createEdgeInstanceWithOptions(shared_ptr<CreateEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEdgeInstanceResponse createEdgeInstance(shared_ptr<CreateEdgeInstanceRequest> request);
  CreateEdgeInstanceChannelResponse createEdgeInstanceChannelWithOptions(shared_ptr<CreateEdgeInstanceChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEdgeInstanceChannelResponse createEdgeInstanceChannel(shared_ptr<CreateEdgeInstanceChannelRequest> request);
  CreateEdgeInstanceDeploymentResponse createEdgeInstanceDeploymentWithOptions(shared_ptr<CreateEdgeInstanceDeploymentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEdgeInstanceDeploymentResponse createEdgeInstanceDeployment(shared_ptr<CreateEdgeInstanceDeploymentRequest> request);
  CreateEdgeInstanceMessageRoutingResponse createEdgeInstanceMessageRoutingWithOptions(shared_ptr<CreateEdgeInstanceMessageRoutingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEdgeInstanceMessageRoutingResponse createEdgeInstanceMessageRouting(shared_ptr<CreateEdgeInstanceMessageRoutingRequest> request);
  CreateEdgeOssPreSignedAddressResponse createEdgeOssPreSignedAddressWithOptions(shared_ptr<CreateEdgeOssPreSignedAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEdgeOssPreSignedAddressResponse createEdgeOssPreSignedAddress(shared_ptr<CreateEdgeOssPreSignedAddressRequest> request);
  CreateJobResponse createJobWithOptions(shared_ptr<CreateJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateJobResponse createJob(shared_ptr<CreateJobRequest> request);
  CreateLoRaNodesTaskResponse createLoRaNodesTaskWithOptions(shared_ptr<CreateLoRaNodesTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLoRaNodesTaskResponse createLoRaNodesTask(shared_ptr<CreateLoRaNodesTaskRequest> request);
  CreateOTADynamicUpgradeJobResponse createOTADynamicUpgradeJobWithOptions(shared_ptr<CreateOTADynamicUpgradeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOTADynamicUpgradeJobResponse createOTADynamicUpgradeJob(shared_ptr<CreateOTADynamicUpgradeJobRequest> request);
  CreateOTAFirmwareResponse createOTAFirmwareWithOptions(shared_ptr<CreateOTAFirmwareRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOTAFirmwareResponse createOTAFirmware(shared_ptr<CreateOTAFirmwareRequest> request);
  CreateOTAModuleResponse createOTAModuleWithOptions(shared_ptr<CreateOTAModuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOTAModuleResponse createOTAModule(shared_ptr<CreateOTAModuleRequest> request);
  CreateOTAStaticUpgradeJobResponse createOTAStaticUpgradeJobWithOptions(shared_ptr<CreateOTAStaticUpgradeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOTAStaticUpgradeJobResponse createOTAStaticUpgradeJob(shared_ptr<CreateOTAStaticUpgradeJobRequest> request);
  CreateOTAVerifyJobResponse createOTAVerifyJobWithOptions(shared_ptr<CreateOTAVerifyJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOTAVerifyJobResponse createOTAVerifyJob(shared_ptr<CreateOTAVerifyJobRequest> request);
  CreateParserResponse createParserWithOptions(shared_ptr<CreateParserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateParserResponse createParser(shared_ptr<CreateParserRequest> request);
  CreateParserDataSourceResponse createParserDataSourceWithOptions(shared_ptr<CreateParserDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateParserDataSourceResponse createParserDataSource(shared_ptr<CreateParserDataSourceRequest> request);
  CreateProductResponse createProductWithOptions(shared_ptr<CreateProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProductResponse createProduct(shared_ptr<CreateProductRequest> request);
  CreateProductDistributeJobResponse createProductDistributeJobWithOptions(shared_ptr<CreateProductDistributeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProductDistributeJobResponse createProductDistributeJob(shared_ptr<CreateProductDistributeJobRequest> request);
  CreateProductTagsResponse createProductTagsWithOptions(shared_ptr<CreateProductTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProductTagsResponse createProductTags(shared_ptr<CreateProductTagsRequest> request);
  CreateProductTopicResponse createProductTopicWithOptions(shared_ptr<CreateProductTopicRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProductTopicResponse createProductTopic(shared_ptr<CreateProductTopicRequest> request);
  CreateRuleResponse createRuleWithOptions(shared_ptr<CreateRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRuleResponse createRule(shared_ptr<CreateRuleRequest> request);
  CreateRuleActionResponse createRuleActionWithOptions(shared_ptr<CreateRuleActionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRuleActionResponse createRuleAction(shared_ptr<CreateRuleActionRequest> request);
  CreateSceneRuleResponse createSceneRuleWithOptions(shared_ptr<CreateSceneRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSceneRuleResponse createSceneRule(shared_ptr<CreateSceneRuleRequest> request);
  CreateSchedulePeriodResponse createSchedulePeriodWithOptions(shared_ptr<CreateSchedulePeriodRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSchedulePeriodResponse createSchedulePeriod(shared_ptr<CreateSchedulePeriodRequest> request);
  CreateSharePromotionActivityResponse createSharePromotionActivityWithOptions(shared_ptr<CreateSharePromotionActivityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSharePromotionActivityResponse createSharePromotionActivity(shared_ptr<CreateSharePromotionActivityRequest> request);
  CreateSharePromotionSpeechModelResponse createSharePromotionSpeechModelWithOptions(shared_ptr<CreateSharePromotionSpeechModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSharePromotionSpeechModelResponse createSharePromotionSpeechModel(shared_ptr<CreateSharePromotionSpeechModelRequest> request);
  CreateSoundCodeResponse createSoundCodeWithOptions(shared_ptr<CreateSoundCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSoundCodeResponse createSoundCode(shared_ptr<CreateSoundCodeRequest> request);
  CreateSoundCodeLabelResponse createSoundCodeLabelWithOptions(shared_ptr<CreateSoundCodeLabelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSoundCodeLabelResponse createSoundCodeLabel(shared_ptr<CreateSoundCodeLabelRequest> request);
  CreateSoundCodeScheduleResponse createSoundCodeScheduleWithOptions(shared_ptr<CreateSoundCodeScheduleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSoundCodeScheduleResponse createSoundCodeSchedule(shared_ptr<CreateSoundCodeScheduleRequest> request);
  CreateSpeechResponse createSpeechWithOptions(shared_ptr<CreateSpeechRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSpeechResponse createSpeech(shared_ptr<CreateSpeechRequest> request);
  CreateStudioAppDomainOpenResponse createStudioAppDomainOpenWithOptions(shared_ptr<CreateStudioAppDomainOpenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateStudioAppDomainOpenResponse createStudioAppDomainOpen(shared_ptr<CreateStudioAppDomainOpenRequest> request);
  CreateSubscribeRelationResponse createSubscribeRelationWithOptions(shared_ptr<CreateSubscribeRelationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSubscribeRelationResponse createSubscribeRelation(shared_ptr<CreateSubscribeRelationRequest> request);
  CreateThingModelResponse createThingModelWithOptions(shared_ptr<CreateThingModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateThingModelResponse createThingModel(shared_ptr<CreateThingModelRequest> request);
  CreateThingScriptResponse createThingScriptWithOptions(shared_ptr<CreateThingScriptRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateThingScriptResponse createThingScript(shared_ptr<CreateThingScriptRequest> request);
  CreateTopicConfigResponse createTopicConfigWithOptions(shared_ptr<CreateTopicConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTopicConfigResponse createTopicConfig(shared_ptr<CreateTopicConfigRequest> request);
  CreateTopicRouteTableResponse createTopicRouteTableWithOptions(shared_ptr<CreateTopicRouteTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTopicRouteTableResponse createTopicRouteTable(shared_ptr<CreateTopicRouteTableRequest> request);
  DeleteClientIdsResponse deleteClientIdsWithOptions(shared_ptr<DeleteClientIdsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteClientIdsResponse deleteClientIds(shared_ptr<DeleteClientIdsRequest> request);
  DeleteConsumerGroupResponse deleteConsumerGroupWithOptions(shared_ptr<DeleteConsumerGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteConsumerGroupResponse deleteConsumerGroup(shared_ptr<DeleteConsumerGroupRequest> request);
  DeleteConsumerGroupSubscribeRelationResponse deleteConsumerGroupSubscribeRelationWithOptions(shared_ptr<DeleteConsumerGroupSubscribeRelationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteConsumerGroupSubscribeRelationResponse deleteConsumerGroupSubscribeRelation(shared_ptr<DeleteConsumerGroupSubscribeRelationRequest> request);
  DeleteDataSourceItemResponse deleteDataSourceItemWithOptions(shared_ptr<DeleteDataSourceItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDataSourceItemResponse deleteDataSourceItem(shared_ptr<DeleteDataSourceItemRequest> request);
  DeleteDestinationResponse deleteDestinationWithOptions(shared_ptr<DeleteDestinationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDestinationResponse deleteDestination(shared_ptr<DeleteDestinationRequest> request);
  DeleteDeviceResponse deleteDeviceWithOptions(shared_ptr<DeleteDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDeviceResponse deleteDevice(shared_ptr<DeleteDeviceRequest> request);
  DeleteDeviceDistributeJobResponse deleteDeviceDistributeJobWithOptions(shared_ptr<DeleteDeviceDistributeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDeviceDistributeJobResponse deleteDeviceDistributeJob(shared_ptr<DeleteDeviceDistributeJobRequest> request);
  DeleteDeviceDynamicGroupResponse deleteDeviceDynamicGroupWithOptions(shared_ptr<DeleteDeviceDynamicGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDeviceDynamicGroupResponse deleteDeviceDynamicGroup(shared_ptr<DeleteDeviceDynamicGroupRequest> request);
  DeleteDeviceFileResponse deleteDeviceFileWithOptions(shared_ptr<DeleteDeviceFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDeviceFileResponse deleteDeviceFile(shared_ptr<DeleteDeviceFileRequest> request);
  DeleteDeviceGroupResponse deleteDeviceGroupWithOptions(shared_ptr<DeleteDeviceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDeviceGroupResponse deleteDeviceGroup(shared_ptr<DeleteDeviceGroupRequest> request);
  DeleteDevicePropResponse deleteDevicePropWithOptions(shared_ptr<DeleteDevicePropRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDevicePropResponse deleteDeviceProp(shared_ptr<DeleteDevicePropRequest> request);
  DeleteDeviceSpeechResponse deleteDeviceSpeechWithOptions(shared_ptr<DeleteDeviceSpeechRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDeviceSpeechResponse deleteDeviceSpeech(shared_ptr<DeleteDeviceSpeechRequest> request);
  DeleteDeviceTunnelResponse deleteDeviceTunnelWithOptions(shared_ptr<DeleteDeviceTunnelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDeviceTunnelResponse deleteDeviceTunnel(shared_ptr<DeleteDeviceTunnelRequest> request);
  DeleteEdgeDriverResponse deleteEdgeDriverWithOptions(shared_ptr<DeleteEdgeDriverRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEdgeDriverResponse deleteEdgeDriver(shared_ptr<DeleteEdgeDriverRequest> request);
  DeleteEdgeDriverVersionResponse deleteEdgeDriverVersionWithOptions(shared_ptr<DeleteEdgeDriverVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEdgeDriverVersionResponse deleteEdgeDriverVersion(shared_ptr<DeleteEdgeDriverVersionRequest> request);
  DeleteEdgeInstanceResponse deleteEdgeInstanceWithOptions(shared_ptr<DeleteEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEdgeInstanceResponse deleteEdgeInstance(shared_ptr<DeleteEdgeInstanceRequest> request);
  DeleteEdgeInstanceMessageRoutingResponse deleteEdgeInstanceMessageRoutingWithOptions(shared_ptr<DeleteEdgeInstanceMessageRoutingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEdgeInstanceMessageRoutingResponse deleteEdgeInstanceMessageRouting(shared_ptr<DeleteEdgeInstanceMessageRoutingRequest> request);
  DeleteJobResponse deleteJobWithOptions(shared_ptr<DeleteJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteJobResponse deleteJob(shared_ptr<DeleteJobRequest> request);
  DeleteOTAFirmwareResponse deleteOTAFirmwareWithOptions(shared_ptr<DeleteOTAFirmwareRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteOTAFirmwareResponse deleteOTAFirmware(shared_ptr<DeleteOTAFirmwareRequest> request);
  DeleteOTAModuleResponse deleteOTAModuleWithOptions(shared_ptr<DeleteOTAModuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteOTAModuleResponse deleteOTAModule(shared_ptr<DeleteOTAModuleRequest> request);
  DeleteParserResponse deleteParserWithOptions(shared_ptr<DeleteParserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteParserResponse deleteParser(shared_ptr<DeleteParserRequest> request);
  DeleteParserDataSourceResponse deleteParserDataSourceWithOptions(shared_ptr<DeleteParserDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteParserDataSourceResponse deleteParserDataSource(shared_ptr<DeleteParserDataSourceRequest> request);
  DeleteProductResponse deleteProductWithOptions(shared_ptr<DeleteProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteProductResponse deleteProduct(shared_ptr<DeleteProductRequest> request);
  DeleteProductTagsResponse deleteProductTagsWithOptions(shared_ptr<DeleteProductTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteProductTagsResponse deleteProductTags(shared_ptr<DeleteProductTagsRequest> request);
  DeleteProductTopicResponse deleteProductTopicWithOptions(shared_ptr<DeleteProductTopicRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteProductTopicResponse deleteProductTopic(shared_ptr<DeleteProductTopicRequest> request);
  DeleteRuleResponse deleteRuleWithOptions(shared_ptr<DeleteRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRuleResponse deleteRule(shared_ptr<DeleteRuleRequest> request);
  DeleteRuleActionResponse deleteRuleActionWithOptions(shared_ptr<DeleteRuleActionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRuleActionResponse deleteRuleAction(shared_ptr<DeleteRuleActionRequest> request);
  DeleteSceneRuleResponse deleteSceneRuleWithOptions(shared_ptr<DeleteSceneRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSceneRuleResponse deleteSceneRule(shared_ptr<DeleteSceneRuleRequest> request);
  DeleteSchedulePeriodResponse deleteSchedulePeriodWithOptions(shared_ptr<DeleteSchedulePeriodRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSchedulePeriodResponse deleteSchedulePeriod(shared_ptr<DeleteSchedulePeriodRequest> request);
  DeleteShareTaskDeviceResponse deleteShareTaskDeviceWithOptions(shared_ptr<DeleteShareTaskDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteShareTaskDeviceResponse deleteShareTaskDevice(shared_ptr<DeleteShareTaskDeviceRequest> request);
  DeleteSoundCodeResponse deleteSoundCodeWithOptions(shared_ptr<DeleteSoundCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSoundCodeResponse deleteSoundCode(shared_ptr<DeleteSoundCodeRequest> request);
  DeleteSoundCodeLabelResponse deleteSoundCodeLabelWithOptions(shared_ptr<DeleteSoundCodeLabelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSoundCodeLabelResponse deleteSoundCodeLabel(shared_ptr<DeleteSoundCodeLabelRequest> request);
  DeleteSoundCodeScheduleResponse deleteSoundCodeScheduleWithOptions(shared_ptr<DeleteSoundCodeScheduleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSoundCodeScheduleResponse deleteSoundCodeSchedule(shared_ptr<DeleteSoundCodeScheduleRequest> request);
  DeleteSpeechResponse deleteSpeechWithOptions(shared_ptr<DeleteSpeechRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSpeechResponse deleteSpeech(shared_ptr<DeleteSpeechRequest> request);
  DeleteStudioAppDomainOpenResponse deleteStudioAppDomainOpenWithOptions(shared_ptr<DeleteStudioAppDomainOpenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteStudioAppDomainOpenResponse deleteStudioAppDomainOpen(shared_ptr<DeleteStudioAppDomainOpenRequest> request);
  DeleteSubscribeRelationResponse deleteSubscribeRelationWithOptions(shared_ptr<DeleteSubscribeRelationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSubscribeRelationResponse deleteSubscribeRelation(shared_ptr<DeleteSubscribeRelationRequest> request);
  DeleteThingModelResponse deleteThingModelWithOptions(shared_ptr<DeleteThingModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteThingModelResponse deleteThingModel(shared_ptr<DeleteThingModelRequest> request);
  DeleteTopicConfigResponse deleteTopicConfigWithOptions(shared_ptr<DeleteTopicConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTopicConfigResponse deleteTopicConfig(shared_ptr<DeleteTopicConfigRequest> request);
  DeleteTopicRouteTableResponse deleteTopicRouteTableWithOptions(shared_ptr<DeleteTopicRouteTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTopicRouteTableResponse deleteTopicRouteTable(shared_ptr<DeleteTopicRouteTableRequest> request);
  DetachDestinationResponse detachDestinationWithOptions(shared_ptr<DetachDestinationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachDestinationResponse detachDestination(shared_ptr<DetachDestinationRequest> request);
  DetachParserDataSourceResponse detachParserDataSourceWithOptions(shared_ptr<DetachParserDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachParserDataSourceResponse detachParserDataSource(shared_ptr<DetachParserDataSourceRequest> request);
  DisableDeviceTunnelResponse disableDeviceTunnelWithOptions(shared_ptr<DisableDeviceTunnelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableDeviceTunnelResponse disableDeviceTunnel(shared_ptr<DisableDeviceTunnelRequest> request);
  DisableDeviceTunnelShareResponse disableDeviceTunnelShareWithOptions(shared_ptr<DisableDeviceTunnelShareRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableDeviceTunnelShareResponse disableDeviceTunnelShare(shared_ptr<DisableDeviceTunnelShareRequest> request);
  DisableSceneRuleResponse disableSceneRuleWithOptions(shared_ptr<DisableSceneRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableSceneRuleResponse disableSceneRule(shared_ptr<DisableSceneRuleRequest> request);
  DisableThingResponse disableThingWithOptions(shared_ptr<DisableThingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableThingResponse disableThing(shared_ptr<DisableThingRequest> request);
  EnableDeviceTunnelResponse enableDeviceTunnelWithOptions(shared_ptr<EnableDeviceTunnelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableDeviceTunnelResponse enableDeviceTunnel(shared_ptr<EnableDeviceTunnelRequest> request);
  EnableDeviceTunnelShareResponse enableDeviceTunnelShareWithOptions(shared_ptr<EnableDeviceTunnelShareRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableDeviceTunnelShareResponse enableDeviceTunnelShare(shared_ptr<EnableDeviceTunnelShareRequest> request);
  EnableSceneRuleResponse enableSceneRuleWithOptions(shared_ptr<EnableSceneRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableSceneRuleResponse enableSceneRule(shared_ptr<EnableSceneRuleRequest> request);
  EnableThingResponse enableThingWithOptions(shared_ptr<EnableThingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableThingResponse enableThing(shared_ptr<EnableThingRequest> request);
  GenerateDeviceNameListURLResponse generateDeviceNameListURLWithOptions(shared_ptr<GenerateDeviceNameListURLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateDeviceNameListURLResponse generateDeviceNameListURL(shared_ptr<GenerateDeviceNameListURLRequest> request);
  GenerateFileUploadURLResponse generateFileUploadURLWithOptions(shared_ptr<GenerateFileUploadURLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateFileUploadURLResponse generateFileUploadURL(shared_ptr<GenerateFileUploadURLRequest> request);
  GenerateOTAUploadURLResponse generateOTAUploadURLWithOptions(shared_ptr<GenerateOTAUploadURLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateOTAUploadURLResponse generateOTAUploadURL(shared_ptr<GenerateOTAUploadURLRequest> request);
  GetDataAPIServiceDetailResponse getDataAPIServiceDetailWithOptions(shared_ptr<GetDataAPIServiceDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataAPIServiceDetailResponse getDataAPIServiceDetail(shared_ptr<GetDataAPIServiceDetailRequest> request);
  GetDestinationResponse getDestinationWithOptions(shared_ptr<GetDestinationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDestinationResponse getDestination(shared_ptr<GetDestinationRequest> request);
  GetDeviceShadowResponse getDeviceShadowWithOptions(shared_ptr<GetDeviceShadowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDeviceShadowResponse getDeviceShadow(shared_ptr<GetDeviceShadowRequest> request);
  GetDeviceStatusResponse getDeviceStatusWithOptions(shared_ptr<GetDeviceStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDeviceStatusResponse getDeviceStatus(shared_ptr<GetDeviceStatusRequest> request);
  GetDeviceTunnelShareStatusResponse getDeviceTunnelShareStatusWithOptions(shared_ptr<GetDeviceTunnelShareStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDeviceTunnelShareStatusResponse getDeviceTunnelShareStatus(shared_ptr<GetDeviceTunnelShareStatusRequest> request);
  GetDeviceTunnelStatusResponse getDeviceTunnelStatusWithOptions(shared_ptr<GetDeviceTunnelStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDeviceTunnelStatusResponse getDeviceTunnelStatus(shared_ptr<GetDeviceTunnelStatusRequest> request);
  GetDownloadFileResponse getDownloadFileWithOptions(shared_ptr<GetDownloadFileRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDownloadFileResponse getDownloadFile(shared_ptr<GetDownloadFileRequest> request);
  GetEdgeDriverVersionResponse getEdgeDriverVersionWithOptions(shared_ptr<GetEdgeDriverVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEdgeDriverVersionResponse getEdgeDriverVersion(shared_ptr<GetEdgeDriverVersionRequest> request);
  GetEdgeInstanceResponse getEdgeInstanceWithOptions(shared_ptr<GetEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEdgeInstanceResponse getEdgeInstance(shared_ptr<GetEdgeInstanceRequest> request);
  GetEdgeInstanceDeploymentResponse getEdgeInstanceDeploymentWithOptions(shared_ptr<GetEdgeInstanceDeploymentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEdgeInstanceDeploymentResponse getEdgeInstanceDeployment(shared_ptr<GetEdgeInstanceDeploymentRequest> request);
  GetEdgeInstanceMessageRoutingResponse getEdgeInstanceMessageRoutingWithOptions(shared_ptr<GetEdgeInstanceMessageRoutingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEdgeInstanceMessageRoutingResponse getEdgeInstanceMessageRouting(shared_ptr<GetEdgeInstanceMessageRoutingRequest> request);
  GetGatewayBySubDeviceResponse getGatewayBySubDeviceWithOptions(shared_ptr<GetGatewayBySubDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetGatewayBySubDeviceResponse getGatewayBySubDevice(shared_ptr<GetGatewayBySubDeviceRequest> request);
  GetLoraNodesTaskResponse getLoraNodesTaskWithOptions(shared_ptr<GetLoraNodesTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLoraNodesTaskResponse getLoraNodesTask(shared_ptr<GetLoraNodesTaskRequest> request);
  GetParserResponse getParserWithOptions(shared_ptr<GetParserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetParserResponse getParser(shared_ptr<GetParserRequest> request);
  GetParserDataSourceResponse getParserDataSourceWithOptions(shared_ptr<GetParserDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetParserDataSourceResponse getParserDataSource(shared_ptr<GetParserDataSourceRequest> request);
  GetRuleResponse getRuleWithOptions(shared_ptr<GetRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRuleResponse getRule(shared_ptr<GetRuleRequest> request);
  GetRuleActionResponse getRuleActionWithOptions(shared_ptr<GetRuleActionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRuleActionResponse getRuleAction(shared_ptr<GetRuleActionRequest> request);
  GetSceneRuleResponse getSceneRuleWithOptions(shared_ptr<GetSceneRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSceneRuleResponse getSceneRule(shared_ptr<GetSceneRuleRequest> request);
  GetShareSpeechModelAudioResponse getShareSpeechModelAudioWithOptions(shared_ptr<GetShareSpeechModelAudioRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetShareSpeechModelAudioResponse getShareSpeechModelAudio(shared_ptr<GetShareSpeechModelAudioRequest> request);
  GetShareTaskByDeviceOpenResponse getShareTaskByDeviceOpenWithOptions(shared_ptr<GetShareTaskByDeviceOpenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetShareTaskByDeviceOpenResponse getShareTaskByDeviceOpen(shared_ptr<GetShareTaskByDeviceOpenRequest> request);
  GetSoundCodeAudioResponse getSoundCodeAudioWithOptions(shared_ptr<GetSoundCodeAudioRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSoundCodeAudioResponse getSoundCodeAudio(shared_ptr<GetSoundCodeAudioRequest> request);
  GetSoundCodeScheduleResponse getSoundCodeScheduleWithOptions(shared_ptr<GetSoundCodeScheduleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSoundCodeScheduleResponse getSoundCodeSchedule(shared_ptr<GetSoundCodeScheduleRequest> request);
  GetSpeechDeviceDetailResponse getSpeechDeviceDetailWithOptions(shared_ptr<GetSpeechDeviceDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSpeechDeviceDetailResponse getSpeechDeviceDetail(shared_ptr<GetSpeechDeviceDetailRequest> request);
  GetSpeechLicenseDeviceStatisticsResponse getSpeechLicenseDeviceStatisticsWithOptions(shared_ptr<GetSpeechLicenseDeviceStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSpeechLicenseDeviceStatisticsResponse getSpeechLicenseDeviceStatistics(shared_ptr<GetSpeechLicenseDeviceStatisticsRequest> request);
  GetSpeechVoiceResponse getSpeechVoiceWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSpeechVoiceResponse getSpeechVoice();
  GetStudioAppTokenOpenResponse getStudioAppTokenOpenWithOptions(shared_ptr<GetStudioAppTokenOpenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetStudioAppTokenOpenResponse getStudioAppTokenOpen(shared_ptr<GetStudioAppTokenOpenRequest> request);
  GetThingModelTslResponse getThingModelTslWithOptions(shared_ptr<GetThingModelTslRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetThingModelTslResponse getThingModelTsl(shared_ptr<GetThingModelTslRequest> request);
  GetThingModelTslPublishedResponse getThingModelTslPublishedWithOptions(shared_ptr<GetThingModelTslPublishedRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetThingModelTslPublishedResponse getThingModelTslPublished(shared_ptr<GetThingModelTslPublishedRequest> request);
  GetThingScriptResponse getThingScriptWithOptions(shared_ptr<GetThingScriptRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetThingScriptResponse getThingScript(shared_ptr<GetThingScriptRequest> request);
  GetThingTemplateResponse getThingTemplateWithOptions(shared_ptr<GetThingTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetThingTemplateResponse getThingTemplate(shared_ptr<GetThingTemplateRequest> request);
  GetThingTopoResponse getThingTopoWithOptions(shared_ptr<GetThingTopoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetThingTopoResponse getThingTopo(shared_ptr<GetThingTopoRequest> request);
  GisQueryDeviceLocationResponse gisQueryDeviceLocationWithOptions(shared_ptr<GisQueryDeviceLocationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GisQueryDeviceLocationResponse gisQueryDeviceLocation(shared_ptr<GisQueryDeviceLocationRequest> request);
  GisSearchDeviceTraceResponse gisSearchDeviceTraceWithOptions(shared_ptr<GisSearchDeviceTraceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GisSearchDeviceTraceResponse gisSearchDeviceTrace(shared_ptr<GisSearchDeviceTraceRequest> request);
  ImportDTDataResponse importDTDataWithOptions(shared_ptr<ImportDTDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportDTDataResponse importDTData(shared_ptr<ImportDTDataRequest> request);
  ImportDeviceResponse importDeviceWithOptions(shared_ptr<ImportDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportDeviceResponse importDevice(shared_ptr<ImportDeviceRequest> request);
  ImportThingModelTslResponse importThingModelTslWithOptions(shared_ptr<ImportThingModelTslRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportThingModelTslResponse importThingModelTsl(shared_ptr<ImportThingModelTslRequest> request);
  InvokeDataAPIServiceResponse invokeDataAPIServiceWithOptions(shared_ptr<InvokeDataAPIServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InvokeDataAPIServiceResponse invokeDataAPIService(shared_ptr<InvokeDataAPIServiceRequest> request);
  InvokeThingServiceResponse invokeThingServiceWithOptions(shared_ptr<InvokeThingServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InvokeThingServiceResponse invokeThingService(shared_ptr<InvokeThingServiceRequest> request);
  InvokeThingsServiceResponse invokeThingsServiceWithOptions(shared_ptr<InvokeThingsServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InvokeThingsServiceResponse invokeThingsService(shared_ptr<InvokeThingsServiceRequest> request);
  ListAnalyticsDataResponse listAnalyticsDataWithOptions(shared_ptr<ListAnalyticsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAnalyticsDataResponse listAnalyticsData(shared_ptr<ListAnalyticsDataRequest> request);
  ListDataSourceItemResponse listDataSourceItemWithOptions(shared_ptr<ListDataSourceItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataSourceItemResponse listDataSourceItem(shared_ptr<ListDataSourceItemRequest> request);
  ListDestinationResponse listDestinationWithOptions(shared_ptr<ListDestinationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDestinationResponse listDestination(shared_ptr<ListDestinationRequest> request);
  ListDeviceDistributeJobResponse listDeviceDistributeJobWithOptions(shared_ptr<ListDeviceDistributeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDeviceDistributeJobResponse listDeviceDistributeJob(shared_ptr<ListDeviceDistributeJobRequest> request);
  ListDistributedDeviceResponse listDistributedDeviceWithOptions(shared_ptr<ListDistributedDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDistributedDeviceResponse listDistributedDevice(shared_ptr<ListDistributedDeviceRequest> request);
  ListDistributedProductResponse listDistributedProductWithOptions(shared_ptr<ListDistributedProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDistributedProductResponse listDistributedProduct(shared_ptr<ListDistributedProductRequest> request);
  ListJobResponse listJobWithOptions(shared_ptr<ListJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListJobResponse listJob(shared_ptr<ListJobRequest> request);
  ListOTAFirmwareResponse listOTAFirmwareWithOptions(shared_ptr<ListOTAFirmwareRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOTAFirmwareResponse listOTAFirmware(shared_ptr<ListOTAFirmwareRequest> request);
  ListOTAJobByDeviceResponse listOTAJobByDeviceWithOptions(shared_ptr<ListOTAJobByDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOTAJobByDeviceResponse listOTAJobByDevice(shared_ptr<ListOTAJobByDeviceRequest> request);
  ListOTAJobByFirmwareResponse listOTAJobByFirmwareWithOptions(shared_ptr<ListOTAJobByFirmwareRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOTAJobByFirmwareResponse listOTAJobByFirmware(shared_ptr<ListOTAJobByFirmwareRequest> request);
  ListOTAModuleByProductResponse listOTAModuleByProductWithOptions(shared_ptr<ListOTAModuleByProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOTAModuleByProductResponse listOTAModuleByProduct(shared_ptr<ListOTAModuleByProductRequest> request);
  ListOTAModuleVersionsByDeviceResponse listOTAModuleVersionsByDeviceWithOptions(shared_ptr<ListOTAModuleVersionsByDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOTAModuleVersionsByDeviceResponse listOTAModuleVersionsByDevice(shared_ptr<ListOTAModuleVersionsByDeviceRequest> request);
  ListOTATaskByJobResponse listOTATaskByJobWithOptions(shared_ptr<ListOTATaskByJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOTATaskByJobResponse listOTATaskByJob(shared_ptr<ListOTATaskByJobRequest> request);
  ListOTAUnfinishedTaskByDeviceResponse listOTAUnfinishedTaskByDeviceWithOptions(shared_ptr<ListOTAUnfinishedTaskByDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOTAUnfinishedTaskByDeviceResponse listOTAUnfinishedTaskByDevice(shared_ptr<ListOTAUnfinishedTaskByDeviceRequest> request);
  ListParserResponse listParserWithOptions(shared_ptr<ListParserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListParserResponse listParser(shared_ptr<ListParserRequest> request);
  ListParserDataSourceResponse listParserDataSourceWithOptions(shared_ptr<ListParserDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListParserDataSourceResponse listParserDataSource(shared_ptr<ListParserDataSourceRequest> request);
  ListParserDestinationResponse listParserDestinationWithOptions(shared_ptr<ListParserDestinationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListParserDestinationResponse listParserDestination(shared_ptr<ListParserDestinationRequest> request);
  ListProductByTagsResponse listProductByTagsWithOptions(shared_ptr<ListProductByTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProductByTagsResponse listProductByTags(shared_ptr<ListProductByTagsRequest> request);
  ListProductTagsResponse listProductTagsWithOptions(shared_ptr<ListProductTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProductTagsResponse listProductTags(shared_ptr<ListProductTagsRequest> request);
  ListRuleResponse listRuleWithOptions(shared_ptr<ListRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRuleResponse listRule(shared_ptr<ListRuleRequest> request);
  ListRuleActionsResponse listRuleActionsWithOptions(shared_ptr<ListRuleActionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRuleActionsResponse listRuleActions(shared_ptr<ListRuleActionsRequest> request);
  ListTaskResponse listTaskWithOptions(shared_ptr<ListTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTaskResponse listTask(shared_ptr<ListTaskRequest> request);
  ListThingModelVersionResponse listThingModelVersionWithOptions(shared_ptr<ListThingModelVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListThingModelVersionResponse listThingModelVersion(shared_ptr<ListThingModelVersionRequest> request);
  ListThingTemplatesResponse listThingTemplatesWithOptions(shared_ptr<ListThingTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListThingTemplatesResponse listThingTemplates(shared_ptr<ListThingTemplatesRequest> request);
  ModifyOTAFirmwareResponse modifyOTAFirmwareWithOptions(shared_ptr<ModifyOTAFirmwareRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyOTAFirmwareResponse modifyOTAFirmware(shared_ptr<ModifyOTAFirmwareRequest> request);
  NotifyAddThingTopoResponse notifyAddThingTopoWithOptions(shared_ptr<NotifyAddThingTopoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  NotifyAddThingTopoResponse notifyAddThingTopo(shared_ptr<NotifyAddThingTopoRequest> request);
  OpenIotServiceResponse openIotServiceWithOptions(shared_ptr<OpenIotServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenIotServiceResponse openIotService(shared_ptr<OpenIotServiceRequest> request);
  PackageSoundCodeLabelBatchAudioResponse packageSoundCodeLabelBatchAudioWithOptions(shared_ptr<PackageSoundCodeLabelBatchAudioRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PackageSoundCodeLabelBatchAudioResponse packageSoundCodeLabelBatchAudio(shared_ptr<PackageSoundCodeLabelBatchAudioRequest> request);
  PageQuerySharedSpeechOpenResponse pageQuerySharedSpeechOpenWithOptions(shared_ptr<PageQuerySharedSpeechOpenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PageQuerySharedSpeechOpenResponse pageQuerySharedSpeechOpen(shared_ptr<PageQuerySharedSpeechOpenRequest> request);
  PageQuerySpeechBroadcastHourResponse pageQuerySpeechBroadcastHourWithOptions(shared_ptr<PageQuerySpeechBroadcastHourRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PageQuerySpeechBroadcastHourResponse pageQuerySpeechBroadcastHour(shared_ptr<PageQuerySpeechBroadcastHourRequest> request);
  PrintByTemplateResponse printByTemplateWithOptions(shared_ptr<PrintByTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PrintByTemplateResponse printByTemplate(shared_ptr<PrintByTemplateRequest> request);
  PubResponse pubWithOptions(shared_ptr<PubRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PubResponse pub(shared_ptr<PubRequest> request);
  PubBroadcastResponse pubBroadcastWithOptions(shared_ptr<PubBroadcastRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PubBroadcastResponse pubBroadcast(shared_ptr<PubBroadcastRequest> request);
  PublishScriptResponse publishScriptWithOptions(shared_ptr<PublishScriptRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublishScriptResponse publishScript(shared_ptr<PublishScriptRequest> request);
  PublishStudioAppResponse publishStudioAppWithOptions(shared_ptr<PublishStudioAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublishStudioAppResponse publishStudioApp(shared_ptr<PublishStudioAppRequest> request);
  PublishThingModelResponse publishThingModelWithOptions(shared_ptr<PublishThingModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublishThingModelResponse publishThingModel(shared_ptr<PublishThingModelRequest> request);
  PushSpeechResponse pushSpeechWithOptions(shared_ptr<PushSpeechRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PushSpeechResponse pushSpeech(shared_ptr<PushSpeechRequest> request);
  QueryBatchRegisterDeviceStatusResponse queryBatchRegisterDeviceStatusWithOptions(shared_ptr<QueryBatchRegisterDeviceStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryBatchRegisterDeviceStatusResponse queryBatchRegisterDeviceStatus(shared_ptr<QueryBatchRegisterDeviceStatusRequest> request);
  QueryCertUrlByApplyIdResponse queryCertUrlByApplyIdWithOptions(shared_ptr<QueryCertUrlByApplyIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryCertUrlByApplyIdResponse queryCertUrlByApplyId(shared_ptr<QueryCertUrlByApplyIdRequest> request);
  QueryClientIdsResponse queryClientIdsWithOptions(shared_ptr<QueryClientIdsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryClientIdsResponse queryClientIds(shared_ptr<QueryClientIdsRequest> request);
  QueryConsumerGroupByGroupIdResponse queryConsumerGroupByGroupIdWithOptions(shared_ptr<QueryConsumerGroupByGroupIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryConsumerGroupByGroupIdResponse queryConsumerGroupByGroupId(shared_ptr<QueryConsumerGroupByGroupIdRequest> request);
  QueryConsumerGroupListResponse queryConsumerGroupListWithOptions(shared_ptr<QueryConsumerGroupListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryConsumerGroupListResponse queryConsumerGroupList(shared_ptr<QueryConsumerGroupListRequest> request);
  QueryConsumerGroupStatusResponse queryConsumerGroupStatusWithOptions(shared_ptr<QueryConsumerGroupStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryConsumerGroupStatusResponse queryConsumerGroupStatus(shared_ptr<QueryConsumerGroupStatusRequest> request);
  QueryDetailSceneRuleLogResponse queryDetailSceneRuleLogWithOptions(shared_ptr<QueryDetailSceneRuleLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDetailSceneRuleLogResponse queryDetailSceneRuleLog(shared_ptr<QueryDetailSceneRuleLogRequest> request);
  QueryDeviceResponse queryDeviceWithOptions(shared_ptr<QueryDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceResponse queryDevice(shared_ptr<QueryDeviceRequest> request);
  QueryDeviceBySQLResponse queryDeviceBySQLWithOptions(shared_ptr<QueryDeviceBySQLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceBySQLResponse queryDeviceBySQL(shared_ptr<QueryDeviceBySQLRequest> request);
  QueryDeviceByStatusResponse queryDeviceByStatusWithOptions(shared_ptr<QueryDeviceByStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceByStatusResponse queryDeviceByStatus(shared_ptr<QueryDeviceByStatusRequest> request);
  QueryDeviceByTagsResponse queryDeviceByTagsWithOptions(shared_ptr<QueryDeviceByTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceByTagsResponse queryDeviceByTags(shared_ptr<QueryDeviceByTagsRequest> request);
  QueryDeviceCertResponse queryDeviceCertWithOptions(shared_ptr<QueryDeviceCertRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceCertResponse queryDeviceCert(shared_ptr<QueryDeviceCertRequest> request);
  QueryDeviceDesiredPropertyResponse queryDeviceDesiredPropertyWithOptions(shared_ptr<QueryDeviceDesiredPropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceDesiredPropertyResponse queryDeviceDesiredProperty(shared_ptr<QueryDeviceDesiredPropertyRequest> request);
  QueryDeviceDetailResponse queryDeviceDetailWithOptions(shared_ptr<QueryDeviceDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceDetailResponse queryDeviceDetail(shared_ptr<QueryDeviceDetailRequest> request);
  QueryDeviceDistributeDetailResponse queryDeviceDistributeDetailWithOptions(shared_ptr<QueryDeviceDistributeDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceDistributeDetailResponse queryDeviceDistributeDetail(shared_ptr<QueryDeviceDistributeDetailRequest> request);
  QueryDeviceDistributeJobResponse queryDeviceDistributeJobWithOptions(shared_ptr<QueryDeviceDistributeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceDistributeJobResponse queryDeviceDistributeJob(shared_ptr<QueryDeviceDistributeJobRequest> request);
  QueryDeviceEventDataResponse queryDeviceEventDataWithOptions(shared_ptr<QueryDeviceEventDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceEventDataResponse queryDeviceEventData(shared_ptr<QueryDeviceEventDataRequest> request);
  QueryDeviceFileResponse queryDeviceFileWithOptions(shared_ptr<QueryDeviceFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceFileResponse queryDeviceFile(shared_ptr<QueryDeviceFileRequest> request);
  QueryDeviceFileListResponse queryDeviceFileListWithOptions(shared_ptr<QueryDeviceFileListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceFileListResponse queryDeviceFileList(shared_ptr<QueryDeviceFileListRequest> request);
  QueryDeviceGroupByDeviceResponse queryDeviceGroupByDeviceWithOptions(shared_ptr<QueryDeviceGroupByDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceGroupByDeviceResponse queryDeviceGroupByDevice(shared_ptr<QueryDeviceGroupByDeviceRequest> request);
  QueryDeviceGroupByTagsResponse queryDeviceGroupByTagsWithOptions(shared_ptr<QueryDeviceGroupByTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceGroupByTagsResponse queryDeviceGroupByTags(shared_ptr<QueryDeviceGroupByTagsRequest> request);
  QueryDeviceGroupInfoResponse queryDeviceGroupInfoWithOptions(shared_ptr<QueryDeviceGroupInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceGroupInfoResponse queryDeviceGroupInfo(shared_ptr<QueryDeviceGroupInfoRequest> request);
  QueryDeviceGroupListResponse queryDeviceGroupListWithOptions(shared_ptr<QueryDeviceGroupListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceGroupListResponse queryDeviceGroupList(shared_ptr<QueryDeviceGroupListRequest> request);
  QueryDeviceGroupTagListResponse queryDeviceGroupTagListWithOptions(shared_ptr<QueryDeviceGroupTagListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceGroupTagListResponse queryDeviceGroupTagList(shared_ptr<QueryDeviceGroupTagListRequest> request);
  QueryDeviceInfoResponse queryDeviceInfoWithOptions(shared_ptr<QueryDeviceInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceInfoResponse queryDeviceInfo(shared_ptr<QueryDeviceInfoRequest> request);
  QueryDeviceListByDeviceGroupResponse queryDeviceListByDeviceGroupWithOptions(shared_ptr<QueryDeviceListByDeviceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceListByDeviceGroupResponse queryDeviceListByDeviceGroup(shared_ptr<QueryDeviceListByDeviceGroupRequest> request);
  QueryDeviceOriginalEventDataResponse queryDeviceOriginalEventDataWithOptions(shared_ptr<QueryDeviceOriginalEventDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceOriginalEventDataResponse queryDeviceOriginalEventData(shared_ptr<QueryDeviceOriginalEventDataRequest> request);
  QueryDeviceOriginalPropertyDataResponse queryDeviceOriginalPropertyDataWithOptions(shared_ptr<QueryDeviceOriginalPropertyDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceOriginalPropertyDataResponse queryDeviceOriginalPropertyData(shared_ptr<QueryDeviceOriginalPropertyDataRequest> request);
  QueryDeviceOriginalPropertyStatusResponse queryDeviceOriginalPropertyStatusWithOptions(shared_ptr<QueryDeviceOriginalPropertyStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceOriginalPropertyStatusResponse queryDeviceOriginalPropertyStatus(shared_ptr<QueryDeviceOriginalPropertyStatusRequest> request);
  QueryDeviceOriginalServiceDataResponse queryDeviceOriginalServiceDataWithOptions(shared_ptr<QueryDeviceOriginalServiceDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceOriginalServiceDataResponse queryDeviceOriginalServiceData(shared_ptr<QueryDeviceOriginalServiceDataRequest> request);
  QueryDevicePropResponse queryDevicePropWithOptions(shared_ptr<QueryDevicePropRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDevicePropResponse queryDeviceProp(shared_ptr<QueryDevicePropRequest> request);
  QueryDevicePropertiesDataResponse queryDevicePropertiesDataWithOptions(shared_ptr<QueryDevicePropertiesDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDevicePropertiesDataResponse queryDevicePropertiesData(shared_ptr<QueryDevicePropertiesDataRequest> request);
  QueryDevicePropertyDataResponse queryDevicePropertyDataWithOptions(shared_ptr<QueryDevicePropertyDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDevicePropertyDataResponse queryDevicePropertyData(shared_ptr<QueryDevicePropertyDataRequest> request);
  QueryDevicePropertyStatusResponse queryDevicePropertyStatusWithOptions(shared_ptr<QueryDevicePropertyStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDevicePropertyStatusResponse queryDevicePropertyStatus(shared_ptr<QueryDevicePropertyStatusRequest> request);
  QueryDeviceProvisioningResponse queryDeviceProvisioningWithOptions(shared_ptr<QueryDeviceProvisioningRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceProvisioningResponse queryDeviceProvisioning(shared_ptr<QueryDeviceProvisioningRequest> request);
  QueryDeviceServiceDataResponse queryDeviceServiceDataWithOptions(shared_ptr<QueryDeviceServiceDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceServiceDataResponse queryDeviceServiceData(shared_ptr<QueryDeviceServiceDataRequest> request);
  QueryDeviceSpeechResponse queryDeviceSpeechWithOptions(shared_ptr<QueryDeviceSpeechRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceSpeechResponse queryDeviceSpeech(shared_ptr<QueryDeviceSpeechRequest> request);
  QueryDeviceStatisticsResponse queryDeviceStatisticsWithOptions(shared_ptr<QueryDeviceStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceStatisticsResponse queryDeviceStatistics(shared_ptr<QueryDeviceStatisticsRequest> request);
  QueryDeviceSubTopicResponse queryDeviceSubTopicWithOptions(shared_ptr<QueryDeviceSubTopicRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceSubTopicResponse queryDeviceSubTopic(shared_ptr<QueryDeviceSubTopicRequest> request);
  QueryDeviceTunnelResponse queryDeviceTunnelWithOptions(shared_ptr<QueryDeviceTunnelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceTunnelResponse queryDeviceTunnel(shared_ptr<QueryDeviceTunnelRequest> request);
  QueryDevicesHotStorageDataResponse queryDevicesHotStorageDataWithOptions(shared_ptr<QueryDevicesHotStorageDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDevicesHotStorageDataResponse queryDevicesHotStorageData(shared_ptr<QueryDevicesHotStorageDataRequest> request);
  QueryDevicesHotStorageDataStatusResponse queryDevicesHotStorageDataStatusWithOptions(shared_ptr<QueryDevicesHotStorageDataStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDevicesHotStorageDataStatusResponse queryDevicesHotStorageDataStatus(shared_ptr<QueryDevicesHotStorageDataStatusRequest> request);
  QueryDynamicGroupDevicesResponse queryDynamicGroupDevicesWithOptions(shared_ptr<QueryDynamicGroupDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDynamicGroupDevicesResponse queryDynamicGroupDevices(shared_ptr<QueryDynamicGroupDevicesRequest> request);
  QueryEdgeDriverResponse queryEdgeDriverWithOptions(shared_ptr<QueryEdgeDriverRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeDriverResponse queryEdgeDriver(shared_ptr<QueryEdgeDriverRequest> request);
  QueryEdgeDriverVersionResponse queryEdgeDriverVersionWithOptions(shared_ptr<QueryEdgeDriverVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeDriverVersionResponse queryEdgeDriverVersion(shared_ptr<QueryEdgeDriverVersionRequest> request);
  QueryEdgeInstanceResponse queryEdgeInstanceWithOptions(shared_ptr<QueryEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeInstanceResponse queryEdgeInstance(shared_ptr<QueryEdgeInstanceRequest> request);
  QueryEdgeInstanceChannelResponse queryEdgeInstanceChannelWithOptions(shared_ptr<QueryEdgeInstanceChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeInstanceChannelResponse queryEdgeInstanceChannel(shared_ptr<QueryEdgeInstanceChannelRequest> request);
  QueryEdgeInstanceDeviceResponse queryEdgeInstanceDeviceWithOptions(shared_ptr<QueryEdgeInstanceDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeInstanceDeviceResponse queryEdgeInstanceDevice(shared_ptr<QueryEdgeInstanceDeviceRequest> request);
  QueryEdgeInstanceDeviceByDriverResponse queryEdgeInstanceDeviceByDriverWithOptions(shared_ptr<QueryEdgeInstanceDeviceByDriverRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeInstanceDeviceByDriverResponse queryEdgeInstanceDeviceByDriver(shared_ptr<QueryEdgeInstanceDeviceByDriverRequest> request);
  QueryEdgeInstanceDriverResponse queryEdgeInstanceDriverWithOptions(shared_ptr<QueryEdgeInstanceDriverRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeInstanceDriverResponse queryEdgeInstanceDriver(shared_ptr<QueryEdgeInstanceDriverRequest> request);
  QueryEdgeInstanceGatewayResponse queryEdgeInstanceGatewayWithOptions(shared_ptr<QueryEdgeInstanceGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeInstanceGatewayResponse queryEdgeInstanceGateway(shared_ptr<QueryEdgeInstanceGatewayRequest> request);
  QueryEdgeInstanceHistoricDeploymentResponse queryEdgeInstanceHistoricDeploymentWithOptions(shared_ptr<QueryEdgeInstanceHistoricDeploymentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeInstanceHistoricDeploymentResponse queryEdgeInstanceHistoricDeployment(shared_ptr<QueryEdgeInstanceHistoricDeploymentRequest> request);
  QueryEdgeInstanceMessageRoutingResponse queryEdgeInstanceMessageRoutingWithOptions(shared_ptr<QueryEdgeInstanceMessageRoutingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeInstanceMessageRoutingResponse queryEdgeInstanceMessageRouting(shared_ptr<QueryEdgeInstanceMessageRoutingRequest> request);
  QueryEdgeInstanceSceneRuleResponse queryEdgeInstanceSceneRuleWithOptions(shared_ptr<QueryEdgeInstanceSceneRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeInstanceSceneRuleResponse queryEdgeInstanceSceneRule(shared_ptr<QueryEdgeInstanceSceneRuleRequest> request);
  QueryImportedDeviceByApplyIdResponse queryImportedDeviceByApplyIdWithOptions(shared_ptr<QueryImportedDeviceByApplyIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryImportedDeviceByApplyIdResponse queryImportedDeviceByApplyId(shared_ptr<QueryImportedDeviceByApplyIdRequest> request);
  QueryJobResponse queryJobWithOptions(shared_ptr<QueryJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryJobResponse queryJob(shared_ptr<QueryJobRequest> request);
  QueryJobStatisticsResponse queryJobStatisticsWithOptions(shared_ptr<QueryJobStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryJobStatisticsResponse queryJobStatistics(shared_ptr<QueryJobStatisticsRequest> request);
  QueryLicenseDeviceListResponse queryLicenseDeviceListWithOptions(shared_ptr<QueryLicenseDeviceListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryLicenseDeviceListResponse queryLicenseDeviceList(shared_ptr<QueryLicenseDeviceListRequest> request);
  QueryLoRaJoinPermissionsResponse queryLoRaJoinPermissionsWithOptions(shared_ptr<QueryLoRaJoinPermissionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryLoRaJoinPermissionsResponse queryLoRaJoinPermissions(shared_ptr<QueryLoRaJoinPermissionsRequest> request);
  QueryMessageInfoResponse queryMessageInfoWithOptions(shared_ptr<QueryMessageInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMessageInfoResponse queryMessageInfo(shared_ptr<QueryMessageInfoRequest> request);
  QueryOTAFirmwareResponse queryOTAFirmwareWithOptions(shared_ptr<QueryOTAFirmwareRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryOTAFirmwareResponse queryOTAFirmware(shared_ptr<QueryOTAFirmwareRequest> request);
  QueryOTAJobResponse queryOTAJobWithOptions(shared_ptr<QueryOTAJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryOTAJobResponse queryOTAJob(shared_ptr<QueryOTAJobRequest> request);
  QueryPageByApplyIdResponse queryPageByApplyIdWithOptions(shared_ptr<QueryPageByApplyIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryPageByApplyIdResponse queryPageByApplyId(shared_ptr<QueryPageByApplyIdRequest> request);
  QueryProductResponse queryProductWithOptions(shared_ptr<QueryProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryProductResponse queryProduct(shared_ptr<QueryProductRequest> request);
  QueryProductCertInfoResponse queryProductCertInfoWithOptions(shared_ptr<QueryProductCertInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryProductCertInfoResponse queryProductCertInfo(shared_ptr<QueryProductCertInfoRequest> request);
  QueryProductListResponse queryProductListWithOptions(shared_ptr<QueryProductListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryProductListResponse queryProductList(shared_ptr<QueryProductListRequest> request);
  QueryProductTopicResponse queryProductTopicWithOptions(shared_ptr<QueryProductTopicRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryProductTopicResponse queryProductTopic(shared_ptr<QueryProductTopicRequest> request);
  QueryProjectShareDeviceListResponse queryProjectShareDeviceListWithOptions(shared_ptr<QueryProjectShareDeviceListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryProjectShareDeviceListResponse queryProjectShareDeviceList(shared_ptr<QueryProjectShareDeviceListRequest> request);
  QuerySceneRuleResponse querySceneRuleWithOptions(shared_ptr<QuerySceneRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySceneRuleResponse querySceneRule(shared_ptr<QuerySceneRuleRequest> request);
  QuerySchedulePeriodListResponse querySchedulePeriodListWithOptions(shared_ptr<QuerySchedulePeriodListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySchedulePeriodListResponse querySchedulePeriodList(shared_ptr<QuerySchedulePeriodListRequest> request);
  QuerySharePromotionActivityAuditResultResponse querySharePromotionActivityAuditResultWithOptions(shared_ptr<QuerySharePromotionActivityAuditResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySharePromotionActivityAuditResultResponse querySharePromotionActivityAuditResult(shared_ptr<QuerySharePromotionActivityAuditResultRequest> request);
  QueryShareTaskDeviceListResponse queryShareTaskDeviceListWithOptions(shared_ptr<QueryShareTaskDeviceListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryShareTaskDeviceListResponse queryShareTaskDeviceList(shared_ptr<QueryShareTaskDeviceListRequest> request);
  QuerySolutionDeviceGroupPageResponse querySolutionDeviceGroupPageWithOptions(shared_ptr<QuerySolutionDeviceGroupPageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySolutionDeviceGroupPageResponse querySolutionDeviceGroupPage(shared_ptr<QuerySolutionDeviceGroupPageRequest> request);
  QuerySoundCodeLabelBatchFailedResultResponse querySoundCodeLabelBatchFailedResultWithOptions(shared_ptr<QuerySoundCodeLabelBatchFailedResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySoundCodeLabelBatchFailedResultResponse querySoundCodeLabelBatchFailedResult(shared_ptr<QuerySoundCodeLabelBatchFailedResultRequest> request);
  QuerySoundCodeLabelBatchListResponse querySoundCodeLabelBatchListWithOptions(shared_ptr<QuerySoundCodeLabelBatchListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySoundCodeLabelBatchListResponse querySoundCodeLabelBatchList(shared_ptr<QuerySoundCodeLabelBatchListRequest> request);
  QuerySoundCodeLabelListResponse querySoundCodeLabelListWithOptions(shared_ptr<QuerySoundCodeLabelListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySoundCodeLabelListResponse querySoundCodeLabelList(shared_ptr<QuerySoundCodeLabelListRequest> request);
  QuerySoundCodeListResponse querySoundCodeListWithOptions(shared_ptr<QuerySoundCodeListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySoundCodeListResponse querySoundCodeList(shared_ptr<QuerySoundCodeListRequest> request);
  QuerySoundCodeScheduleListResponse querySoundCodeScheduleListWithOptions(shared_ptr<QuerySoundCodeScheduleListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySoundCodeScheduleListResponse querySoundCodeScheduleList(shared_ptr<QuerySoundCodeScheduleListRequest> request);
  QuerySpeechResponse querySpeechWithOptions(shared_ptr<QuerySpeechRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySpeechResponse querySpeech(shared_ptr<QuerySpeechRequest> request);
  QuerySpeechDeviceResponse querySpeechDeviceWithOptions(shared_ptr<QuerySpeechDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySpeechDeviceResponse querySpeechDevice(shared_ptr<QuerySpeechDeviceRequest> request);
  QuerySpeechLicenseAvailableQuotaResponse querySpeechLicenseAvailableQuotaWithOptions(shared_ptr<QuerySpeechLicenseAvailableQuotaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySpeechLicenseAvailableQuotaResponse querySpeechLicenseAvailableQuota(shared_ptr<QuerySpeechLicenseAvailableQuotaRequest> request);
  QuerySpeechLicenseDeviceListResponse querySpeechLicenseDeviceListWithOptions(shared_ptr<QuerySpeechLicenseDeviceListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySpeechLicenseDeviceListResponse querySpeechLicenseDeviceList(shared_ptr<QuerySpeechLicenseDeviceListRequest> request);
  QuerySpeechListResponse querySpeechListWithOptions(shared_ptr<QuerySpeechListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySpeechListResponse querySpeechList(shared_ptr<QuerySpeechListRequest> request);
  QuerySpeechPushJobResponse querySpeechPushJobWithOptions(shared_ptr<QuerySpeechPushJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySpeechPushJobResponse querySpeechPushJob(shared_ptr<QuerySpeechPushJobRequest> request);
  QuerySpeechPushJobDeviceResponse querySpeechPushJobDeviceWithOptions(shared_ptr<QuerySpeechPushJobDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySpeechPushJobDeviceResponse querySpeechPushJobDevice(shared_ptr<QuerySpeechPushJobDeviceRequest> request);
  QuerySpeechPushJobSpeechResponse querySpeechPushJobSpeechWithOptions(shared_ptr<QuerySpeechPushJobSpeechRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySpeechPushJobSpeechResponse querySpeechPushJobSpeech(shared_ptr<QuerySpeechPushJobSpeechRequest> request);
  QueryStudioAppDomainListOpenResponse queryStudioAppDomainListOpenWithOptions(shared_ptr<QueryStudioAppDomainListOpenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryStudioAppDomainListOpenResponse queryStudioAppDomainListOpen(shared_ptr<QueryStudioAppDomainListOpenRequest> request);
  QueryStudioAppListResponse queryStudioAppListWithOptions(shared_ptr<QueryStudioAppListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryStudioAppListResponse queryStudioAppList(shared_ptr<QueryStudioAppListRequest> request);
  QueryStudioAppPageListOpenResponse queryStudioAppPageListOpenWithOptions(shared_ptr<QueryStudioAppPageListOpenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryStudioAppPageListOpenResponse queryStudioAppPageListOpen(shared_ptr<QueryStudioAppPageListOpenRequest> request);
  QueryStudioProjectListResponse queryStudioProjectListWithOptions(shared_ptr<QueryStudioProjectListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryStudioProjectListResponse queryStudioProjectList(shared_ptr<QueryStudioProjectListRequest> request);
  QuerySubscribeRelationResponse querySubscribeRelationWithOptions(shared_ptr<QuerySubscribeRelationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySubscribeRelationResponse querySubscribeRelation(shared_ptr<QuerySubscribeRelationRequest> request);
  QuerySummarySceneRuleLogResponse querySummarySceneRuleLogWithOptions(shared_ptr<QuerySummarySceneRuleLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySummarySceneRuleLogResponse querySummarySceneRuleLog(shared_ptr<QuerySummarySceneRuleLogRequest> request);
  QuerySuperDeviceGroupResponse querySuperDeviceGroupWithOptions(shared_ptr<QuerySuperDeviceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySuperDeviceGroupResponse querySuperDeviceGroup(shared_ptr<QuerySuperDeviceGroupRequest> request);
  QueryTaskResponse queryTaskWithOptions(shared_ptr<QueryTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTaskResponse queryTask(shared_ptr<QueryTaskRequest> request);
  QueryThingModelResponse queryThingModelWithOptions(shared_ptr<QueryThingModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryThingModelResponse queryThingModel(shared_ptr<QueryThingModelRequest> request);
  QueryThingModelExtendConfigResponse queryThingModelExtendConfigWithOptions(shared_ptr<QueryThingModelExtendConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryThingModelExtendConfigResponse queryThingModelExtendConfig(shared_ptr<QueryThingModelExtendConfigRequest> request);
  QueryThingModelExtendConfigPublishedResponse queryThingModelExtendConfigPublishedWithOptions(shared_ptr<QueryThingModelExtendConfigPublishedRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryThingModelExtendConfigPublishedResponse queryThingModelExtendConfigPublished(shared_ptr<QueryThingModelExtendConfigPublishedRequest> request);
  QueryThingModelPublishedResponse queryThingModelPublishedWithOptions(shared_ptr<QueryThingModelPublishedRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryThingModelPublishedResponse queryThingModelPublished(shared_ptr<QueryThingModelPublishedRequest> request);
  QueryTopicConfigResponse queryTopicConfigWithOptions(shared_ptr<QueryTopicConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTopicConfigResponse queryTopicConfig(shared_ptr<QueryTopicConfigRequest> request);
  QueryTopicReverseRouteTableResponse queryTopicReverseRouteTableWithOptions(shared_ptr<QueryTopicReverseRouteTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTopicReverseRouteTableResponse queryTopicReverseRouteTable(shared_ptr<QueryTopicReverseRouteTableRequest> request);
  QueryTopicRouteTableResponse queryTopicRouteTableWithOptions(shared_ptr<QueryTopicRouteTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTopicRouteTableResponse queryTopicRouteTable(shared_ptr<QueryTopicRouteTableRequest> request);
  QueryVehicleDeviceResponse queryVehicleDeviceWithOptions(shared_ptr<QueryVehicleDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryVehicleDeviceResponse queryVehicleDevice(shared_ptr<QueryVehicleDeviceRequest> request);
  RRpcResponse rRpcWithOptions(shared_ptr<RRpcRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RRpcResponse rRpc(shared_ptr<RRpcRequest> request);
  ReBindLicenseDeviceResponse reBindLicenseDeviceWithOptions(shared_ptr<ReBindLicenseDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReBindLicenseDeviceResponse reBindLicenseDevice(shared_ptr<ReBindLicenseDeviceRequest> request);
  RecognizeCarNumResponse recognizeCarNumWithOptions(shared_ptr<RecognizeCarNumRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RecognizeCarNumResponse recognizeCarNum(shared_ptr<RecognizeCarNumRequest> request);
  RecognizePictureGeneralResponse recognizePictureGeneralWithOptions(shared_ptr<RecognizePictureGeneralRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RecognizePictureGeneralResponse recognizePictureGeneral(shared_ptr<RecognizePictureGeneralRequest> request);
  RefreshDeviceTunnelSharePasswordResponse refreshDeviceTunnelSharePasswordWithOptions(shared_ptr<RefreshDeviceTunnelSharePasswordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefreshDeviceTunnelSharePasswordResponse refreshDeviceTunnelSharePassword(shared_ptr<RefreshDeviceTunnelSharePasswordRequest> request);
  RefreshStudioAppTokenOpenResponse refreshStudioAppTokenOpenWithOptions(shared_ptr<RefreshStudioAppTokenOpenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefreshStudioAppTokenOpenResponse refreshStudioAppTokenOpen(shared_ptr<RefreshStudioAppTokenOpenRequest> request);
  RegisterDeviceResponse registerDeviceWithOptions(shared_ptr<RegisterDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RegisterDeviceResponse registerDevice(shared_ptr<RegisterDeviceRequest> request);
  ReleaseEdgeDriverVersionResponse releaseEdgeDriverVersionWithOptions(shared_ptr<ReleaseEdgeDriverVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseEdgeDriverVersionResponse releaseEdgeDriverVersion(shared_ptr<ReleaseEdgeDriverVersionRequest> request);
  ReleaseProductResponse releaseProductWithOptions(shared_ptr<ReleaseProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseProductResponse releaseProduct(shared_ptr<ReleaseProductRequest> request);
  RemoveThingTopoResponse removeThingTopoWithOptions(shared_ptr<RemoveThingTopoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveThingTopoResponse removeThingTopo(shared_ptr<RemoveThingTopoRequest> request);
  ReplaceEdgeInstanceGatewayResponse replaceEdgeInstanceGatewayWithOptions(shared_ptr<ReplaceEdgeInstanceGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReplaceEdgeInstanceGatewayResponse replaceEdgeInstanceGateway(shared_ptr<ReplaceEdgeInstanceGatewayRequest> request);
  RerunJobResponse rerunJobWithOptions(shared_ptr<RerunJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RerunJobResponse rerunJob(shared_ptr<RerunJobRequest> request);
  ResetConsumerGroupPositionResponse resetConsumerGroupPositionWithOptions(shared_ptr<ResetConsumerGroupPositionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetConsumerGroupPositionResponse resetConsumerGroupPosition(shared_ptr<ResetConsumerGroupPositionRequest> request);
  ResetThingResponse resetThingWithOptions(shared_ptr<ResetThingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetThingResponse resetThing(shared_ptr<ResetThingRequest> request);
  RetrySoundCodeLabelBatchResponse retrySoundCodeLabelBatchWithOptions(shared_ptr<RetrySoundCodeLabelBatchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RetrySoundCodeLabelBatchResponse retrySoundCodeLabelBatch(shared_ptr<RetrySoundCodeLabelBatchRequest> request);
  ReupgradeOTATaskResponse reupgradeOTATaskWithOptions(shared_ptr<ReupgradeOTATaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReupgradeOTATaskResponse reupgradeOTATask(shared_ptr<ReupgradeOTATaskRequest> request);
  SaveDevicePropResponse saveDevicePropWithOptions(shared_ptr<SaveDevicePropRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveDevicePropResponse saveDeviceProp(shared_ptr<SaveDevicePropRequest> request);
  SaveScriptResponse saveScriptWithOptions(shared_ptr<SaveScriptRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveScriptResponse saveScript(shared_ptr<SaveScriptRequest> request);
  SetDeviceDesiredPropertyResponse setDeviceDesiredPropertyWithOptions(shared_ptr<SetDeviceDesiredPropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDeviceDesiredPropertyResponse setDeviceDesiredProperty(shared_ptr<SetDeviceDesiredPropertyRequest> request);
  SetDeviceGroupTagsResponse setDeviceGroupTagsWithOptions(shared_ptr<SetDeviceGroupTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDeviceGroupTagsResponse setDeviceGroupTags(shared_ptr<SetDeviceGroupTagsRequest> request);
  SetDevicePropertyResponse setDevicePropertyWithOptions(shared_ptr<SetDevicePropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDevicePropertyResponse setDeviceProperty(shared_ptr<SetDevicePropertyRequest> request);
  SetDevicesPropertyResponse setDevicesPropertyWithOptions(shared_ptr<SetDevicesPropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDevicesPropertyResponse setDevicesProperty(shared_ptr<SetDevicesPropertyRequest> request);
  SetEdgeInstanceDriverConfigsResponse setEdgeInstanceDriverConfigsWithOptions(shared_ptr<SetEdgeInstanceDriverConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetEdgeInstanceDriverConfigsResponse setEdgeInstanceDriverConfigs(shared_ptr<SetEdgeInstanceDriverConfigsRequest> request);
  SetProductCertInfoResponse setProductCertInfoWithOptions(shared_ptr<SetProductCertInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetProductCertInfoResponse setProductCertInfo(shared_ptr<SetProductCertInfoRequest> request);
  SetStudioProjectCooperationResponse setStudioProjectCooperationWithOptions(shared_ptr<SetStudioProjectCooperationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetStudioProjectCooperationResponse setStudioProjectCooperation(shared_ptr<SetStudioProjectCooperationRequest> request);
  SetupStudioAppAuthModeOpenResponse setupStudioAppAuthModeOpenWithOptions(shared_ptr<SetupStudioAppAuthModeOpenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetupStudioAppAuthModeOpenResponse setupStudioAppAuthModeOpen(shared_ptr<SetupStudioAppAuthModeOpenRequest> request);
  ShareSpeechByCombinationResponse shareSpeechByCombinationWithOptions(shared_ptr<ShareSpeechByCombinationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ShareSpeechByCombinationResponse shareSpeechByCombination(shared_ptr<ShareSpeechByCombinationRequest> request);
  SpeechByCombinationResponse speechByCombinationWithOptions(shared_ptr<SpeechByCombinationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SpeechByCombinationResponse speechByCombination(shared_ptr<SpeechByCombinationRequest> request);
  SpeechBySynthesisResponse speechBySynthesisWithOptions(shared_ptr<SpeechBySynthesisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SpeechBySynthesisResponse speechBySynthesis(shared_ptr<SpeechBySynthesisRequest> request);
  StartParserResponse startParserWithOptions(shared_ptr<StartParserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartParserResponse startParser(shared_ptr<StartParserRequest> request);
  StartRuleResponse startRuleWithOptions(shared_ptr<StartRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartRuleResponse startRule(shared_ptr<StartRuleRequest> request);
  StopParserResponse stopParserWithOptions(shared_ptr<StopParserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopParserResponse stopParser(shared_ptr<StopParserRequest> request);
  StopRuleResponse stopRuleWithOptions(shared_ptr<StopRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopRuleResponse stopRule(shared_ptr<StopRuleRequest> request);
  SubscribeTopicResponse subscribeTopicWithOptions(shared_ptr<SubscribeTopicRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubscribeTopicResponse subscribeTopic(shared_ptr<SubscribeTopicRequest> request);
  SyncSpeechByCombinationResponse syncSpeechByCombinationWithOptions(shared_ptr<SyncSpeechByCombinationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SyncSpeechByCombinationResponse syncSpeechByCombination(shared_ptr<SyncSpeechByCombinationRequest> request);
  TestSpeechResponse testSpeechWithOptions(shared_ptr<TestSpeechRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TestSpeechResponse testSpeech(shared_ptr<TestSpeechRequest> request);
  TestSwitchResponse testSwitchWithOptions(shared_ptr<TestSwitchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TestSwitchResponse testSwitch(shared_ptr<TestSwitchRequest> request);
  TransformClientIdResponse transformClientIdWithOptions(shared_ptr<TransformClientIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TransformClientIdResponse transformClientId(shared_ptr<TransformClientIdRequest> request);
  TriggerSceneRuleResponse triggerSceneRuleWithOptions(shared_ptr<TriggerSceneRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TriggerSceneRuleResponse triggerSceneRule(shared_ptr<TriggerSceneRuleRequest> request);
  UnbindApplicationFromEdgeInstanceResponse unbindApplicationFromEdgeInstanceWithOptions(shared_ptr<UnbindApplicationFromEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindApplicationFromEdgeInstanceResponse unbindApplicationFromEdgeInstance(shared_ptr<UnbindApplicationFromEdgeInstanceRequest> request);
  UnbindDriverFromEdgeInstanceResponse unbindDriverFromEdgeInstanceWithOptions(shared_ptr<UnbindDriverFromEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindDriverFromEdgeInstanceResponse unbindDriverFromEdgeInstance(shared_ptr<UnbindDriverFromEdgeInstanceRequest> request);
  UnbindLicenseProductResponse unbindLicenseProductWithOptions(shared_ptr<UnbindLicenseProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindLicenseProductResponse unbindLicenseProduct(shared_ptr<UnbindLicenseProductRequest> request);
  UnbindRoleFromEdgeInstanceResponse unbindRoleFromEdgeInstanceWithOptions(shared_ptr<UnbindRoleFromEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindRoleFromEdgeInstanceResponse unbindRoleFromEdgeInstance(shared_ptr<UnbindRoleFromEdgeInstanceRequest> request);
  UnbindSceneRuleFromEdgeInstanceResponse unbindSceneRuleFromEdgeInstanceWithOptions(shared_ptr<UnbindSceneRuleFromEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindSceneRuleFromEdgeInstanceResponse unbindSceneRuleFromEdgeInstance(shared_ptr<UnbindSceneRuleFromEdgeInstanceRequest> request);
  UpdateConsumerGroupResponse updateConsumerGroupWithOptions(shared_ptr<UpdateConsumerGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateConsumerGroupResponse updateConsumerGroup(shared_ptr<UpdateConsumerGroupRequest> request);
  UpdateDestinationResponse updateDestinationWithOptions(shared_ptr<UpdateDestinationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDestinationResponse updateDestination(shared_ptr<UpdateDestinationRequest> request);
  UpdateDeviceGroupResponse updateDeviceGroupWithOptions(shared_ptr<UpdateDeviceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDeviceGroupResponse updateDeviceGroup(shared_ptr<UpdateDeviceGroupRequest> request);
  UpdateDeviceShadowResponse updateDeviceShadowWithOptions(shared_ptr<UpdateDeviceShadowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDeviceShadowResponse updateDeviceShadow(shared_ptr<UpdateDeviceShadowRequest> request);
  UpdateEdgeDriverVersionResponse updateEdgeDriverVersionWithOptions(shared_ptr<UpdateEdgeDriverVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEdgeDriverVersionResponse updateEdgeDriverVersion(shared_ptr<UpdateEdgeDriverVersionRequest> request);
  UpdateEdgeInstanceResponse updateEdgeInstanceWithOptions(shared_ptr<UpdateEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEdgeInstanceResponse updateEdgeInstance(shared_ptr<UpdateEdgeInstanceRequest> request);
  UpdateEdgeInstanceChannelResponse updateEdgeInstanceChannelWithOptions(shared_ptr<UpdateEdgeInstanceChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEdgeInstanceChannelResponse updateEdgeInstanceChannel(shared_ptr<UpdateEdgeInstanceChannelRequest> request);
  UpdateEdgeInstanceMessageRoutingResponse updateEdgeInstanceMessageRoutingWithOptions(shared_ptr<UpdateEdgeInstanceMessageRoutingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEdgeInstanceMessageRoutingResponse updateEdgeInstanceMessageRouting(shared_ptr<UpdateEdgeInstanceMessageRoutingRequest> request);
  UpdateJobResponse updateJobWithOptions(shared_ptr<UpdateJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateJobResponse updateJob(shared_ptr<UpdateJobRequest> request);
  UpdateOTAModuleResponse updateOTAModuleWithOptions(shared_ptr<UpdateOTAModuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateOTAModuleResponse updateOTAModule(shared_ptr<UpdateOTAModuleRequest> request);
  UpdateParserResponse updateParserWithOptions(shared_ptr<UpdateParserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateParserResponse updateParser(shared_ptr<UpdateParserRequest> request);
  UpdateParserDataSourceResponse updateParserDataSourceWithOptions(shared_ptr<UpdateParserDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateParserDataSourceResponse updateParserDataSource(shared_ptr<UpdateParserDataSourceRequest> request);
  UpdateProductResponse updateProductWithOptions(shared_ptr<UpdateProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProductResponse updateProduct(shared_ptr<UpdateProductRequest> request);
  UpdateProductFilterConfigResponse updateProductFilterConfigWithOptions(shared_ptr<UpdateProductFilterConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProductFilterConfigResponse updateProductFilterConfig(shared_ptr<UpdateProductFilterConfigRequest> request);
  UpdateProductTagsResponse updateProductTagsWithOptions(shared_ptr<UpdateProductTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProductTagsResponse updateProductTags(shared_ptr<UpdateProductTagsRequest> request);
  UpdateProductTopicResponse updateProductTopicWithOptions(shared_ptr<UpdateProductTopicRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProductTopicResponse updateProductTopic(shared_ptr<UpdateProductTopicRequest> request);
  UpdateRuleResponse updateRuleWithOptions(shared_ptr<UpdateRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRuleResponse updateRule(shared_ptr<UpdateRuleRequest> request);
  UpdateRuleActionResponse updateRuleActionWithOptions(shared_ptr<UpdateRuleActionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRuleActionResponse updateRuleAction(shared_ptr<UpdateRuleActionRequest> request);
  UpdateSceneRuleResponse updateSceneRuleWithOptions(shared_ptr<UpdateSceneRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSceneRuleResponse updateSceneRule(shared_ptr<UpdateSceneRuleRequest> request);
  UpdateSchedulePeriodResponse updateSchedulePeriodWithOptions(shared_ptr<UpdateSchedulePeriodRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSchedulePeriodResponse updateSchedulePeriod(shared_ptr<UpdateSchedulePeriodRequest> request);
  UpdateSoundCodeResponse updateSoundCodeWithOptions(shared_ptr<UpdateSoundCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSoundCodeResponse updateSoundCode(shared_ptr<UpdateSoundCodeRequest> request);
  UpdateSoundCodeLabelResponse updateSoundCodeLabelWithOptions(shared_ptr<UpdateSoundCodeLabelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSoundCodeLabelResponse updateSoundCodeLabel(shared_ptr<UpdateSoundCodeLabelRequest> request);
  UpdateSoundCodeScheduleResponse updateSoundCodeScheduleWithOptions(shared_ptr<UpdateSoundCodeScheduleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSoundCodeScheduleResponse updateSoundCodeSchedule(shared_ptr<UpdateSoundCodeScheduleRequest> request);
  UpdateSpeechResponse updateSpeechWithOptions(shared_ptr<UpdateSpeechRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSpeechResponse updateSpeech(shared_ptr<UpdateSpeechRequest> request);
  UpdateSubscribeRelationResponse updateSubscribeRelationWithOptions(shared_ptr<UpdateSubscribeRelationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSubscribeRelationResponse updateSubscribeRelation(shared_ptr<UpdateSubscribeRelationRequest> request);
  UpdateThingModelResponse updateThingModelWithOptions(shared_ptr<UpdateThingModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateThingModelResponse updateThingModel(shared_ptr<UpdateThingModelRequest> request);
  UpdateThingScriptResponse updateThingScriptWithOptions(shared_ptr<UpdateThingScriptRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateThingScriptResponse updateThingScript(shared_ptr<UpdateThingScriptRequest> request);
  UpdateTopicConfigResponse updateTopicConfigWithOptions(shared_ptr<UpdateTopicConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTopicConfigResponse updateTopicConfig(shared_ptr<UpdateTopicConfigRequest> request);
  WriteDevicesHotStorageDataResponse writeDevicesHotStorageDataWithOptions(shared_ptr<WriteDevicesHotStorageDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  WriteDevicesHotStorageDataResponse writeDevicesHotStorageData(shared_ptr<WriteDevicesHotStorageDataRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Iot20180120

#endif
