// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_IOT20180120_H_
#define ALIBABACLOUD_IOT20180120_H_

#include <alibabacloud/open_api.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Iot20180120 {
class BatchAddDeviceGroupRelationsRequestDevice : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};

  BatchAddDeviceGroupRelationsRequestDevice() {}

  explicit BatchAddDeviceGroupRelationsRequestDevice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
  }


  virtual ~BatchAddDeviceGroupRelationsRequestDevice() = default;
};
class BatchAddDeviceGroupRelationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> groupId{};
  shared_ptr<vector<BatchAddDeviceGroupRelationsRequestDevice>> device{};

  BatchAddDeviceGroupRelationsRequest() {}

  explicit BatchAddDeviceGroupRelationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (device) {
      vector<boost::any> temp1;
      for(auto item1:*device){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Device"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      if (typeid(vector<boost::any>) == m["Device"].type()) {
        vector<BatchAddDeviceGroupRelationsRequestDevice> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Device"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchAddDeviceGroupRelationsRequestDevice model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        device = make_shared<vector<BatchAddDeviceGroupRelationsRequestDevice>>(expect1);
      }
    }
  }


  virtual ~BatchAddDeviceGroupRelationsRequest() = default;
};
class BatchAddDeviceGroupRelationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<long> validDeviceCount{};
  shared_ptr<long> exceedTenGroupDeviceCount{};
  shared_ptr<long> alreadyRelatedGroupDeviceCount{};
  shared_ptr<long> successAddedDeviceCount{};
  shared_ptr<string> errorMessage{};

  BatchAddDeviceGroupRelationsResponseBody() {}

  explicit BatchAddDeviceGroupRelationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (validDeviceCount) {
      res["ValidDeviceCount"] = boost::any(*validDeviceCount);
    }
    if (exceedTenGroupDeviceCount) {
      res["ExceedTenGroupDeviceCount"] = boost::any(*exceedTenGroupDeviceCount);
    }
    if (alreadyRelatedGroupDeviceCount) {
      res["AlreadyRelatedGroupDeviceCount"] = boost::any(*alreadyRelatedGroupDeviceCount);
    }
    if (successAddedDeviceCount) {
      res["SuccessAddedDeviceCount"] = boost::any(*successAddedDeviceCount);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ValidDeviceCount") != m.end() && !m["ValidDeviceCount"].empty()) {
      validDeviceCount = make_shared<long>(boost::any_cast<long>(m["ValidDeviceCount"]));
    }
    if (m.find("ExceedTenGroupDeviceCount") != m.end() && !m["ExceedTenGroupDeviceCount"].empty()) {
      exceedTenGroupDeviceCount = make_shared<long>(boost::any_cast<long>(m["ExceedTenGroupDeviceCount"]));
    }
    if (m.find("AlreadyRelatedGroupDeviceCount") != m.end() && !m["AlreadyRelatedGroupDeviceCount"].empty()) {
      alreadyRelatedGroupDeviceCount = make_shared<long>(boost::any_cast<long>(m["AlreadyRelatedGroupDeviceCount"]));
    }
    if (m.find("SuccessAddedDeviceCount") != m.end() && !m["SuccessAddedDeviceCount"].empty()) {
      successAddedDeviceCount = make_shared<long>(boost::any_cast<long>(m["SuccessAddedDeviceCount"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~BatchAddDeviceGroupRelationsResponseBody() = default;
};
class BatchAddDeviceGroupRelationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchAddDeviceGroupRelationsResponseBody> body{};

  BatchAddDeviceGroupRelationsResponse() {}

  explicit BatchAddDeviceGroupRelationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchAddDeviceGroupRelationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchAddDeviceGroupRelationsResponseBody>(model1);
      }
    }
  }


  virtual ~BatchAddDeviceGroupRelationsResponse() = default;
};
class BatchAddThingTopoRequestTopoAddItem : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> sign{};
  shared_ptr<string> signMethod{};
  shared_ptr<string> timestamp{};
  shared_ptr<string> clientId{};

  BatchAddThingTopoRequestTopoAddItem() {}

  explicit BatchAddThingTopoRequestTopoAddItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (sign) {
      res["Sign"] = boost::any(*sign);
    }
    if (signMethod) {
      res["SignMethod"] = boost::any(*signMethod);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Sign") != m.end() && !m["Sign"].empty()) {
      sign = make_shared<string>(boost::any_cast<string>(m["Sign"]));
    }
    if (m.find("SignMethod") != m.end() && !m["SignMethod"].empty()) {
      signMethod = make_shared<string>(boost::any_cast<string>(m["SignMethod"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
  }


  virtual ~BatchAddThingTopoRequestTopoAddItem() = default;
};
class BatchAddThingTopoRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<BatchAddThingTopoRequestTopoAddItem>> topoAddItem{};
  shared_ptr<string> gwProductKey{};
  shared_ptr<string> gwDeviceName{};

  BatchAddThingTopoRequest() {}

  explicit BatchAddThingTopoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (topoAddItem) {
      vector<boost::any> temp1;
      for(auto item1:*topoAddItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TopoAddItem"] = boost::any(temp1);
    }
    if (gwProductKey) {
      res["GwProductKey"] = boost::any(*gwProductKey);
    }
    if (gwDeviceName) {
      res["GwDeviceName"] = boost::any(*gwDeviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("TopoAddItem") != m.end() && !m["TopoAddItem"].empty()) {
      if (typeid(vector<boost::any>) == m["TopoAddItem"].type()) {
        vector<BatchAddThingTopoRequestTopoAddItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TopoAddItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchAddThingTopoRequestTopoAddItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topoAddItem = make_shared<vector<BatchAddThingTopoRequestTopoAddItem>>(expect1);
      }
    }
    if (m.find("GwProductKey") != m.end() && !m["GwProductKey"].empty()) {
      gwProductKey = make_shared<string>(boost::any_cast<string>(m["GwProductKey"]));
    }
    if (m.find("GwDeviceName") != m.end() && !m["GwDeviceName"].empty()) {
      gwDeviceName = make_shared<string>(boost::any_cast<string>(m["GwDeviceName"]));
    }
  }


  virtual ~BatchAddThingTopoRequest() = default;
};
class BatchAddThingTopoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  BatchAddThingTopoResponseBody() {}

  explicit BatchAddThingTopoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~BatchAddThingTopoResponseBody() = default;
};
class BatchAddThingTopoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchAddThingTopoResponseBody> body{};

  BatchAddThingTopoResponse() {}

  explicit BatchAddThingTopoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchAddThingTopoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchAddThingTopoResponseBody>(model1);
      }
    }
  }


  virtual ~BatchAddThingTopoResponse() = default;
};
class BatchBindDevicesIntoProjectRequestDevices : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};

  BatchBindDevicesIntoProjectRequestDevices() {}

  explicit BatchBindDevicesIntoProjectRequestDevices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
  }


  virtual ~BatchBindDevicesIntoProjectRequestDevices() = default;
};
class BatchBindDevicesIntoProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<BatchBindDevicesIntoProjectRequestDevices>> devices{};
  shared_ptr<string> projectId{};

  BatchBindDevicesIntoProjectRequest() {}

  explicit BatchBindDevicesIntoProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (devices) {
      vector<boost::any> temp1;
      for(auto item1:*devices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Devices"] = boost::any(temp1);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Devices") != m.end() && !m["Devices"].empty()) {
      if (typeid(vector<boost::any>) == m["Devices"].type()) {
        vector<BatchBindDevicesIntoProjectRequestDevices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Devices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchBindDevicesIntoProjectRequestDevices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        devices = make_shared<vector<BatchBindDevicesIntoProjectRequestDevices>>(expect1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~BatchBindDevicesIntoProjectRequest() = default;
};
class BatchBindDevicesIntoProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> data{};

  BatchBindDevicesIntoProjectResponseBody() {}

  explicit BatchBindDevicesIntoProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~BatchBindDevicesIntoProjectResponseBody() = default;
};
class BatchBindDevicesIntoProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchBindDevicesIntoProjectResponseBody> body{};

  BatchBindDevicesIntoProjectResponse() {}

  explicit BatchBindDevicesIntoProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchBindDevicesIntoProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchBindDevicesIntoProjectResponseBody>(model1);
      }
    }
  }


  virtual ~BatchBindDevicesIntoProjectResponse() = default;
};
class BatchBindDeviceToEdgeInstanceWithDriverRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<vector<string>> iotIds{};

  BatchBindDeviceToEdgeInstanceWithDriverRequest() {}

  explicit BatchBindDeviceToEdgeInstanceWithDriverRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (iotIds) {
      res["IotIds"] = boost::any(*iotIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("IotIds") != m.end() && !m["IotIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchBindDeviceToEdgeInstanceWithDriverRequest() = default;
};
class BatchBindDeviceToEdgeInstanceWithDriverResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  BatchBindDeviceToEdgeInstanceWithDriverResponseBody() {}

  explicit BatchBindDeviceToEdgeInstanceWithDriverResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~BatchBindDeviceToEdgeInstanceWithDriverResponseBody() = default;
};
class BatchBindDeviceToEdgeInstanceWithDriverResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchBindDeviceToEdgeInstanceWithDriverResponseBody> body{};

  BatchBindDeviceToEdgeInstanceWithDriverResponse() {}

  explicit BatchBindDeviceToEdgeInstanceWithDriverResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchBindDeviceToEdgeInstanceWithDriverResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchBindDeviceToEdgeInstanceWithDriverResponseBody>(model1);
      }
    }
  }


  virtual ~BatchBindDeviceToEdgeInstanceWithDriverResponse() = default;
};
class BatchBindProductsIntoProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<string>> productKeys{};
  shared_ptr<string> projectId{};

  BatchBindProductsIntoProjectRequest() {}

  explicit BatchBindProductsIntoProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKeys) {
      res["ProductKeys"] = boost::any(*productKeys);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKeys") != m.end() && !m["ProductKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProductKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProductKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      productKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~BatchBindProductsIntoProjectRequest() = default;
};
class BatchBindProductsIntoProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> data{};

  BatchBindProductsIntoProjectResponseBody() {}

  explicit BatchBindProductsIntoProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~BatchBindProductsIntoProjectResponseBody() = default;
};
class BatchBindProductsIntoProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchBindProductsIntoProjectResponseBody> body{};

  BatchBindProductsIntoProjectResponse() {}

  explicit BatchBindProductsIntoProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchBindProductsIntoProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchBindProductsIntoProjectResponseBody>(model1);
      }
    }
  }


  virtual ~BatchBindProductsIntoProjectResponse() = default;
};
class BatchCheckDeviceNamesRequestDeviceNameList : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceNickname{};

  BatchCheckDeviceNamesRequestDeviceNameList() {}

  explicit BatchCheckDeviceNamesRequestDeviceNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceNickname) {
      res["DeviceNickname"] = boost::any(*deviceNickname);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceNickname") != m.end() && !m["DeviceNickname"].empty()) {
      deviceNickname = make_shared<string>(boost::any_cast<string>(m["DeviceNickname"]));
    }
  }


  virtual ~BatchCheckDeviceNamesRequestDeviceNameList() = default;
};
class BatchCheckDeviceNamesRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<vector<string>> deviceName{};
  shared_ptr<vector<BatchCheckDeviceNamesRequestDeviceNameList>> deviceNameList{};

  BatchCheckDeviceNamesRequest() {}

  explicit BatchCheckDeviceNamesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceNameList) {
      vector<boost::any> temp1;
      for(auto item1:*deviceNameList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceNameList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DeviceNameList") != m.end() && !m["DeviceNameList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceNameList"].type()) {
        vector<BatchCheckDeviceNamesRequestDeviceNameList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceNameList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchCheckDeviceNamesRequestDeviceNameList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceNameList = make_shared<vector<BatchCheckDeviceNamesRequestDeviceNameList>>(expect1);
      }
    }
  }


  virtual ~BatchCheckDeviceNamesRequest() = default;
};
class BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> invalidDeviceName{};

  BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList() {}

  explicit BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invalidDeviceName) {
      res["InvalidDeviceName"] = boost::any(*invalidDeviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InvalidDeviceName") != m.end() && !m["InvalidDeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InvalidDeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InvalidDeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      invalidDeviceName = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList() = default;
};
class BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> invalidDeviceNickname{};

  BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList() {}

  explicit BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invalidDeviceNickname) {
      res["InvalidDeviceNickname"] = boost::any(*invalidDeviceNickname);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InvalidDeviceNickname") != m.end() && !m["InvalidDeviceNickname"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InvalidDeviceNickname"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InvalidDeviceNickname"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      invalidDeviceNickname = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList() = default;
};
class BatchCheckDeviceNamesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList> invalidDeviceNameList{};
  shared_ptr<BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList> invalidDeviceNicknameList{};

  BatchCheckDeviceNamesResponseBodyData() {}

  explicit BatchCheckDeviceNamesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["ApplyId"] = boost::any(*applyId);
    }
    if (invalidDeviceNameList) {
      res["InvalidDeviceNameList"] = invalidDeviceNameList ? boost::any(invalidDeviceNameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (invalidDeviceNicknameList) {
      res["InvalidDeviceNicknameList"] = invalidDeviceNicknameList ? boost::any(invalidDeviceNicknameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyId") != m.end() && !m["ApplyId"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["ApplyId"]));
    }
    if (m.find("InvalidDeviceNameList") != m.end() && !m["InvalidDeviceNameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvalidDeviceNameList"].type()) {
        BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvalidDeviceNameList"]));
        invalidDeviceNameList = make_shared<BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList>(model1);
      }
    }
    if (m.find("InvalidDeviceNicknameList") != m.end() && !m["InvalidDeviceNicknameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvalidDeviceNicknameList"].type()) {
        BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvalidDeviceNicknameList"]));
        invalidDeviceNicknameList = make_shared<BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList>(model1);
      }
    }
  }


  virtual ~BatchCheckDeviceNamesResponseBodyData() = default;
};
class BatchCheckDeviceNamesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<BatchCheckDeviceNamesResponseBodyData> data{};

  BatchCheckDeviceNamesResponseBody() {}

  explicit BatchCheckDeviceNamesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BatchCheckDeviceNamesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BatchCheckDeviceNamesResponseBodyData>(model1);
      }
    }
  }


  virtual ~BatchCheckDeviceNamesResponseBody() = default;
};
class BatchCheckDeviceNamesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchCheckDeviceNamesResponseBody> body{};

  BatchCheckDeviceNamesResponse() {}

  explicit BatchCheckDeviceNamesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchCheckDeviceNamesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchCheckDeviceNamesResponseBody>(model1);
      }
    }
  }


  virtual ~BatchCheckDeviceNamesResponse() = default;
};
class BatchClearEdgeInstanceDeviceConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> iotIds{};

  BatchClearEdgeInstanceDeviceConfigRequest() {}

  explicit BatchClearEdgeInstanceDeviceConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotIds) {
      res["IotIds"] = boost::any(*iotIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotIds") != m.end() && !m["IotIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchClearEdgeInstanceDeviceConfigRequest() = default;
};
class BatchClearEdgeInstanceDeviceConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  BatchClearEdgeInstanceDeviceConfigResponseBody() {}

  explicit BatchClearEdgeInstanceDeviceConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~BatchClearEdgeInstanceDeviceConfigResponseBody() = default;
};
class BatchClearEdgeInstanceDeviceConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchClearEdgeInstanceDeviceConfigResponseBody> body{};

  BatchClearEdgeInstanceDeviceConfigResponse() {}

  explicit BatchClearEdgeInstanceDeviceConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchClearEdgeInstanceDeviceConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchClearEdgeInstanceDeviceConfigResponseBody>(model1);
      }
    }
  }


  virtual ~BatchClearEdgeInstanceDeviceConfigResponse() = default;
};
class BatchDeleteDeviceGroupRelationsRequestDevice : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};

  BatchDeleteDeviceGroupRelationsRequestDevice() {}

  explicit BatchDeleteDeviceGroupRelationsRequestDevice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
  }


  virtual ~BatchDeleteDeviceGroupRelationsRequestDevice() = default;
};
class BatchDeleteDeviceGroupRelationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> groupId{};
  shared_ptr<vector<BatchDeleteDeviceGroupRelationsRequestDevice>> device{};

  BatchDeleteDeviceGroupRelationsRequest() {}

  explicit BatchDeleteDeviceGroupRelationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (device) {
      vector<boost::any> temp1;
      for(auto item1:*device){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Device"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      if (typeid(vector<boost::any>) == m["Device"].type()) {
        vector<BatchDeleteDeviceGroupRelationsRequestDevice> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Device"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchDeleteDeviceGroupRelationsRequestDevice model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        device = make_shared<vector<BatchDeleteDeviceGroupRelationsRequestDevice>>(expect1);
      }
    }
  }


  virtual ~BatchDeleteDeviceGroupRelationsRequest() = default;
};
class BatchDeleteDeviceGroupRelationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> validDeviceCount{};
  shared_ptr<long> alreadyRelatedGroupDeviceCount{};
  shared_ptr<long> successDeviceCount{};

  BatchDeleteDeviceGroupRelationsResponseBody() {}

  explicit BatchDeleteDeviceGroupRelationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (validDeviceCount) {
      res["ValidDeviceCount"] = boost::any(*validDeviceCount);
    }
    if (alreadyRelatedGroupDeviceCount) {
      res["AlreadyRelatedGroupDeviceCount"] = boost::any(*alreadyRelatedGroupDeviceCount);
    }
    if (successDeviceCount) {
      res["SuccessDeviceCount"] = boost::any(*successDeviceCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ValidDeviceCount") != m.end() && !m["ValidDeviceCount"].empty()) {
      validDeviceCount = make_shared<long>(boost::any_cast<long>(m["ValidDeviceCount"]));
    }
    if (m.find("AlreadyRelatedGroupDeviceCount") != m.end() && !m["AlreadyRelatedGroupDeviceCount"].empty()) {
      alreadyRelatedGroupDeviceCount = make_shared<long>(boost::any_cast<long>(m["AlreadyRelatedGroupDeviceCount"]));
    }
    if (m.find("SuccessDeviceCount") != m.end() && !m["SuccessDeviceCount"].empty()) {
      successDeviceCount = make_shared<long>(boost::any_cast<long>(m["SuccessDeviceCount"]));
    }
  }


  virtual ~BatchDeleteDeviceGroupRelationsResponseBody() = default;
};
class BatchDeleteDeviceGroupRelationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchDeleteDeviceGroupRelationsResponseBody> body{};

  BatchDeleteDeviceGroupRelationsResponse() {}

  explicit BatchDeleteDeviceGroupRelationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchDeleteDeviceGroupRelationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchDeleteDeviceGroupRelationsResponseBody>(model1);
      }
    }
  }


  virtual ~BatchDeleteDeviceGroupRelationsResponse() = default;
};
class BatchDeleteEdgeInstanceChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<vector<string>> channelIds{};

  BatchDeleteEdgeInstanceChannelRequest() {}

  explicit BatchDeleteEdgeInstanceChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (channelIds) {
      res["ChannelIds"] = boost::any(*channelIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("ChannelIds") != m.end() && !m["ChannelIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ChannelIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ChannelIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channelIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchDeleteEdgeInstanceChannelRequest() = default;
};
class BatchDeleteEdgeInstanceChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  BatchDeleteEdgeInstanceChannelResponseBody() {}

  explicit BatchDeleteEdgeInstanceChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~BatchDeleteEdgeInstanceChannelResponseBody() = default;
};
class BatchDeleteEdgeInstanceChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchDeleteEdgeInstanceChannelResponseBody> body{};

  BatchDeleteEdgeInstanceChannelResponse() {}

  explicit BatchDeleteEdgeInstanceChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchDeleteEdgeInstanceChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchDeleteEdgeInstanceChannelResponseBody>(model1);
      }
    }
  }


  virtual ~BatchDeleteEdgeInstanceChannelResponse() = default;
};
class BatchGetDeviceBindStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<string>> iotIds{};

  BatchGetDeviceBindStatusRequest() {}

  explicit BatchGetDeviceBindStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (iotIds) {
      res["IotIds"] = boost::any(*iotIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("IotIds") != m.end() && !m["IotIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchGetDeviceBindStatusRequest() = default;
};
class BatchGetDeviceBindStatusResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> iotId{};
  shared_ptr<long> bindStatus{};

  BatchGetDeviceBindStatusResponseBodyData() {}

  explicit BatchGetDeviceBindStatusResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (bindStatus) {
      res["BindStatus"] = boost::any(*bindStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("BindStatus") != m.end() && !m["BindStatus"].empty()) {
      bindStatus = make_shared<long>(boost::any_cast<long>(m["BindStatus"]));
    }
  }


  virtual ~BatchGetDeviceBindStatusResponseBodyData() = default;
};
class BatchGetDeviceBindStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<BatchGetDeviceBindStatusResponseBodyData>> data{};

  BatchGetDeviceBindStatusResponseBody() {}

  explicit BatchGetDeviceBindStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<BatchGetDeviceBindStatusResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetDeviceBindStatusResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<BatchGetDeviceBindStatusResponseBodyData>>(expect1);
      }
    }
  }


  virtual ~BatchGetDeviceBindStatusResponseBody() = default;
};
class BatchGetDeviceBindStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchGetDeviceBindStatusResponseBody> body{};

  BatchGetDeviceBindStatusResponse() {}

  explicit BatchGetDeviceBindStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchGetDeviceBindStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchGetDeviceBindStatusResponseBody>(model1);
      }
    }
  }


  virtual ~BatchGetDeviceBindStatusResponse() = default;
};
class BatchGetDeviceStateRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<vector<string>> iotId{};

  BatchGetDeviceStateRequest() {}

  explicit BatchGetDeviceStateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchGetDeviceStateRequest() = default;
};
class BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> status{};
  shared_ptr<string> asAddress{};
  shared_ptr<string> lastOnlineTime{};
  shared_ptr<string> iotId{};

  BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus() {}

  explicit BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (asAddress) {
      res["AsAddress"] = boost::any(*asAddress);
    }
    if (lastOnlineTime) {
      res["LastOnlineTime"] = boost::any(*lastOnlineTime);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("AsAddress") != m.end() && !m["AsAddress"].empty()) {
      asAddress = make_shared<string>(boost::any_cast<string>(m["AsAddress"]));
    }
    if (m.find("LastOnlineTime") != m.end() && !m["LastOnlineTime"].empty()) {
      lastOnlineTime = make_shared<string>(boost::any_cast<string>(m["LastOnlineTime"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus() = default;
};
class BatchGetDeviceStateResponseBodyDeviceStatusList : public Darabonba::Model {
public:
  shared_ptr<vector<BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus>> deviceStatus{};

  BatchGetDeviceStateResponseBodyDeviceStatusList() {}

  explicit BatchGetDeviceStateResponseBodyDeviceStatusList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceStatus) {
      vector<boost::any> temp1;
      for(auto item1:*deviceStatus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceStatus"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceStatus") != m.end() && !m["DeviceStatus"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceStatus"].type()) {
        vector<BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceStatus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceStatus = make_shared<vector<BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus>>(expect1);
      }
    }
  }


  virtual ~BatchGetDeviceStateResponseBodyDeviceStatusList() = default;
};
class BatchGetDeviceStateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<BatchGetDeviceStateResponseBodyDeviceStatusList> deviceStatusList{};

  BatchGetDeviceStateResponseBody() {}

  explicit BatchGetDeviceStateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (deviceStatusList) {
      res["DeviceStatusList"] = deviceStatusList ? boost::any(deviceStatusList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("DeviceStatusList") != m.end() && !m["DeviceStatusList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeviceStatusList"].type()) {
        BatchGetDeviceStateResponseBodyDeviceStatusList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeviceStatusList"]));
        deviceStatusList = make_shared<BatchGetDeviceStateResponseBodyDeviceStatusList>(model1);
      }
    }
  }


  virtual ~BatchGetDeviceStateResponseBody() = default;
};
class BatchGetDeviceStateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchGetDeviceStateResponseBody> body{};

  BatchGetDeviceStateResponse() {}

  explicit BatchGetDeviceStateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchGetDeviceStateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchGetDeviceStateResponseBody>(model1);
      }
    }
  }


  virtual ~BatchGetDeviceStateResponse() = default;
};
class BatchGetEdgeDriverRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<string>> driverIds{};

  BatchGetEdgeDriverRequest() {}

  explicit BatchGetEdgeDriverRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (driverIds) {
      res["DriverIds"] = boost::any(*driverIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("DriverIds") != m.end() && !m["DriverIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DriverIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DriverIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      driverIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchGetEdgeDriverRequest() = default;
};
class BatchGetEdgeDriverResponseBodyDriverList : public Darabonba::Model {
public:
  shared_ptr<string> driverId{};
  shared_ptr<string> driverName{};
  shared_ptr<string> driverProtocol{};
  shared_ptr<string> runtime{};
  shared_ptr<string> cpuArch{};
  shared_ptr<long> type{};
  shared_ptr<bool> isBuiltIn{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<long> gmtModifiedTimestamp{};

  BatchGetEdgeDriverResponseBodyDriverList() {}

  explicit BatchGetEdgeDriverResponseBodyDriverList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverName) {
      res["DriverName"] = boost::any(*driverName);
    }
    if (driverProtocol) {
      res["DriverProtocol"] = boost::any(*driverProtocol);
    }
    if (runtime) {
      res["Runtime"] = boost::any(*runtime);
    }
    if (cpuArch) {
      res["CpuArch"] = boost::any(*cpuArch);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (isBuiltIn) {
      res["IsBuiltIn"] = boost::any(*isBuiltIn);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverName") != m.end() && !m["DriverName"].empty()) {
      driverName = make_shared<string>(boost::any_cast<string>(m["DriverName"]));
    }
    if (m.find("DriverProtocol") != m.end() && !m["DriverProtocol"].empty()) {
      driverProtocol = make_shared<string>(boost::any_cast<string>(m["DriverProtocol"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      runtime = make_shared<string>(boost::any_cast<string>(m["Runtime"]));
    }
    if (m.find("CpuArch") != m.end() && !m["CpuArch"].empty()) {
      cpuArch = make_shared<string>(boost::any_cast<string>(m["CpuArch"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("IsBuiltIn") != m.end() && !m["IsBuiltIn"].empty()) {
      isBuiltIn = make_shared<bool>(boost::any_cast<bool>(m["IsBuiltIn"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
  }


  virtual ~BatchGetEdgeDriverResponseBodyDriverList() = default;
};
class BatchGetEdgeDriverResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<BatchGetEdgeDriverResponseBodyDriverList>> driverList{};

  BatchGetEdgeDriverResponseBody() {}

  explicit BatchGetEdgeDriverResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (driverList) {
      vector<boost::any> temp1;
      for(auto item1:*driverList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DriverList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("DriverList") != m.end() && !m["DriverList"].empty()) {
      if (typeid(vector<boost::any>) == m["DriverList"].type()) {
        vector<BatchGetEdgeDriverResponseBodyDriverList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DriverList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetEdgeDriverResponseBodyDriverList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        driverList = make_shared<vector<BatchGetEdgeDriverResponseBodyDriverList>>(expect1);
      }
    }
  }


  virtual ~BatchGetEdgeDriverResponseBody() = default;
};
class BatchGetEdgeDriverResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchGetEdgeDriverResponseBody> body{};

  BatchGetEdgeDriverResponse() {}

  explicit BatchGetEdgeDriverResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchGetEdgeDriverResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchGetEdgeDriverResponseBody>(model1);
      }
    }
  }


  virtual ~BatchGetEdgeDriverResponse() = default;
};
class BatchGetEdgeInstanceChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<vector<string>> channelIds{};

  BatchGetEdgeInstanceChannelRequest() {}

  explicit BatchGetEdgeInstanceChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (channelIds) {
      res["ChannelIds"] = boost::any(*channelIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("ChannelIds") != m.end() && !m["ChannelIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ChannelIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ChannelIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channelIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchGetEdgeInstanceChannelRequest() = default;
};
class BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<string> format{};
  shared_ptr<string> content{};
  shared_ptr<string> key{};

  BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig() {}

  explicit BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig() = default;
};
class BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig>> config{};

  BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList() {}

  explicit BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      vector<boost::any> temp1;
      for(auto item1:*config){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Config"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(vector<boost::any>) == m["Config"].type()) {
        vector<BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Config"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        config = make_shared<vector<BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig>>(expect1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList() = default;
};
class BatchGetEdgeInstanceChannelResponseBodyDataChannel : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> channelName{};
  shared_ptr<BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList> configList{};

  BatchGetEdgeInstanceChannelResponseBodyDataChannel() {}

  explicit BatchGetEdgeInstanceChannelResponseBodyDataChannel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (configList) {
      res["ConfigList"] = configList ? boost::any(configList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ConfigList") != m.end() && !m["ConfigList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigList"].type()) {
        BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigList"]));
        configList = make_shared<BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList>(model1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceChannelResponseBodyDataChannel() = default;
};
class BatchGetEdgeInstanceChannelResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<BatchGetEdgeInstanceChannelResponseBodyDataChannel>> channel{};

  BatchGetEdgeInstanceChannelResponseBodyData() {}

  explicit BatchGetEdgeInstanceChannelResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channel) {
      vector<boost::any> temp1;
      for(auto item1:*channel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Channel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      if (typeid(vector<boost::any>) == m["Channel"].type()) {
        vector<BatchGetEdgeInstanceChannelResponseBodyDataChannel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Channel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetEdgeInstanceChannelResponseBodyDataChannel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channel = make_shared<vector<BatchGetEdgeInstanceChannelResponseBodyDataChannel>>(expect1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceChannelResponseBodyData() = default;
};
class BatchGetEdgeInstanceChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<BatchGetEdgeInstanceChannelResponseBodyData> data{};

  BatchGetEdgeInstanceChannelResponseBody() {}

  explicit BatchGetEdgeInstanceChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BatchGetEdgeInstanceChannelResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BatchGetEdgeInstanceChannelResponseBodyData>(model1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceChannelResponseBody() = default;
};
class BatchGetEdgeInstanceChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchGetEdgeInstanceChannelResponseBody> body{};

  BatchGetEdgeInstanceChannelResponse() {}

  explicit BatchGetEdgeInstanceChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchGetEdgeInstanceChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchGetEdgeInstanceChannelResponseBody>(model1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceChannelResponse() = default;
};
class BatchGetEdgeInstanceDeviceChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<vector<string>> iotIds{};

  BatchGetEdgeInstanceDeviceChannelRequest() {}

  explicit BatchGetEdgeInstanceDeviceChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (iotIds) {
      res["IotIds"] = boost::any(*iotIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("IotIds") != m.end() && !m["IotIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceChannelRequest() = default;
};
class BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> channelName{};
  shared_ptr<string> iotId{};

  BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList() {}

  explicit BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList() = default;
};
class BatchGetEdgeInstanceDeviceChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList>> deviceChannelList{};

  BatchGetEdgeInstanceDeviceChannelResponseBody() {}

  explicit BatchGetEdgeInstanceDeviceChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (deviceChannelList) {
      vector<boost::any> temp1;
      for(auto item1:*deviceChannelList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceChannelList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("DeviceChannelList") != m.end() && !m["DeviceChannelList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceChannelList"].type()) {
        vector<BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceChannelList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceChannelList = make_shared<vector<BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList>>(expect1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceChannelResponseBody() = default;
};
class BatchGetEdgeInstanceDeviceChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchGetEdgeInstanceDeviceChannelResponseBody> body{};

  BatchGetEdgeInstanceDeviceChannelResponse() {}

  explicit BatchGetEdgeInstanceDeviceChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchGetEdgeInstanceDeviceChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchGetEdgeInstanceDeviceChannelResponseBody>(model1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceChannelResponse() = default;
};
class BatchGetEdgeInstanceDeviceConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> iotIds{};

  BatchGetEdgeInstanceDeviceConfigRequest() {}

  explicit BatchGetEdgeInstanceDeviceConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotIds) {
      res["IotIds"] = boost::any(*iotIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotIds") != m.end() && !m["IotIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceConfigRequest() = default;
};
class BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig : public Darabonba::Model {
public:
  shared_ptr<string> format{};
  shared_ptr<string> content{};

  BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig() {}

  explicit BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig() = default;
};
class BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList : public Darabonba::Model {
public:
  shared_ptr<string> iotId{};
  shared_ptr<BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig> config{};

  BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList() {}

  explicit BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (config) {
      res["Config"] = config ? boost::any(config->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(map<string, boost::any>) == m["Config"].type()) {
        BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Config"]));
        config = make_shared<BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig>(model1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList() = default;
};
class BatchGetEdgeInstanceDeviceConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList>> deviceConfigList{};

  BatchGetEdgeInstanceDeviceConfigResponseBody() {}

  explicit BatchGetEdgeInstanceDeviceConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (deviceConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*deviceConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceConfigList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("DeviceConfigList") != m.end() && !m["DeviceConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceConfigList"].type()) {
        vector<BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceConfigList = make_shared<vector<BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList>>(expect1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceConfigResponseBody() = default;
};
class BatchGetEdgeInstanceDeviceConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchGetEdgeInstanceDeviceConfigResponseBody> body{};

  BatchGetEdgeInstanceDeviceConfigResponse() {}

  explicit BatchGetEdgeInstanceDeviceConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchGetEdgeInstanceDeviceConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchGetEdgeInstanceDeviceConfigResponseBody>(model1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceConfigResponse() = default;
};
class BatchGetEdgeInstanceDeviceDriverRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> iotIds{};

  BatchGetEdgeInstanceDeviceDriverRequest() {}

  explicit BatchGetEdgeInstanceDeviceDriverRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotIds) {
      res["IotIds"] = boost::any(*iotIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotIds") != m.end() && !m["IotIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceDriverRequest() = default;
};
class BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList : public Darabonba::Model {
public:
  shared_ptr<string> driverId{};
  shared_ptr<string> iotId{};

  BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList() {}

  explicit BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList() = default;
};
class BatchGetEdgeInstanceDeviceDriverResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList>> deviceDriverList{};

  BatchGetEdgeInstanceDeviceDriverResponseBody() {}

  explicit BatchGetEdgeInstanceDeviceDriverResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (deviceDriverList) {
      vector<boost::any> temp1;
      for(auto item1:*deviceDriverList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceDriverList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("DeviceDriverList") != m.end() && !m["DeviceDriverList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceDriverList"].type()) {
        vector<BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceDriverList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceDriverList = make_shared<vector<BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList>>(expect1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceDriverResponseBody() = default;
};
class BatchGetEdgeInstanceDeviceDriverResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchGetEdgeInstanceDeviceDriverResponseBody> body{};

  BatchGetEdgeInstanceDeviceDriverResponse() {}

  explicit BatchGetEdgeInstanceDeviceDriverResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchGetEdgeInstanceDeviceDriverResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchGetEdgeInstanceDeviceDriverResponseBody>(model1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceDriverResponse() = default;
};
class BatchGetEdgeInstanceDriverConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> driverIds{};

  BatchGetEdgeInstanceDriverConfigsRequest() {}

  explicit BatchGetEdgeInstanceDriverConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (driverIds) {
      res["DriverIds"] = boost::any(*driverIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DriverIds") != m.end() && !m["DriverIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DriverIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DriverIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      driverIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchGetEdgeInstanceDriverConfigsRequest() = default;
};
class BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<string> format{};
  shared_ptr<string> content{};
  shared_ptr<string> key{};

  BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList() {}

  explicit BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList() = default;
};
class BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList : public Darabonba::Model {
public:
  shared_ptr<string> driverId{};
  shared_ptr<vector<BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList>> configList{};

  BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList() {}

  explicit BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (configList) {
      vector<boost::any> temp1;
      for(auto item1:*configList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("ConfigList") != m.end() && !m["ConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigList"].type()) {
        vector<BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configList = make_shared<vector<BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList>>(expect1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList() = default;
};
class BatchGetEdgeInstanceDriverConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList>> driverConfigList{};

  BatchGetEdgeInstanceDriverConfigsResponseBody() {}

  explicit BatchGetEdgeInstanceDriverConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (driverConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*driverConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DriverConfigList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("DriverConfigList") != m.end() && !m["DriverConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["DriverConfigList"].type()) {
        vector<BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DriverConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        driverConfigList = make_shared<vector<BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList>>(expect1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceDriverConfigsResponseBody() = default;
};
class BatchGetEdgeInstanceDriverConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchGetEdgeInstanceDriverConfigsResponseBody> body{};

  BatchGetEdgeInstanceDriverConfigsResponse() {}

  explicit BatchGetEdgeInstanceDriverConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchGetEdgeInstanceDriverConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchGetEdgeInstanceDriverConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceDriverConfigsResponse() = default;
};
class BatchPubRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<string>> deviceName{};
  shared_ptr<string> productKey{};
  shared_ptr<long> qos{};
  shared_ptr<string> topicShortName{};
  shared_ptr<string> messageContent{};

  BatchPubRequest() {}

  explicit BatchPubRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (qos) {
      res["Qos"] = boost::any(*qos);
    }
    if (topicShortName) {
      res["TopicShortName"] = boost::any(*topicShortName);
    }
    if (messageContent) {
      res["MessageContent"] = boost::any(*messageContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Qos") != m.end() && !m["Qos"].empty()) {
      qos = make_shared<long>(boost::any_cast<long>(m["Qos"]));
    }
    if (m.find("TopicShortName") != m.end() && !m["TopicShortName"].empty()) {
      topicShortName = make_shared<string>(boost::any_cast<string>(m["TopicShortName"]));
    }
    if (m.find("MessageContent") != m.end() && !m["MessageContent"].empty()) {
      messageContent = make_shared<string>(boost::any_cast<string>(m["MessageContent"]));
    }
  }


  virtual ~BatchPubRequest() = default;
};
class BatchPubResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  BatchPubResponseBody() {}

  explicit BatchPubResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~BatchPubResponseBody() = default;
};
class BatchPubResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchPubResponseBody> body{};

  BatchPubResponse() {}

  explicit BatchPubResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchPubResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchPubResponseBody>(model1);
      }
    }
  }


  virtual ~BatchPubResponse() = default;
};
class BatchQueryDeviceDetailRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> deviceName{};
  shared_ptr<string> productKey{};
  shared_ptr<string> iotInstanceId{};

  BatchQueryDeviceDetailRequest() {}

  explicit BatchQueryDeviceDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~BatchQueryDeviceDetailRequest() = default;
};
class BatchQueryDeviceDetailResponseBodyDataData : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> nickname{};
  shared_ptr<string> deviceSecret{};
  shared_ptr<string> iotId{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> utcActive{};
  shared_ptr<string> gmtActive{};
  shared_ptr<string> status{};
  shared_ptr<string> firmwareVersion{};
  shared_ptr<long> nodeType{};
  shared_ptr<string> region{};

  BatchQueryDeviceDetailResponseBodyDataData() {}

  explicit BatchQueryDeviceDetailResponseBodyDataData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    if (deviceSecret) {
      res["DeviceSecret"] = boost::any(*deviceSecret);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (utcActive) {
      res["UtcActive"] = boost::any(*utcActive);
    }
    if (gmtActive) {
      res["GmtActive"] = boost::any(*gmtActive);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (firmwareVersion) {
      res["FirmwareVersion"] = boost::any(*firmwareVersion);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
    if (m.find("DeviceSecret") != m.end() && !m["DeviceSecret"].empty()) {
      deviceSecret = make_shared<string>(boost::any_cast<string>(m["DeviceSecret"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("UtcActive") != m.end() && !m["UtcActive"].empty()) {
      utcActive = make_shared<string>(boost::any_cast<string>(m["UtcActive"]));
    }
    if (m.find("GmtActive") != m.end() && !m["GmtActive"].empty()) {
      gmtActive = make_shared<string>(boost::any_cast<string>(m["GmtActive"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("FirmwareVersion") != m.end() && !m["FirmwareVersion"].empty()) {
      firmwareVersion = make_shared<string>(boost::any_cast<string>(m["FirmwareVersion"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<long>(boost::any_cast<long>(m["NodeType"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~BatchQueryDeviceDetailResponseBodyDataData() = default;
};
class BatchQueryDeviceDetailResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<BatchQueryDeviceDetailResponseBodyDataData>> data{};

  BatchQueryDeviceDetailResponseBodyData() {}

  explicit BatchQueryDeviceDetailResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<BatchQueryDeviceDetailResponseBodyDataData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchQueryDeviceDetailResponseBodyDataData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<BatchQueryDeviceDetailResponseBodyDataData>>(expect1);
      }
    }
  }


  virtual ~BatchQueryDeviceDetailResponseBodyData() = default;
};
class BatchQueryDeviceDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<BatchQueryDeviceDetailResponseBodyData> data{};

  BatchQueryDeviceDetailResponseBody() {}

  explicit BatchQueryDeviceDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BatchQueryDeviceDetailResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BatchQueryDeviceDetailResponseBodyData>(model1);
      }
    }
  }


  virtual ~BatchQueryDeviceDetailResponseBody() = default;
};
class BatchQueryDeviceDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchQueryDeviceDetailResponseBody> body{};

  BatchQueryDeviceDetailResponse() {}

  explicit BatchQueryDeviceDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchQueryDeviceDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchQueryDeviceDetailResponseBody>(model1);
      }
    }
  }


  virtual ~BatchQueryDeviceDetailResponse() = default;
};
class BatchRegisterDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<long> count{};

  BatchRegisterDeviceRequest() {}

  explicit BatchRegisterDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~BatchRegisterDeviceRequest() = default;
};
class BatchRegisterDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};

  BatchRegisterDeviceResponseBodyData() {}

  explicit BatchRegisterDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["ApplyId"] = boost::any(*applyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyId") != m.end() && !m["ApplyId"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["ApplyId"]));
    }
  }


  virtual ~BatchRegisterDeviceResponseBodyData() = default;
};
class BatchRegisterDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<BatchRegisterDeviceResponseBodyData> data{};

  BatchRegisterDeviceResponseBody() {}

  explicit BatchRegisterDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BatchRegisterDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BatchRegisterDeviceResponseBodyData>(model1);
      }
    }
  }


  virtual ~BatchRegisterDeviceResponseBody() = default;
};
class BatchRegisterDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchRegisterDeviceResponseBody> body{};

  BatchRegisterDeviceResponse() {}

  explicit BatchRegisterDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchRegisterDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchRegisterDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~BatchRegisterDeviceResponse() = default;
};
class BatchRegisterDeviceWithApplyIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<long> applyId{};

  BatchRegisterDeviceWithApplyIdRequest() {}

  explicit BatchRegisterDeviceWithApplyIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (applyId) {
      res["ApplyId"] = boost::any(*applyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ApplyId") != m.end() && !m["ApplyId"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["ApplyId"]));
    }
  }


  virtual ~BatchRegisterDeviceWithApplyIdRequest() = default;
};
class BatchRegisterDeviceWithApplyIdResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};

  BatchRegisterDeviceWithApplyIdResponseBodyData() {}

  explicit BatchRegisterDeviceWithApplyIdResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["ApplyId"] = boost::any(*applyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyId") != m.end() && !m["ApplyId"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["ApplyId"]));
    }
  }


  virtual ~BatchRegisterDeviceWithApplyIdResponseBodyData() = default;
};
class BatchRegisterDeviceWithApplyIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<BatchRegisterDeviceWithApplyIdResponseBodyData> data{};

  BatchRegisterDeviceWithApplyIdResponseBody() {}

  explicit BatchRegisterDeviceWithApplyIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BatchRegisterDeviceWithApplyIdResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BatchRegisterDeviceWithApplyIdResponseBodyData>(model1);
      }
    }
  }


  virtual ~BatchRegisterDeviceWithApplyIdResponseBody() = default;
};
class BatchRegisterDeviceWithApplyIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchRegisterDeviceWithApplyIdResponseBody> body{};

  BatchRegisterDeviceWithApplyIdResponse() {}

  explicit BatchRegisterDeviceWithApplyIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchRegisterDeviceWithApplyIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchRegisterDeviceWithApplyIdResponseBody>(model1);
      }
    }
  }


  virtual ~BatchRegisterDeviceWithApplyIdResponse() = default;
};
class BatchSetEdgeInstanceDeviceChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<string> channelId{};
  shared_ptr<vector<string>> iotIds{};

  BatchSetEdgeInstanceDeviceChannelRequest() {}

  explicit BatchSetEdgeInstanceDeviceChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (iotIds) {
      res["IotIds"] = boost::any(*iotIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("IotIds") != m.end() && !m["IotIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchSetEdgeInstanceDeviceChannelRequest() = default;
};
class BatchSetEdgeInstanceDeviceChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  BatchSetEdgeInstanceDeviceChannelResponseBody() {}

  explicit BatchSetEdgeInstanceDeviceChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~BatchSetEdgeInstanceDeviceChannelResponseBody() = default;
};
class BatchSetEdgeInstanceDeviceChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchSetEdgeInstanceDeviceChannelResponseBody> body{};

  BatchSetEdgeInstanceDeviceChannelResponse() {}

  explicit BatchSetEdgeInstanceDeviceChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchSetEdgeInstanceDeviceChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchSetEdgeInstanceDeviceChannelResponseBody>(model1);
      }
    }
  }


  virtual ~BatchSetEdgeInstanceDeviceChannelResponse() = default;
};
class BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs : public Darabonba::Model {
public:
  shared_ptr<string> iotId{};
  shared_ptr<string> content{};

  BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs() {}

  explicit BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs() = default;
};
class BatchSetEdgeInstanceDeviceConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs>> deviceConfigs{};

  BatchSetEdgeInstanceDeviceConfigRequest() {}

  explicit BatchSetEdgeInstanceDeviceConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (deviceConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*deviceConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceConfigs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DeviceConfigs") != m.end() && !m["DeviceConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceConfigs"].type()) {
        vector<BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceConfigs = make_shared<vector<BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs>>(expect1);
      }
    }
  }


  virtual ~BatchSetEdgeInstanceDeviceConfigRequest() = default;
};
class BatchSetEdgeInstanceDeviceConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  BatchSetEdgeInstanceDeviceConfigResponseBody() {}

  explicit BatchSetEdgeInstanceDeviceConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~BatchSetEdgeInstanceDeviceConfigResponseBody() = default;
};
class BatchSetEdgeInstanceDeviceConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchSetEdgeInstanceDeviceConfigResponseBody> body{};

  BatchSetEdgeInstanceDeviceConfigResponse() {}

  explicit BatchSetEdgeInstanceDeviceConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchSetEdgeInstanceDeviceConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchSetEdgeInstanceDeviceConfigResponseBody>(model1);
      }
    }
  }


  virtual ~BatchSetEdgeInstanceDeviceConfigResponse() = default;
};
class BatchUnbindDeviceFromEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> iotIds{};

  BatchUnbindDeviceFromEdgeInstanceRequest() {}

  explicit BatchUnbindDeviceFromEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotIds) {
      res["IotIds"] = boost::any(*iotIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotIds") != m.end() && !m["IotIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchUnbindDeviceFromEdgeInstanceRequest() = default;
};
class BatchUnbindDeviceFromEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  BatchUnbindDeviceFromEdgeInstanceResponseBody() {}

  explicit BatchUnbindDeviceFromEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~BatchUnbindDeviceFromEdgeInstanceResponseBody() = default;
};
class BatchUnbindDeviceFromEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchUnbindDeviceFromEdgeInstanceResponseBody> body{};

  BatchUnbindDeviceFromEdgeInstanceResponse() {}

  explicit BatchUnbindDeviceFromEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchUnbindDeviceFromEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchUnbindDeviceFromEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~BatchUnbindDeviceFromEdgeInstanceResponse() = default;
};
class BatchUnbindProjectDevicesRequestDevices : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};

  BatchUnbindProjectDevicesRequestDevices() {}

  explicit BatchUnbindProjectDevicesRequestDevices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
  }


  virtual ~BatchUnbindProjectDevicesRequestDevices() = default;
};
class BatchUnbindProjectDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<BatchUnbindProjectDevicesRequestDevices>> devices{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> projectId{};

  BatchUnbindProjectDevicesRequest() {}

  explicit BatchUnbindProjectDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (devices) {
      vector<boost::any> temp1;
      for(auto item1:*devices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Devices"] = boost::any(temp1);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Devices") != m.end() && !m["Devices"].empty()) {
      if (typeid(vector<boost::any>) == m["Devices"].type()) {
        vector<BatchUnbindProjectDevicesRequestDevices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Devices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchUnbindProjectDevicesRequestDevices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        devices = make_shared<vector<BatchUnbindProjectDevicesRequestDevices>>(expect1);
      }
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~BatchUnbindProjectDevicesRequest() = default;
};
class BatchUnbindProjectDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> data{};

  BatchUnbindProjectDevicesResponseBody() {}

  explicit BatchUnbindProjectDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~BatchUnbindProjectDevicesResponseBody() = default;
};
class BatchUnbindProjectDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchUnbindProjectDevicesResponseBody> body{};

  BatchUnbindProjectDevicesResponse() {}

  explicit BatchUnbindProjectDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchUnbindProjectDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchUnbindProjectDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~BatchUnbindProjectDevicesResponse() = default;
};
class BatchUnbindProjectProductsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<string>> productKeys{};
  shared_ptr<string> projectId{};

  BatchUnbindProjectProductsRequest() {}

  explicit BatchUnbindProjectProductsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKeys) {
      res["ProductKeys"] = boost::any(*productKeys);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKeys") != m.end() && !m["ProductKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProductKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProductKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      productKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~BatchUnbindProjectProductsRequest() = default;
};
class BatchUnbindProjectProductsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> data{};

  BatchUnbindProjectProductsResponseBody() {}

  explicit BatchUnbindProjectProductsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~BatchUnbindProjectProductsResponseBody() = default;
};
class BatchUnbindProjectProductsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchUnbindProjectProductsResponseBody> body{};

  BatchUnbindProjectProductsResponse() {}

  explicit BatchUnbindProjectProductsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchUnbindProjectProductsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchUnbindProjectProductsResponseBody>(model1);
      }
    }
  }


  virtual ~BatchUnbindProjectProductsResponse() = default;
};
class BatchUpdateDeviceNicknameRequestDeviceNicknameInfo : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> nickname{};
  shared_ptr<string> iotId{};

  BatchUpdateDeviceNicknameRequestDeviceNicknameInfo() {}

  explicit BatchUpdateDeviceNicknameRequestDeviceNicknameInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~BatchUpdateDeviceNicknameRequestDeviceNicknameInfo() = default;
};
class BatchUpdateDeviceNicknameRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<BatchUpdateDeviceNicknameRequestDeviceNicknameInfo>> deviceNicknameInfo{};

  BatchUpdateDeviceNicknameRequest() {}

  explicit BatchUpdateDeviceNicknameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (deviceNicknameInfo) {
      vector<boost::any> temp1;
      for(auto item1:*deviceNicknameInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceNicknameInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("DeviceNicknameInfo") != m.end() && !m["DeviceNicknameInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceNicknameInfo"].type()) {
        vector<BatchUpdateDeviceNicknameRequestDeviceNicknameInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceNicknameInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchUpdateDeviceNicknameRequestDeviceNicknameInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceNicknameInfo = make_shared<vector<BatchUpdateDeviceNicknameRequestDeviceNicknameInfo>>(expect1);
      }
    }
  }


  virtual ~BatchUpdateDeviceNicknameRequest() = default;
};
class BatchUpdateDeviceNicknameResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  BatchUpdateDeviceNicknameResponseBody() {}

  explicit BatchUpdateDeviceNicknameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~BatchUpdateDeviceNicknameResponseBody() = default;
};
class BatchUpdateDeviceNicknameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchUpdateDeviceNicknameResponseBody> body{};

  BatchUpdateDeviceNicknameResponse() {}

  explicit BatchUpdateDeviceNicknameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchUpdateDeviceNicknameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchUpdateDeviceNicknameResponseBody>(model1);
      }
    }
  }


  virtual ~BatchUpdateDeviceNicknameResponse() = default;
};
class BindApplicationToEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> applicationId{};
  shared_ptr<string> applicationVersion{};

  BindApplicationToEdgeInstanceRequest() {}

  explicit BindApplicationToEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (applicationVersion) {
      res["ApplicationVersion"] = boost::any(*applicationVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("ApplicationVersion") != m.end() && !m["ApplicationVersion"].empty()) {
      applicationVersion = make_shared<string>(boost::any_cast<string>(m["ApplicationVersion"]));
    }
  }


  virtual ~BindApplicationToEdgeInstanceRequest() = default;
};
class BindApplicationToEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  BindApplicationToEdgeInstanceResponseBody() {}

  explicit BindApplicationToEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~BindApplicationToEdgeInstanceResponseBody() = default;
};
class BindApplicationToEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BindApplicationToEdgeInstanceResponseBody> body{};

  BindApplicationToEdgeInstanceResponse() {}

  explicit BindApplicationToEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindApplicationToEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindApplicationToEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~BindApplicationToEdgeInstanceResponse() = default;
};
class BindDriverToEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};
  shared_ptr<string> orderId{};

  BindDriverToEdgeInstanceRequest() {}

  explicit BindDriverToEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
  }


  virtual ~BindDriverToEdgeInstanceRequest() = default;
};
class BindDriverToEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  BindDriverToEdgeInstanceResponseBody() {}

  explicit BindDriverToEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~BindDriverToEdgeInstanceResponseBody() = default;
};
class BindDriverToEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BindDriverToEdgeInstanceResponseBody> body{};

  BindDriverToEdgeInstanceResponse() {}

  explicit BindDriverToEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindDriverToEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindDriverToEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~BindDriverToEdgeInstanceResponse() = default;
};
class BindGatewayToEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};

  BindGatewayToEdgeInstanceRequest() {}

  explicit BindGatewayToEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~BindGatewayToEdgeInstanceRequest() = default;
};
class BindGatewayToEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  BindGatewayToEdgeInstanceResponseBody() {}

  explicit BindGatewayToEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~BindGatewayToEdgeInstanceResponseBody() = default;
};
class BindGatewayToEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BindGatewayToEdgeInstanceResponseBody> body{};

  BindGatewayToEdgeInstanceResponse() {}

  explicit BindGatewayToEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindGatewayToEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindGatewayToEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~BindGatewayToEdgeInstanceResponse() = default;
};
class BindRoleToEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> roleName{};

  BindRoleToEdgeInstanceRequest() {}

  explicit BindRoleToEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
  }


  virtual ~BindRoleToEdgeInstanceRequest() = default;
};
class BindRoleToEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  BindRoleToEdgeInstanceResponseBody() {}

  explicit BindRoleToEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~BindRoleToEdgeInstanceResponseBody() = default;
};
class BindRoleToEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BindRoleToEdgeInstanceResponseBody> body{};

  BindRoleToEdgeInstanceResponse() {}

  explicit BindRoleToEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindRoleToEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindRoleToEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~BindRoleToEdgeInstanceResponse() = default;
};
class BindSceneRuleToEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ruleId{};

  BindSceneRuleToEdgeInstanceRequest() {}

  explicit BindSceneRuleToEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~BindSceneRuleToEdgeInstanceRequest() = default;
};
class BindSceneRuleToEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};

  BindSceneRuleToEdgeInstanceResponseBody() {}

  explicit BindSceneRuleToEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~BindSceneRuleToEdgeInstanceResponseBody() = default;
};
class BindSceneRuleToEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BindSceneRuleToEdgeInstanceResponseBody> body{};

  BindSceneRuleToEdgeInstanceResponse() {}

  explicit BindSceneRuleToEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindSceneRuleToEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindSceneRuleToEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~BindSceneRuleToEdgeInstanceResponse() = default;
};
class CancelJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobId{};

  CancelJobRequest() {}

  explicit CancelJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~CancelJobRequest() = default;
};
class CancelJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  CancelJobResponseBody() {}

  explicit CancelJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CancelJobResponseBody() = default;
};
class CancelJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CancelJobResponseBody> body{};

  CancelJobResponse() {}

  explicit CancelJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelJobResponseBody>(model1);
      }
    }
  }


  virtual ~CancelJobResponse() = default;
};
class CancelOTAStrategyByJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobId{};

  CancelOTAStrategyByJobRequest() {}

  explicit CancelOTAStrategyByJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~CancelOTAStrategyByJobRequest() = default;
};
class CancelOTAStrategyByJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  CancelOTAStrategyByJobResponseBody() {}

  explicit CancelOTAStrategyByJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CancelOTAStrategyByJobResponseBody() = default;
};
class CancelOTAStrategyByJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CancelOTAStrategyByJobResponseBody> body{};

  CancelOTAStrategyByJobResponse() {}

  explicit CancelOTAStrategyByJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelOTAStrategyByJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelOTAStrategyByJobResponseBody>(model1);
      }
    }
  }


  virtual ~CancelOTAStrategyByJobResponse() = default;
};
class CancelOTATaskByDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> productKey{};
  shared_ptr<vector<string>> deviceName{};
  shared_ptr<string> jobId{};

  CancelOTATaskByDeviceRequest() {}

  explicit CancelOTATaskByDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~CancelOTATaskByDeviceRequest() = default;
};
class CancelOTATaskByDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  CancelOTATaskByDeviceResponseBody() {}

  explicit CancelOTATaskByDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CancelOTATaskByDeviceResponseBody() = default;
};
class CancelOTATaskByDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CancelOTATaskByDeviceResponseBody> body{};

  CancelOTATaskByDeviceResponse() {}

  explicit CancelOTATaskByDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelOTATaskByDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelOTATaskByDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~CancelOTATaskByDeviceResponse() = default;
};
class CancelOTATaskByJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<bool> cancelScheduledTask{};
  shared_ptr<bool> cancelQueuedTask{};
  shared_ptr<bool> cancelInProgressTask{};
  shared_ptr<bool> cancelNotifiedTask{};

  CancelOTATaskByJobRequest() {}

  explicit CancelOTATaskByJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (cancelScheduledTask) {
      res["CancelScheduledTask"] = boost::any(*cancelScheduledTask);
    }
    if (cancelQueuedTask) {
      res["CancelQueuedTask"] = boost::any(*cancelQueuedTask);
    }
    if (cancelInProgressTask) {
      res["CancelInProgressTask"] = boost::any(*cancelInProgressTask);
    }
    if (cancelNotifiedTask) {
      res["CancelNotifiedTask"] = boost::any(*cancelNotifiedTask);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("CancelScheduledTask") != m.end() && !m["CancelScheduledTask"].empty()) {
      cancelScheduledTask = make_shared<bool>(boost::any_cast<bool>(m["CancelScheduledTask"]));
    }
    if (m.find("CancelQueuedTask") != m.end() && !m["CancelQueuedTask"].empty()) {
      cancelQueuedTask = make_shared<bool>(boost::any_cast<bool>(m["CancelQueuedTask"]));
    }
    if (m.find("CancelInProgressTask") != m.end() && !m["CancelInProgressTask"].empty()) {
      cancelInProgressTask = make_shared<bool>(boost::any_cast<bool>(m["CancelInProgressTask"]));
    }
    if (m.find("CancelNotifiedTask") != m.end() && !m["CancelNotifiedTask"].empty()) {
      cancelNotifiedTask = make_shared<bool>(boost::any_cast<bool>(m["CancelNotifiedTask"]));
    }
  }


  virtual ~CancelOTATaskByJobRequest() = default;
};
class CancelOTATaskByJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  CancelOTATaskByJobResponseBody() {}

  explicit CancelOTATaskByJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CancelOTATaskByJobResponseBody() = default;
};
class CancelOTATaskByJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CancelOTATaskByJobResponseBody> body{};

  CancelOTATaskByJobResponse() {}

  explicit CancelOTATaskByJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelOTATaskByJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelOTATaskByJobResponseBody>(model1);
      }
    }
  }


  virtual ~CancelOTATaskByJobResponse() = default;
};
class ClearEdgeInstanceDriverConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> driverId{};

  ClearEdgeInstanceDriverConfigsRequest() {}

  explicit ClearEdgeInstanceDriverConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
  }


  virtual ~ClearEdgeInstanceDriverConfigsRequest() = default;
};
class ClearEdgeInstanceDriverConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  ClearEdgeInstanceDriverConfigsResponseBody() {}

  explicit ClearEdgeInstanceDriverConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~ClearEdgeInstanceDriverConfigsResponseBody() = default;
};
class ClearEdgeInstanceDriverConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ClearEdgeInstanceDriverConfigsResponseBody> body{};

  ClearEdgeInstanceDriverConfigsResponse() {}

  explicit ClearEdgeInstanceDriverConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ClearEdgeInstanceDriverConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ClearEdgeInstanceDriverConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~ClearEdgeInstanceDriverConfigsResponse() = default;
};
class CloseEdgeInstanceDeploymentRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};

  CloseEdgeInstanceDeploymentRequest() {}

  explicit CloseEdgeInstanceDeploymentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~CloseEdgeInstanceDeploymentRequest() = default;
};
class CloseEdgeInstanceDeploymentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  CloseEdgeInstanceDeploymentResponseBody() {}

  explicit CloseEdgeInstanceDeploymentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CloseEdgeInstanceDeploymentResponseBody() = default;
};
class CloseEdgeInstanceDeploymentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CloseEdgeInstanceDeploymentResponseBody> body{};

  CloseEdgeInstanceDeploymentResponse() {}

  explicit CloseEdgeInstanceDeploymentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CloseEdgeInstanceDeploymentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CloseEdgeInstanceDeploymentResponseBody>(model1);
      }
    }
  }


  virtual ~CloseEdgeInstanceDeploymentResponse() = default;
};
class CopyThingModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> sourceProductKey{};
  shared_ptr<string> targetProductKey{};
  shared_ptr<string> sourceModelVersion{};

  CopyThingModelRequest() {}

  explicit CopyThingModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (sourceProductKey) {
      res["SourceProductKey"] = boost::any(*sourceProductKey);
    }
    if (targetProductKey) {
      res["TargetProductKey"] = boost::any(*targetProductKey);
    }
    if (sourceModelVersion) {
      res["SourceModelVersion"] = boost::any(*sourceModelVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SourceProductKey") != m.end() && !m["SourceProductKey"].empty()) {
      sourceProductKey = make_shared<string>(boost::any_cast<string>(m["SourceProductKey"]));
    }
    if (m.find("TargetProductKey") != m.end() && !m["TargetProductKey"].empty()) {
      targetProductKey = make_shared<string>(boost::any_cast<string>(m["TargetProductKey"]));
    }
    if (m.find("SourceModelVersion") != m.end() && !m["SourceModelVersion"].empty()) {
      sourceModelVersion = make_shared<string>(boost::any_cast<string>(m["SourceModelVersion"]));
    }
  }


  virtual ~CopyThingModelRequest() = default;
};
class CopyThingModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  CopyThingModelResponseBody() {}

  explicit CopyThingModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CopyThingModelResponseBody() = default;
};
class CopyThingModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CopyThingModelResponseBody> body{};

  CopyThingModelResponse() {}

  explicit CopyThingModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CopyThingModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CopyThingModelResponseBody>(model1);
      }
    }
  }


  virtual ~CopyThingModelResponse() = default;
};
class CreateConsumerGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> groupName{};

  CreateConsumerGroupRequest() {}

  explicit CreateConsumerGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~CreateConsumerGroupRequest() = default;
};
class CreateConsumerGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> groupId{};
  shared_ptr<string> code{};

  CreateConsumerGroupResponseBody() {}

  explicit CreateConsumerGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~CreateConsumerGroupResponseBody() = default;
};
class CreateConsumerGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateConsumerGroupResponseBody> body{};

  CreateConsumerGroupResponse() {}

  explicit CreateConsumerGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateConsumerGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateConsumerGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateConsumerGroupResponse() = default;
};
class CreateConsumerGroupSubscribeRelationRequest : public Darabonba::Model {
public:
  shared_ptr<string> consumerGroupId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  CreateConsumerGroupSubscribeRelationRequest() {}

  explicit CreateConsumerGroupSubscribeRelationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consumerGroupId) {
      res["ConsumerGroupId"] = boost::any(*consumerGroupId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsumerGroupId") != m.end() && !m["ConsumerGroupId"].empty()) {
      consumerGroupId = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~CreateConsumerGroupSubscribeRelationRequest() = default;
};
class CreateConsumerGroupSubscribeRelationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  CreateConsumerGroupSubscribeRelationResponseBody() {}

  explicit CreateConsumerGroupSubscribeRelationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CreateConsumerGroupSubscribeRelationResponseBody() = default;
};
class CreateConsumerGroupSubscribeRelationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateConsumerGroupSubscribeRelationResponseBody> body{};

  CreateConsumerGroupSubscribeRelationResponse() {}

  explicit CreateConsumerGroupSubscribeRelationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateConsumerGroupSubscribeRelationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateConsumerGroupSubscribeRelationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateConsumerGroupSubscribeRelationResponse() = default;
};
class CreateDataAPIServiceRequestRequestParam : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> desc{};
  shared_ptr<string> example{};
  shared_ptr<bool> required{};

  CreateDataAPIServiceRequestRequestParam() {}

  explicit CreateDataAPIServiceRequestRequestParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (example) {
      res["Example"] = boost::any(*example);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Example") != m.end() && !m["Example"].empty()) {
      example = make_shared<string>(boost::any_cast<string>(m["Example"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<bool>(boost::any_cast<bool>(m["Required"]));
    }
  }


  virtual ~CreateDataAPIServiceRequestRequestParam() = default;
};
class CreateDataAPIServiceRequestResponseParam : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> desc{};
  shared_ptr<string> example{};
  shared_ptr<bool> required{};

  CreateDataAPIServiceRequestResponseParam() {}

  explicit CreateDataAPIServiceRequestResponseParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (example) {
      res["Example"] = boost::any(*example);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Example") != m.end() && !m["Example"].empty()) {
      example = make_shared<string>(boost::any_cast<string>(m["Example"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<bool>(boost::any_cast<bool>(m["Required"]));
    }
  }


  virtual ~CreateDataAPIServiceRequestResponseParam() = default;
};
class CreateDataAPIServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> originSql{};
  shared_ptr<vector<CreateDataAPIServiceRequestRequestParam>> requestParam{};
  shared_ptr<string> desc{};
  shared_ptr<vector<CreateDataAPIServiceRequestResponseParam>> responseParam{};
  shared_ptr<string> templateSql{};
  shared_ptr<string> apiPath{};
  shared_ptr<string> iotInstanceId{};

  CreateDataAPIServiceRequest() {}

  explicit CreateDataAPIServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (originSql) {
      res["OriginSql"] = boost::any(*originSql);
    }
    if (requestParam) {
      vector<boost::any> temp1;
      for(auto item1:*requestParam){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParam"] = boost::any(temp1);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (responseParam) {
      vector<boost::any> temp1;
      for(auto item1:*responseParam){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResponseParam"] = boost::any(temp1);
    }
    if (templateSql) {
      res["TemplateSql"] = boost::any(*templateSql);
    }
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("OriginSql") != m.end() && !m["OriginSql"].empty()) {
      originSql = make_shared<string>(boost::any_cast<string>(m["OriginSql"]));
    }
    if (m.find("RequestParam") != m.end() && !m["RequestParam"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParam"].type()) {
        vector<CreateDataAPIServiceRequestRequestParam> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParam"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataAPIServiceRequestRequestParam model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParam = make_shared<vector<CreateDataAPIServiceRequestRequestParam>>(expect1);
      }
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("ResponseParam") != m.end() && !m["ResponseParam"].empty()) {
      if (typeid(vector<boost::any>) == m["ResponseParam"].type()) {
        vector<CreateDataAPIServiceRequestResponseParam> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResponseParam"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataAPIServiceRequestResponseParam model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        responseParam = make_shared<vector<CreateDataAPIServiceRequestResponseParam>>(expect1);
      }
    }
    if (m.find("TemplateSql") != m.end() && !m["TemplateSql"].empty()) {
      templateSql = make_shared<string>(boost::any_cast<string>(m["TemplateSql"]));
    }
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~CreateDataAPIServiceRequest() = default;
};
class CreateDataAPIServiceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> apiSrn{};
  shared_ptr<long> createTime{};
  shared_ptr<long> lastUpdateTime{};

  CreateDataAPIServiceResponseBodyData() {}

  explicit CreateDataAPIServiceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiSrn) {
      res["ApiSrn"] = boost::any(*apiSrn);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (lastUpdateTime) {
      res["LastUpdateTime"] = boost::any(*lastUpdateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiSrn") != m.end() && !m["ApiSrn"].empty()) {
      apiSrn = make_shared<string>(boost::any_cast<string>(m["ApiSrn"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("LastUpdateTime") != m.end() && !m["LastUpdateTime"].empty()) {
      lastUpdateTime = make_shared<long>(boost::any_cast<long>(m["LastUpdateTime"]));
    }
  }


  virtual ~CreateDataAPIServiceResponseBodyData() = default;
};
class CreateDataAPIServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<CreateDataAPIServiceResponseBodyData> data{};

  CreateDataAPIServiceResponseBody() {}

  explicit CreateDataAPIServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateDataAPIServiceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateDataAPIServiceResponseBodyData>(model1);
      }
    }
  }


  virtual ~CreateDataAPIServiceResponseBody() = default;
};
class CreateDataAPIServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDataAPIServiceResponseBody> body{};

  CreateDataAPIServiceResponse() {}

  explicit CreateDataAPIServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataAPIServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataAPIServiceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataAPIServiceResponse() = default;
};
class CreateDeviceDistributeJobRequestTargetInstanceConfig : public Darabonba::Model {
public:
  shared_ptr<string> targetInstanceId{};

  CreateDeviceDistributeJobRequestTargetInstanceConfig() {}

  explicit CreateDeviceDistributeJobRequestTargetInstanceConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
  }


  virtual ~CreateDeviceDistributeJobRequestTargetInstanceConfig() = default;
};
class CreateDeviceDistributeJobRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> deviceName{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> targetUid{};
  shared_ptr<string> targetAliyunId{};
  shared_ptr<vector<CreateDeviceDistributeJobRequestTargetInstanceConfig>> targetInstanceConfig{};
  shared_ptr<long> strategy{};

  CreateDeviceDistributeJobRequest() {}

  explicit CreateDeviceDistributeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (targetUid) {
      res["TargetUid"] = boost::any(*targetUid);
    }
    if (targetAliyunId) {
      res["TargetAliyunId"] = boost::any(*targetAliyunId);
    }
    if (targetInstanceConfig) {
      vector<boost::any> temp1;
      for(auto item1:*targetInstanceConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TargetInstanceConfig"] = boost::any(temp1);
    }
    if (strategy) {
      res["Strategy"] = boost::any(*strategy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("TargetUid") != m.end() && !m["TargetUid"].empty()) {
      targetUid = make_shared<string>(boost::any_cast<string>(m["TargetUid"]));
    }
    if (m.find("TargetAliyunId") != m.end() && !m["TargetAliyunId"].empty()) {
      targetAliyunId = make_shared<string>(boost::any_cast<string>(m["TargetAliyunId"]));
    }
    if (m.find("TargetInstanceConfig") != m.end() && !m["TargetInstanceConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["TargetInstanceConfig"].type()) {
        vector<CreateDeviceDistributeJobRequestTargetInstanceConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TargetInstanceConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDeviceDistributeJobRequestTargetInstanceConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targetInstanceConfig = make_shared<vector<CreateDeviceDistributeJobRequestTargetInstanceConfig>>(expect1);
      }
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      strategy = make_shared<long>(boost::any_cast<long>(m["Strategy"]));
    }
  }


  virtual ~CreateDeviceDistributeJobRequest() = default;
};
class CreateDeviceDistributeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> jobId{};

  CreateDeviceDistributeJobResponseBody() {}

  explicit CreateDeviceDistributeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~CreateDeviceDistributeJobResponseBody() = default;
};
class CreateDeviceDistributeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDeviceDistributeJobResponseBody> body{};

  CreateDeviceDistributeJobResponse() {}

  explicit CreateDeviceDistributeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDeviceDistributeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDeviceDistributeJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDeviceDistributeJobResponse() = default;
};
class CreateDeviceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> superGroupId{};
  shared_ptr<string> groupDesc{};
  shared_ptr<string> groupName{};

  CreateDeviceGroupRequest() {}

  explicit CreateDeviceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (superGroupId) {
      res["SuperGroupId"] = boost::any(*superGroupId);
    }
    if (groupDesc) {
      res["GroupDesc"] = boost::any(*groupDesc);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("SuperGroupId") != m.end() && !m["SuperGroupId"].empty()) {
      superGroupId = make_shared<string>(boost::any_cast<string>(m["SuperGroupId"]));
    }
    if (m.find("GroupDesc") != m.end() && !m["GroupDesc"].empty()) {
      groupDesc = make_shared<string>(boost::any_cast<string>(m["GroupDesc"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~CreateDeviceGroupRequest() = default;
};
class CreateDeviceGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> groupName{};
  shared_ptr<string> groupDesc{};

  CreateDeviceGroupResponseBodyData() {}

  explicit CreateDeviceGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupDesc) {
      res["GroupDesc"] = boost::any(*groupDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupDesc") != m.end() && !m["GroupDesc"].empty()) {
      groupDesc = make_shared<string>(boost::any_cast<string>(m["GroupDesc"]));
    }
  }


  virtual ~CreateDeviceGroupResponseBodyData() = default;
};
class CreateDeviceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<CreateDeviceGroupResponseBodyData> data{};

  CreateDeviceGroupResponseBody() {}

  explicit CreateDeviceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateDeviceGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateDeviceGroupResponseBodyData>(model1);
      }
    }
  }


  virtual ~CreateDeviceGroupResponseBody() = default;
};
class CreateDeviceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDeviceGroupResponseBody> body{};

  CreateDeviceGroupResponse() {}

  explicit CreateDeviceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDeviceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDeviceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDeviceGroupResponse() = default;
};
class CreateEdgeDriverRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> driverName{};
  shared_ptr<string> driverProtocol{};
  shared_ptr<string> runtime{};
  shared_ptr<string> cpuArch{};
  shared_ptr<bool> isBuiltIn{};

  CreateEdgeDriverRequest() {}

  explicit CreateEdgeDriverRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (driverName) {
      res["DriverName"] = boost::any(*driverName);
    }
    if (driverProtocol) {
      res["DriverProtocol"] = boost::any(*driverProtocol);
    }
    if (runtime) {
      res["Runtime"] = boost::any(*runtime);
    }
    if (cpuArch) {
      res["CpuArch"] = boost::any(*cpuArch);
    }
    if (isBuiltIn) {
      res["IsBuiltIn"] = boost::any(*isBuiltIn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("DriverName") != m.end() && !m["DriverName"].empty()) {
      driverName = make_shared<string>(boost::any_cast<string>(m["DriverName"]));
    }
    if (m.find("DriverProtocol") != m.end() && !m["DriverProtocol"].empty()) {
      driverProtocol = make_shared<string>(boost::any_cast<string>(m["DriverProtocol"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      runtime = make_shared<string>(boost::any_cast<string>(m["Runtime"]));
    }
    if (m.find("CpuArch") != m.end() && !m["CpuArch"].empty()) {
      cpuArch = make_shared<string>(boost::any_cast<string>(m["CpuArch"]));
    }
    if (m.find("IsBuiltIn") != m.end() && !m["IsBuiltIn"].empty()) {
      isBuiltIn = make_shared<bool>(boost::any_cast<bool>(m["IsBuiltIn"]));
    }
  }


  virtual ~CreateEdgeDriverRequest() = default;
};
class CreateEdgeDriverResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> driverId{};

  CreateEdgeDriverResponseBody() {}

  explicit CreateEdgeDriverResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
  }


  virtual ~CreateEdgeDriverResponseBody() = default;
};
class CreateEdgeDriverResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateEdgeDriverResponseBody> body{};

  CreateEdgeDriverResponse() {}

  explicit CreateEdgeDriverResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEdgeDriverResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEdgeDriverResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEdgeDriverResponse() = default;
};
class CreateEdgeDriverVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};
  shared_ptr<string> edgeVersion{};
  shared_ptr<string> description{};
  shared_ptr<string> sourceConfig{};
  shared_ptr<string> driverConfig{};
  shared_ptr<string> containerConfig{};
  shared_ptr<string> configCheckRule{};
  shared_ptr<string> argument{};

  CreateEdgeDriverVersionRequest() {}

  explicit CreateEdgeDriverVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    if (edgeVersion) {
      res["EdgeVersion"] = boost::any(*edgeVersion);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (sourceConfig) {
      res["SourceConfig"] = boost::any(*sourceConfig);
    }
    if (driverConfig) {
      res["DriverConfig"] = boost::any(*driverConfig);
    }
    if (containerConfig) {
      res["ContainerConfig"] = boost::any(*containerConfig);
    }
    if (configCheckRule) {
      res["ConfigCheckRule"] = boost::any(*configCheckRule);
    }
    if (argument) {
      res["Argument"] = boost::any(*argument);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
    if (m.find("EdgeVersion") != m.end() && !m["EdgeVersion"].empty()) {
      edgeVersion = make_shared<string>(boost::any_cast<string>(m["EdgeVersion"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SourceConfig") != m.end() && !m["SourceConfig"].empty()) {
      sourceConfig = make_shared<string>(boost::any_cast<string>(m["SourceConfig"]));
    }
    if (m.find("DriverConfig") != m.end() && !m["DriverConfig"].empty()) {
      driverConfig = make_shared<string>(boost::any_cast<string>(m["DriverConfig"]));
    }
    if (m.find("ContainerConfig") != m.end() && !m["ContainerConfig"].empty()) {
      containerConfig = make_shared<string>(boost::any_cast<string>(m["ContainerConfig"]));
    }
    if (m.find("ConfigCheckRule") != m.end() && !m["ConfigCheckRule"].empty()) {
      configCheckRule = make_shared<string>(boost::any_cast<string>(m["ConfigCheckRule"]));
    }
    if (m.find("Argument") != m.end() && !m["Argument"].empty()) {
      argument = make_shared<string>(boost::any_cast<string>(m["Argument"]));
    }
  }


  virtual ~CreateEdgeDriverVersionRequest() = default;
};
class CreateEdgeDriverVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  CreateEdgeDriverVersionResponseBody() {}

  explicit CreateEdgeDriverVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CreateEdgeDriverVersionResponseBody() = default;
};
class CreateEdgeDriverVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateEdgeDriverVersionResponseBody> body{};

  CreateEdgeDriverVersionResponse() {}

  explicit CreateEdgeDriverVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEdgeDriverVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEdgeDriverVersionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEdgeDriverVersionResponse() = default;
};
class CreateEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> tags{};
  shared_ptr<long> spec{};

  CreateEdgeInstanceRequest() {}

  explicit CreateEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<long>(boost::any_cast<long>(m["Spec"]));
    }
  }


  virtual ~CreateEdgeInstanceRequest() = default;
};
class CreateEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<string> instanceId{};

  CreateEdgeInstanceResponseBody() {}

  explicit CreateEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~CreateEdgeInstanceResponseBody() = default;
};
class CreateEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateEdgeInstanceResponseBody> body{};

  CreateEdgeInstanceResponse() {}

  explicit CreateEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEdgeInstanceResponse() = default;
};
class CreateEdgeInstanceChannelRequestConfigs : public Darabonba::Model {
public:
  shared_ptr<string> format{};
  shared_ptr<string> content{};
  shared_ptr<string> key{};

  CreateEdgeInstanceChannelRequestConfigs() {}

  explicit CreateEdgeInstanceChannelRequestConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~CreateEdgeInstanceChannelRequestConfigs() = default;
};
class CreateEdgeInstanceChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<string> channelName{};
  shared_ptr<vector<CreateEdgeInstanceChannelRequestConfigs>> configs{};

  CreateEdgeInstanceChannelRequest() {}

  explicit CreateEdgeInstanceChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (configs) {
      vector<boost::any> temp1;
      for(auto item1:*configs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Configs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("Configs") != m.end() && !m["Configs"].empty()) {
      if (typeid(vector<boost::any>) == m["Configs"].type()) {
        vector<CreateEdgeInstanceChannelRequestConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Configs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEdgeInstanceChannelRequestConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configs = make_shared<vector<CreateEdgeInstanceChannelRequestConfigs>>(expect1);
      }
    }
  }


  virtual ~CreateEdgeInstanceChannelRequest() = default;
};
class CreateEdgeInstanceChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> data{};

  CreateEdgeInstanceChannelResponseBody() {}

  explicit CreateEdgeInstanceChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
  }


  virtual ~CreateEdgeInstanceChannelResponseBody() = default;
};
class CreateEdgeInstanceChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateEdgeInstanceChannelResponseBody> body{};

  CreateEdgeInstanceChannelResponse() {}

  explicit CreateEdgeInstanceChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEdgeInstanceChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEdgeInstanceChannelResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEdgeInstanceChannelResponse() = default;
};
class CreateEdgeInstanceDeploymentRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> type{};

  CreateEdgeInstanceDeploymentRequest() {}

  explicit CreateEdgeInstanceDeploymentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateEdgeInstanceDeploymentRequest() = default;
};
class CreateEdgeInstanceDeploymentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> deploymentId{};

  CreateEdgeInstanceDeploymentResponseBody() {}

  explicit CreateEdgeInstanceDeploymentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (deploymentId) {
      res["DeploymentId"] = boost::any(*deploymentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("DeploymentId") != m.end() && !m["DeploymentId"].empty()) {
      deploymentId = make_shared<string>(boost::any_cast<string>(m["DeploymentId"]));
    }
  }


  virtual ~CreateEdgeInstanceDeploymentResponseBody() = default;
};
class CreateEdgeInstanceDeploymentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateEdgeInstanceDeploymentResponseBody> body{};

  CreateEdgeInstanceDeploymentResponse() {}

  explicit CreateEdgeInstanceDeploymentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEdgeInstanceDeploymentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEdgeInstanceDeploymentResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEdgeInstanceDeploymentResponse() = default;
};
class CreateEdgeInstanceMessageRoutingRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> topicFilter{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> sourceData{};
  shared_ptr<string> targetType{};
  shared_ptr<string> targetData{};
  shared_ptr<long> targetIotHubQos{};

  CreateEdgeInstanceMessageRoutingRequest() {}

  explicit CreateEdgeInstanceMessageRoutingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (topicFilter) {
      res["TopicFilter"] = boost::any(*topicFilter);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (sourceData) {
      res["SourceData"] = boost::any(*sourceData);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (targetData) {
      res["TargetData"] = boost::any(*targetData);
    }
    if (targetIotHubQos) {
      res["TargetIotHubQos"] = boost::any(*targetIotHubQos);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TopicFilter") != m.end() && !m["TopicFilter"].empty()) {
      topicFilter = make_shared<string>(boost::any_cast<string>(m["TopicFilter"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("SourceData") != m.end() && !m["SourceData"].empty()) {
      sourceData = make_shared<string>(boost::any_cast<string>(m["SourceData"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("TargetData") != m.end() && !m["TargetData"].empty()) {
      targetData = make_shared<string>(boost::any_cast<string>(m["TargetData"]));
    }
    if (m.find("TargetIotHubQos") != m.end() && !m["TargetIotHubQos"].empty()) {
      targetIotHubQos = make_shared<long>(boost::any_cast<long>(m["TargetIotHubQos"]));
    }
  }


  virtual ~CreateEdgeInstanceMessageRoutingRequest() = default;
};
class CreateEdgeInstanceMessageRoutingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> routeId{};

  CreateEdgeInstanceMessageRoutingResponseBody() {}

  explicit CreateEdgeInstanceMessageRoutingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<long>(boost::any_cast<long>(m["RouteId"]));
    }
  }


  virtual ~CreateEdgeInstanceMessageRoutingResponseBody() = default;
};
class CreateEdgeInstanceMessageRoutingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateEdgeInstanceMessageRoutingResponseBody> body{};

  CreateEdgeInstanceMessageRoutingResponse() {}

  explicit CreateEdgeInstanceMessageRoutingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEdgeInstanceMessageRoutingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEdgeInstanceMessageRoutingResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEdgeInstanceMessageRoutingResponse() = default;
};
class CreateEdgeOssPreSignedAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> fileName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> type{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> resourceVersion{};

  CreateEdgeOssPreSignedAddressRequest() {}

  explicit CreateEdgeOssPreSignedAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (resourceVersion) {
      res["ResourceVersion"] = boost::any(*resourceVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ResourceVersion") != m.end() && !m["ResourceVersion"].empty()) {
      resourceVersion = make_shared<string>(boost::any_cast<string>(m["ResourceVersion"]));
    }
  }


  virtual ~CreateEdgeOssPreSignedAddressRequest() = default;
};
class CreateEdgeOssPreSignedAddressResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> ossPreSignedAddress{};
  shared_ptr<string> ossAddress{};

  CreateEdgeOssPreSignedAddressResponseBodyData() {}

  explicit CreateEdgeOssPreSignedAddressResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ossPreSignedAddress) {
      res["OssPreSignedAddress"] = boost::any(*ossPreSignedAddress);
    }
    if (ossAddress) {
      res["OssAddress"] = boost::any(*ossAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OssPreSignedAddress") != m.end() && !m["OssPreSignedAddress"].empty()) {
      ossPreSignedAddress = make_shared<string>(boost::any_cast<string>(m["OssPreSignedAddress"]));
    }
    if (m.find("OssAddress") != m.end() && !m["OssAddress"].empty()) {
      ossAddress = make_shared<string>(boost::any_cast<string>(m["OssAddress"]));
    }
  }


  virtual ~CreateEdgeOssPreSignedAddressResponseBodyData() = default;
};
class CreateEdgeOssPreSignedAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<CreateEdgeOssPreSignedAddressResponseBodyData> data{};

  CreateEdgeOssPreSignedAddressResponseBody() {}

  explicit CreateEdgeOssPreSignedAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateEdgeOssPreSignedAddressResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateEdgeOssPreSignedAddressResponseBodyData>(model1);
      }
    }
  }


  virtual ~CreateEdgeOssPreSignedAddressResponseBody() = default;
};
class CreateEdgeOssPreSignedAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateEdgeOssPreSignedAddressResponseBody> body{};

  CreateEdgeOssPreSignedAddressResponse() {}

  explicit CreateEdgeOssPreSignedAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEdgeOssPreSignedAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEdgeOssPreSignedAddressResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEdgeOssPreSignedAddressResponse() = default;
};
class CreateJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> description{};
  shared_ptr<string> jobDocument{};
  shared_ptr<string> type{};
  shared_ptr<string> jobFile{};
  shared_ptr<string> jobName{};
  shared_ptr<string> timeoutConfig{};
  shared_ptr<string> rolloutConfig{};
  shared_ptr<string> targetConfig{};

  CreateJobRequest() {}

  explicit CreateJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (jobDocument) {
      res["JobDocument"] = boost::any(*jobDocument);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (jobFile) {
      res["JobFile"] = boost::any(*jobFile);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (timeoutConfig) {
      res["TimeoutConfig"] = boost::any(*timeoutConfig);
    }
    if (rolloutConfig) {
      res["RolloutConfig"] = boost::any(*rolloutConfig);
    }
    if (targetConfig) {
      res["TargetConfig"] = boost::any(*targetConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("JobDocument") != m.end() && !m["JobDocument"].empty()) {
      jobDocument = make_shared<string>(boost::any_cast<string>(m["JobDocument"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("JobFile") != m.end() && !m["JobFile"].empty()) {
      jobFile = make_shared<string>(boost::any_cast<string>(m["JobFile"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("TimeoutConfig") != m.end() && !m["TimeoutConfig"].empty()) {
      timeoutConfig = make_shared<string>(boost::any_cast<string>(m["TimeoutConfig"]));
    }
    if (m.find("RolloutConfig") != m.end() && !m["RolloutConfig"].empty()) {
      rolloutConfig = make_shared<string>(boost::any_cast<string>(m["RolloutConfig"]));
    }
    if (m.find("TargetConfig") != m.end() && !m["TargetConfig"].empty()) {
      targetConfig = make_shared<string>(boost::any_cast<string>(m["TargetConfig"]));
    }
  }


  virtual ~CreateJobRequest() = default;
};
class CreateJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> jobId{};

  CreateJobResponseBody() {}

  explicit CreateJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~CreateJobResponseBody() = default;
};
class CreateJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateJobResponseBody> body{};

  CreateJobResponse() {}

  explicit CreateJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateJobResponse() = default;
};
class CreateLoRaNodesTaskRequestDeviceInfo : public Darabonba::Model {
public:
  shared_ptr<string> devEui{};
  shared_ptr<string> pinCode{};

  CreateLoRaNodesTaskRequestDeviceInfo() {}

  explicit CreateLoRaNodesTaskRequestDeviceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (devEui) {
      res["DevEui"] = boost::any(*devEui);
    }
    if (pinCode) {
      res["PinCode"] = boost::any(*pinCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DevEui") != m.end() && !m["DevEui"].empty()) {
      devEui = make_shared<string>(boost::any_cast<string>(m["DevEui"]));
    }
    if (m.find("PinCode") != m.end() && !m["PinCode"].empty()) {
      pinCode = make_shared<string>(boost::any_cast<string>(m["PinCode"]));
    }
  }


  virtual ~CreateLoRaNodesTaskRequestDeviceInfo() = default;
};
class CreateLoRaNodesTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<vector<CreateLoRaNodesTaskRequestDeviceInfo>> deviceInfo{};

  CreateLoRaNodesTaskRequest() {}

  explicit CreateLoRaNodesTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*deviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceInfo") != m.end() && !m["DeviceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceInfo"].type()) {
        vector<CreateLoRaNodesTaskRequestDeviceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateLoRaNodesTaskRequestDeviceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceInfo = make_shared<vector<CreateLoRaNodesTaskRequestDeviceInfo>>(expect1);
      }
    }
  }


  virtual ~CreateLoRaNodesTaskRequest() = default;
};
class CreateLoRaNodesTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> taskId{};

  CreateLoRaNodesTaskResponseBody() {}

  explicit CreateLoRaNodesTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateLoRaNodesTaskResponseBody() = default;
};
class CreateLoRaNodesTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateLoRaNodesTaskResponseBody> body{};

  CreateLoRaNodesTaskResponse() {}

  explicit CreateLoRaNodesTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLoRaNodesTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLoRaNodesTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLoRaNodesTaskResponse() = default;
};
class CreateOTADynamicUpgradeJobRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateOTADynamicUpgradeJobRequestTag() {}

  explicit CreateOTADynamicUpgradeJobRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateOTADynamicUpgradeJobRequestTag() = default;
};
class CreateOTADynamicUpgradeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> productKey{};
  shared_ptr<vector<string>> srcVersion{};
  shared_ptr<long> retryInterval{};
  shared_ptr<long> retryCount{};
  shared_ptr<long> timeoutInMinutes{};
  shared_ptr<long> maximumPerMinute{};
  shared_ptr<long> overwriteMode{};
  shared_ptr<long> dynamicMode{};
  shared_ptr<vector<CreateOTADynamicUpgradeJobRequestTag>> tag{};

  CreateOTADynamicUpgradeJobRequest() {}

  explicit CreateOTADynamicUpgradeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (srcVersion) {
      res["SrcVersion"] = boost::any(*srcVersion);
    }
    if (retryInterval) {
      res["RetryInterval"] = boost::any(*retryInterval);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (timeoutInMinutes) {
      res["TimeoutInMinutes"] = boost::any(*timeoutInMinutes);
    }
    if (maximumPerMinute) {
      res["MaximumPerMinute"] = boost::any(*maximumPerMinute);
    }
    if (overwriteMode) {
      res["OverwriteMode"] = boost::any(*overwriteMode);
    }
    if (dynamicMode) {
      res["DynamicMode"] = boost::any(*dynamicMode);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("SrcVersion") != m.end() && !m["SrcVersion"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SrcVersion"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SrcVersion"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      srcVersion = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RetryInterval") != m.end() && !m["RetryInterval"].empty()) {
      retryInterval = make_shared<long>(boost::any_cast<long>(m["RetryInterval"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<long>(boost::any_cast<long>(m["RetryCount"]));
    }
    if (m.find("TimeoutInMinutes") != m.end() && !m["TimeoutInMinutes"].empty()) {
      timeoutInMinutes = make_shared<long>(boost::any_cast<long>(m["TimeoutInMinutes"]));
    }
    if (m.find("MaximumPerMinute") != m.end() && !m["MaximumPerMinute"].empty()) {
      maximumPerMinute = make_shared<long>(boost::any_cast<long>(m["MaximumPerMinute"]));
    }
    if (m.find("OverwriteMode") != m.end() && !m["OverwriteMode"].empty()) {
      overwriteMode = make_shared<long>(boost::any_cast<long>(m["OverwriteMode"]));
    }
    if (m.find("DynamicMode") != m.end() && !m["DynamicMode"].empty()) {
      dynamicMode = make_shared<long>(boost::any_cast<long>(m["DynamicMode"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateOTADynamicUpgradeJobRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOTADynamicUpgradeJobRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateOTADynamicUpgradeJobRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateOTADynamicUpgradeJobRequest() = default;
};
class CreateOTADynamicUpgradeJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> utcCreate{};

  CreateOTADynamicUpgradeJobResponseBodyData() {}

  explicit CreateOTADynamicUpgradeJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
  }


  virtual ~CreateOTADynamicUpgradeJobResponseBodyData() = default;
};
class CreateOTADynamicUpgradeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<CreateOTADynamicUpgradeJobResponseBodyData> data{};

  CreateOTADynamicUpgradeJobResponseBody() {}

  explicit CreateOTADynamicUpgradeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateOTADynamicUpgradeJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateOTADynamicUpgradeJobResponseBodyData>(model1);
      }
    }
  }


  virtual ~CreateOTADynamicUpgradeJobResponseBody() = default;
};
class CreateOTADynamicUpgradeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateOTADynamicUpgradeJobResponseBody> body{};

  CreateOTADynamicUpgradeJobResponse() {}

  explicit CreateOTADynamicUpgradeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOTADynamicUpgradeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOTADynamicUpgradeJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOTADynamicUpgradeJobResponse() = default;
};
class CreateOTAFirmwareRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> firmwareName{};
  shared_ptr<string> destVersion{};
  shared_ptr<string> firmwareUrl{};
  shared_ptr<string> firmwareSign{};
  shared_ptr<string> signMethod{};
  shared_ptr<long> firmwareSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> firmwareDesc{};
  shared_ptr<long> type{};
  shared_ptr<string> srcVersion{};
  shared_ptr<string> moduleName{};
  shared_ptr<bool> needToVerify{};

  CreateOTAFirmwareRequest() {}

  explicit CreateOTAFirmwareRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (firmwareName) {
      res["FirmwareName"] = boost::any(*firmwareName);
    }
    if (destVersion) {
      res["DestVersion"] = boost::any(*destVersion);
    }
    if (firmwareUrl) {
      res["FirmwareUrl"] = boost::any(*firmwareUrl);
    }
    if (firmwareSign) {
      res["FirmwareSign"] = boost::any(*firmwareSign);
    }
    if (signMethod) {
      res["SignMethod"] = boost::any(*signMethod);
    }
    if (firmwareSize) {
      res["FirmwareSize"] = boost::any(*firmwareSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (firmwareDesc) {
      res["FirmwareDesc"] = boost::any(*firmwareDesc);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (srcVersion) {
      res["SrcVersion"] = boost::any(*srcVersion);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    if (needToVerify) {
      res["NeedToVerify"] = boost::any(*needToVerify);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("FirmwareName") != m.end() && !m["FirmwareName"].empty()) {
      firmwareName = make_shared<string>(boost::any_cast<string>(m["FirmwareName"]));
    }
    if (m.find("DestVersion") != m.end() && !m["DestVersion"].empty()) {
      destVersion = make_shared<string>(boost::any_cast<string>(m["DestVersion"]));
    }
    if (m.find("FirmwareUrl") != m.end() && !m["FirmwareUrl"].empty()) {
      firmwareUrl = make_shared<string>(boost::any_cast<string>(m["FirmwareUrl"]));
    }
    if (m.find("FirmwareSign") != m.end() && !m["FirmwareSign"].empty()) {
      firmwareSign = make_shared<string>(boost::any_cast<string>(m["FirmwareSign"]));
    }
    if (m.find("SignMethod") != m.end() && !m["SignMethod"].empty()) {
      signMethod = make_shared<string>(boost::any_cast<string>(m["SignMethod"]));
    }
    if (m.find("FirmwareSize") != m.end() && !m["FirmwareSize"].empty()) {
      firmwareSize = make_shared<long>(boost::any_cast<long>(m["FirmwareSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("FirmwareDesc") != m.end() && !m["FirmwareDesc"].empty()) {
      firmwareDesc = make_shared<string>(boost::any_cast<string>(m["FirmwareDesc"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("SrcVersion") != m.end() && !m["SrcVersion"].empty()) {
      srcVersion = make_shared<string>(boost::any_cast<string>(m["SrcVersion"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
    if (m.find("NeedToVerify") != m.end() && !m["NeedToVerify"].empty()) {
      needToVerify = make_shared<bool>(boost::any_cast<bool>(m["NeedToVerify"]));
    }
  }


  virtual ~CreateOTAFirmwareRequest() = default;
};
class CreateOTAFirmwareResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> firmwareId{};
  shared_ptr<string> utcCreate{};

  CreateOTAFirmwareResponseBodyData() {}

  explicit CreateOTAFirmwareResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
  }


  virtual ~CreateOTAFirmwareResponseBodyData() = default;
};
class CreateOTAFirmwareResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<CreateOTAFirmwareResponseBodyData> data{};

  CreateOTAFirmwareResponseBody() {}

  explicit CreateOTAFirmwareResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateOTAFirmwareResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateOTAFirmwareResponseBodyData>(model1);
      }
    }
  }


  virtual ~CreateOTAFirmwareResponseBody() = default;
};
class CreateOTAFirmwareResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateOTAFirmwareResponseBody> body{};

  CreateOTAFirmwareResponse() {}

  explicit CreateOTAFirmwareResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOTAFirmwareResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOTAFirmwareResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOTAFirmwareResponse() = default;
};
class CreateOTAModuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> moduleName{};
  shared_ptr<string> desc{};
  shared_ptr<string> productKey{};

  CreateOTAModuleRequest() {}

  explicit CreateOTAModuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~CreateOTAModuleRequest() = default;
};
class CreateOTAModuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  CreateOTAModuleResponseBody() {}

  explicit CreateOTAModuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CreateOTAModuleResponseBody() = default;
};
class CreateOTAModuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateOTAModuleResponseBody> body{};

  CreateOTAModuleResponse() {}

  explicit CreateOTAModuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOTAModuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOTAModuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOTAModuleResponse() = default;
};
class CreateOTAStaticUpgradeJobRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateOTAStaticUpgradeJobRequestTag() {}

  explicit CreateOTAStaticUpgradeJobRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateOTAStaticUpgradeJobRequestTag() = default;
};
class CreateOTAStaticUpgradeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> targetSelection{};
  shared_ptr<vector<string>> srcVersion{};
  shared_ptr<long> scheduleTime{};
  shared_ptr<long> retryInterval{};
  shared_ptr<long> retryCount{};
  shared_ptr<long> timeoutInMinutes{};
  shared_ptr<long> maximumPerMinute{};
  shared_ptr<string> grayPercent{};
  shared_ptr<vector<string>> targetDeviceName{};
  shared_ptr<long> scheduleFinishTime{};
  shared_ptr<long> overwriteMode{};
  shared_ptr<vector<CreateOTAStaticUpgradeJobRequestTag>> tag{};
  shared_ptr<string> dnListFileUrl{};

  CreateOTAStaticUpgradeJobRequest() {}

  explicit CreateOTAStaticUpgradeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (targetSelection) {
      res["TargetSelection"] = boost::any(*targetSelection);
    }
    if (srcVersion) {
      res["SrcVersion"] = boost::any(*srcVersion);
    }
    if (scheduleTime) {
      res["ScheduleTime"] = boost::any(*scheduleTime);
    }
    if (retryInterval) {
      res["RetryInterval"] = boost::any(*retryInterval);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (timeoutInMinutes) {
      res["TimeoutInMinutes"] = boost::any(*timeoutInMinutes);
    }
    if (maximumPerMinute) {
      res["MaximumPerMinute"] = boost::any(*maximumPerMinute);
    }
    if (grayPercent) {
      res["GrayPercent"] = boost::any(*grayPercent);
    }
    if (targetDeviceName) {
      res["TargetDeviceName"] = boost::any(*targetDeviceName);
    }
    if (scheduleFinishTime) {
      res["ScheduleFinishTime"] = boost::any(*scheduleFinishTime);
    }
    if (overwriteMode) {
      res["OverwriteMode"] = boost::any(*overwriteMode);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (dnListFileUrl) {
      res["DnListFileUrl"] = boost::any(*dnListFileUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("TargetSelection") != m.end() && !m["TargetSelection"].empty()) {
      targetSelection = make_shared<string>(boost::any_cast<string>(m["TargetSelection"]));
    }
    if (m.find("SrcVersion") != m.end() && !m["SrcVersion"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SrcVersion"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SrcVersion"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      srcVersion = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScheduleTime") != m.end() && !m["ScheduleTime"].empty()) {
      scheduleTime = make_shared<long>(boost::any_cast<long>(m["ScheduleTime"]));
    }
    if (m.find("RetryInterval") != m.end() && !m["RetryInterval"].empty()) {
      retryInterval = make_shared<long>(boost::any_cast<long>(m["RetryInterval"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<long>(boost::any_cast<long>(m["RetryCount"]));
    }
    if (m.find("TimeoutInMinutes") != m.end() && !m["TimeoutInMinutes"].empty()) {
      timeoutInMinutes = make_shared<long>(boost::any_cast<long>(m["TimeoutInMinutes"]));
    }
    if (m.find("MaximumPerMinute") != m.end() && !m["MaximumPerMinute"].empty()) {
      maximumPerMinute = make_shared<long>(boost::any_cast<long>(m["MaximumPerMinute"]));
    }
    if (m.find("GrayPercent") != m.end() && !m["GrayPercent"].empty()) {
      grayPercent = make_shared<string>(boost::any_cast<string>(m["GrayPercent"]));
    }
    if (m.find("TargetDeviceName") != m.end() && !m["TargetDeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TargetDeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TargetDeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      targetDeviceName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScheduleFinishTime") != m.end() && !m["ScheduleFinishTime"].empty()) {
      scheduleFinishTime = make_shared<long>(boost::any_cast<long>(m["ScheduleFinishTime"]));
    }
    if (m.find("OverwriteMode") != m.end() && !m["OverwriteMode"].empty()) {
      overwriteMode = make_shared<long>(boost::any_cast<long>(m["OverwriteMode"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateOTAStaticUpgradeJobRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOTAStaticUpgradeJobRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateOTAStaticUpgradeJobRequestTag>>(expect1);
      }
    }
    if (m.find("DnListFileUrl") != m.end() && !m["DnListFileUrl"].empty()) {
      dnListFileUrl = make_shared<string>(boost::any_cast<string>(m["DnListFileUrl"]));
    }
  }


  virtual ~CreateOTAStaticUpgradeJobRequest() = default;
};
class CreateOTAStaticUpgradeJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> utcCreate{};

  CreateOTAStaticUpgradeJobResponseBodyData() {}

  explicit CreateOTAStaticUpgradeJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
  }


  virtual ~CreateOTAStaticUpgradeJobResponseBodyData() = default;
};
class CreateOTAStaticUpgradeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<CreateOTAStaticUpgradeJobResponseBodyData> data{};

  CreateOTAStaticUpgradeJobResponseBody() {}

  explicit CreateOTAStaticUpgradeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateOTAStaticUpgradeJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateOTAStaticUpgradeJobResponseBodyData>(model1);
      }
    }
  }


  virtual ~CreateOTAStaticUpgradeJobResponseBody() = default;
};
class CreateOTAStaticUpgradeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateOTAStaticUpgradeJobResponseBody> body{};

  CreateOTAStaticUpgradeJobResponse() {}

  explicit CreateOTAStaticUpgradeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOTAStaticUpgradeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOTAStaticUpgradeJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOTAStaticUpgradeJobResponse() = default;
};
class CreateOTAVerifyJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> firmwareId{};
  shared_ptr<long> timeoutInMinutes{};
  shared_ptr<string> productKey{};
  shared_ptr<vector<string>> targetDeviceName{};

  CreateOTAVerifyJobRequest() {}

  explicit CreateOTAVerifyJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (timeoutInMinutes) {
      res["TimeoutInMinutes"] = boost::any(*timeoutInMinutes);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (targetDeviceName) {
      res["TargetDeviceName"] = boost::any(*targetDeviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("TimeoutInMinutes") != m.end() && !m["TimeoutInMinutes"].empty()) {
      timeoutInMinutes = make_shared<long>(boost::any_cast<long>(m["TimeoutInMinutes"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("TargetDeviceName") != m.end() && !m["TargetDeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TargetDeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TargetDeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      targetDeviceName = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateOTAVerifyJobRequest() = default;
};
class CreateOTAVerifyJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> utcCreate{};

  CreateOTAVerifyJobResponseBodyData() {}

  explicit CreateOTAVerifyJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
  }


  virtual ~CreateOTAVerifyJobResponseBodyData() = default;
};
class CreateOTAVerifyJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<CreateOTAVerifyJobResponseBodyData> data{};

  CreateOTAVerifyJobResponseBody() {}

  explicit CreateOTAVerifyJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateOTAVerifyJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateOTAVerifyJobResponseBodyData>(model1);
      }
    }
  }


  virtual ~CreateOTAVerifyJobResponseBody() = default;
};
class CreateOTAVerifyJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateOTAVerifyJobResponseBody> body{};

  CreateOTAVerifyJobResponse() {}

  explicit CreateOTAVerifyJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOTAVerifyJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOTAVerifyJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOTAVerifyJobResponse() = default;
};
class CreateProductRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productName{};
  shared_ptr<long> nodeType{};
  shared_ptr<long> dataFormat{};
  shared_ptr<string> description{};
  shared_ptr<string> aliyunCommodityCode{};
  shared_ptr<bool> id2{};
  shared_ptr<string> protocolType{};
  shared_ptr<string> netType{};
  shared_ptr<string> joinPermissionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> authType{};
  shared_ptr<string> categoryKey{};
  shared_ptr<bool> publishAuto{};
  shared_ptr<long> validateType{};

  CreateProductRequest() {}

  explicit CreateProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (dataFormat) {
      res["DataFormat"] = boost::any(*dataFormat);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (aliyunCommodityCode) {
      res["AliyunCommodityCode"] = boost::any(*aliyunCommodityCode);
    }
    if (id2) {
      res["Id2"] = boost::any(*id2);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (joinPermissionId) {
      res["JoinPermissionId"] = boost::any(*joinPermissionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (categoryKey) {
      res["CategoryKey"] = boost::any(*categoryKey);
    }
    if (publishAuto) {
      res["PublishAuto"] = boost::any(*publishAuto);
    }
    if (validateType) {
      res["ValidateType"] = boost::any(*validateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<long>(boost::any_cast<long>(m["NodeType"]));
    }
    if (m.find("DataFormat") != m.end() && !m["DataFormat"].empty()) {
      dataFormat = make_shared<long>(boost::any_cast<long>(m["DataFormat"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("AliyunCommodityCode") != m.end() && !m["AliyunCommodityCode"].empty()) {
      aliyunCommodityCode = make_shared<string>(boost::any_cast<string>(m["AliyunCommodityCode"]));
    }
    if (m.find("Id2") != m.end() && !m["Id2"].empty()) {
      id2 = make_shared<bool>(boost::any_cast<bool>(m["Id2"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<string>(boost::any_cast<string>(m["NetType"]));
    }
    if (m.find("JoinPermissionId") != m.end() && !m["JoinPermissionId"].empty()) {
      joinPermissionId = make_shared<string>(boost::any_cast<string>(m["JoinPermissionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("CategoryKey") != m.end() && !m["CategoryKey"].empty()) {
      categoryKey = make_shared<string>(boost::any_cast<string>(m["CategoryKey"]));
    }
    if (m.find("PublishAuto") != m.end() && !m["PublishAuto"].empty()) {
      publishAuto = make_shared<bool>(boost::any_cast<bool>(m["PublishAuto"]));
    }
    if (m.find("ValidateType") != m.end() && !m["ValidateType"].empty()) {
      validateType = make_shared<long>(boost::any_cast<long>(m["ValidateType"]));
    }
  }


  virtual ~CreateProductRequest() = default;
};
class CreateProductResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> dataFormat{};
  shared_ptr<string> description{};
  shared_ptr<long> nodeType{};
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};
  shared_ptr<string> aliyunCommodityCode{};
  shared_ptr<bool> id2{};
  shared_ptr<string> protocolType{};
  shared_ptr<string> authType{};
  shared_ptr<string> productSecret{};

  CreateProductResponseBodyData() {}

  explicit CreateProductResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataFormat) {
      res["DataFormat"] = boost::any(*dataFormat);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (aliyunCommodityCode) {
      res["AliyunCommodityCode"] = boost::any(*aliyunCommodityCode);
    }
    if (id2) {
      res["Id2"] = boost::any(*id2);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (productSecret) {
      res["ProductSecret"] = boost::any(*productSecret);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataFormat") != m.end() && !m["DataFormat"].empty()) {
      dataFormat = make_shared<long>(boost::any_cast<long>(m["DataFormat"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<long>(boost::any_cast<long>(m["NodeType"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("AliyunCommodityCode") != m.end() && !m["AliyunCommodityCode"].empty()) {
      aliyunCommodityCode = make_shared<string>(boost::any_cast<string>(m["AliyunCommodityCode"]));
    }
    if (m.find("Id2") != m.end() && !m["Id2"].empty()) {
      id2 = make_shared<bool>(boost::any_cast<bool>(m["Id2"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("ProductSecret") != m.end() && !m["ProductSecret"].empty()) {
      productSecret = make_shared<string>(boost::any_cast<string>(m["ProductSecret"]));
    }
  }


  virtual ~CreateProductResponseBodyData() = default;
};
class CreateProductResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> productKey{};
  shared_ptr<CreateProductResponseBodyData> data{};

  CreateProductResponseBody() {}

  explicit CreateProductResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateProductResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateProductResponseBodyData>(model1);
      }
    }
  }


  virtual ~CreateProductResponseBody() = default;
};
class CreateProductResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateProductResponseBody> body{};

  CreateProductResponse() {}

  explicit CreateProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProductResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProductResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProductResponse() = default;
};
class CreateProductDistributeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> targetInstanceId{};
  shared_ptr<string> targetUid{};
  shared_ptr<string> targetAliyunId{};

  CreateProductDistributeJobRequest() {}

  explicit CreateProductDistributeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    if (targetUid) {
      res["TargetUid"] = boost::any(*targetUid);
    }
    if (targetAliyunId) {
      res["TargetAliyunId"] = boost::any(*targetAliyunId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
    if (m.find("TargetUid") != m.end() && !m["TargetUid"].empty()) {
      targetUid = make_shared<string>(boost::any_cast<string>(m["TargetUid"]));
    }
    if (m.find("TargetAliyunId") != m.end() && !m["TargetAliyunId"].empty()) {
      targetAliyunId = make_shared<string>(boost::any_cast<string>(m["TargetAliyunId"]));
    }
  }


  virtual ~CreateProductDistributeJobRequest() = default;
};
class CreateProductDistributeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> jobId{};

  CreateProductDistributeJobResponseBody() {}

  explicit CreateProductDistributeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~CreateProductDistributeJobResponseBody() = default;
};
class CreateProductDistributeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateProductDistributeJobResponseBody> body{};

  CreateProductDistributeJobResponse() {}

  explicit CreateProductDistributeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProductDistributeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProductDistributeJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProductDistributeJobResponse() = default;
};
class CreateProductTagsRequestProductTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  CreateProductTagsRequestProductTag() {}

  explicit CreateProductTagsRequestProductTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~CreateProductTagsRequestProductTag() = default;
};
class CreateProductTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<vector<CreateProductTagsRequestProductTag>> productTag{};

  CreateProductTagsRequest() {}

  explicit CreateProductTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productTag) {
      vector<boost::any> temp1;
      for(auto item1:*productTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProductTag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductTag") != m.end() && !m["ProductTag"].empty()) {
      if (typeid(vector<boost::any>) == m["ProductTag"].type()) {
        vector<CreateProductTagsRequestProductTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProductTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateProductTagsRequestProductTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        productTag = make_shared<vector<CreateProductTagsRequestProductTag>>(expect1);
      }
    }
  }


  virtual ~CreateProductTagsRequest() = default;
};
class CreateProductTagsResponseBodyInvalidProductTagsProductTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  CreateProductTagsResponseBodyInvalidProductTagsProductTag() {}

  explicit CreateProductTagsResponseBodyInvalidProductTagsProductTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~CreateProductTagsResponseBodyInvalidProductTagsProductTag() = default;
};
class CreateProductTagsResponseBodyInvalidProductTags : public Darabonba::Model {
public:
  shared_ptr<vector<CreateProductTagsResponseBodyInvalidProductTagsProductTag>> productTag{};

  CreateProductTagsResponseBodyInvalidProductTags() {}

  explicit CreateProductTagsResponseBodyInvalidProductTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productTag) {
      vector<boost::any> temp1;
      for(auto item1:*productTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProductTag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductTag") != m.end() && !m["ProductTag"].empty()) {
      if (typeid(vector<boost::any>) == m["ProductTag"].type()) {
        vector<CreateProductTagsResponseBodyInvalidProductTagsProductTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProductTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateProductTagsResponseBodyInvalidProductTagsProductTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        productTag = make_shared<vector<CreateProductTagsResponseBodyInvalidProductTagsProductTag>>(expect1);
      }
    }
  }


  virtual ~CreateProductTagsResponseBodyInvalidProductTags() = default;
};
class CreateProductTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<CreateProductTagsResponseBodyInvalidProductTags> invalidProductTags{};

  CreateProductTagsResponseBody() {}

  explicit CreateProductTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (invalidProductTags) {
      res["InvalidProductTags"] = invalidProductTags ? boost::any(invalidProductTags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("InvalidProductTags") != m.end() && !m["InvalidProductTags"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvalidProductTags"].type()) {
        CreateProductTagsResponseBodyInvalidProductTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvalidProductTags"]));
        invalidProductTags = make_shared<CreateProductTagsResponseBodyInvalidProductTags>(model1);
      }
    }
  }


  virtual ~CreateProductTagsResponseBody() = default;
};
class CreateProductTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateProductTagsResponseBody> body{};

  CreateProductTagsResponse() {}

  explicit CreateProductTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProductTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProductTagsResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProductTagsResponse() = default;
};
class CreateProductTopicRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> topicShortName{};
  shared_ptr<string> operation{};
  shared_ptr<string> desc{};

  CreateProductTopicRequest() {}

  explicit CreateProductTopicRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (topicShortName) {
      res["TopicShortName"] = boost::any(*topicShortName);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("TopicShortName") != m.end() && !m["TopicShortName"].empty()) {
      topicShortName = make_shared<string>(boost::any_cast<string>(m["TopicShortName"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
  }


  virtual ~CreateProductTopicRequest() = default;
};
class CreateProductTopicResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> topicId{};

  CreateProductTopicResponseBody() {}

  explicit CreateProductTopicResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<long>(boost::any_cast<long>(m["TopicId"]));
    }
  }


  virtual ~CreateProductTopicResponseBody() = default;
};
class CreateProductTopicResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateProductTopicResponseBody> body{};

  CreateProductTopicResponse() {}

  explicit CreateProductTopicResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProductTopicResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProductTopicResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProductTopicResponse() = default;
};
class CreateRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> select{};
  shared_ptr<string> shortTopic{};
  shared_ptr<string> where{};
  shared_ptr<string> productKey{};
  shared_ptr<string> name{};
  shared_ptr<string> ruleDesc{};
  shared_ptr<string> dataType{};
  shared_ptr<long> topicType{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> topic{};

  CreateRuleRequest() {}

  explicit CreateRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (select) {
      res["Select"] = boost::any(*select);
    }
    if (shortTopic) {
      res["ShortTopic"] = boost::any(*shortTopic);
    }
    if (where) {
      res["Where"] = boost::any(*where);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ruleDesc) {
      res["RuleDesc"] = boost::any(*ruleDesc);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (topicType) {
      res["TopicType"] = boost::any(*topicType);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Select") != m.end() && !m["Select"].empty()) {
      select = make_shared<string>(boost::any_cast<string>(m["Select"]));
    }
    if (m.find("ShortTopic") != m.end() && !m["ShortTopic"].empty()) {
      shortTopic = make_shared<string>(boost::any_cast<string>(m["ShortTopic"]));
    }
    if (m.find("Where") != m.end() && !m["Where"].empty()) {
      where = make_shared<string>(boost::any_cast<string>(m["Where"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RuleDesc") != m.end() && !m["RuleDesc"].empty()) {
      ruleDesc = make_shared<string>(boost::any_cast<string>(m["RuleDesc"]));
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("TopicType") != m.end() && !m["TopicType"].empty()) {
      topicType = make_shared<long>(boost::any_cast<long>(m["TopicType"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~CreateRuleRequest() = default;
};
class CreateRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> ruleId{};

  CreateRuleResponseBody() {}

  explicit CreateRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~CreateRuleResponseBody() = default;
};
class CreateRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateRuleResponseBody> body{};

  CreateRuleResponse() {}

  explicit CreateRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRuleResponse() = default;
};
class CreateRuleActionRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> type{};
  shared_ptr<string> configuration{};
  shared_ptr<bool> errorActionFlag{};

  CreateRuleActionRequest() {}

  explicit CreateRuleActionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (configuration) {
      res["Configuration"] = boost::any(*configuration);
    }
    if (errorActionFlag) {
      res["ErrorActionFlag"] = boost::any(*errorActionFlag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configuration = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
    if (m.find("ErrorActionFlag") != m.end() && !m["ErrorActionFlag"].empty()) {
      errorActionFlag = make_shared<bool>(boost::any_cast<bool>(m["ErrorActionFlag"]));
    }
  }


  virtual ~CreateRuleActionRequest() = default;
};
class CreateRuleActionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> actionId{};

  CreateRuleActionResponseBody() {}

  explicit CreateRuleActionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (actionId) {
      res["ActionId"] = boost::any(*actionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ActionId") != m.end() && !m["ActionId"].empty()) {
      actionId = make_shared<long>(boost::any_cast<long>(m["ActionId"]));
    }
  }


  virtual ~CreateRuleActionResponseBody() = default;
};
class CreateRuleActionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateRuleActionResponseBody> body{};

  CreateRuleActionResponse() {}

  explicit CreateRuleActionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRuleActionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRuleActionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRuleActionResponse() = default;
};
class CreateRulengDistributeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> targetInstanceId{};

  CreateRulengDistributeJobRequest() {}

  explicit CreateRulengDistributeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
  }


  virtual ~CreateRulengDistributeJobRequest() = default;
};
class CreateRulengDistributeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  CreateRulengDistributeJobResponseBody() {}

  explicit CreateRulengDistributeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CreateRulengDistributeJobResponseBody() = default;
};
class CreateRulengDistributeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateRulengDistributeJobResponseBody> body{};

  CreateRulengDistributeJobResponse() {}

  explicit CreateRulengDistributeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRulengDistributeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRulengDistributeJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRulengDistributeJobResponse() = default;
};
class CreateSceneRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleContent{};
  shared_ptr<string> ruleDescription{};

  CreateSceneRuleRequest() {}

  explicit CreateSceneRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleContent) {
      res["RuleContent"] = boost::any(*ruleContent);
    }
    if (ruleDescription) {
      res["RuleDescription"] = boost::any(*ruleDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleContent") != m.end() && !m["RuleContent"].empty()) {
      ruleContent = make_shared<string>(boost::any_cast<string>(m["RuleContent"]));
    }
    if (m.find("RuleDescription") != m.end() && !m["RuleDescription"].empty()) {
      ruleDescription = make_shared<string>(boost::any_cast<string>(m["RuleDescription"]));
    }
  }


  virtual ~CreateSceneRuleRequest() = default;
};
class CreateSceneRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> ruleId{};

  CreateSceneRuleResponseBody() {}

  explicit CreateSceneRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~CreateSceneRuleResponseBody() = default;
};
class CreateSceneRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateSceneRuleResponseBody> body{};

  CreateSceneRuleResponse() {}

  explicit CreateSceneRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSceneRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSceneRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSceneRuleResponse() = default;
};
class CreateSubscribeRelationRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<bool> deviceDataFlag{};
  shared_ptr<bool> deviceLifeCycleFlag{};
  shared_ptr<bool> deviceStatusChangeFlag{};
  shared_ptr<bool> deviceTopoLifeCycleFlag{};
  shared_ptr<bool> foundDeviceListFlag{};
  shared_ptr<string> mnsConfiguration{};
  shared_ptr<string> type{};
  shared_ptr<vector<string>> consumerGroupIds{};
  shared_ptr<bool> otaEventFlag{};
  shared_ptr<bool> thingHistoryFlag{};
  shared_ptr<bool> deviceTagFlag{};
  shared_ptr<bool> otaVersionFlag{};
  shared_ptr<bool> otaJobFlag{};

  CreateSubscribeRelationRequest() {}

  explicit CreateSubscribeRelationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceDataFlag) {
      res["DeviceDataFlag"] = boost::any(*deviceDataFlag);
    }
    if (deviceLifeCycleFlag) {
      res["DeviceLifeCycleFlag"] = boost::any(*deviceLifeCycleFlag);
    }
    if (deviceStatusChangeFlag) {
      res["DeviceStatusChangeFlag"] = boost::any(*deviceStatusChangeFlag);
    }
    if (deviceTopoLifeCycleFlag) {
      res["DeviceTopoLifeCycleFlag"] = boost::any(*deviceTopoLifeCycleFlag);
    }
    if (foundDeviceListFlag) {
      res["FoundDeviceListFlag"] = boost::any(*foundDeviceListFlag);
    }
    if (mnsConfiguration) {
      res["MnsConfiguration"] = boost::any(*mnsConfiguration);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (consumerGroupIds) {
      res["ConsumerGroupIds"] = boost::any(*consumerGroupIds);
    }
    if (otaEventFlag) {
      res["OtaEventFlag"] = boost::any(*otaEventFlag);
    }
    if (thingHistoryFlag) {
      res["ThingHistoryFlag"] = boost::any(*thingHistoryFlag);
    }
    if (deviceTagFlag) {
      res["DeviceTagFlag"] = boost::any(*deviceTagFlag);
    }
    if (otaVersionFlag) {
      res["OtaVersionFlag"] = boost::any(*otaVersionFlag);
    }
    if (otaJobFlag) {
      res["OtaJobFlag"] = boost::any(*otaJobFlag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceDataFlag") != m.end() && !m["DeviceDataFlag"].empty()) {
      deviceDataFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceDataFlag"]));
    }
    if (m.find("DeviceLifeCycleFlag") != m.end() && !m["DeviceLifeCycleFlag"].empty()) {
      deviceLifeCycleFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceLifeCycleFlag"]));
    }
    if (m.find("DeviceStatusChangeFlag") != m.end() && !m["DeviceStatusChangeFlag"].empty()) {
      deviceStatusChangeFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceStatusChangeFlag"]));
    }
    if (m.find("DeviceTopoLifeCycleFlag") != m.end() && !m["DeviceTopoLifeCycleFlag"].empty()) {
      deviceTopoLifeCycleFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceTopoLifeCycleFlag"]));
    }
    if (m.find("FoundDeviceListFlag") != m.end() && !m["FoundDeviceListFlag"].empty()) {
      foundDeviceListFlag = make_shared<bool>(boost::any_cast<bool>(m["FoundDeviceListFlag"]));
    }
    if (m.find("MnsConfiguration") != m.end() && !m["MnsConfiguration"].empty()) {
      mnsConfiguration = make_shared<string>(boost::any_cast<string>(m["MnsConfiguration"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ConsumerGroupIds") != m.end() && !m["ConsumerGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ConsumerGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ConsumerGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      consumerGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OtaEventFlag") != m.end() && !m["OtaEventFlag"].empty()) {
      otaEventFlag = make_shared<bool>(boost::any_cast<bool>(m["OtaEventFlag"]));
    }
    if (m.find("ThingHistoryFlag") != m.end() && !m["ThingHistoryFlag"].empty()) {
      thingHistoryFlag = make_shared<bool>(boost::any_cast<bool>(m["ThingHistoryFlag"]));
    }
    if (m.find("DeviceTagFlag") != m.end() && !m["DeviceTagFlag"].empty()) {
      deviceTagFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceTagFlag"]));
    }
    if (m.find("OtaVersionFlag") != m.end() && !m["OtaVersionFlag"].empty()) {
      otaVersionFlag = make_shared<bool>(boost::any_cast<bool>(m["OtaVersionFlag"]));
    }
    if (m.find("OtaJobFlag") != m.end() && !m["OtaJobFlag"].empty()) {
      otaJobFlag = make_shared<bool>(boost::any_cast<bool>(m["OtaJobFlag"]));
    }
  }


  virtual ~CreateSubscribeRelationRequest() = default;
};
class CreateSubscribeRelationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  CreateSubscribeRelationResponseBody() {}

  explicit CreateSubscribeRelationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CreateSubscribeRelationResponseBody() = default;
};
class CreateSubscribeRelationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateSubscribeRelationResponseBody> body{};

  CreateSubscribeRelationResponse() {}

  explicit CreateSubscribeRelationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSubscribeRelationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSubscribeRelationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSubscribeRelationResponse() = default;
};
class CreateThingModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> thingModelJson{};
  shared_ptr<string> functionBlockId{};
  shared_ptr<string> functionBlockName{};

  CreateThingModelRequest() {}

  explicit CreateThingModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (thingModelJson) {
      res["ThingModelJson"] = boost::any(*thingModelJson);
    }
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    if (functionBlockName) {
      res["FunctionBlockName"] = boost::any(*functionBlockName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ThingModelJson") != m.end() && !m["ThingModelJson"].empty()) {
      thingModelJson = make_shared<string>(boost::any_cast<string>(m["ThingModelJson"]));
    }
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
    if (m.find("FunctionBlockName") != m.end() && !m["FunctionBlockName"].empty()) {
      functionBlockName = make_shared<string>(boost::any_cast<string>(m["FunctionBlockName"]));
    }
  }


  virtual ~CreateThingModelRequest() = default;
};
class CreateThingModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  CreateThingModelResponseBody() {}

  explicit CreateThingModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CreateThingModelResponseBody() = default;
};
class CreateThingModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateThingModelResponseBody> body{};

  CreateThingModelResponse() {}

  explicit CreateThingModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateThingModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateThingModelResponseBody>(model1);
      }
    }
  }


  virtual ~CreateThingModelResponse() = default;
};
class CreateThingScriptRequest : public Darabonba::Model {
public:
  shared_ptr<string> scriptContent{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> scriptType{};

  CreateThingScriptRequest() {}

  explicit CreateThingScriptRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scriptContent) {
      res["ScriptContent"] = boost::any(*scriptContent);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (scriptType) {
      res["ScriptType"] = boost::any(*scriptType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScriptContent") != m.end() && !m["ScriptContent"].empty()) {
      scriptContent = make_shared<string>(boost::any_cast<string>(m["ScriptContent"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ScriptType") != m.end() && !m["ScriptType"].empty()) {
      scriptType = make_shared<string>(boost::any_cast<string>(m["ScriptType"]));
    }
  }


  virtual ~CreateThingScriptRequest() = default;
};
class CreateThingScriptResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  CreateThingScriptResponseBody() {}

  explicit CreateThingScriptResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CreateThingScriptResponseBody() = default;
};
class CreateThingScriptResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateThingScriptResponseBody> body{};

  CreateThingScriptResponse() {}

  explicit CreateThingScriptResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateThingScriptResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateThingScriptResponseBody>(model1);
      }
    }
  }


  virtual ~CreateThingScriptResponse() = default;
};
class CreateTopicRouteTableRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<string>> dstTopic{};
  shared_ptr<string> srcTopic{};

  CreateTopicRouteTableRequest() {}

  explicit CreateTopicRouteTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (dstTopic) {
      res["DstTopic"] = boost::any(*dstTopic);
    }
    if (srcTopic) {
      res["SrcTopic"] = boost::any(*srcTopic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("DstTopic") != m.end() && !m["DstTopic"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DstTopic"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DstTopic"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dstTopic = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SrcTopic") != m.end() && !m["SrcTopic"].empty()) {
      srcTopic = make_shared<string>(boost::any_cast<string>(m["SrcTopic"]));
    }
  }


  virtual ~CreateTopicRouteTableRequest() = default;
};
class CreateTopicRouteTableResponseBodyFailureTopics : public Darabonba::Model {
public:
  shared_ptr<vector<map<string, string>>> topic{};

  CreateTopicRouteTableResponseBodyFailureTopics() {}

  explicit CreateTopicRouteTableResponseBodyFailureTopics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      vector<map<string, string>> toVec1;
      if (typeid(vector<boost::any>) == m["Topic"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Topic"]);
        for (auto item:vec1) {
          map<string, string> map2 = boost::any_cast<map<string, string>>(item);
          map<string, string> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      topic = make_shared<vector<map<string, string>>>(toVec1);
    }
  }


  virtual ~CreateTopicRouteTableResponseBodyFailureTopics() = default;
};
class CreateTopicRouteTableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<bool> isAllSucceed{};
  shared_ptr<string> errorMessage{};
  shared_ptr<CreateTopicRouteTableResponseBodyFailureTopics> failureTopics{};

  CreateTopicRouteTableResponseBody() {}

  explicit CreateTopicRouteTableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (isAllSucceed) {
      res["IsAllSucceed"] = boost::any(*isAllSucceed);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (failureTopics) {
      res["FailureTopics"] = failureTopics ? boost::any(failureTopics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("IsAllSucceed") != m.end() && !m["IsAllSucceed"].empty()) {
      isAllSucceed = make_shared<bool>(boost::any_cast<bool>(m["IsAllSucceed"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("FailureTopics") != m.end() && !m["FailureTopics"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailureTopics"].type()) {
        CreateTopicRouteTableResponseBodyFailureTopics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailureTopics"]));
        failureTopics = make_shared<CreateTopicRouteTableResponseBodyFailureTopics>(model1);
      }
    }
  }


  virtual ~CreateTopicRouteTableResponseBody() = default;
};
class CreateTopicRouteTableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateTopicRouteTableResponseBody> body{};

  CreateTopicRouteTableResponse() {}

  explicit CreateTopicRouteTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTopicRouteTableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTopicRouteTableResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTopicRouteTableResponse() = default;
};
class DeleteConsumerGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> groupId{};

  DeleteConsumerGroupRequest() {}

  explicit DeleteConsumerGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~DeleteConsumerGroupRequest() = default;
};
class DeleteConsumerGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};

  DeleteConsumerGroupResponseBody() {}

  explicit DeleteConsumerGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~DeleteConsumerGroupResponseBody() = default;
};
class DeleteConsumerGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteConsumerGroupResponseBody> body{};

  DeleteConsumerGroupResponse() {}

  explicit DeleteConsumerGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteConsumerGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteConsumerGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteConsumerGroupResponse() = default;
};
class DeleteConsumerGroupSubscribeRelationRequest : public Darabonba::Model {
public:
  shared_ptr<string> consumerGroupId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  DeleteConsumerGroupSubscribeRelationRequest() {}

  explicit DeleteConsumerGroupSubscribeRelationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consumerGroupId) {
      res["ConsumerGroupId"] = boost::any(*consumerGroupId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsumerGroupId") != m.end() && !m["ConsumerGroupId"].empty()) {
      consumerGroupId = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~DeleteConsumerGroupSubscribeRelationRequest() = default;
};
class DeleteConsumerGroupSubscribeRelationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteConsumerGroupSubscribeRelationResponseBody() {}

  explicit DeleteConsumerGroupSubscribeRelationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteConsumerGroupSubscribeRelationResponseBody() = default;
};
class DeleteConsumerGroupSubscribeRelationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteConsumerGroupSubscribeRelationResponseBody> body{};

  DeleteConsumerGroupSubscribeRelationResponse() {}

  explicit DeleteConsumerGroupSubscribeRelationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteConsumerGroupSubscribeRelationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteConsumerGroupSubscribeRelationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteConsumerGroupSubscribeRelationResponse() = default;
};
class DeleteDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};

  DeleteDeviceRequest() {}

  explicit DeleteDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~DeleteDeviceRequest() = default;
};
class DeleteDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteDeviceResponseBody() {}

  explicit DeleteDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteDeviceResponseBody() = default;
};
class DeleteDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDeviceResponseBody> body{};

  DeleteDeviceResponse() {}

  explicit DeleteDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDeviceResponse() = default;
};
class DeleteDeviceDistributeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  DeleteDeviceDistributeJobRequest() {}

  explicit DeleteDeviceDistributeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~DeleteDeviceDistributeJobRequest() = default;
};
class DeleteDeviceDistributeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteDeviceDistributeJobResponseBody() {}

  explicit DeleteDeviceDistributeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteDeviceDistributeJobResponseBody() = default;
};
class DeleteDeviceDistributeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDeviceDistributeJobResponseBody> body{};

  DeleteDeviceDistributeJobResponse() {}

  explicit DeleteDeviceDistributeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDeviceDistributeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDeviceDistributeJobResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDeviceDistributeJobResponse() = default;
};
class DeleteDeviceFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> fileId{};

  DeleteDeviceFileRequest() {}

  explicit DeleteDeviceFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
  }


  virtual ~DeleteDeviceFileRequest() = default;
};
class DeleteDeviceFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteDeviceFileResponseBody() {}

  explicit DeleteDeviceFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteDeviceFileResponseBody() = default;
};
class DeleteDeviceFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDeviceFileResponseBody> body{};

  DeleteDeviceFileResponse() {}

  explicit DeleteDeviceFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDeviceFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDeviceFileResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDeviceFileResponse() = default;
};
class DeleteDeviceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> groupId{};

  DeleteDeviceGroupRequest() {}

  explicit DeleteDeviceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~DeleteDeviceGroupRequest() = default;
};
class DeleteDeviceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteDeviceGroupResponseBody() {}

  explicit DeleteDeviceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteDeviceGroupResponseBody() = default;
};
class DeleteDeviceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDeviceGroupResponseBody> body{};

  DeleteDeviceGroupResponse() {}

  explicit DeleteDeviceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDeviceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDeviceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDeviceGroupResponse() = default;
};
class DeleteDevicePropRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> propKey{};
  shared_ptr<string> iotId{};

  DeleteDevicePropRequest() {}

  explicit DeleteDevicePropRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (propKey) {
      res["PropKey"] = boost::any(*propKey);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("PropKey") != m.end() && !m["PropKey"].empty()) {
      propKey = make_shared<string>(boost::any_cast<string>(m["PropKey"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~DeleteDevicePropRequest() = default;
};
class DeleteDevicePropResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteDevicePropResponseBody() {}

  explicit DeleteDevicePropResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteDevicePropResponseBody() = default;
};
class DeleteDevicePropResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDevicePropResponseBody> body{};

  DeleteDevicePropResponse() {}

  explicit DeleteDevicePropResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDevicePropResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDevicePropResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDevicePropResponse() = default;
};
class DeleteEdgeDriverRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> driverId{};

  DeleteEdgeDriverRequest() {}

  explicit DeleteEdgeDriverRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
  }


  virtual ~DeleteEdgeDriverRequest() = default;
};
class DeleteEdgeDriverResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteEdgeDriverResponseBody() {}

  explicit DeleteEdgeDriverResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteEdgeDriverResponseBody() = default;
};
class DeleteEdgeDriverResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteEdgeDriverResponseBody> body{};

  DeleteEdgeDriverResponse() {}

  explicit DeleteEdgeDriverResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEdgeDriverResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEdgeDriverResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEdgeDriverResponse() = default;
};
class DeleteEdgeDriverVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};

  DeleteEdgeDriverVersionRequest() {}

  explicit DeleteEdgeDriverVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
  }


  virtual ~DeleteEdgeDriverVersionRequest() = default;
};
class DeleteEdgeDriverVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteEdgeDriverVersionResponseBody() {}

  explicit DeleteEdgeDriverVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteEdgeDriverVersionResponseBody() = default;
};
class DeleteEdgeDriverVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteEdgeDriverVersionResponseBody> body{};

  DeleteEdgeDriverVersionResponse() {}

  explicit DeleteEdgeDriverVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEdgeDriverVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEdgeDriverVersionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEdgeDriverVersionResponse() = default;
};
class DeleteEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};

  DeleteEdgeInstanceRequest() {}

  explicit DeleteEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteEdgeInstanceRequest() = default;
};
class DeleteEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteEdgeInstanceResponseBody() {}

  explicit DeleteEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteEdgeInstanceResponseBody() = default;
};
class DeleteEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteEdgeInstanceResponseBody> body{};

  DeleteEdgeInstanceResponse() {}

  explicit DeleteEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEdgeInstanceResponse() = default;
};
class DeleteEdgeInstanceMessageRoutingRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> routeId{};

  DeleteEdgeInstanceMessageRoutingRequest() {}

  explicit DeleteEdgeInstanceMessageRoutingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<long>(boost::any_cast<long>(m["RouteId"]));
    }
  }


  virtual ~DeleteEdgeInstanceMessageRoutingRequest() = default;
};
class DeleteEdgeInstanceMessageRoutingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteEdgeInstanceMessageRoutingResponseBody() {}

  explicit DeleteEdgeInstanceMessageRoutingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteEdgeInstanceMessageRoutingResponseBody() = default;
};
class DeleteEdgeInstanceMessageRoutingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteEdgeInstanceMessageRoutingResponseBody> body{};

  DeleteEdgeInstanceMessageRoutingResponse() {}

  explicit DeleteEdgeInstanceMessageRoutingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEdgeInstanceMessageRoutingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEdgeInstanceMessageRoutingResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEdgeInstanceMessageRoutingResponse() = default;
};
class DeleteJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobId{};

  DeleteJobRequest() {}

  explicit DeleteJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~DeleteJobRequest() = default;
};
class DeleteJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteJobResponseBody() {}

  explicit DeleteJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteJobResponseBody() = default;
};
class DeleteJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteJobResponseBody> body{};

  DeleteJobResponse() {}

  explicit DeleteJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteJobResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteJobResponse() = default;
};
class DeleteOTAFirmwareRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> firmwareId{};

  DeleteOTAFirmwareRequest() {}

  explicit DeleteOTAFirmwareRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
  }


  virtual ~DeleteOTAFirmwareRequest() = default;
};
class DeleteOTAFirmwareResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteOTAFirmwareResponseBody() {}

  explicit DeleteOTAFirmwareResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteOTAFirmwareResponseBody() = default;
};
class DeleteOTAFirmwareResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteOTAFirmwareResponseBody> body{};

  DeleteOTAFirmwareResponse() {}

  explicit DeleteOTAFirmwareResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteOTAFirmwareResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteOTAFirmwareResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteOTAFirmwareResponse() = default;
};
class DeleteOTAModuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> moduleName{};

  DeleteOTAModuleRequest() {}

  explicit DeleteOTAModuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
  }


  virtual ~DeleteOTAModuleRequest() = default;
};
class DeleteOTAModuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteOTAModuleResponseBody() {}

  explicit DeleteOTAModuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteOTAModuleResponseBody() = default;
};
class DeleteOTAModuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteOTAModuleResponseBody> body{};

  DeleteOTAModuleResponse() {}

  explicit DeleteOTAModuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteOTAModuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteOTAModuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteOTAModuleResponse() = default;
};
class DeleteProductRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  DeleteProductRequest() {}

  explicit DeleteProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~DeleteProductRequest() = default;
};
class DeleteProductResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteProductResponseBody() {}

  explicit DeleteProductResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteProductResponseBody() = default;
};
class DeleteProductResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteProductResponseBody> body{};

  DeleteProductResponse() {}

  explicit DeleteProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteProductResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteProductResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteProductResponse() = default;
};
class DeleteProductTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<string>> productTagKey{};
  shared_ptr<string> productKey{};

  DeleteProductTagsRequest() {}

  explicit DeleteProductTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productTagKey) {
      res["ProductTagKey"] = boost::any(*productTagKey);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductTagKey") != m.end() && !m["ProductTagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProductTagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProductTagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      productTagKey = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~DeleteProductTagsRequest() = default;
};
class DeleteProductTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};

  DeleteProductTagsResponseBody() {}

  explicit DeleteProductTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~DeleteProductTagsResponseBody() = default;
};
class DeleteProductTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteProductTagsResponseBody> body{};

  DeleteProductTagsResponse() {}

  explicit DeleteProductTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteProductTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteProductTagsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteProductTagsResponse() = default;
};
class DeleteProductTopicRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> topicId{};

  DeleteProductTopicRequest() {}

  explicit DeleteProductTopicRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<string>(boost::any_cast<string>(m["TopicId"]));
    }
  }


  virtual ~DeleteProductTopicRequest() = default;
};
class DeleteProductTopicResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteProductTopicResponseBody() {}

  explicit DeleteProductTopicResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteProductTopicResponseBody() = default;
};
class DeleteProductTopicResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteProductTopicResponseBody> body{};

  DeleteProductTopicResponse() {}

  explicit DeleteProductTopicResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteProductTopicResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteProductTopicResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteProductTopicResponse() = default;
};
class DeleteRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> ruleId{};

  DeleteRuleRequest() {}

  explicit DeleteRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~DeleteRuleRequest() = default;
};
class DeleteRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteRuleResponseBody() {}

  explicit DeleteRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteRuleResponseBody() = default;
};
class DeleteRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteRuleResponseBody> body{};

  DeleteRuleResponse() {}

  explicit DeleteRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRuleResponse() = default;
};
class DeleteRuleActionRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> actionId{};

  DeleteRuleActionRequest() {}

  explicit DeleteRuleActionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (actionId) {
      res["ActionId"] = boost::any(*actionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ActionId") != m.end() && !m["ActionId"].empty()) {
      actionId = make_shared<long>(boost::any_cast<long>(m["ActionId"]));
    }
  }


  virtual ~DeleteRuleActionRequest() = default;
};
class DeleteRuleActionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteRuleActionResponseBody() {}

  explicit DeleteRuleActionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteRuleActionResponseBody() = default;
};
class DeleteRuleActionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteRuleActionResponseBody> body{};

  DeleteRuleActionResponse() {}

  explicit DeleteRuleActionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRuleActionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRuleActionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRuleActionResponse() = default;
};
class DeleteSceneRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> ruleId{};

  DeleteSceneRuleRequest() {}

  explicit DeleteSceneRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~DeleteSceneRuleRequest() = default;
};
class DeleteSceneRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};

  DeleteSceneRuleResponseBody() {}

  explicit DeleteSceneRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~DeleteSceneRuleResponseBody() = default;
};
class DeleteSceneRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteSceneRuleResponseBody> body{};

  DeleteSceneRuleResponse() {}

  explicit DeleteSceneRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSceneRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSceneRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSceneRuleResponse() = default;
};
class DeleteSubscribeRelationRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> type{};

  DeleteSubscribeRelationRequest() {}

  explicit DeleteSubscribeRelationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DeleteSubscribeRelationRequest() = default;
};
class DeleteSubscribeRelationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteSubscribeRelationResponseBody() {}

  explicit DeleteSubscribeRelationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteSubscribeRelationResponseBody() = default;
};
class DeleteSubscribeRelationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteSubscribeRelationResponseBody> body{};

  DeleteSubscribeRelationResponse() {}

  explicit DeleteSubscribeRelationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSubscribeRelationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSubscribeRelationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSubscribeRelationResponse() = default;
};
class DeleteThingModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> productKey{};
  shared_ptr<vector<string>> propertyIdentifier{};
  shared_ptr<vector<string>> serviceIdentifier{};
  shared_ptr<vector<string>> eventIdentifier{};
  shared_ptr<string> functionBlockId{};

  DeleteThingModelRequest() {}

  explicit DeleteThingModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (propertyIdentifier) {
      res["PropertyIdentifier"] = boost::any(*propertyIdentifier);
    }
    if (serviceIdentifier) {
      res["ServiceIdentifier"] = boost::any(*serviceIdentifier);
    }
    if (eventIdentifier) {
      res["EventIdentifier"] = boost::any(*eventIdentifier);
    }
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("PropertyIdentifier") != m.end() && !m["PropertyIdentifier"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PropertyIdentifier"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PropertyIdentifier"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      propertyIdentifier = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ServiceIdentifier") != m.end() && !m["ServiceIdentifier"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ServiceIdentifier"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ServiceIdentifier"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      serviceIdentifier = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EventIdentifier") != m.end() && !m["EventIdentifier"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EventIdentifier"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EventIdentifier"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      eventIdentifier = make_shared<vector<string>>(toVec1);
    }
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
  }


  virtual ~DeleteThingModelRequest() = default;
};
class DeleteThingModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteThingModelResponseBody() {}

  explicit DeleteThingModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteThingModelResponseBody() = default;
};
class DeleteThingModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteThingModelResponseBody> body{};

  DeleteThingModelResponse() {}

  explicit DeleteThingModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteThingModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteThingModelResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteThingModelResponse() = default;
};
class DeleteTopicRouteTableRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<string>> dstTopic{};
  shared_ptr<string> srcTopic{};

  DeleteTopicRouteTableRequest() {}

  explicit DeleteTopicRouteTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (dstTopic) {
      res["DstTopic"] = boost::any(*dstTopic);
    }
    if (srcTopic) {
      res["SrcTopic"] = boost::any(*srcTopic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("DstTopic") != m.end() && !m["DstTopic"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DstTopic"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DstTopic"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dstTopic = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SrcTopic") != m.end() && !m["SrcTopic"].empty()) {
      srcTopic = make_shared<string>(boost::any_cast<string>(m["SrcTopic"]));
    }
  }


  virtual ~DeleteTopicRouteTableRequest() = default;
};
class DeleteTopicRouteTableResponseBodyFailureTopics : public Darabonba::Model {
public:
  shared_ptr<vector<map<string, string>>> topic{};

  DeleteTopicRouteTableResponseBodyFailureTopics() {}

  explicit DeleteTopicRouteTableResponseBodyFailureTopics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      vector<map<string, string>> toVec1;
      if (typeid(vector<boost::any>) == m["Topic"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Topic"]);
        for (auto item:vec1) {
          map<string, string> map2 = boost::any_cast<map<string, string>>(item);
          map<string, string> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      topic = make_shared<vector<map<string, string>>>(toVec1);
    }
  }


  virtual ~DeleteTopicRouteTableResponseBodyFailureTopics() = default;
};
class DeleteTopicRouteTableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<bool> isAllSucceed{};
  shared_ptr<string> errorMessage{};
  shared_ptr<DeleteTopicRouteTableResponseBodyFailureTopics> failureTopics{};

  DeleteTopicRouteTableResponseBody() {}

  explicit DeleteTopicRouteTableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (isAllSucceed) {
      res["IsAllSucceed"] = boost::any(*isAllSucceed);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (failureTopics) {
      res["FailureTopics"] = failureTopics ? boost::any(failureTopics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("IsAllSucceed") != m.end() && !m["IsAllSucceed"].empty()) {
      isAllSucceed = make_shared<bool>(boost::any_cast<bool>(m["IsAllSucceed"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("FailureTopics") != m.end() && !m["FailureTopics"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailureTopics"].type()) {
        DeleteTopicRouteTableResponseBodyFailureTopics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailureTopics"]));
        failureTopics = make_shared<DeleteTopicRouteTableResponseBodyFailureTopics>(model1);
      }
    }
  }


  virtual ~DeleteTopicRouteTableResponseBody() = default;
};
class DeleteTopicRouteTableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteTopicRouteTableResponseBody> body{};

  DeleteTopicRouteTableResponse() {}

  explicit DeleteTopicRouteTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTopicRouteTableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTopicRouteTableResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTopicRouteTableResponse() = default;
};
class DisableDeviceTunnelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};

  DisableDeviceTunnelRequest() {}

  explicit DisableDeviceTunnelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
  }


  virtual ~DisableDeviceTunnelRequest() = default;
};
class DisableDeviceTunnelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DisableDeviceTunnelResponseBody() {}

  explicit DisableDeviceTunnelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DisableDeviceTunnelResponseBody() = default;
};
class DisableDeviceTunnelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DisableDeviceTunnelResponseBody> body{};

  DisableDeviceTunnelResponse() {}

  explicit DisableDeviceTunnelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableDeviceTunnelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableDeviceTunnelResponseBody>(model1);
      }
    }
  }


  virtual ~DisableDeviceTunnelResponse() = default;
};
class DisableDeviceTunnelShareRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};

  DisableDeviceTunnelShareRequest() {}

  explicit DisableDeviceTunnelShareRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
  }


  virtual ~DisableDeviceTunnelShareRequest() = default;
};
class DisableDeviceTunnelShareResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};

  DisableDeviceTunnelShareResponseBody() {}

  explicit DisableDeviceTunnelShareResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~DisableDeviceTunnelShareResponseBody() = default;
};
class DisableDeviceTunnelShareResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DisableDeviceTunnelShareResponseBody> body{};

  DisableDeviceTunnelShareResponse() {}

  explicit DisableDeviceTunnelShareResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableDeviceTunnelShareResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableDeviceTunnelShareResponseBody>(model1);
      }
    }
  }


  virtual ~DisableDeviceTunnelShareResponse() = default;
};
class DisableSceneRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> ruleId{};

  DisableSceneRuleRequest() {}

  explicit DisableSceneRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~DisableSceneRuleRequest() = default;
};
class DisableSceneRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};

  DisableSceneRuleResponseBody() {}

  explicit DisableSceneRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~DisableSceneRuleResponseBody() = default;
};
class DisableSceneRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DisableSceneRuleResponseBody> body{};

  DisableSceneRuleResponse() {}

  explicit DisableSceneRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableSceneRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableSceneRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DisableSceneRuleResponse() = default;
};
class DisableThingRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};

  DisableThingRequest() {}

  explicit DisableThingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~DisableThingRequest() = default;
};
class DisableThingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DisableThingResponseBody() {}

  explicit DisableThingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DisableThingResponseBody() = default;
};
class DisableThingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DisableThingResponseBody> body{};

  DisableThingResponse() {}

  explicit DisableThingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableThingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableThingResponseBody>(model1);
      }
    }
  }


  virtual ~DisableThingResponse() = default;
};
class EnableDeviceTunnelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};

  EnableDeviceTunnelRequest() {}

  explicit EnableDeviceTunnelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
  }


  virtual ~EnableDeviceTunnelRequest() = default;
};
class EnableDeviceTunnelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  EnableDeviceTunnelResponseBody() {}

  explicit EnableDeviceTunnelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~EnableDeviceTunnelResponseBody() = default;
};
class EnableDeviceTunnelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<EnableDeviceTunnelResponseBody> body{};

  EnableDeviceTunnelResponse() {}

  explicit EnableDeviceTunnelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableDeviceTunnelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableDeviceTunnelResponseBody>(model1);
      }
    }
  }


  virtual ~EnableDeviceTunnelResponse() = default;
};
class EnableDeviceTunnelShareRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};

  EnableDeviceTunnelShareRequest() {}

  explicit EnableDeviceTunnelShareRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
  }


  virtual ~EnableDeviceTunnelShareRequest() = default;
};
class EnableDeviceTunnelShareResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};

  EnableDeviceTunnelShareResponseBody() {}

  explicit EnableDeviceTunnelShareResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~EnableDeviceTunnelShareResponseBody() = default;
};
class EnableDeviceTunnelShareResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<EnableDeviceTunnelShareResponseBody> body{};

  EnableDeviceTunnelShareResponse() {}

  explicit EnableDeviceTunnelShareResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableDeviceTunnelShareResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableDeviceTunnelShareResponseBody>(model1);
      }
    }
  }


  virtual ~EnableDeviceTunnelShareResponse() = default;
};
class EnableSceneRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> ruleId{};

  EnableSceneRuleRequest() {}

  explicit EnableSceneRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~EnableSceneRuleRequest() = default;
};
class EnableSceneRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};

  EnableSceneRuleResponseBody() {}

  explicit EnableSceneRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~EnableSceneRuleResponseBody() = default;
};
class EnableSceneRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<EnableSceneRuleResponseBody> body{};

  EnableSceneRuleResponse() {}

  explicit EnableSceneRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableSceneRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableSceneRuleResponseBody>(model1);
      }
    }
  }


  virtual ~EnableSceneRuleResponse() = default;
};
class EnableThingRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};

  EnableThingRequest() {}

  explicit EnableThingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~EnableThingRequest() = default;
};
class EnableThingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  EnableThingResponseBody() {}

  explicit EnableThingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~EnableThingResponseBody() = default;
};
class EnableThingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<EnableThingResponseBody> body{};

  EnableThingResponse() {}

  explicit EnableThingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableThingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableThingResponseBody>(model1);
      }
    }
  }


  virtual ~EnableThingResponse() = default;
};
class GenerateDeviceNameListURLRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};

  GenerateDeviceNameListURLRequest() {}

  explicit GenerateDeviceNameListURLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~GenerateDeviceNameListURLRequest() = default;
};
class GenerateDeviceNameListURLResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> host{};
  shared_ptr<string> policy{};
  shared_ptr<string> accessKeyId{};
  shared_ptr<string> signature{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> objectStorage{};

  GenerateDeviceNameListURLResponseBodyData() {}

  explicit GenerateDeviceNameListURLResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (accessKeyId) {
      res["AccessKeyId"] = boost::any(*accessKeyId);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (objectStorage) {
      res["ObjectStorage"] = boost::any(*objectStorage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("AccessKeyId") != m.end() && !m["AccessKeyId"].empty()) {
      accessKeyId = make_shared<string>(boost::any_cast<string>(m["AccessKeyId"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("ObjectStorage") != m.end() && !m["ObjectStorage"].empty()) {
      objectStorage = make_shared<string>(boost::any_cast<string>(m["ObjectStorage"]));
    }
  }


  virtual ~GenerateDeviceNameListURLResponseBodyData() = default;
};
class GenerateDeviceNameListURLResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GenerateDeviceNameListURLResponseBodyData> data{};

  GenerateDeviceNameListURLResponseBody() {}

  explicit GenerateDeviceNameListURLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GenerateDeviceNameListURLResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GenerateDeviceNameListURLResponseBodyData>(model1);
      }
    }
  }


  virtual ~GenerateDeviceNameListURLResponseBody() = default;
};
class GenerateDeviceNameListURLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GenerateDeviceNameListURLResponseBody> body{};

  GenerateDeviceNameListURLResponse() {}

  explicit GenerateDeviceNameListURLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateDeviceNameListURLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateDeviceNameListURLResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateDeviceNameListURLResponse() = default;
};
class GenerateFileUploadURLRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> fileSuffix{};
  shared_ptr<string> bizCode{};
  shared_ptr<string> fileName{};

  GenerateFileUploadURLRequest() {}

  explicit GenerateFileUploadURLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (fileSuffix) {
      res["FileSuffix"] = boost::any(*fileSuffix);
    }
    if (bizCode) {
      res["BizCode"] = boost::any(*bizCode);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("FileSuffix") != m.end() && !m["FileSuffix"].empty()) {
      fileSuffix = make_shared<string>(boost::any_cast<string>(m["FileSuffix"]));
    }
    if (m.find("BizCode") != m.end() && !m["BizCode"].empty()) {
      bizCode = make_shared<string>(boost::any_cast<string>(m["BizCode"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
  }


  virtual ~GenerateFileUploadURLRequest() = default;
};
class GenerateFileUploadURLResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> host{};
  shared_ptr<string> policy{};
  shared_ptr<string> ossAccessKeyId{};
  shared_ptr<string> signature{};
  shared_ptr<string> objectStorage{};

  GenerateFileUploadURLResponseBodyData() {}

  explicit GenerateFileUploadURLResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (ossAccessKeyId) {
      res["OssAccessKeyId"] = boost::any(*ossAccessKeyId);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    if (objectStorage) {
      res["ObjectStorage"] = boost::any(*objectStorage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("OssAccessKeyId") != m.end() && !m["OssAccessKeyId"].empty()) {
      ossAccessKeyId = make_shared<string>(boost::any_cast<string>(m["OssAccessKeyId"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
    if (m.find("ObjectStorage") != m.end() && !m["ObjectStorage"].empty()) {
      objectStorage = make_shared<string>(boost::any_cast<string>(m["ObjectStorage"]));
    }
  }


  virtual ~GenerateFileUploadURLResponseBodyData() = default;
};
class GenerateFileUploadURLResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GenerateFileUploadURLResponseBodyData> data{};

  GenerateFileUploadURLResponseBody() {}

  explicit GenerateFileUploadURLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GenerateFileUploadURLResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GenerateFileUploadURLResponseBodyData>(model1);
      }
    }
  }


  virtual ~GenerateFileUploadURLResponseBody() = default;
};
class GenerateFileUploadURLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GenerateFileUploadURLResponseBody> body{};

  GenerateFileUploadURLResponse() {}

  explicit GenerateFileUploadURLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateFileUploadURLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateFileUploadURLResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateFileUploadURLResponse() = default;
};
class GenerateOTAUploadURLRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> fileSuffix{};

  GenerateOTAUploadURLRequest() {}

  explicit GenerateOTAUploadURLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (fileSuffix) {
      res["FileSuffix"] = boost::any(*fileSuffix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("FileSuffix") != m.end() && !m["FileSuffix"].empty()) {
      fileSuffix = make_shared<string>(boost::any_cast<string>(m["FileSuffix"]));
    }
  }


  virtual ~GenerateOTAUploadURLRequest() = default;
};
class GenerateOTAUploadURLResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> host{};
  shared_ptr<string> policy{};
  shared_ptr<string> OSSAccessKeyId{};
  shared_ptr<string> signature{};
  shared_ptr<string> firmwareUrl{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> objectStorage{};

  GenerateOTAUploadURLResponseBodyData() {}

  explicit GenerateOTAUploadURLResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (OSSAccessKeyId) {
      res["OSSAccessKeyId"] = boost::any(*OSSAccessKeyId);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    if (firmwareUrl) {
      res["FirmwareUrl"] = boost::any(*firmwareUrl);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (objectStorage) {
      res["ObjectStorage"] = boost::any(*objectStorage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("OSSAccessKeyId") != m.end() && !m["OSSAccessKeyId"].empty()) {
      OSSAccessKeyId = make_shared<string>(boost::any_cast<string>(m["OSSAccessKeyId"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
    if (m.find("FirmwareUrl") != m.end() && !m["FirmwareUrl"].empty()) {
      firmwareUrl = make_shared<string>(boost::any_cast<string>(m["FirmwareUrl"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("ObjectStorage") != m.end() && !m["ObjectStorage"].empty()) {
      objectStorage = make_shared<string>(boost::any_cast<string>(m["ObjectStorage"]));
    }
  }


  virtual ~GenerateOTAUploadURLResponseBodyData() = default;
};
class GenerateOTAUploadURLResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GenerateOTAUploadURLResponseBodyData> data{};

  GenerateOTAUploadURLResponseBody() {}

  explicit GenerateOTAUploadURLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GenerateOTAUploadURLResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GenerateOTAUploadURLResponseBodyData>(model1);
      }
    }
  }


  virtual ~GenerateOTAUploadURLResponseBody() = default;
};
class GenerateOTAUploadURLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GenerateOTAUploadURLResponseBody> body{};

  GenerateOTAUploadURLResponse() {}

  explicit GenerateOTAUploadURLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateOTAUploadURLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateOTAUploadURLResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateOTAUploadURLResponse() = default;
};
class GetDataAPIServiceDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiSrn{};
  shared_ptr<string> iotInstanceId{};

  GetDataAPIServiceDetailRequest() {}

  explicit GetDataAPIServiceDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiSrn) {
      res["ApiSrn"] = boost::any(*apiSrn);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiSrn") != m.end() && !m["ApiSrn"].empty()) {
      apiSrn = make_shared<string>(boost::any_cast<string>(m["ApiSrn"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~GetDataAPIServiceDetailRequest() = default;
};
class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> desc{};
  shared_ptr<string> example{};
  shared_ptr<bool> required{};

  GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams() {}

  explicit GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (example) {
      res["Example"] = boost::any(*example);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Example") != m.end() && !m["Example"].empty()) {
      example = make_shared<string>(boost::any_cast<string>(m["Example"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<bool>(boost::any_cast<bool>(m["Required"]));
    }
  }


  virtual ~GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams() = default;
};
class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams : public Darabonba::Model {
public:
  shared_ptr<vector<GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams>> requestParams{};

  GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams() {}

  explicit GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParams) {
      vector<boost::any> temp1;
      for(auto item1:*requestParams){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParams"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParams") != m.end() && !m["RequestParams"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParams"].type()) {
        vector<GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParams"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParams = make_shared<vector<GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams>>(expect1);
      }
    }
  }


  virtual ~GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams() = default;
};
class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> desc{};
  shared_ptr<string> example{};
  shared_ptr<bool> required{};

  GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams() {}

  explicit GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (example) {
      res["Example"] = boost::any(*example);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Example") != m.end() && !m["Example"].empty()) {
      example = make_shared<string>(boost::any_cast<string>(m["Example"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<bool>(boost::any_cast<bool>(m["Required"]));
    }
  }


  virtual ~GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams() = default;
};
class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams : public Darabonba::Model {
public:
  shared_ptr<vector<GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams>> responseParams{};

  GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams() {}

  explicit GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (responseParams) {
      vector<boost::any> temp1;
      for(auto item1:*responseParams){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResponseParams"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResponseParams") != m.end() && !m["ResponseParams"].empty()) {
      if (typeid(vector<boost::any>) == m["ResponseParams"].type()) {
        vector<GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResponseParams"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        responseParams = make_shared<vector<GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams>>(expect1);
      }
    }
  }


  virtual ~GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams() = default;
};
class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO : public Darabonba::Model {
public:
  shared_ptr<string> originSql{};
  shared_ptr<string> templateSql{};
  shared_ptr<GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams> requestParams{};
  shared_ptr<GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams> responseParams{};

  GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO() {}

  explicit GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (originSql) {
      res["OriginSql"] = boost::any(*originSql);
    }
    if (templateSql) {
      res["TemplateSql"] = boost::any(*templateSql);
    }
    if (requestParams) {
      res["RequestParams"] = requestParams ? boost::any(requestParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (responseParams) {
      res["ResponseParams"] = responseParams ? boost::any(responseParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OriginSql") != m.end() && !m["OriginSql"].empty()) {
      originSql = make_shared<string>(boost::any_cast<string>(m["OriginSql"]));
    }
    if (m.find("TemplateSql") != m.end() && !m["TemplateSql"].empty()) {
      templateSql = make_shared<string>(boost::any_cast<string>(m["TemplateSql"]));
    }
    if (m.find("RequestParams") != m.end() && !m["RequestParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestParams"].type()) {
        GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestParams"]));
        requestParams = make_shared<GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams>(model1);
      }
    }
    if (m.find("ResponseParams") != m.end() && !m["ResponseParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResponseParams"].type()) {
        GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResponseParams"]));
        responseParams = make_shared<GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams>(model1);
      }
    }
  }


  virtual ~GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO() = default;
};
class GetDataAPIServiceDetailResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> apiSrn{};
  shared_ptr<long> status{};
  shared_ptr<string> displayName{};
  shared_ptr<string> apiPath{};
  shared_ptr<long> createTime{};
  shared_ptr<long> lastUpdateTime{};
  shared_ptr<string> dateFormat{};
  shared_ptr<string> requestMethod{};
  shared_ptr<string> requestProtocol{};
  shared_ptr<string> description{};
  shared_ptr<GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO> sqlTemplateDTO{};

  GetDataAPIServiceDetailResponseBodyData() {}

  explicit GetDataAPIServiceDetailResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiSrn) {
      res["ApiSrn"] = boost::any(*apiSrn);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (lastUpdateTime) {
      res["LastUpdateTime"] = boost::any(*lastUpdateTime);
    }
    if (dateFormat) {
      res["DateFormat"] = boost::any(*dateFormat);
    }
    if (requestMethod) {
      res["RequestMethod"] = boost::any(*requestMethod);
    }
    if (requestProtocol) {
      res["RequestProtocol"] = boost::any(*requestProtocol);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (sqlTemplateDTO) {
      res["SqlTemplateDTO"] = sqlTemplateDTO ? boost::any(sqlTemplateDTO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiSrn") != m.end() && !m["ApiSrn"].empty()) {
      apiSrn = make_shared<string>(boost::any_cast<string>(m["ApiSrn"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("LastUpdateTime") != m.end() && !m["LastUpdateTime"].empty()) {
      lastUpdateTime = make_shared<long>(boost::any_cast<long>(m["LastUpdateTime"]));
    }
    if (m.find("DateFormat") != m.end() && !m["DateFormat"].empty()) {
      dateFormat = make_shared<string>(boost::any_cast<string>(m["DateFormat"]));
    }
    if (m.find("RequestMethod") != m.end() && !m["RequestMethod"].empty()) {
      requestMethod = make_shared<string>(boost::any_cast<string>(m["RequestMethod"]));
    }
    if (m.find("RequestProtocol") != m.end() && !m["RequestProtocol"].empty()) {
      requestProtocol = make_shared<string>(boost::any_cast<string>(m["RequestProtocol"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SqlTemplateDTO") != m.end() && !m["SqlTemplateDTO"].empty()) {
      if (typeid(map<string, boost::any>) == m["SqlTemplateDTO"].type()) {
        GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SqlTemplateDTO"]));
        sqlTemplateDTO = make_shared<GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO>(model1);
      }
    }
  }


  virtual ~GetDataAPIServiceDetailResponseBodyData() = default;
};
class GetDataAPIServiceDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetDataAPIServiceDetailResponseBodyData> data{};

  GetDataAPIServiceDetailResponseBody() {}

  explicit GetDataAPIServiceDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDataAPIServiceDetailResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDataAPIServiceDetailResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetDataAPIServiceDetailResponseBody() = default;
};
class GetDataAPIServiceDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetDataAPIServiceDetailResponseBody> body{};

  GetDataAPIServiceDetailResponse() {}

  explicit GetDataAPIServiceDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataAPIServiceDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataAPIServiceDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataAPIServiceDetailResponse() = default;
};
class GetDeviceShadowRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};

  GetDeviceShadowRequest() {}

  explicit GetDeviceShadowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
  }


  virtual ~GetDeviceShadowRequest() = default;
};
class GetDeviceShadowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> shadowMessage{};

  GetDeviceShadowResponseBody() {}

  explicit GetDeviceShadowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (shadowMessage) {
      res["ShadowMessage"] = boost::any(*shadowMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ShadowMessage") != m.end() && !m["ShadowMessage"].empty()) {
      shadowMessage = make_shared<string>(boost::any_cast<string>(m["ShadowMessage"]));
    }
  }


  virtual ~GetDeviceShadowResponseBody() = default;
};
class GetDeviceShadowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetDeviceShadowResponseBody> body{};

  GetDeviceShadowResponse() {}

  explicit GetDeviceShadowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDeviceShadowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDeviceShadowResponseBody>(model1);
      }
    }
  }


  virtual ~GetDeviceShadowResponse() = default;
};
class GetDeviceStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};

  GetDeviceStatusRequest() {}

  explicit GetDeviceStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~GetDeviceStatusRequest() = default;
};
class GetDeviceStatusResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> status{};

  GetDeviceStatusResponseBodyData() {}

  explicit GetDeviceStatusResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetDeviceStatusResponseBodyData() = default;
};
class GetDeviceStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetDeviceStatusResponseBodyData> data{};

  GetDeviceStatusResponseBody() {}

  explicit GetDeviceStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDeviceStatusResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDeviceStatusResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetDeviceStatusResponseBody() = default;
};
class GetDeviceStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetDeviceStatusResponseBody> body{};

  GetDeviceStatusResponse() {}

  explicit GetDeviceStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDeviceStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDeviceStatusResponseBody>(model1);
      }
    }
  }


  virtual ~GetDeviceStatusResponse() = default;
};
class GetDeviceTunnelShareStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};

  GetDeviceTunnelShareStatusRequest() {}

  explicit GetDeviceTunnelShareStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
  }


  virtual ~GetDeviceTunnelShareStatusRequest() = default;
};
class GetDeviceTunnelShareStatusResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> shareId{};
  shared_ptr<string> password{};
  shared_ptr<bool> isOpen{};
  shared_ptr<long> gmtOpened{};

  GetDeviceTunnelShareStatusResponseBodyData() {}

  explicit GetDeviceTunnelShareStatusResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (shareId) {
      res["ShareId"] = boost::any(*shareId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (isOpen) {
      res["IsOpen"] = boost::any(*isOpen);
    }
    if (gmtOpened) {
      res["GmtOpened"] = boost::any(*gmtOpened);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ShareId") != m.end() && !m["ShareId"].empty()) {
      shareId = make_shared<string>(boost::any_cast<string>(m["ShareId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("IsOpen") != m.end() && !m["IsOpen"].empty()) {
      isOpen = make_shared<bool>(boost::any_cast<bool>(m["IsOpen"]));
    }
    if (m.find("GmtOpened") != m.end() && !m["GmtOpened"].empty()) {
      gmtOpened = make_shared<long>(boost::any_cast<long>(m["GmtOpened"]));
    }
  }


  virtual ~GetDeviceTunnelShareStatusResponseBodyData() = default;
};
class GetDeviceTunnelShareStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<GetDeviceTunnelShareStatusResponseBodyData> data{};

  GetDeviceTunnelShareStatusResponseBody() {}

  explicit GetDeviceTunnelShareStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDeviceTunnelShareStatusResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDeviceTunnelShareStatusResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetDeviceTunnelShareStatusResponseBody() = default;
};
class GetDeviceTunnelShareStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetDeviceTunnelShareStatusResponseBody> body{};

  GetDeviceTunnelShareStatusResponse() {}

  explicit GetDeviceTunnelShareStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDeviceTunnelShareStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDeviceTunnelShareStatusResponseBody>(model1);
      }
    }
  }


  virtual ~GetDeviceTunnelShareStatusResponse() = default;
};
class GetDeviceTunnelStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};

  GetDeviceTunnelStatusRequest() {}

  explicit GetDeviceTunnelStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
  }


  virtual ~GetDeviceTunnelStatusRequest() = default;
};
class GetDeviceTunnelStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<string> data{};

  GetDeviceTunnelStatusResponseBody() {}

  explicit GetDeviceTunnelStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
  }


  virtual ~GetDeviceTunnelStatusResponseBody() = default;
};
class GetDeviceTunnelStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetDeviceTunnelStatusResponseBody> body{};

  GetDeviceTunnelStatusResponse() {}

  explicit GetDeviceTunnelStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDeviceTunnelStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDeviceTunnelStatusResponseBody>(model1);
      }
    }
  }


  virtual ~GetDeviceTunnelStatusResponse() = default;
};
class GetEdgeDriverVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};

  GetEdgeDriverVersionRequest() {}

  explicit GetEdgeDriverVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
  }


  virtual ~GetEdgeDriverVersionRequest() = default;
};
class GetEdgeDriverVersionResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};
  shared_ptr<string> versionState{};
  shared_ptr<string> edgeVersion{};
  shared_ptr<string> description{};
  shared_ptr<string> sourceConfig{};
  shared_ptr<string> driverConfig{};
  shared_ptr<string> containerConfig{};
  shared_ptr<string> configCheckRule{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<string> argument{};

  GetEdgeDriverVersionResponseBodyData() {}

  explicit GetEdgeDriverVersionResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    if (versionState) {
      res["VersionState"] = boost::any(*versionState);
    }
    if (edgeVersion) {
      res["EdgeVersion"] = boost::any(*edgeVersion);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (sourceConfig) {
      res["SourceConfig"] = boost::any(*sourceConfig);
    }
    if (driverConfig) {
      res["DriverConfig"] = boost::any(*driverConfig);
    }
    if (containerConfig) {
      res["ContainerConfig"] = boost::any(*containerConfig);
    }
    if (configCheckRule) {
      res["ConfigCheckRule"] = boost::any(*configCheckRule);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (argument) {
      res["Argument"] = boost::any(*argument);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
    if (m.find("VersionState") != m.end() && !m["VersionState"].empty()) {
      versionState = make_shared<string>(boost::any_cast<string>(m["VersionState"]));
    }
    if (m.find("EdgeVersion") != m.end() && !m["EdgeVersion"].empty()) {
      edgeVersion = make_shared<string>(boost::any_cast<string>(m["EdgeVersion"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SourceConfig") != m.end() && !m["SourceConfig"].empty()) {
      sourceConfig = make_shared<string>(boost::any_cast<string>(m["SourceConfig"]));
    }
    if (m.find("DriverConfig") != m.end() && !m["DriverConfig"].empty()) {
      driverConfig = make_shared<string>(boost::any_cast<string>(m["DriverConfig"]));
    }
    if (m.find("ContainerConfig") != m.end() && !m["ContainerConfig"].empty()) {
      containerConfig = make_shared<string>(boost::any_cast<string>(m["ContainerConfig"]));
    }
    if (m.find("ConfigCheckRule") != m.end() && !m["ConfigCheckRule"].empty()) {
      configCheckRule = make_shared<string>(boost::any_cast<string>(m["ConfigCheckRule"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("Argument") != m.end() && !m["Argument"].empty()) {
      argument = make_shared<string>(boost::any_cast<string>(m["Argument"]));
    }
  }


  virtual ~GetEdgeDriverVersionResponseBodyData() = default;
};
class GetEdgeDriverVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetEdgeDriverVersionResponseBodyData> data{};

  GetEdgeDriverVersionResponseBody() {}

  explicit GetEdgeDriverVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetEdgeDriverVersionResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetEdgeDriverVersionResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetEdgeDriverVersionResponseBody() = default;
};
class GetEdgeDriverVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetEdgeDriverVersionResponseBody> body{};

  GetEdgeDriverVersionResponse() {}

  explicit GetEdgeDriverVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEdgeDriverVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEdgeDriverVersionResponseBody>(model1);
      }
    }
  }


  virtual ~GetEdgeDriverVersionResponse() = default;
};
class GetEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};

  GetEdgeInstanceRequest() {}

  explicit GetEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetEdgeInstanceRequest() = default;
};
class GetEdgeInstanceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> tags{};
  shared_ptr<string> type{};
  shared_ptr<long> spec{};
  shared_ptr<bool> bizEnable{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> roleName{};
  shared_ptr<string> roleAttachTime{};
  shared_ptr<long> latestDeploymentStatus{};
  shared_ptr<string> latestDeploymentType{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<long> roleAttachTimestamp{};

  GetEdgeInstanceResponseBodyData() {}

  explicit GetEdgeInstanceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (bizEnable) {
      res["BizEnable"] = boost::any(*bizEnable);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (roleAttachTime) {
      res["RoleAttachTime"] = boost::any(*roleAttachTime);
    }
    if (latestDeploymentStatus) {
      res["LatestDeploymentStatus"] = boost::any(*latestDeploymentStatus);
    }
    if (latestDeploymentType) {
      res["LatestDeploymentType"] = boost::any(*latestDeploymentType);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (roleAttachTimestamp) {
      res["RoleAttachTimestamp"] = boost::any(*roleAttachTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<long>(boost::any_cast<long>(m["Spec"]));
    }
    if (m.find("BizEnable") != m.end() && !m["BizEnable"].empty()) {
      bizEnable = make_shared<bool>(boost::any_cast<bool>(m["BizEnable"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("RoleAttachTime") != m.end() && !m["RoleAttachTime"].empty()) {
      roleAttachTime = make_shared<string>(boost::any_cast<string>(m["RoleAttachTime"]));
    }
    if (m.find("LatestDeploymentStatus") != m.end() && !m["LatestDeploymentStatus"].empty()) {
      latestDeploymentStatus = make_shared<long>(boost::any_cast<long>(m["LatestDeploymentStatus"]));
    }
    if (m.find("LatestDeploymentType") != m.end() && !m["LatestDeploymentType"].empty()) {
      latestDeploymentType = make_shared<string>(boost::any_cast<string>(m["LatestDeploymentType"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("RoleAttachTimestamp") != m.end() && !m["RoleAttachTimestamp"].empty()) {
      roleAttachTimestamp = make_shared<long>(boost::any_cast<long>(m["RoleAttachTimestamp"]));
    }
  }


  virtual ~GetEdgeInstanceResponseBodyData() = default;
};
class GetEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetEdgeInstanceResponseBodyData> data{};

  GetEdgeInstanceResponseBody() {}

  explicit GetEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetEdgeInstanceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetEdgeInstanceResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetEdgeInstanceResponseBody() = default;
};
class GetEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetEdgeInstanceResponseBody> body{};

  GetEdgeInstanceResponse() {}

  explicit GetEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~GetEdgeInstanceResponse() = default;
};
class GetEdgeInstanceDeploymentRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> deploymentId{};

  GetEdgeInstanceDeploymentRequest() {}

  explicit GetEdgeInstanceDeploymentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (deploymentId) {
      res["DeploymentId"] = boost::any(*deploymentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DeploymentId") != m.end() && !m["DeploymentId"].empty()) {
      deploymentId = make_shared<string>(boost::any_cast<string>(m["DeploymentId"]));
    }
  }


  virtual ~GetEdgeInstanceDeploymentRequest() = default;
};
class GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> gmtCompleted{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceName{};
  shared_ptr<long> operateType{};
  shared_ptr<long> stage{};
  shared_ptr<long> status{};
  shared_ptr<string> log{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<long> gmtCompletedTimestamp{};

  GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList() {}

  explicit GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtCompleted) {
      res["GmtCompleted"] = boost::any(*gmtCompleted);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (operateType) {
      res["OperateType"] = boost::any(*operateType);
    }
    if (stage) {
      res["Stage"] = boost::any(*stage);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (log) {
      res["Log"] = boost::any(*log);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (gmtCompletedTimestamp) {
      res["GmtCompletedTimestamp"] = boost::any(*gmtCompletedTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtCompleted") != m.end() && !m["GmtCompleted"].empty()) {
      gmtCompleted = make_shared<string>(boost::any_cast<string>(m["GmtCompleted"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("OperateType") != m.end() && !m["OperateType"].empty()) {
      operateType = make_shared<long>(boost::any_cast<long>(m["OperateType"]));
    }
    if (m.find("Stage") != m.end() && !m["Stage"].empty()) {
      stage = make_shared<long>(boost::any_cast<long>(m["Stage"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Log") != m.end() && !m["Log"].empty()) {
      log = make_shared<string>(boost::any_cast<string>(m["Log"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("GmtCompletedTimestamp") != m.end() && !m["GmtCompletedTimestamp"].empty()) {
      gmtCompletedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCompletedTimestamp"]));
    }
  }


  virtual ~GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList() = default;
};
class GetEdgeInstanceDeploymentResponseBodyDataTaskList : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> gmtCompleted{};
  shared_ptr<string> gatewayId{};
  shared_ptr<string> taskId{};
  shared_ptr<long> stage{};
  shared_ptr<long> status{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<long> gmtCompletedTimestamp{};
  shared_ptr<vector<GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList>> resourceSnapshotList{};

  GetEdgeInstanceDeploymentResponseBodyDataTaskList() {}

  explicit GetEdgeInstanceDeploymentResponseBodyDataTaskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtCompleted) {
      res["GmtCompleted"] = boost::any(*gmtCompleted);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (stage) {
      res["Stage"] = boost::any(*stage);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (gmtCompletedTimestamp) {
      res["GmtCompletedTimestamp"] = boost::any(*gmtCompletedTimestamp);
    }
    if (resourceSnapshotList) {
      vector<boost::any> temp1;
      for(auto item1:*resourceSnapshotList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceSnapshotList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtCompleted") != m.end() && !m["GmtCompleted"].empty()) {
      gmtCompleted = make_shared<string>(boost::any_cast<string>(m["GmtCompleted"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<string>(boost::any_cast<string>(m["GatewayId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Stage") != m.end() && !m["Stage"].empty()) {
      stage = make_shared<long>(boost::any_cast<long>(m["Stage"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("GmtCompletedTimestamp") != m.end() && !m["GmtCompletedTimestamp"].empty()) {
      gmtCompletedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCompletedTimestamp"]));
    }
    if (m.find("ResourceSnapshotList") != m.end() && !m["ResourceSnapshotList"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceSnapshotList"].type()) {
        vector<GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceSnapshotList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceSnapshotList = make_shared<vector<GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList>>(expect1);
      }
    }
  }


  virtual ~GetEdgeInstanceDeploymentResponseBodyDataTaskList() = default;
};
class GetEdgeInstanceDeploymentResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> gmtCompleted{};
  shared_ptr<string> deploymentId{};
  shared_ptr<string> description{};
  shared_ptr<long> status{};
  shared_ptr<string> type{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<long> gmtCompletedTimestamp{};
  shared_ptr<vector<GetEdgeInstanceDeploymentResponseBodyDataTaskList>> taskList{};

  GetEdgeInstanceDeploymentResponseBodyData() {}

  explicit GetEdgeInstanceDeploymentResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtCompleted) {
      res["GmtCompleted"] = boost::any(*gmtCompleted);
    }
    if (deploymentId) {
      res["DeploymentId"] = boost::any(*deploymentId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (gmtCompletedTimestamp) {
      res["GmtCompletedTimestamp"] = boost::any(*gmtCompletedTimestamp);
    }
    if (taskList) {
      vector<boost::any> temp1;
      for(auto item1:*taskList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtCompleted") != m.end() && !m["GmtCompleted"].empty()) {
      gmtCompleted = make_shared<string>(boost::any_cast<string>(m["GmtCompleted"]));
    }
    if (m.find("DeploymentId") != m.end() && !m["DeploymentId"].empty()) {
      deploymentId = make_shared<string>(boost::any_cast<string>(m["DeploymentId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("GmtCompletedTimestamp") != m.end() && !m["GmtCompletedTimestamp"].empty()) {
      gmtCompletedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCompletedTimestamp"]));
    }
    if (m.find("TaskList") != m.end() && !m["TaskList"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskList"].type()) {
        vector<GetEdgeInstanceDeploymentResponseBodyDataTaskList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEdgeInstanceDeploymentResponseBodyDataTaskList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskList = make_shared<vector<GetEdgeInstanceDeploymentResponseBodyDataTaskList>>(expect1);
      }
    }
  }


  virtual ~GetEdgeInstanceDeploymentResponseBodyData() = default;
};
class GetEdgeInstanceDeploymentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetEdgeInstanceDeploymentResponseBodyData> data{};

  GetEdgeInstanceDeploymentResponseBody() {}

  explicit GetEdgeInstanceDeploymentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetEdgeInstanceDeploymentResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetEdgeInstanceDeploymentResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetEdgeInstanceDeploymentResponseBody() = default;
};
class GetEdgeInstanceDeploymentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetEdgeInstanceDeploymentResponseBody> body{};

  GetEdgeInstanceDeploymentResponse() {}

  explicit GetEdgeInstanceDeploymentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEdgeInstanceDeploymentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEdgeInstanceDeploymentResponseBody>(model1);
      }
    }
  }


  virtual ~GetEdgeInstanceDeploymentResponse() = default;
};
class GetEdgeInstanceMessageRoutingRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> routeId{};

  GetEdgeInstanceMessageRoutingRequest() {}

  explicit GetEdgeInstanceMessageRoutingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<long>(boost::any_cast<long>(m["RouteId"]));
    }
  }


  virtual ~GetEdgeInstanceMessageRoutingRequest() = default;
};
class GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext : public Darabonba::Model {
public:
  shared_ptr<string> sourceFcServiceName{};
  shared_ptr<string> sourceFcFunctionName{};
  shared_ptr<string> sourceApplicationName{};
  shared_ptr<string> targetFcServiceName{};
  shared_ptr<string> targetFcFunctionName{};
  shared_ptr<string> targetApplicationName{};
  shared_ptr<string> qos{};

  GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext() {}

  explicit GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceFcServiceName) {
      res["SourceFcServiceName"] = boost::any(*sourceFcServiceName);
    }
    if (sourceFcFunctionName) {
      res["SourceFcFunctionName"] = boost::any(*sourceFcFunctionName);
    }
    if (sourceApplicationName) {
      res["SourceApplicationName"] = boost::any(*sourceApplicationName);
    }
    if (targetFcServiceName) {
      res["TargetFcServiceName"] = boost::any(*targetFcServiceName);
    }
    if (targetFcFunctionName) {
      res["TargetFcFunctionName"] = boost::any(*targetFcFunctionName);
    }
    if (targetApplicationName) {
      res["TargetApplicationName"] = boost::any(*targetApplicationName);
    }
    if (qos) {
      res["Qos"] = boost::any(*qos);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceFcServiceName") != m.end() && !m["SourceFcServiceName"].empty()) {
      sourceFcServiceName = make_shared<string>(boost::any_cast<string>(m["SourceFcServiceName"]));
    }
    if (m.find("SourceFcFunctionName") != m.end() && !m["SourceFcFunctionName"].empty()) {
      sourceFcFunctionName = make_shared<string>(boost::any_cast<string>(m["SourceFcFunctionName"]));
    }
    if (m.find("SourceApplicationName") != m.end() && !m["SourceApplicationName"].empty()) {
      sourceApplicationName = make_shared<string>(boost::any_cast<string>(m["SourceApplicationName"]));
    }
    if (m.find("TargetFcServiceName") != m.end() && !m["TargetFcServiceName"].empty()) {
      targetFcServiceName = make_shared<string>(boost::any_cast<string>(m["TargetFcServiceName"]));
    }
    if (m.find("TargetFcFunctionName") != m.end() && !m["TargetFcFunctionName"].empty()) {
      targetFcFunctionName = make_shared<string>(boost::any_cast<string>(m["TargetFcFunctionName"]));
    }
    if (m.find("TargetApplicationName") != m.end() && !m["TargetApplicationName"].empty()) {
      targetApplicationName = make_shared<string>(boost::any_cast<string>(m["TargetApplicationName"]));
    }
    if (m.find("Qos") != m.end() && !m["Qos"].empty()) {
      qos = make_shared<string>(boost::any_cast<string>(m["Qos"]));
    }
  }


  virtual ~GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext() = default;
};
class GetEdgeInstanceMessageRoutingResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> topicFilter{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceData{};
  shared_ptr<string> targetType{};
  shared_ptr<string> targetData{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext> routeContext{};

  GetEdgeInstanceMessageRoutingResponseBodyData() {}

  explicit GetEdgeInstanceMessageRoutingResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topicFilter) {
      res["TopicFilter"] = boost::any(*topicFilter);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (sourceData) {
      res["SourceData"] = boost::any(*sourceData);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (targetData) {
      res["TargetData"] = boost::any(*targetData);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (routeContext) {
      res["RouteContext"] = routeContext ? boost::any(routeContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TopicFilter") != m.end() && !m["TopicFilter"].empty()) {
      topicFilter = make_shared<string>(boost::any_cast<string>(m["TopicFilter"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SourceData") != m.end() && !m["SourceData"].empty()) {
      sourceData = make_shared<string>(boost::any_cast<string>(m["SourceData"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("TargetData") != m.end() && !m["TargetData"].empty()) {
      targetData = make_shared<string>(boost::any_cast<string>(m["TargetData"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("RouteContext") != m.end() && !m["RouteContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["RouteContext"].type()) {
        GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RouteContext"]));
        routeContext = make_shared<GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext>(model1);
      }
    }
  }


  virtual ~GetEdgeInstanceMessageRoutingResponseBodyData() = default;
};
class GetEdgeInstanceMessageRoutingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetEdgeInstanceMessageRoutingResponseBodyData> data{};

  GetEdgeInstanceMessageRoutingResponseBody() {}

  explicit GetEdgeInstanceMessageRoutingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetEdgeInstanceMessageRoutingResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetEdgeInstanceMessageRoutingResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetEdgeInstanceMessageRoutingResponseBody() = default;
};
class GetEdgeInstanceMessageRoutingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetEdgeInstanceMessageRoutingResponseBody> body{};

  GetEdgeInstanceMessageRoutingResponse() {}

  explicit GetEdgeInstanceMessageRoutingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEdgeInstanceMessageRoutingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEdgeInstanceMessageRoutingResponseBody>(model1);
      }
    }
  }


  virtual ~GetEdgeInstanceMessageRoutingResponse() = default;
};
class GetGatewayBySubDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};

  GetGatewayBySubDeviceRequest() {}

  explicit GetGatewayBySubDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~GetGatewayBySubDeviceRequest() = default;
};
class GetGatewayBySubDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};
  shared_ptr<string> deviceSecret{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> firmwareVersion{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> gmtActive{};
  shared_ptr<string> utcActive{};
  shared_ptr<string> gmtOnline{};
  shared_ptr<string> utcOnline{};
  shared_ptr<string> status{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> nodeType{};
  shared_ptr<string> region{};
  shared_ptr<string> iotId{};

  GetGatewayBySubDeviceResponseBodyData() {}

  explicit GetGatewayBySubDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (deviceSecret) {
      res["DeviceSecret"] = boost::any(*deviceSecret);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (firmwareVersion) {
      res["FirmwareVersion"] = boost::any(*firmwareVersion);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (gmtActive) {
      res["GmtActive"] = boost::any(*gmtActive);
    }
    if (utcActive) {
      res["UtcActive"] = boost::any(*utcActive);
    }
    if (gmtOnline) {
      res["GmtOnline"] = boost::any(*gmtOnline);
    }
    if (utcOnline) {
      res["UtcOnline"] = boost::any(*utcOnline);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (region) {
      res["region"] = boost::any(*region);
    }
    if (iotId) {
      res["iotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("DeviceSecret") != m.end() && !m["DeviceSecret"].empty()) {
      deviceSecret = make_shared<string>(boost::any_cast<string>(m["DeviceSecret"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("FirmwareVersion") != m.end() && !m["FirmwareVersion"].empty()) {
      firmwareVersion = make_shared<string>(boost::any_cast<string>(m["FirmwareVersion"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("GmtActive") != m.end() && !m["GmtActive"].empty()) {
      gmtActive = make_shared<string>(boost::any_cast<string>(m["GmtActive"]));
    }
    if (m.find("UtcActive") != m.end() && !m["UtcActive"].empty()) {
      utcActive = make_shared<string>(boost::any_cast<string>(m["UtcActive"]));
    }
    if (m.find("GmtOnline") != m.end() && !m["GmtOnline"].empty()) {
      gmtOnline = make_shared<string>(boost::any_cast<string>(m["GmtOnline"]));
    }
    if (m.find("UtcOnline") != m.end() && !m["UtcOnline"].empty()) {
      utcOnline = make_shared<string>(boost::any_cast<string>(m["UtcOnline"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
    if (m.find("region") != m.end() && !m["region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["region"]));
    }
    if (m.find("iotId") != m.end() && !m["iotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["iotId"]));
    }
  }


  virtual ~GetGatewayBySubDeviceResponseBodyData() = default;
};
class GetGatewayBySubDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetGatewayBySubDeviceResponseBodyData> data{};

  GetGatewayBySubDeviceResponseBody() {}

  explicit GetGatewayBySubDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetGatewayBySubDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetGatewayBySubDeviceResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetGatewayBySubDeviceResponseBody() = default;
};
class GetGatewayBySubDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetGatewayBySubDeviceResponseBody> body{};

  GetGatewayBySubDeviceResponse() {}

  explicit GetGatewayBySubDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetGatewayBySubDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetGatewayBySubDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~GetGatewayBySubDeviceResponse() = default;
};
class GetLoraNodesTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> taskId{};

  GetLoraNodesTaskRequest() {}

  explicit GetLoraNodesTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetLoraNodesTaskRequest() = default;
};
class GetLoraNodesTaskResponseBodySuccessDevEuis : public Darabonba::Model {
public:
  shared_ptr<vector<string>> successDevEui{};

  GetLoraNodesTaskResponseBodySuccessDevEuis() {}

  explicit GetLoraNodesTaskResponseBodySuccessDevEuis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (successDevEui) {
      res["SuccessDevEui"] = boost::any(*successDevEui);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SuccessDevEui") != m.end() && !m["SuccessDevEui"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SuccessDevEui"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SuccessDevEui"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      successDevEui = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetLoraNodesTaskResponseBodySuccessDevEuis() = default;
};
class GetLoraNodesTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskState{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> successCount{};
  shared_ptr<GetLoraNodesTaskResponseBodySuccessDevEuis> successDevEuis{};

  GetLoraNodesTaskResponseBody() {}

  explicit GetLoraNodesTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskState) {
      res["TaskState"] = boost::any(*taskState);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    if (successDevEuis) {
      res["SuccessDevEuis"] = successDevEuis ? boost::any(successDevEuis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskState") != m.end() && !m["TaskState"].empty()) {
      taskState = make_shared<string>(boost::any_cast<string>(m["TaskState"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
    if (m.find("SuccessDevEuis") != m.end() && !m["SuccessDevEuis"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuccessDevEuis"].type()) {
        GetLoraNodesTaskResponseBodySuccessDevEuis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SuccessDevEuis"]));
        successDevEuis = make_shared<GetLoraNodesTaskResponseBodySuccessDevEuis>(model1);
      }
    }
  }


  virtual ~GetLoraNodesTaskResponseBody() = default;
};
class GetLoraNodesTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetLoraNodesTaskResponseBody> body{};

  GetLoraNodesTaskResponse() {}

  explicit GetLoraNodesTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLoraNodesTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLoraNodesTaskResponseBody>(model1);
      }
    }
  }


  virtual ~GetLoraNodesTaskResponse() = default;
};
class GetNodesAddingTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> taskId{};

  GetNodesAddingTaskRequest() {}

  explicit GetNodesAddingTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetNodesAddingTaskRequest() = default;
};
class GetNodesAddingTaskResponseBodySuccessDevEuis : public Darabonba::Model {
public:
  shared_ptr<vector<string>> successDevEui{};

  GetNodesAddingTaskResponseBodySuccessDevEuis() {}

  explicit GetNodesAddingTaskResponseBodySuccessDevEuis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (successDevEui) {
      res["SuccessDevEui"] = boost::any(*successDevEui);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SuccessDevEui") != m.end() && !m["SuccessDevEui"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SuccessDevEui"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SuccessDevEui"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      successDevEui = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetNodesAddingTaskResponseBodySuccessDevEuis() = default;
};
class GetNodesAddingTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskState{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> successCount{};
  shared_ptr<GetNodesAddingTaskResponseBodySuccessDevEuis> successDevEuis{};

  GetNodesAddingTaskResponseBody() {}

  explicit GetNodesAddingTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskState) {
      res["TaskState"] = boost::any(*taskState);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    if (successDevEuis) {
      res["SuccessDevEuis"] = successDevEuis ? boost::any(successDevEuis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskState") != m.end() && !m["TaskState"].empty()) {
      taskState = make_shared<string>(boost::any_cast<string>(m["TaskState"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
    if (m.find("SuccessDevEuis") != m.end() && !m["SuccessDevEuis"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuccessDevEuis"].type()) {
        GetNodesAddingTaskResponseBodySuccessDevEuis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SuccessDevEuis"]));
        successDevEuis = make_shared<GetNodesAddingTaskResponseBodySuccessDevEuis>(model1);
      }
    }
  }


  virtual ~GetNodesAddingTaskResponseBody() = default;
};
class GetNodesAddingTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetNodesAddingTaskResponseBody> body{};

  GetNodesAddingTaskResponse() {}

  explicit GetNodesAddingTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNodesAddingTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNodesAddingTaskResponseBody>(model1);
      }
    }
  }


  virtual ~GetNodesAddingTaskResponse() = default;
};
class GetRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> ruleId{};

  GetRuleRequest() {}

  explicit GetRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~GetRuleRequest() = default;
};
class GetRuleResponseBodyRuleInfo : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> select{};
  shared_ptr<string> topic{};
  shared_ptr<string> shortTopic{};
  shared_ptr<string> where{};
  shared_ptr<string> status{};
  shared_ptr<long> createUserId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> name{};
  shared_ptr<string> ruleDesc{};
  shared_ptr<string> dataType{};
  shared_ptr<string> created{};
  shared_ptr<string> utcCreated{};
  shared_ptr<string> modified{};
  shared_ptr<string> utcModified{};
  shared_ptr<long> topicType{};

  GetRuleResponseBodyRuleInfo() {}

  explicit GetRuleResponseBodyRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (select) {
      res["Select"] = boost::any(*select);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (shortTopic) {
      res["ShortTopic"] = boost::any(*shortTopic);
    }
    if (where) {
      res["Where"] = boost::any(*where);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (createUserId) {
      res["CreateUserId"] = boost::any(*createUserId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ruleDesc) {
      res["RuleDesc"] = boost::any(*ruleDesc);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (created) {
      res["Created"] = boost::any(*created);
    }
    if (utcCreated) {
      res["UtcCreated"] = boost::any(*utcCreated);
    }
    if (modified) {
      res["Modified"] = boost::any(*modified);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (topicType) {
      res["TopicType"] = boost::any(*topicType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Select") != m.end() && !m["Select"].empty()) {
      select = make_shared<string>(boost::any_cast<string>(m["Select"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("ShortTopic") != m.end() && !m["ShortTopic"].empty()) {
      shortTopic = make_shared<string>(boost::any_cast<string>(m["ShortTopic"]));
    }
    if (m.find("Where") != m.end() && !m["Where"].empty()) {
      where = make_shared<string>(boost::any_cast<string>(m["Where"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CreateUserId") != m.end() && !m["CreateUserId"].empty()) {
      createUserId = make_shared<long>(boost::any_cast<long>(m["CreateUserId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RuleDesc") != m.end() && !m["RuleDesc"].empty()) {
      ruleDesc = make_shared<string>(boost::any_cast<string>(m["RuleDesc"]));
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("Created") != m.end() && !m["Created"].empty()) {
      created = make_shared<string>(boost::any_cast<string>(m["Created"]));
    }
    if (m.find("UtcCreated") != m.end() && !m["UtcCreated"].empty()) {
      utcCreated = make_shared<string>(boost::any_cast<string>(m["UtcCreated"]));
    }
    if (m.find("Modified") != m.end() && !m["Modified"].empty()) {
      modified = make_shared<string>(boost::any_cast<string>(m["Modified"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("TopicType") != m.end() && !m["TopicType"].empty()) {
      topicType = make_shared<long>(boost::any_cast<long>(m["TopicType"]));
    }
  }


  virtual ~GetRuleResponseBodyRuleInfo() = default;
};
class GetRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetRuleResponseBodyRuleInfo> ruleInfo{};

  GetRuleResponseBody() {}

  explicit GetRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (ruleInfo) {
      res["RuleInfo"] = ruleInfo ? boost::any(ruleInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RuleInfo") != m.end() && !m["RuleInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuleInfo"].type()) {
        GetRuleResponseBodyRuleInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuleInfo"]));
        ruleInfo = make_shared<GetRuleResponseBodyRuleInfo>(model1);
      }
    }
  }


  virtual ~GetRuleResponseBody() = default;
};
class GetRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetRuleResponseBody> body{};

  GetRuleResponse() {}

  explicit GetRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRuleResponseBody>(model1);
      }
    }
  }


  virtual ~GetRuleResponse() = default;
};
class GetRuleActionRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> actionId{};

  GetRuleActionRequest() {}

  explicit GetRuleActionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (actionId) {
      res["ActionId"] = boost::any(*actionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ActionId") != m.end() && !m["ActionId"].empty()) {
      actionId = make_shared<long>(boost::any_cast<long>(m["ActionId"]));
    }
  }


  virtual ~GetRuleActionRequest() = default;
};
class GetRuleActionResponseBodyRuleActionInfo : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> type{};
  shared_ptr<string> configuration{};
  shared_ptr<bool> errorActionFlag{};

  GetRuleActionResponseBodyRuleActionInfo() {}

  explicit GetRuleActionResponseBodyRuleActionInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (configuration) {
      res["Configuration"] = boost::any(*configuration);
    }
    if (errorActionFlag) {
      res["ErrorActionFlag"] = boost::any(*errorActionFlag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configuration = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
    if (m.find("ErrorActionFlag") != m.end() && !m["ErrorActionFlag"].empty()) {
      errorActionFlag = make_shared<bool>(boost::any_cast<bool>(m["ErrorActionFlag"]));
    }
  }


  virtual ~GetRuleActionResponseBodyRuleActionInfo() = default;
};
class GetRuleActionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetRuleActionResponseBodyRuleActionInfo> ruleActionInfo{};

  GetRuleActionResponseBody() {}

  explicit GetRuleActionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (ruleActionInfo) {
      res["RuleActionInfo"] = ruleActionInfo ? boost::any(ruleActionInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RuleActionInfo") != m.end() && !m["RuleActionInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuleActionInfo"].type()) {
        GetRuleActionResponseBodyRuleActionInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuleActionInfo"]));
        ruleActionInfo = make_shared<GetRuleActionResponseBodyRuleActionInfo>(model1);
      }
    }
  }


  virtual ~GetRuleActionResponseBody() = default;
};
class GetRuleActionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetRuleActionResponseBody> body{};

  GetRuleActionResponse() {}

  explicit GetRuleActionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRuleActionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRuleActionResponseBody>(model1);
      }
    }
  }


  virtual ~GetRuleActionResponse() = default;
};
class GetSceneRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> ruleId{};

  GetSceneRuleRequest() {}

  explicit GetSceneRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~GetSceneRuleRequest() = default;
};
class GetSceneRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleContent{};
  shared_ptr<string> ruleDescription{};
  shared_ptr<long> ruleStatus{};

  GetSceneRuleResponseBodyData() {}

  explicit GetSceneRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleContent) {
      res["RuleContent"] = boost::any(*ruleContent);
    }
    if (ruleDescription) {
      res["RuleDescription"] = boost::any(*ruleDescription);
    }
    if (ruleStatus) {
      res["RuleStatus"] = boost::any(*ruleStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleContent") != m.end() && !m["RuleContent"].empty()) {
      ruleContent = make_shared<string>(boost::any_cast<string>(m["RuleContent"]));
    }
    if (m.find("RuleDescription") != m.end() && !m["RuleDescription"].empty()) {
      ruleDescription = make_shared<string>(boost::any_cast<string>(m["RuleDescription"]));
    }
    if (m.find("RuleStatus") != m.end() && !m["RuleStatus"].empty()) {
      ruleStatus = make_shared<long>(boost::any_cast<long>(m["RuleStatus"]));
    }
  }


  virtual ~GetSceneRuleResponseBodyData() = default;
};
class GetSceneRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<GetSceneRuleResponseBodyData> data{};

  GetSceneRuleResponseBody() {}

  explicit GetSceneRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetSceneRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetSceneRuleResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetSceneRuleResponseBody() = default;
};
class GetSceneRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetSceneRuleResponseBody> body{};

  GetSceneRuleResponse() {}

  explicit GetSceneRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSceneRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSceneRuleResponseBody>(model1);
      }
    }
  }


  virtual ~GetSceneRuleResponse() = default;
};
class GetThingModelTslRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> modelVersion{};
  shared_ptr<bool> simple{};
  shared_ptr<string> functionBlockId{};

  GetThingModelTslRequest() {}

  explicit GetThingModelTslRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (modelVersion) {
      res["ModelVersion"] = boost::any(*modelVersion);
    }
    if (simple) {
      res["Simple"] = boost::any(*simple);
    }
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ModelVersion") != m.end() && !m["ModelVersion"].empty()) {
      modelVersion = make_shared<string>(boost::any_cast<string>(m["ModelVersion"]));
    }
    if (m.find("Simple") != m.end() && !m["Simple"].empty()) {
      simple = make_shared<bool>(boost::any_cast<bool>(m["Simple"]));
    }
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
  }


  virtual ~GetThingModelTslRequest() = default;
};
class GetThingModelTslResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> tslStr{};
  shared_ptr<string> tslUri{};

  GetThingModelTslResponseBodyData() {}

  explicit GetThingModelTslResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tslStr) {
      res["TslStr"] = boost::any(*tslStr);
    }
    if (tslUri) {
      res["TslUri"] = boost::any(*tslUri);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TslStr") != m.end() && !m["TslStr"].empty()) {
      tslStr = make_shared<string>(boost::any_cast<string>(m["TslStr"]));
    }
    if (m.find("TslUri") != m.end() && !m["TslUri"].empty()) {
      tslUri = make_shared<string>(boost::any_cast<string>(m["TslUri"]));
    }
  }


  virtual ~GetThingModelTslResponseBodyData() = default;
};
class GetThingModelTslResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetThingModelTslResponseBodyData> data{};

  GetThingModelTslResponseBody() {}

  explicit GetThingModelTslResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetThingModelTslResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetThingModelTslResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetThingModelTslResponseBody() = default;
};
class GetThingModelTslResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetThingModelTslResponseBody> body{};

  GetThingModelTslResponse() {}

  explicit GetThingModelTslResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetThingModelTslResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetThingModelTslResponseBody>(model1);
      }
    }
  }


  virtual ~GetThingModelTslResponse() = default;
};
class GetThingModelTslPublishedRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> simple{};
  shared_ptr<string> modelVersion{};
  shared_ptr<string> functionBlockId{};

  GetThingModelTslPublishedRequest() {}

  explicit GetThingModelTslPublishedRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (simple) {
      res["Simple"] = boost::any(*simple);
    }
    if (modelVersion) {
      res["ModelVersion"] = boost::any(*modelVersion);
    }
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Simple") != m.end() && !m["Simple"].empty()) {
      simple = make_shared<bool>(boost::any_cast<bool>(m["Simple"]));
    }
    if (m.find("ModelVersion") != m.end() && !m["ModelVersion"].empty()) {
      modelVersion = make_shared<string>(boost::any_cast<string>(m["ModelVersion"]));
    }
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
  }


  virtual ~GetThingModelTslPublishedRequest() = default;
};
class GetThingModelTslPublishedResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> tslStr{};
  shared_ptr<string> tslUri{};

  GetThingModelTslPublishedResponseBodyData() {}

  explicit GetThingModelTslPublishedResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tslStr) {
      res["TslStr"] = boost::any(*tslStr);
    }
    if (tslUri) {
      res["TslUri"] = boost::any(*tslUri);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TslStr") != m.end() && !m["TslStr"].empty()) {
      tslStr = make_shared<string>(boost::any_cast<string>(m["TslStr"]));
    }
    if (m.find("TslUri") != m.end() && !m["TslUri"].empty()) {
      tslUri = make_shared<string>(boost::any_cast<string>(m["TslUri"]));
    }
  }


  virtual ~GetThingModelTslPublishedResponseBodyData() = default;
};
class GetThingModelTslPublishedResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetThingModelTslPublishedResponseBodyData> data{};

  GetThingModelTslPublishedResponseBody() {}

  explicit GetThingModelTslPublishedResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetThingModelTslPublishedResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetThingModelTslPublishedResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetThingModelTslPublishedResponseBody() = default;
};
class GetThingModelTslPublishedResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetThingModelTslPublishedResponseBody> body{};

  GetThingModelTslPublishedResponse() {}

  explicit GetThingModelTslPublishedResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetThingModelTslPublishedResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetThingModelTslPublishedResponseBody>(model1);
      }
    }
  }


  virtual ~GetThingModelTslPublishedResponse() = default;
};
class GetThingScriptRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  GetThingScriptRequest() {}

  explicit GetThingScriptRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~GetThingScriptRequest() = default;
};
class GetThingScriptResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> scriptType{};
  shared_ptr<string> scriptUrl{};

  GetThingScriptResponseBodyData() {}

  explicit GetThingScriptResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scriptType) {
      res["ScriptType"] = boost::any(*scriptType);
    }
    if (scriptUrl) {
      res["ScriptUrl"] = boost::any(*scriptUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScriptType") != m.end() && !m["ScriptType"].empty()) {
      scriptType = make_shared<string>(boost::any_cast<string>(m["ScriptType"]));
    }
    if (m.find("ScriptUrl") != m.end() && !m["ScriptUrl"].empty()) {
      scriptUrl = make_shared<string>(boost::any_cast<string>(m["ScriptUrl"]));
    }
  }


  virtual ~GetThingScriptResponseBodyData() = default;
};
class GetThingScriptResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetThingScriptResponseBodyData> data{};

  GetThingScriptResponseBody() {}

  explicit GetThingScriptResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetThingScriptResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetThingScriptResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetThingScriptResponseBody() = default;
};
class GetThingScriptResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetThingScriptResponseBody> body{};

  GetThingScriptResponse() {}

  explicit GetThingScriptResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetThingScriptResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetThingScriptResponseBody>(model1);
      }
    }
  }


  virtual ~GetThingScriptResponse() = default;
};
class GetThingTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> categoryKey{};

  GetThingTemplateRequest() {}

  explicit GetThingTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (categoryKey) {
      res["CategoryKey"] = boost::any(*categoryKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("CategoryKey") != m.end() && !m["CategoryKey"].empty()) {
      categoryKey = make_shared<string>(boost::any_cast<string>(m["CategoryKey"]));
    }
  }


  virtual ~GetThingTemplateRequest() = default;
};
class GetThingTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> thingModelJSON{};

  GetThingTemplateResponseBody() {}

  explicit GetThingTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (thingModelJSON) {
      res["ThingModelJSON"] = boost::any(*thingModelJSON);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ThingModelJSON") != m.end() && !m["ThingModelJSON"].empty()) {
      thingModelJSON = make_shared<string>(boost::any_cast<string>(m["ThingModelJSON"]));
    }
  }


  virtual ~GetThingTemplateResponseBody() = default;
};
class GetThingTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetThingTemplateResponseBody> body{};

  GetThingTemplateResponse() {}

  explicit GetThingTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetThingTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetThingTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~GetThingTemplateResponse() = default;
};
class GetThingTopoRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<long> pageNo{};
  shared_ptr<string> iotId{};

  GetThingTopoRequest() {}

  explicit GetThingTopoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~GetThingTopoRequest() = default;
};
class GetThingTopoResponseBodyDataListDeviceInfo : public Darabonba::Model {
public:
  shared_ptr<string> iotId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};

  GetThingTopoResponseBodyDataListDeviceInfo() {}

  explicit GetThingTopoResponseBodyDataListDeviceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
  }


  virtual ~GetThingTopoResponseBodyDataListDeviceInfo() = default;
};
class GetThingTopoResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<GetThingTopoResponseBodyDataListDeviceInfo>> deviceInfo{};

  GetThingTopoResponseBodyDataList() {}

  explicit GetThingTopoResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*deviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["deviceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("deviceInfo") != m.end() && !m["deviceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["deviceInfo"].type()) {
        vector<GetThingTopoResponseBodyDataListDeviceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["deviceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetThingTopoResponseBodyDataListDeviceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceInfo = make_shared<vector<GetThingTopoResponseBodyDataListDeviceInfo>>(expect1);
      }
    }
  }


  virtual ~GetThingTopoResponseBodyDataList() = default;
};
class GetThingTopoResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> total{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageCount{};
  shared_ptr<GetThingTopoResponseBodyDataList> list{};

  GetThingTopoResponseBodyData() {}

  explicit GetThingTopoResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        GetThingTopoResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<GetThingTopoResponseBodyDataList>(model1);
      }
    }
  }


  virtual ~GetThingTopoResponseBodyData() = default;
};
class GetThingTopoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetThingTopoResponseBodyData> data{};

  GetThingTopoResponseBody() {}

  explicit GetThingTopoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetThingTopoResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetThingTopoResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetThingTopoResponseBody() = default;
};
class GetThingTopoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetThingTopoResponseBody> body{};

  GetThingTopoResponse() {}

  explicit GetThingTopoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetThingTopoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetThingTopoResponseBody>(model1);
      }
    }
  }


  virtual ~GetThingTopoResponse() = default;
};
class ImportThingModelTslRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> tslStr{};
  shared_ptr<string> tslUrl{};
  shared_ptr<string> functionBlockId{};
  shared_ptr<string> functionBlockName{};

  ImportThingModelTslRequest() {}

  explicit ImportThingModelTslRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (tslStr) {
      res["TslStr"] = boost::any(*tslStr);
    }
    if (tslUrl) {
      res["TslUrl"] = boost::any(*tslUrl);
    }
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    if (functionBlockName) {
      res["FunctionBlockName"] = boost::any(*functionBlockName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("TslStr") != m.end() && !m["TslStr"].empty()) {
      tslStr = make_shared<string>(boost::any_cast<string>(m["TslStr"]));
    }
    if (m.find("TslUrl") != m.end() && !m["TslUrl"].empty()) {
      tslUrl = make_shared<string>(boost::any_cast<string>(m["TslUrl"]));
    }
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
    if (m.find("FunctionBlockName") != m.end() && !m["FunctionBlockName"].empty()) {
      functionBlockName = make_shared<string>(boost::any_cast<string>(m["FunctionBlockName"]));
    }
  }


  virtual ~ImportThingModelTslRequest() = default;
};
class ImportThingModelTslResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  ImportThingModelTslResponseBody() {}

  explicit ImportThingModelTslResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~ImportThingModelTslResponseBody() = default;
};
class ImportThingModelTslResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ImportThingModelTslResponseBody> body{};

  ImportThingModelTslResponse() {}

  explicit ImportThingModelTslResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportThingModelTslResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportThingModelTslResponseBody>(model1);
      }
    }
  }


  virtual ~ImportThingModelTslResponse() = default;
};
class InvokeDataAPIServiceRequestParam : public Darabonba::Model {
public:
  shared_ptr<string> paramType{};
  shared_ptr<vector<string>> listParamValue{};
  shared_ptr<string> listParamType{};
  shared_ptr<string> paramName{};
  shared_ptr<string> paramValue{};

  InvokeDataAPIServiceRequestParam() {}

  explicit InvokeDataAPIServiceRequestParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (paramType) {
      res["ParamType"] = boost::any(*paramType);
    }
    if (listParamValue) {
      res["ListParamValue"] = boost::any(*listParamValue);
    }
    if (listParamType) {
      res["ListParamType"] = boost::any(*listParamType);
    }
    if (paramName) {
      res["ParamName"] = boost::any(*paramName);
    }
    if (paramValue) {
      res["ParamValue"] = boost::any(*paramValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParamType") != m.end() && !m["ParamType"].empty()) {
      paramType = make_shared<string>(boost::any_cast<string>(m["ParamType"]));
    }
    if (m.find("ListParamValue") != m.end() && !m["ListParamValue"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ListParamValue"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ListParamValue"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      listParamValue = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ListParamType") != m.end() && !m["ListParamType"].empty()) {
      listParamType = make_shared<string>(boost::any_cast<string>(m["ListParamType"]));
    }
    if (m.find("ParamName") != m.end() && !m["ParamName"].empty()) {
      paramName = make_shared<string>(boost::any_cast<string>(m["ParamName"]));
    }
    if (m.find("ParamValue") != m.end() && !m["ParamValue"].empty()) {
      paramValue = make_shared<string>(boost::any_cast<string>(m["ParamValue"]));
    }
  }


  virtual ~InvokeDataAPIServiceRequestParam() = default;
};
class InvokeDataAPIServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiSrn{};
  shared_ptr<vector<InvokeDataAPIServiceRequestParam>> param{};
  shared_ptr<string> iotInstanceId{};

  InvokeDataAPIServiceRequest() {}

  explicit InvokeDataAPIServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiSrn) {
      res["ApiSrn"] = boost::any(*apiSrn);
    }
    if (param) {
      vector<boost::any> temp1;
      for(auto item1:*param){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Param"] = boost::any(temp1);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiSrn") != m.end() && !m["ApiSrn"].empty()) {
      apiSrn = make_shared<string>(boost::any_cast<string>(m["ApiSrn"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      if (typeid(vector<boost::any>) == m["Param"].type()) {
        vector<InvokeDataAPIServiceRequestParam> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Param"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InvokeDataAPIServiceRequestParam model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        param = make_shared<vector<InvokeDataAPIServiceRequestParam>>(expect1);
      }
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~InvokeDataAPIServiceRequest() = default;
};
class InvokeDataAPIServiceResponseBodyDataFieldNameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fieldNameList{};

  InvokeDataAPIServiceResponseBodyDataFieldNameList() {}

  explicit InvokeDataAPIServiceResponseBodyDataFieldNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldNameList) {
      res["FieldNameList"] = boost::any(*fieldNameList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldNameList") != m.end() && !m["FieldNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FieldNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FieldNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fieldNameList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~InvokeDataAPIServiceResponseBodyDataFieldNameList() = default;
};
class InvokeDataAPIServiceResponseBodyDataResultList : public Darabonba::Model {
public:
  shared_ptr<vector<map<string, string>>> resultList{};

  InvokeDataAPIServiceResponseBodyDataResultList() {}

  explicit InvokeDataAPIServiceResponseBodyDataResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resultList) {
      res["ResultList"] = boost::any(*resultList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResultList") != m.end() && !m["ResultList"].empty()) {
      vector<map<string, string>> toVec1;
      if (typeid(vector<boost::any>) == m["ResultList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResultList"]);
        for (auto item:vec1) {
          map<string, string> map2 = boost::any_cast<map<string, string>>(item);
          map<string, string> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      resultList = make_shared<vector<map<string, string>>>(toVec1);
    }
  }


  virtual ~InvokeDataAPIServiceResponseBodyDataResultList() = default;
};
class InvokeDataAPIServiceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> apiSrn{};
  shared_ptr<InvokeDataAPIServiceResponseBodyDataFieldNameList> fieldNameList{};
  shared_ptr<InvokeDataAPIServiceResponseBodyDataResultList> resultList{};

  InvokeDataAPIServiceResponseBodyData() {}

  explicit InvokeDataAPIServiceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (apiSrn) {
      res["ApiSrn"] = boost::any(*apiSrn);
    }
    if (fieldNameList) {
      res["FieldNameList"] = fieldNameList ? boost::any(fieldNameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultList) {
      res["ResultList"] = resultList ? boost::any(resultList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ApiSrn") != m.end() && !m["ApiSrn"].empty()) {
      apiSrn = make_shared<string>(boost::any_cast<string>(m["ApiSrn"]));
    }
    if (m.find("FieldNameList") != m.end() && !m["FieldNameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["FieldNameList"].type()) {
        InvokeDataAPIServiceResponseBodyDataFieldNameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FieldNameList"]));
        fieldNameList = make_shared<InvokeDataAPIServiceResponseBodyDataFieldNameList>(model1);
      }
    }
    if (m.find("ResultList") != m.end() && !m["ResultList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultList"].type()) {
        InvokeDataAPIServiceResponseBodyDataResultList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultList"]));
        resultList = make_shared<InvokeDataAPIServiceResponseBodyDataResultList>(model1);
      }
    }
  }


  virtual ~InvokeDataAPIServiceResponseBodyData() = default;
};
class InvokeDataAPIServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<InvokeDataAPIServiceResponseBodyData> data{};

  InvokeDataAPIServiceResponseBody() {}

  explicit InvokeDataAPIServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        InvokeDataAPIServiceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<InvokeDataAPIServiceResponseBodyData>(model1);
      }
    }
  }


  virtual ~InvokeDataAPIServiceResponseBody() = default;
};
class InvokeDataAPIServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<InvokeDataAPIServiceResponseBody> body{};

  InvokeDataAPIServiceResponse() {}

  explicit InvokeDataAPIServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InvokeDataAPIServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InvokeDataAPIServiceResponseBody>(model1);
      }
    }
  }


  virtual ~InvokeDataAPIServiceResponse() = default;
};
class InvokeThingServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> identifier{};
  shared_ptr<string> args{};
  shared_ptr<string> iotId{};

  InvokeThingServiceRequest() {}

  explicit InvokeThingServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (args) {
      res["Args"] = boost::any(*args);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Args") != m.end() && !m["Args"].empty()) {
      args = make_shared<string>(boost::any_cast<string>(m["Args"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~InvokeThingServiceRequest() = default;
};
class InvokeThingServiceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> result{};
  shared_ptr<string> messageId{};

  InvokeThingServiceResponseBodyData() {}

  explicit InvokeThingServiceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~InvokeThingServiceResponseBodyData() = default;
};
class InvokeThingServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<InvokeThingServiceResponseBodyData> data{};

  InvokeThingServiceResponseBody() {}

  explicit InvokeThingServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        InvokeThingServiceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<InvokeThingServiceResponseBodyData>(model1);
      }
    }
  }


  virtual ~InvokeThingServiceResponseBody() = default;
};
class InvokeThingServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<InvokeThingServiceResponseBody> body{};

  InvokeThingServiceResponse() {}

  explicit InvokeThingServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InvokeThingServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InvokeThingServiceResponseBody>(model1);
      }
    }
  }


  virtual ~InvokeThingServiceResponse() = default;
};
class InvokeThingsServiceRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> identifier{};
  shared_ptr<string> args{};

  InvokeThingsServiceRequest() {}

  explicit InvokeThingsServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (args) {
      res["Args"] = boost::any(*args);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Args") != m.end() && !m["Args"].empty()) {
      args = make_shared<string>(boost::any_cast<string>(m["Args"]));
    }
  }


  virtual ~InvokeThingsServiceRequest() = default;
};
class InvokeThingsServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};

  InvokeThingsServiceResponseBody() {}

  explicit InvokeThingsServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~InvokeThingsServiceResponseBody() = default;
};
class InvokeThingsServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<InvokeThingsServiceResponseBody> body{};

  InvokeThingsServiceResponse() {}

  explicit InvokeThingsServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InvokeThingsServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InvokeThingsServiceResponseBody>(model1);
      }
    }
  }


  virtual ~InvokeThingsServiceResponse() = default;
};
class ListAnalyticsDataRequestCondition : public Darabonba::Model {
public:
  shared_ptr<string> fieldName{};
  shared_ptr<string> operate{};
  shared_ptr<string> value{};
  shared_ptr<string> betweenStart{};
  shared_ptr<string> betweenEnd{};

  ListAnalyticsDataRequestCondition() {}

  explicit ListAnalyticsDataRequestCondition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    if (operate) {
      res["Operate"] = boost::any(*operate);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (betweenStart) {
      res["BetweenStart"] = boost::any(*betweenStart);
    }
    if (betweenEnd) {
      res["BetweenEnd"] = boost::any(*betweenEnd);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
    if (m.find("Operate") != m.end() && !m["Operate"].empty()) {
      operate = make_shared<string>(boost::any_cast<string>(m["Operate"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("BetweenStart") != m.end() && !m["BetweenStart"].empty()) {
      betweenStart = make_shared<string>(boost::any_cast<string>(m["BetweenStart"]));
    }
    if (m.find("BetweenEnd") != m.end() && !m["BetweenEnd"].empty()) {
      betweenEnd = make_shared<string>(boost::any_cast<string>(m["BetweenEnd"]));
    }
  }


  virtual ~ListAnalyticsDataRequestCondition() = default;
};
class ListAnalyticsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> isoId{};
  shared_ptr<string> apiPath{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListAnalyticsDataRequestCondition>> condition{};
  shared_ptr<long> pageNum{};

  ListAnalyticsDataRequest() {}

  explicit ListAnalyticsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (isoId) {
      res["IsoId"] = boost::any(*isoId);
    }
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (condition) {
      vector<boost::any> temp1;
      for(auto item1:*condition){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Condition"] = boost::any(temp1);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("IsoId") != m.end() && !m["IsoId"].empty()) {
      isoId = make_shared<string>(boost::any_cast<string>(m["IsoId"]));
    }
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      if (typeid(vector<boost::any>) == m["Condition"].type()) {
        vector<ListAnalyticsDataRequestCondition> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Condition"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAnalyticsDataRequestCondition model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        condition = make_shared<vector<ListAnalyticsDataRequestCondition>>(expect1);
      }
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
  }


  virtual ~ListAnalyticsDataRequest() = default;
};
class ListAnalyticsDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> hasNext{};
  shared_ptr<string> resultJson{};
  shared_ptr<long> count{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};

  ListAnalyticsDataResponseBodyData() {}

  explicit ListAnalyticsDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasNext) {
      res["HasNext"] = boost::any(*hasNext);
    }
    if (resultJson) {
      res["ResultJson"] = boost::any(*resultJson);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HasNext") != m.end() && !m["HasNext"].empty()) {
      hasNext = make_shared<bool>(boost::any_cast<bool>(m["HasNext"]));
    }
    if (m.find("ResultJson") != m.end() && !m["ResultJson"].empty()) {
      resultJson = make_shared<string>(boost::any_cast<string>(m["ResultJson"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListAnalyticsDataResponseBodyData() = default;
};
class ListAnalyticsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<ListAnalyticsDataResponseBodyData> data{};

  ListAnalyticsDataResponseBody() {}

  explicit ListAnalyticsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListAnalyticsDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListAnalyticsDataResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListAnalyticsDataResponseBody() = default;
};
class ListAnalyticsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListAnalyticsDataResponseBody> body{};

  ListAnalyticsDataResponse() {}

  explicit ListAnalyticsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAnalyticsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAnalyticsDataResponseBody>(model1);
      }
    }
  }


  virtual ~ListAnalyticsDataResponse() = default;
};
class ListDeviceDistributeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> targetUid{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> status{};

  ListDeviceDistributeJobRequest() {}

  explicit ListDeviceDistributeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetUid) {
      res["TargetUid"] = boost::any(*targetUid);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetUid") != m.end() && !m["TargetUid"].empty()) {
      targetUid = make_shared<string>(boost::any_cast<string>(m["TargetUid"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~ListDeviceDistributeJobRequest() = default;
};
class ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs : public Darabonba::Model {
public:
  shared_ptr<string> targetInstanceId{};

  ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs() {}

  explicit ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
  }


  virtual ~ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs() = default;
};
class ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs>> targetInstanceConfigs{};

  ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs() {}

  explicit ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetInstanceConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*targetInstanceConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["targetInstanceConfigs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("targetInstanceConfigs") != m.end() && !m["targetInstanceConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["targetInstanceConfigs"].type()) {
        vector<ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["targetInstanceConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targetInstanceConfigs = make_shared<vector<ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs>>(expect1);
      }
    }
  }


  virtual ~ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs() = default;
};
class ListDeviceDistributeJobResponseBodyDataJobInfoItems : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> sourceUid{};
  shared_ptr<string> targetUid{};
  shared_ptr<string> jobId{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<long> total{};
  shared_ptr<long> status{};
  shared_ptr<long> strategy{};
  shared_ptr<ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs> targetInstanceConfigs{};

  ListDeviceDistributeJobResponseBodyDataJobInfoItems() {}

  explicit ListDeviceDistributeJobResponseBodyDataJobInfoItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (sourceUid) {
      res["SourceUid"] = boost::any(*sourceUid);
    }
    if (targetUid) {
      res["TargetUid"] = boost::any(*targetUid);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (strategy) {
      res["Strategy"] = boost::any(*strategy);
    }
    if (targetInstanceConfigs) {
      res["TargetInstanceConfigs"] = targetInstanceConfigs ? boost::any(targetInstanceConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("SourceUid") != m.end() && !m["SourceUid"].empty()) {
      sourceUid = make_shared<string>(boost::any_cast<string>(m["SourceUid"]));
    }
    if (m.find("TargetUid") != m.end() && !m["TargetUid"].empty()) {
      targetUid = make_shared<string>(boost::any_cast<string>(m["TargetUid"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      strategy = make_shared<long>(boost::any_cast<long>(m["Strategy"]));
    }
    if (m.find("TargetInstanceConfigs") != m.end() && !m["TargetInstanceConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["TargetInstanceConfigs"].type()) {
        ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TargetInstanceConfigs"]));
        targetInstanceConfigs = make_shared<ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs>(model1);
      }
    }
  }


  virtual ~ListDeviceDistributeJobResponseBodyDataJobInfoItems() = default;
};
class ListDeviceDistributeJobResponseBodyDataJobInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDeviceDistributeJobResponseBodyDataJobInfoItems>> items{};

  ListDeviceDistributeJobResponseBodyDataJobInfo() {}

  explicit ListDeviceDistributeJobResponseBodyDataJobInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<ListDeviceDistributeJobResponseBodyDataJobInfoItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDeviceDistributeJobResponseBodyDataJobInfoItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<ListDeviceDistributeJobResponseBodyDataJobInfoItems>>(expect1);
      }
    }
  }


  virtual ~ListDeviceDistributeJobResponseBodyDataJobInfo() = default;
};
class ListDeviceDistributeJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> total{};
  shared_ptr<ListDeviceDistributeJobResponseBodyDataJobInfo> jobInfo{};

  ListDeviceDistributeJobResponseBodyData() {}

  explicit ListDeviceDistributeJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (jobInfo) {
      res["JobInfo"] = jobInfo ? boost::any(jobInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("JobInfo") != m.end() && !m["JobInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobInfo"].type()) {
        ListDeviceDistributeJobResponseBodyDataJobInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobInfo"]));
        jobInfo = make_shared<ListDeviceDistributeJobResponseBodyDataJobInfo>(model1);
      }
    }
  }


  virtual ~ListDeviceDistributeJobResponseBodyData() = default;
};
class ListDeviceDistributeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<ListDeviceDistributeJobResponseBodyData> data{};

  ListDeviceDistributeJobResponseBody() {}

  explicit ListDeviceDistributeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListDeviceDistributeJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListDeviceDistributeJobResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListDeviceDistributeJobResponseBody() = default;
};
class ListDeviceDistributeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListDeviceDistributeJobResponseBody> body{};

  ListDeviceDistributeJobResponse() {}

  explicit ListDeviceDistributeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDeviceDistributeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDeviceDistributeJobResponseBody>(model1);
      }
    }
  }


  virtual ~ListDeviceDistributeJobResponse() = default;
};
class ListDistributedDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> targetUid{};
  shared_ptr<string> sourceInstanceId{};

  ListDistributedDeviceRequest() {}

  explicit ListDistributedDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (targetUid) {
      res["TargetUid"] = boost::any(*targetUid);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("TargetUid") != m.end() && !m["TargetUid"].empty()) {
      targetUid = make_shared<string>(boost::any_cast<string>(m["TargetUid"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
  }


  virtual ~ListDistributedDeviceRequest() = default;
};
class ListDistributedDeviceResponseBodyDataInfoItems : public Darabonba::Model {
public:
  shared_ptr<string> sourceUid{};
  shared_ptr<string> targetUid{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> targetInstanceId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> targetAliyunId{};
  shared_ptr<string> sourceRegion{};
  shared_ptr<string> targetRegion{};
  shared_ptr<string> sourceInstanceName{};
  shared_ptr<string> targetInstanceName{};
  shared_ptr<long> gmtModified{};

  ListDistributedDeviceResponseBodyDataInfoItems() {}

  explicit ListDistributedDeviceResponseBodyDataInfoItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceUid) {
      res["SourceUid"] = boost::any(*sourceUid);
    }
    if (targetUid) {
      res["TargetUid"] = boost::any(*targetUid);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (targetAliyunId) {
      res["TargetAliyunId"] = boost::any(*targetAliyunId);
    }
    if (sourceRegion) {
      res["SourceRegion"] = boost::any(*sourceRegion);
    }
    if (targetRegion) {
      res["TargetRegion"] = boost::any(*targetRegion);
    }
    if (sourceInstanceName) {
      res["SourceInstanceName"] = boost::any(*sourceInstanceName);
    }
    if (targetInstanceName) {
      res["TargetInstanceName"] = boost::any(*targetInstanceName);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceUid") != m.end() && !m["SourceUid"].empty()) {
      sourceUid = make_shared<string>(boost::any_cast<string>(m["SourceUid"]));
    }
    if (m.find("TargetUid") != m.end() && !m["TargetUid"].empty()) {
      targetUid = make_shared<string>(boost::any_cast<string>(m["TargetUid"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("TargetAliyunId") != m.end() && !m["TargetAliyunId"].empty()) {
      targetAliyunId = make_shared<string>(boost::any_cast<string>(m["TargetAliyunId"]));
    }
    if (m.find("SourceRegion") != m.end() && !m["SourceRegion"].empty()) {
      sourceRegion = make_shared<string>(boost::any_cast<string>(m["SourceRegion"]));
    }
    if (m.find("TargetRegion") != m.end() && !m["TargetRegion"].empty()) {
      targetRegion = make_shared<string>(boost::any_cast<string>(m["TargetRegion"]));
    }
    if (m.find("SourceInstanceName") != m.end() && !m["SourceInstanceName"].empty()) {
      sourceInstanceName = make_shared<string>(boost::any_cast<string>(m["SourceInstanceName"]));
    }
    if (m.find("TargetInstanceName") != m.end() && !m["TargetInstanceName"].empty()) {
      targetInstanceName = make_shared<string>(boost::any_cast<string>(m["TargetInstanceName"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
  }


  virtual ~ListDistributedDeviceResponseBodyDataInfoItems() = default;
};
class ListDistributedDeviceResponseBodyDataInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDistributedDeviceResponseBodyDataInfoItems>> items{};

  ListDistributedDeviceResponseBodyDataInfo() {}

  explicit ListDistributedDeviceResponseBodyDataInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<ListDistributedDeviceResponseBodyDataInfoItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDistributedDeviceResponseBodyDataInfoItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<ListDistributedDeviceResponseBodyDataInfoItems>>(expect1);
      }
    }
  }


  virtual ~ListDistributedDeviceResponseBodyDataInfo() = default;
};
class ListDistributedDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> total{};
  shared_ptr<ListDistributedDeviceResponseBodyDataInfo> info{};

  ListDistributedDeviceResponseBodyData() {}

  explicit ListDistributedDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (info) {
      res["Info"] = info ? boost::any(info->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      if (typeid(map<string, boost::any>) == m["Info"].type()) {
        ListDistributedDeviceResponseBodyDataInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Info"]));
        info = make_shared<ListDistributedDeviceResponseBodyDataInfo>(model1);
      }
    }
  }


  virtual ~ListDistributedDeviceResponseBodyData() = default;
};
class ListDistributedDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<ListDistributedDeviceResponseBodyData> data{};

  ListDistributedDeviceResponseBody() {}

  explicit ListDistributedDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListDistributedDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListDistributedDeviceResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListDistributedDeviceResponseBody() = default;
};
class ListDistributedDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListDistributedDeviceResponseBody> body{};

  ListDistributedDeviceResponse() {}

  explicit ListDistributedDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDistributedDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDistributedDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~ListDistributedDeviceResponse() = default;
};
class ListDistributedProductRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> targetInstanceId{};
  shared_ptr<string> targetUid{};
  shared_ptr<long> currentPage{};

  ListDistributedProductRequest() {}

  explicit ListDistributedProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    if (targetUid) {
      res["TargetUid"] = boost::any(*targetUid);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
    if (m.find("TargetUid") != m.end() && !m["TargetUid"].empty()) {
      targetUid = make_shared<string>(boost::any_cast<string>(m["TargetUid"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~ListDistributedProductRequest() = default;
};
class ListDistributedProductResponseBodyDataInfoItems : public Darabonba::Model {
public:
  shared_ptr<string> sourceUid{};
  shared_ptr<string> targetUid{};
  shared_ptr<string> productKey{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> targetInstanceId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> targetAliyunId{};
  shared_ptr<string> sourceRegion{};
  shared_ptr<string> targetRegion{};
  shared_ptr<string> sourceInstanceName{};
  shared_ptr<string> targetInstanceName{};

  ListDistributedProductResponseBodyDataInfoItems() {}

  explicit ListDistributedProductResponseBodyDataInfoItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceUid) {
      res["SourceUid"] = boost::any(*sourceUid);
    }
    if (targetUid) {
      res["TargetUid"] = boost::any(*targetUid);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (targetAliyunId) {
      res["TargetAliyunId"] = boost::any(*targetAliyunId);
    }
    if (sourceRegion) {
      res["SourceRegion"] = boost::any(*sourceRegion);
    }
    if (targetRegion) {
      res["TargetRegion"] = boost::any(*targetRegion);
    }
    if (sourceInstanceName) {
      res["SourceInstanceName"] = boost::any(*sourceInstanceName);
    }
    if (targetInstanceName) {
      res["TargetInstanceName"] = boost::any(*targetInstanceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceUid") != m.end() && !m["SourceUid"].empty()) {
      sourceUid = make_shared<string>(boost::any_cast<string>(m["SourceUid"]));
    }
    if (m.find("TargetUid") != m.end() && !m["TargetUid"].empty()) {
      targetUid = make_shared<string>(boost::any_cast<string>(m["TargetUid"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("TargetAliyunId") != m.end() && !m["TargetAliyunId"].empty()) {
      targetAliyunId = make_shared<string>(boost::any_cast<string>(m["TargetAliyunId"]));
    }
    if (m.find("SourceRegion") != m.end() && !m["SourceRegion"].empty()) {
      sourceRegion = make_shared<string>(boost::any_cast<string>(m["SourceRegion"]));
    }
    if (m.find("TargetRegion") != m.end() && !m["TargetRegion"].empty()) {
      targetRegion = make_shared<string>(boost::any_cast<string>(m["TargetRegion"]));
    }
    if (m.find("SourceInstanceName") != m.end() && !m["SourceInstanceName"].empty()) {
      sourceInstanceName = make_shared<string>(boost::any_cast<string>(m["SourceInstanceName"]));
    }
    if (m.find("TargetInstanceName") != m.end() && !m["TargetInstanceName"].empty()) {
      targetInstanceName = make_shared<string>(boost::any_cast<string>(m["TargetInstanceName"]));
    }
  }


  virtual ~ListDistributedProductResponseBodyDataInfoItems() = default;
};
class ListDistributedProductResponseBodyDataInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDistributedProductResponseBodyDataInfoItems>> items{};

  ListDistributedProductResponseBodyDataInfo() {}

  explicit ListDistributedProductResponseBodyDataInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<ListDistributedProductResponseBodyDataInfoItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDistributedProductResponseBodyDataInfoItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<ListDistributedProductResponseBodyDataInfoItems>>(expect1);
      }
    }
  }


  virtual ~ListDistributedProductResponseBodyDataInfo() = default;
};
class ListDistributedProductResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> total{};
  shared_ptr<ListDistributedProductResponseBodyDataInfo> info{};

  ListDistributedProductResponseBodyData() {}

  explicit ListDistributedProductResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (info) {
      res["Info"] = info ? boost::any(info->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      if (typeid(map<string, boost::any>) == m["Info"].type()) {
        ListDistributedProductResponseBodyDataInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Info"]));
        info = make_shared<ListDistributedProductResponseBodyDataInfo>(model1);
      }
    }
  }


  virtual ~ListDistributedProductResponseBodyData() = default;
};
class ListDistributedProductResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<ListDistributedProductResponseBodyData> data{};

  ListDistributedProductResponseBody() {}

  explicit ListDistributedProductResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListDistributedProductResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListDistributedProductResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListDistributedProductResponseBody() = default;
};
class ListDistributedProductResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListDistributedProductResponseBody> body{};

  ListDistributedProductResponse() {}

  explicit ListDistributedProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDistributedProductResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDistributedProductResponseBody>(model1);
      }
    }
  }


  virtual ~ListDistributedProductResponse() = default;
};
class ListJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> status{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};

  ListJobRequest() {}

  explicit ListJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~ListJobRequest() = default;
};
class ListJobResponseBodyDataData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> jobName{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> utcModified{};
  shared_ptr<string> status{};
  shared_ptr<string> description{};
  shared_ptr<string> type{};

  ListJobResponseBodyDataData() {}

  explicit ListJobResponseBodyDataData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListJobResponseBodyDataData() = default;
};
class ListJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyDataData>> data{};

  ListJobResponseBodyData() {}

  explicit ListJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListJobResponseBodyDataData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyDataData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListJobResponseBodyDataData>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyData() = default;
};
class ListJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> total{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> page{};
  shared_ptr<ListJobResponseBodyData> data{};

  ListJobResponseBody() {}

  explicit ListJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListJobResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListJobResponseBody() = default;
};
class ListJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListJobResponseBody> body{};

  ListJobResponse() {}

  explicit ListJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListJobResponseBody>(model1);
      }
    }
  }


  virtual ~ListJobResponse() = default;
};
class ListOTAFirmwareRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> destVersion{};

  ListOTAFirmwareRequest() {}

  explicit ListOTAFirmwareRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (destVersion) {
      res["DestVersion"] = boost::any(*destVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DestVersion") != m.end() && !m["DestVersion"].empty()) {
      destVersion = make_shared<string>(boost::any_cast<string>(m["DestVersion"]));
    }
  }


  virtual ~ListOTAFirmwareRequest() = default;
};
class ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo : public Darabonba::Model {
public:
  shared_ptr<string> firmwareName{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> srcVersion{};
  shared_ptr<string> destVersion{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> utcModified{};
  shared_ptr<long> status{};
  shared_ptr<string> firmwareDesc{};
  shared_ptr<string> firmwareSign{};
  shared_ptr<long> firmwareSize{};
  shared_ptr<string> firmwareUrl{};
  shared_ptr<string> productKey{};
  shared_ptr<string> signMethod{};
  shared_ptr<string> productName{};
  shared_ptr<long> type{};
  shared_ptr<string> moduleName{};

  ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo() {}

  explicit ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (firmwareName) {
      res["FirmwareName"] = boost::any(*firmwareName);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (srcVersion) {
      res["SrcVersion"] = boost::any(*srcVersion);
    }
    if (destVersion) {
      res["DestVersion"] = boost::any(*destVersion);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (firmwareDesc) {
      res["FirmwareDesc"] = boost::any(*firmwareDesc);
    }
    if (firmwareSign) {
      res["FirmwareSign"] = boost::any(*firmwareSign);
    }
    if (firmwareSize) {
      res["FirmwareSize"] = boost::any(*firmwareSize);
    }
    if (firmwareUrl) {
      res["FirmwareUrl"] = boost::any(*firmwareUrl);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (signMethod) {
      res["SignMethod"] = boost::any(*signMethod);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FirmwareName") != m.end() && !m["FirmwareName"].empty()) {
      firmwareName = make_shared<string>(boost::any_cast<string>(m["FirmwareName"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("SrcVersion") != m.end() && !m["SrcVersion"].empty()) {
      srcVersion = make_shared<string>(boost::any_cast<string>(m["SrcVersion"]));
    }
    if (m.find("DestVersion") != m.end() && !m["DestVersion"].empty()) {
      destVersion = make_shared<string>(boost::any_cast<string>(m["DestVersion"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("FirmwareDesc") != m.end() && !m["FirmwareDesc"].empty()) {
      firmwareDesc = make_shared<string>(boost::any_cast<string>(m["FirmwareDesc"]));
    }
    if (m.find("FirmwareSign") != m.end() && !m["FirmwareSign"].empty()) {
      firmwareSign = make_shared<string>(boost::any_cast<string>(m["FirmwareSign"]));
    }
    if (m.find("FirmwareSize") != m.end() && !m["FirmwareSize"].empty()) {
      firmwareSize = make_shared<long>(boost::any_cast<long>(m["FirmwareSize"]));
    }
    if (m.find("FirmwareUrl") != m.end() && !m["FirmwareUrl"].empty()) {
      firmwareUrl = make_shared<string>(boost::any_cast<string>(m["FirmwareUrl"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("SignMethod") != m.end() && !m["SignMethod"].empty()) {
      signMethod = make_shared<string>(boost::any_cast<string>(m["SignMethod"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
  }


  virtual ~ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo() = default;
};
class ListOTAFirmwareResponseBodyFirmwareInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo>> simpleFirmwareInfo{};

  ListOTAFirmwareResponseBodyFirmwareInfo() {}

  explicit ListOTAFirmwareResponseBodyFirmwareInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (simpleFirmwareInfo) {
      vector<boost::any> temp1;
      for(auto item1:*simpleFirmwareInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SimpleFirmwareInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SimpleFirmwareInfo") != m.end() && !m["SimpleFirmwareInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SimpleFirmwareInfo"].type()) {
        vector<ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SimpleFirmwareInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        simpleFirmwareInfo = make_shared<vector<ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo>>(expect1);
      }
    }
  }


  virtual ~ListOTAFirmwareResponseBodyFirmwareInfo() = default;
};
class ListOTAFirmwareResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> total{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> currentPage{};
  shared_ptr<ListOTAFirmwareResponseBodyFirmwareInfo> firmwareInfo{};

  ListOTAFirmwareResponseBody() {}

  explicit ListOTAFirmwareResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (firmwareInfo) {
      res["FirmwareInfo"] = firmwareInfo ? boost::any(firmwareInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("FirmwareInfo") != m.end() && !m["FirmwareInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FirmwareInfo"].type()) {
        ListOTAFirmwareResponseBodyFirmwareInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FirmwareInfo"]));
        firmwareInfo = make_shared<ListOTAFirmwareResponseBodyFirmwareInfo>(model1);
      }
    }
  }


  virtual ~ListOTAFirmwareResponseBody() = default;
};
class ListOTAFirmwareResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListOTAFirmwareResponseBody> body{};

  ListOTAFirmwareResponse() {}

  explicit ListOTAFirmwareResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOTAFirmwareResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOTAFirmwareResponseBody>(model1);
      }
    }
  }


  virtual ~ListOTAFirmwareResponse() = default;
};
class ListOTAJobByDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> firmwareId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<long> currentPage{};

  ListOTAJobByDeviceRequest() {}

  explicit ListOTAJobByDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~ListOTAJobByDeviceRequest() = default;
};
class ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO() {}

  explicit ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO() = default;
};
class ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags : public Darabonba::Model {
public:
  shared_ptr<vector<ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO>> otaTagDTO{};

  ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags() {}

  explicit ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (otaTagDTO) {
      vector<boost::any> temp1;
      for(auto item1:*otaTagDTO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OtaTagDTO"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OtaTagDTO") != m.end() && !m["OtaTagDTO"].empty()) {
      if (typeid(vector<boost::any>) == m["OtaTagDTO"].type()) {
        vector<ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OtaTagDTO"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        otaTagDTO = make_shared<vector<ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO>>(expect1);
      }
    }
  }


  virtual ~ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags() = default;
};
class ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> utcModified{};
  shared_ptr<string> productKey{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> utcStartTime{};
  shared_ptr<string> utcEndTime{};
  shared_ptr<string> jobStatus{};
  shared_ptr<string> jobType{};
  shared_ptr<string> targetSelection{};
  shared_ptr<string> selectionType{};
  shared_ptr<ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags> tags{};

  ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo() {}

  explicit ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (utcStartTime) {
      res["UtcStartTime"] = boost::any(*utcStartTime);
    }
    if (utcEndTime) {
      res["UtcEndTime"] = boost::any(*utcEndTime);
    }
    if (jobStatus) {
      res["JobStatus"] = boost::any(*jobStatus);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (targetSelection) {
      res["TargetSelection"] = boost::any(*targetSelection);
    }
    if (selectionType) {
      res["SelectionType"] = boost::any(*selectionType);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("UtcStartTime") != m.end() && !m["UtcStartTime"].empty()) {
      utcStartTime = make_shared<string>(boost::any_cast<string>(m["UtcStartTime"]));
    }
    if (m.find("UtcEndTime") != m.end() && !m["UtcEndTime"].empty()) {
      utcEndTime = make_shared<string>(boost::any_cast<string>(m["UtcEndTime"]));
    }
    if (m.find("JobStatus") != m.end() && !m["JobStatus"].empty()) {
      jobStatus = make_shared<string>(boost::any_cast<string>(m["JobStatus"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("TargetSelection") != m.end() && !m["TargetSelection"].empty()) {
      targetSelection = make_shared<string>(boost::any_cast<string>(m["TargetSelection"]));
    }
    if (m.find("SelectionType") != m.end() && !m["SelectionType"].empty()) {
      selectionType = make_shared<string>(boost::any_cast<string>(m["SelectionType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags>(model1);
      }
    }
  }


  virtual ~ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo() = default;
};
class ListOTAJobByDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo>> simpleOTAJobInfo{};

  ListOTAJobByDeviceResponseBodyData() {}

  explicit ListOTAJobByDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (simpleOTAJobInfo) {
      vector<boost::any> temp1;
      for(auto item1:*simpleOTAJobInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SimpleOTAJobInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SimpleOTAJobInfo") != m.end() && !m["SimpleOTAJobInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SimpleOTAJobInfo"].type()) {
        vector<ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SimpleOTAJobInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        simpleOTAJobInfo = make_shared<vector<ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo>>(expect1);
      }
    }
  }


  virtual ~ListOTAJobByDeviceResponseBodyData() = default;
};
class ListOTAJobByDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> total{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> currentPage{};
  shared_ptr<ListOTAJobByDeviceResponseBodyData> data{};

  ListOTAJobByDeviceResponseBody() {}

  explicit ListOTAJobByDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListOTAJobByDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListOTAJobByDeviceResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListOTAJobByDeviceResponseBody() = default;
};
class ListOTAJobByDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListOTAJobByDeviceResponseBody> body{};

  ListOTAJobByDeviceResponse() {}

  explicit ListOTAJobByDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOTAJobByDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOTAJobByDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~ListOTAJobByDeviceResponse() = default;
};
class ListOTAJobByFirmwareRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> firmwareId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};

  ListOTAJobByFirmwareRequest() {}

  explicit ListOTAJobByFirmwareRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~ListOTAJobByFirmwareRequest() = default;
};
class ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO() {}

  explicit ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO() = default;
};
class ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags : public Darabonba::Model {
public:
  shared_ptr<vector<ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO>> otaTagDTO{};

  ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags() {}

  explicit ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (otaTagDTO) {
      vector<boost::any> temp1;
      for(auto item1:*otaTagDTO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OtaTagDTO"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OtaTagDTO") != m.end() && !m["OtaTagDTO"].empty()) {
      if (typeid(vector<boost::any>) == m["OtaTagDTO"].type()) {
        vector<ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OtaTagDTO"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        otaTagDTO = make_shared<vector<ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO>>(expect1);
      }
    }
  }


  virtual ~ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags() = default;
};
class ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> utcModified{};
  shared_ptr<string> productKey{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> utcStartTime{};
  shared_ptr<string> utcEndTime{};
  shared_ptr<string> jobStatus{};
  shared_ptr<string> jobType{};
  shared_ptr<string> targetSelection{};
  shared_ptr<string> selectionType{};
  shared_ptr<ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags> tags{};

  ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo() {}

  explicit ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (utcStartTime) {
      res["UtcStartTime"] = boost::any(*utcStartTime);
    }
    if (utcEndTime) {
      res["UtcEndTime"] = boost::any(*utcEndTime);
    }
    if (jobStatus) {
      res["JobStatus"] = boost::any(*jobStatus);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (targetSelection) {
      res["TargetSelection"] = boost::any(*targetSelection);
    }
    if (selectionType) {
      res["SelectionType"] = boost::any(*selectionType);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("UtcStartTime") != m.end() && !m["UtcStartTime"].empty()) {
      utcStartTime = make_shared<string>(boost::any_cast<string>(m["UtcStartTime"]));
    }
    if (m.find("UtcEndTime") != m.end() && !m["UtcEndTime"].empty()) {
      utcEndTime = make_shared<string>(boost::any_cast<string>(m["UtcEndTime"]));
    }
    if (m.find("JobStatus") != m.end() && !m["JobStatus"].empty()) {
      jobStatus = make_shared<string>(boost::any_cast<string>(m["JobStatus"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("TargetSelection") != m.end() && !m["TargetSelection"].empty()) {
      targetSelection = make_shared<string>(boost::any_cast<string>(m["TargetSelection"]));
    }
    if (m.find("SelectionType") != m.end() && !m["SelectionType"].empty()) {
      selectionType = make_shared<string>(boost::any_cast<string>(m["SelectionType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags>(model1);
      }
    }
  }


  virtual ~ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo() = default;
};
class ListOTAJobByFirmwareResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo>> simpleOTAJobInfo{};

  ListOTAJobByFirmwareResponseBodyData() {}

  explicit ListOTAJobByFirmwareResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (simpleOTAJobInfo) {
      vector<boost::any> temp1;
      for(auto item1:*simpleOTAJobInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SimpleOTAJobInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SimpleOTAJobInfo") != m.end() && !m["SimpleOTAJobInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SimpleOTAJobInfo"].type()) {
        vector<ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SimpleOTAJobInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        simpleOTAJobInfo = make_shared<vector<ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo>>(expect1);
      }
    }
  }


  virtual ~ListOTAJobByFirmwareResponseBodyData() = default;
};
class ListOTAJobByFirmwareResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> total{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> currentPage{};
  shared_ptr<ListOTAJobByFirmwareResponseBodyData> data{};

  ListOTAJobByFirmwareResponseBody() {}

  explicit ListOTAJobByFirmwareResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListOTAJobByFirmwareResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListOTAJobByFirmwareResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListOTAJobByFirmwareResponseBody() = default;
};
class ListOTAJobByFirmwareResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListOTAJobByFirmwareResponseBody> body{};

  ListOTAJobByFirmwareResponse() {}

  explicit ListOTAJobByFirmwareResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOTAJobByFirmwareResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOTAJobByFirmwareResponseBody>(model1);
      }
    }
  }


  virtual ~ListOTAJobByFirmwareResponse() = default;
};
class ListOTAModuleByProductRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  ListOTAModuleByProductRequest() {}

  explicit ListOTAModuleByProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~ListOTAModuleByProductRequest() = default;
};
class ListOTAModuleByProductResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> moduleName{};
  shared_ptr<string> aliasName{};
  shared_ptr<string> desc{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};

  ListOTAModuleByProductResponseBodyData() {}

  explicit ListOTAModuleByProductResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
  }


  virtual ~ListOTAModuleByProductResponseBodyData() = default;
};
class ListOTAModuleByProductResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<ListOTAModuleByProductResponseBodyData>> data{};

  ListOTAModuleByProductResponseBody() {}

  explicit ListOTAModuleByProductResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListOTAModuleByProductResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOTAModuleByProductResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListOTAModuleByProductResponseBodyData>>(expect1);
      }
    }
  }


  virtual ~ListOTAModuleByProductResponseBody() = default;
};
class ListOTAModuleByProductResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListOTAModuleByProductResponseBody> body{};

  ListOTAModuleByProductResponse() {}

  explicit ListOTAModuleByProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOTAModuleByProductResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOTAModuleByProductResponseBody>(model1);
      }
    }
  }


  virtual ~ListOTAModuleByProductResponse() = default;
};
class ListOTAModuleVersionsByDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<long> currentPage{};

  ListOTAModuleVersionsByDeviceRequest() {}

  explicit ListOTAModuleVersionsByDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~ListOTAModuleVersionsByDeviceRequest() = default;
};
class ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> moduleVersion{};
  shared_ptr<string> moduleName{};

  ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo() {}

  explicit ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (moduleVersion) {
      res["ModuleVersion"] = boost::any(*moduleVersion);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("ModuleVersion") != m.end() && !m["ModuleVersion"].empty()) {
      moduleVersion = make_shared<string>(boost::any_cast<string>(m["ModuleVersion"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
  }


  virtual ~ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo() = default;
};
class ListOTAModuleVersionsByDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo>> simpleOTAModuleInfo{};

  ListOTAModuleVersionsByDeviceResponseBodyData() {}

  explicit ListOTAModuleVersionsByDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (simpleOTAModuleInfo) {
      vector<boost::any> temp1;
      for(auto item1:*simpleOTAModuleInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SimpleOTAModuleInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SimpleOTAModuleInfo") != m.end() && !m["SimpleOTAModuleInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SimpleOTAModuleInfo"].type()) {
        vector<ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SimpleOTAModuleInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        simpleOTAModuleInfo = make_shared<vector<ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo>>(expect1);
      }
    }
  }


  virtual ~ListOTAModuleVersionsByDeviceResponseBodyData() = default;
};
class ListOTAModuleVersionsByDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> total{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> currentPage{};
  shared_ptr<ListOTAModuleVersionsByDeviceResponseBodyData> data{};

  ListOTAModuleVersionsByDeviceResponseBody() {}

  explicit ListOTAModuleVersionsByDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListOTAModuleVersionsByDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListOTAModuleVersionsByDeviceResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListOTAModuleVersionsByDeviceResponseBody() = default;
};
class ListOTAModuleVersionsByDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListOTAModuleVersionsByDeviceResponseBody> body{};

  ListOTAModuleVersionsByDeviceResponse() {}

  explicit ListOTAModuleVersionsByDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOTAModuleVersionsByDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOTAModuleVersionsByDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~ListOTAModuleVersionsByDeviceResponse() = default;
};
class ListOTATaskByJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> taskStatus{};
  shared_ptr<string> jobId{};
  shared_ptr<long> currentPage{};
  shared_ptr<vector<string>> deviceNames{};

  ListOTATaskByJobRequest() {}

  explicit ListOTATaskByJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (deviceNames) {
      res["DeviceNames"] = boost::any(*deviceNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DeviceNames") != m.end() && !m["DeviceNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListOTATaskByJobRequest() = default;
};
class ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};
  shared_ptr<string> utcModified{};
  shared_ptr<string> productKey{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> taskStatus{};
  shared_ptr<string> jobId{};
  shared_ptr<string> productName{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> srcVersion{};
  shared_ptr<string> destVersion{};
  shared_ptr<string> taskDesc{};
  shared_ptr<string> progress{};
  shared_ptr<string> iotId{};
  shared_ptr<string> utcCreate{};

  ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo() {}

  explicit ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (srcVersion) {
      res["SrcVersion"] = boost::any(*srcVersion);
    }
    if (destVersion) {
      res["DestVersion"] = boost::any(*destVersion);
    }
    if (taskDesc) {
      res["TaskDesc"] = boost::any(*taskDesc);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("SrcVersion") != m.end() && !m["SrcVersion"].empty()) {
      srcVersion = make_shared<string>(boost::any_cast<string>(m["SrcVersion"]));
    }
    if (m.find("DestVersion") != m.end() && !m["DestVersion"].empty()) {
      destVersion = make_shared<string>(boost::any_cast<string>(m["DestVersion"]));
    }
    if (m.find("TaskDesc") != m.end() && !m["TaskDesc"].empty()) {
      taskDesc = make_shared<string>(boost::any_cast<string>(m["TaskDesc"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
  }


  virtual ~ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo() = default;
};
class ListOTATaskByJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo>> simpleOTATaskInfo{};

  ListOTATaskByJobResponseBodyData() {}

  explicit ListOTATaskByJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (simpleOTATaskInfo) {
      vector<boost::any> temp1;
      for(auto item1:*simpleOTATaskInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SimpleOTATaskInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SimpleOTATaskInfo") != m.end() && !m["SimpleOTATaskInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SimpleOTATaskInfo"].type()) {
        vector<ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SimpleOTATaskInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        simpleOTATaskInfo = make_shared<vector<ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo>>(expect1);
      }
    }
  }


  virtual ~ListOTATaskByJobResponseBodyData() = default;
};
class ListOTATaskByJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> total{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> currentPage{};
  shared_ptr<ListOTATaskByJobResponseBodyData> data{};

  ListOTATaskByJobResponseBody() {}

  explicit ListOTATaskByJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListOTATaskByJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListOTATaskByJobResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListOTATaskByJobResponseBody() = default;
};
class ListOTATaskByJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListOTATaskByJobResponseBody> body{};

  ListOTATaskByJobResponse() {}

  explicit ListOTATaskByJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOTATaskByJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOTATaskByJobResponseBody>(model1);
      }
    }
  }


  virtual ~ListOTATaskByJobResponse() = default;
};
class ListProductByTagsRequestProductTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListProductByTagsRequestProductTag() {}

  explicit ListProductByTagsRequestProductTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListProductByTagsRequestProductTag() = default;
};
class ListProductByTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListProductByTagsRequestProductTag>> productTag{};

  ListProductByTagsRequest() {}

  explicit ListProductByTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productTag) {
      vector<boost::any> temp1;
      for(auto item1:*productTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProductTag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductTag") != m.end() && !m["ProductTag"].empty()) {
      if (typeid(vector<boost::any>) == m["ProductTag"].type()) {
        vector<ListProductByTagsRequestProductTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProductTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProductByTagsRequestProductTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        productTag = make_shared<vector<ListProductByTagsRequestProductTag>>(expect1);
      }
    }
  }


  virtual ~ListProductByTagsRequest() = default;
};
class ListProductByTagsResponseBodyProductInfosProductInfo : public Darabonba::Model {
public:
  shared_ptr<string> productName{};
  shared_ptr<string> productKey{};
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<long> nodeType{};

  ListProductByTagsResponseBodyProductInfosProductInfo() {}

  explicit ListProductByTagsResponseBodyProductInfosProductInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<long>(boost::any_cast<long>(m["NodeType"]));
    }
  }


  virtual ~ListProductByTagsResponseBodyProductInfosProductInfo() = default;
};
class ListProductByTagsResponseBodyProductInfos : public Darabonba::Model {
public:
  shared_ptr<vector<ListProductByTagsResponseBodyProductInfosProductInfo>> productInfo{};

  ListProductByTagsResponseBodyProductInfos() {}

  explicit ListProductByTagsResponseBodyProductInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productInfo) {
      vector<boost::any> temp1;
      for(auto item1:*productInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProductInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductInfo") != m.end() && !m["ProductInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ProductInfo"].type()) {
        vector<ListProductByTagsResponseBodyProductInfosProductInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProductInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProductByTagsResponseBodyProductInfosProductInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        productInfo = make_shared<vector<ListProductByTagsResponseBodyProductInfosProductInfo>>(expect1);
      }
    }
  }


  virtual ~ListProductByTagsResponseBodyProductInfos() = default;
};
class ListProductByTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<ListProductByTagsResponseBodyProductInfos> productInfos{};

  ListProductByTagsResponseBody() {}

  explicit ListProductByTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (productInfos) {
      res["ProductInfos"] = productInfos ? boost::any(productInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ProductInfos") != m.end() && !m["ProductInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProductInfos"].type()) {
        ListProductByTagsResponseBodyProductInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProductInfos"]));
        productInfos = make_shared<ListProductByTagsResponseBodyProductInfos>(model1);
      }
    }
  }


  virtual ~ListProductByTagsResponseBody() = default;
};
class ListProductByTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListProductByTagsResponseBody> body{};

  ListProductByTagsResponse() {}

  explicit ListProductByTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProductByTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProductByTagsResponseBody>(model1);
      }
    }
  }


  virtual ~ListProductByTagsResponse() = default;
};
class ListProductTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  ListProductTagsRequest() {}

  explicit ListProductTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~ListProductTagsRequest() = default;
};
class ListProductTagsResponseBodyDataProductTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListProductTagsResponseBodyDataProductTag() {}

  explicit ListProductTagsResponseBodyDataProductTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListProductTagsResponseBodyDataProductTag() = default;
};
class ListProductTagsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListProductTagsResponseBodyDataProductTag>> productTag{};

  ListProductTagsResponseBodyData() {}

  explicit ListProductTagsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productTag) {
      vector<boost::any> temp1;
      for(auto item1:*productTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProductTag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductTag") != m.end() && !m["ProductTag"].empty()) {
      if (typeid(vector<boost::any>) == m["ProductTag"].type()) {
        vector<ListProductTagsResponseBodyDataProductTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProductTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProductTagsResponseBodyDataProductTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        productTag = make_shared<vector<ListProductTagsResponseBodyDataProductTag>>(expect1);
      }
    }
  }


  virtual ~ListProductTagsResponseBodyData() = default;
};
class ListProductTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<ListProductTagsResponseBodyData> data{};

  ListProductTagsResponseBody() {}

  explicit ListProductTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListProductTagsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListProductTagsResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListProductTagsResponseBody() = default;
};
class ListProductTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListProductTagsResponseBody> body{};

  ListProductTagsResponse() {}

  explicit ListProductTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProductTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProductTagsResponseBody>(model1);
      }
    }
  }


  virtual ~ListProductTagsResponse() = default;
};
class ListRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};

  ListRuleRequest() {}

  explicit ListRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListRuleRequest() = default;
};
class ListRuleResponseBodyDataRuleInfo : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> select{};
  shared_ptr<string> topic{};
  shared_ptr<string> shortTopic{};
  shared_ptr<string> where{};
  shared_ptr<string> status{};
  shared_ptr<long> createUserId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> name{};
  shared_ptr<string> dataType{};
  shared_ptr<string> ruleDesc{};
  shared_ptr<string> created{};
  shared_ptr<string> utcCreated{};
  shared_ptr<string> modified{};
  shared_ptr<string> utcModified{};

  ListRuleResponseBodyDataRuleInfo() {}

  explicit ListRuleResponseBodyDataRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (select) {
      res["Select"] = boost::any(*select);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (shortTopic) {
      res["ShortTopic"] = boost::any(*shortTopic);
    }
    if (where) {
      res["Where"] = boost::any(*where);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (createUserId) {
      res["CreateUserId"] = boost::any(*createUserId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (ruleDesc) {
      res["RuleDesc"] = boost::any(*ruleDesc);
    }
    if (created) {
      res["Created"] = boost::any(*created);
    }
    if (utcCreated) {
      res["UtcCreated"] = boost::any(*utcCreated);
    }
    if (modified) {
      res["Modified"] = boost::any(*modified);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Select") != m.end() && !m["Select"].empty()) {
      select = make_shared<string>(boost::any_cast<string>(m["Select"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("ShortTopic") != m.end() && !m["ShortTopic"].empty()) {
      shortTopic = make_shared<string>(boost::any_cast<string>(m["ShortTopic"]));
    }
    if (m.find("Where") != m.end() && !m["Where"].empty()) {
      where = make_shared<string>(boost::any_cast<string>(m["Where"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CreateUserId") != m.end() && !m["CreateUserId"].empty()) {
      createUserId = make_shared<long>(boost::any_cast<long>(m["CreateUserId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("RuleDesc") != m.end() && !m["RuleDesc"].empty()) {
      ruleDesc = make_shared<string>(boost::any_cast<string>(m["RuleDesc"]));
    }
    if (m.find("Created") != m.end() && !m["Created"].empty()) {
      created = make_shared<string>(boost::any_cast<string>(m["Created"]));
    }
    if (m.find("UtcCreated") != m.end() && !m["UtcCreated"].empty()) {
      utcCreated = make_shared<string>(boost::any_cast<string>(m["UtcCreated"]));
    }
    if (m.find("Modified") != m.end() && !m["Modified"].empty()) {
      modified = make_shared<string>(boost::any_cast<string>(m["Modified"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
  }


  virtual ~ListRuleResponseBodyDataRuleInfo() = default;
};
class ListRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListRuleResponseBodyDataRuleInfo>> ruleInfo{};

  ListRuleResponseBodyData() {}

  explicit ListRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleInfo) {
      vector<boost::any> temp1;
      for(auto item1:*ruleInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleInfo") != m.end() && !m["RuleInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleInfo"].type()) {
        vector<ListRuleResponseBodyDataRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRuleResponseBodyDataRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleInfo = make_shared<vector<ListRuleResponseBodyDataRuleInfo>>(expect1);
      }
    }
  }


  virtual ~ListRuleResponseBodyData() = default;
};
class ListRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> page{};
  shared_ptr<long> total{};
  shared_ptr<long> pageSize{};
  shared_ptr<ListRuleResponseBodyData> data{};

  ListRuleResponseBody() {}

  explicit ListRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListRuleResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListRuleResponseBody() = default;
};
class ListRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListRuleResponseBody> body{};

  ListRuleResponse() {}

  explicit ListRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ListRuleResponse() = default;
};
class ListRuleActionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> ruleId{};

  ListRuleActionsRequest() {}

  explicit ListRuleActionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~ListRuleActionsRequest() = default;
};
class ListRuleActionsResponseBodyRuleActionListRuleActionInfo : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> type{};
  shared_ptr<string> configuration{};
  shared_ptr<bool> errorActionFlag{};

  ListRuleActionsResponseBodyRuleActionListRuleActionInfo() {}

  explicit ListRuleActionsResponseBodyRuleActionListRuleActionInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (configuration) {
      res["Configuration"] = boost::any(*configuration);
    }
    if (errorActionFlag) {
      res["ErrorActionFlag"] = boost::any(*errorActionFlag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configuration = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
    if (m.find("ErrorActionFlag") != m.end() && !m["ErrorActionFlag"].empty()) {
      errorActionFlag = make_shared<bool>(boost::any_cast<bool>(m["ErrorActionFlag"]));
    }
  }


  virtual ~ListRuleActionsResponseBodyRuleActionListRuleActionInfo() = default;
};
class ListRuleActionsResponseBodyRuleActionList : public Darabonba::Model {
public:
  shared_ptr<vector<ListRuleActionsResponseBodyRuleActionListRuleActionInfo>> ruleActionInfo{};

  ListRuleActionsResponseBodyRuleActionList() {}

  explicit ListRuleActionsResponseBodyRuleActionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleActionInfo) {
      vector<boost::any> temp1;
      for(auto item1:*ruleActionInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleActionInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleActionInfo") != m.end() && !m["RuleActionInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleActionInfo"].type()) {
        vector<ListRuleActionsResponseBodyRuleActionListRuleActionInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleActionInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRuleActionsResponseBodyRuleActionListRuleActionInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleActionInfo = make_shared<vector<ListRuleActionsResponseBodyRuleActionListRuleActionInfo>>(expect1);
      }
    }
  }


  virtual ~ListRuleActionsResponseBodyRuleActionList() = default;
};
class ListRuleActionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<ListRuleActionsResponseBodyRuleActionList> ruleActionList{};

  ListRuleActionsResponseBody() {}

  explicit ListRuleActionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (ruleActionList) {
      res["RuleActionList"] = ruleActionList ? boost::any(ruleActionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RuleActionList") != m.end() && !m["RuleActionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuleActionList"].type()) {
        ListRuleActionsResponseBodyRuleActionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuleActionList"]));
        ruleActionList = make_shared<ListRuleActionsResponseBodyRuleActionList>(model1);
      }
    }
  }


  virtual ~ListRuleActionsResponseBody() = default;
};
class ListRuleActionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListRuleActionsResponseBody> body{};

  ListRuleActionsResponse() {}

  explicit ListRuleActionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRuleActionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRuleActionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListRuleActionsResponse() = default;
};
class ListTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> limit{};
  shared_ptr<string> jobId{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> device{};
  shared_ptr<string> status{};

  ListTaskRequest() {}

  explicit ListTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListTaskRequest() = default;
};
class ListTaskResponseBodyDataData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> jobName{};
  shared_ptr<string> taskId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> progress{};
  shared_ptr<string> utcQueueTime{};
  shared_ptr<string> utcModified{};
  shared_ptr<string> status{};

  ListTaskResponseBodyDataData() {}

  explicit ListTaskResponseBodyDataData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (utcQueueTime) {
      res["UtcQueueTime"] = boost::any(*utcQueueTime);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("UtcQueueTime") != m.end() && !m["UtcQueueTime"].empty()) {
      utcQueueTime = make_shared<string>(boost::any_cast<string>(m["UtcQueueTime"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListTaskResponseBodyDataData() = default;
};
class ListTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListTaskResponseBodyDataData>> data{};

  ListTaskResponseBodyData() {}

  explicit ListTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListTaskResponseBodyDataData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTaskResponseBodyDataData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListTaskResponseBodyDataData>>(expect1);
      }
    }
  }


  virtual ~ListTaskResponseBodyData() = default;
};
class ListTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> nextToken{};
  shared_ptr<ListTaskResponseBodyData> data{};

  ListTaskResponseBody() {}

  explicit ListTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListTaskResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListTaskResponseBody() = default;
};
class ListTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListTaskResponseBody> body{};

  ListTaskResponse() {}

  explicit ListTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTaskResponseBody>(model1);
      }
    }
  }


  virtual ~ListTaskResponse() = default;
};
class ListTaskByPageRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> pageNo{};
  shared_ptr<string> jobId{};
  shared_ptr<string> device{};
  shared_ptr<string> status{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> jobName{};

  ListTaskByPageRequest() {}

  explicit ListTaskByPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<string>(boost::any_cast<string>(m["PageNo"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
  }


  virtual ~ListTaskByPageRequest() = default;
};
class ListTaskByPageResponseBodyDataData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> jobName{};
  shared_ptr<string> taskId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<long> progress{};
  shared_ptr<string> utcQueueTime{};
  shared_ptr<string> utcModified{};
  shared_ptr<string> statusDetail{};
  shared_ptr<string> status{};
  shared_ptr<string> productName{};

  ListTaskByPageResponseBodyDataData() {}

  explicit ListTaskByPageResponseBodyDataData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (utcQueueTime) {
      res["UtcQueueTime"] = boost::any(*utcQueueTime);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (statusDetail) {
      res["StatusDetail"] = boost::any(*statusDetail);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("UtcQueueTime") != m.end() && !m["UtcQueueTime"].empty()) {
      utcQueueTime = make_shared<string>(boost::any_cast<string>(m["UtcQueueTime"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("StatusDetail") != m.end() && !m["StatusDetail"].empty()) {
      statusDetail = make_shared<string>(boost::any_cast<string>(m["StatusDetail"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
  }


  virtual ~ListTaskByPageResponseBodyDataData() = default;
};
class ListTaskByPageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListTaskByPageResponseBodyDataData>> data{};

  ListTaskByPageResponseBodyData() {}

  explicit ListTaskByPageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListTaskByPageResponseBodyDataData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTaskByPageResponseBodyDataData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListTaskByPageResponseBodyDataData>>(expect1);
      }
    }
  }


  virtual ~ListTaskByPageResponseBodyData() = default;
};
class ListTaskByPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> total{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> page{};
  shared_ptr<ListTaskByPageResponseBodyData> data{};

  ListTaskByPageResponseBody() {}

  explicit ListTaskByPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListTaskByPageResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListTaskByPageResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListTaskByPageResponseBody() = default;
};
class ListTaskByPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListTaskByPageResponseBody> body{};

  ListTaskByPageResponse() {}

  explicit ListTaskByPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTaskByPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTaskByPageResponseBody>(model1);
      }
    }
  }


  virtual ~ListTaskByPageResponse() = default;
};
class ListThingModelVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  ListThingModelVersionRequest() {}

  explicit ListThingModelVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~ListThingModelVersionRequest() = default;
};
class ListThingModelVersionResponseBodyDataModelVersions : public Darabonba::Model {
public:
  shared_ptr<string> modelVersion{};
  shared_ptr<string> description{};
  shared_ptr<long> gmtCreate{};

  ListThingModelVersionResponseBodyDataModelVersions() {}

  explicit ListThingModelVersionResponseBodyDataModelVersions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (modelVersion) {
      res["ModelVersion"] = boost::any(*modelVersion);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModelVersion") != m.end() && !m["ModelVersion"].empty()) {
      modelVersion = make_shared<string>(boost::any_cast<string>(m["ModelVersion"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
  }


  virtual ~ListThingModelVersionResponseBodyDataModelVersions() = default;
};
class ListThingModelVersionResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListThingModelVersionResponseBodyDataModelVersions>> modelVersions{};

  ListThingModelVersionResponseBodyData() {}

  explicit ListThingModelVersionResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (modelVersions) {
      vector<boost::any> temp1;
      for(auto item1:*modelVersions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ModelVersions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModelVersions") != m.end() && !m["ModelVersions"].empty()) {
      if (typeid(vector<boost::any>) == m["ModelVersions"].type()) {
        vector<ListThingModelVersionResponseBodyDataModelVersions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ModelVersions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListThingModelVersionResponseBodyDataModelVersions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        modelVersions = make_shared<vector<ListThingModelVersionResponseBodyDataModelVersions>>(expect1);
      }
    }
  }


  virtual ~ListThingModelVersionResponseBodyData() = default;
};
class ListThingModelVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<ListThingModelVersionResponseBodyData> data{};

  ListThingModelVersionResponseBody() {}

  explicit ListThingModelVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListThingModelVersionResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListThingModelVersionResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListThingModelVersionResponseBody() = default;
};
class ListThingModelVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListThingModelVersionResponseBody> body{};

  ListThingModelVersionResponse() {}

  explicit ListThingModelVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListThingModelVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListThingModelVersionResponseBody>(model1);
      }
    }
  }


  virtual ~ListThingModelVersionResponse() = default;
};
class ListThingTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};

  ListThingTemplatesRequest() {}

  explicit ListThingTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~ListThingTemplatesRequest() = default;
};
class ListThingTemplatesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> categoryKey{};
  shared_ptr<string> categoryName{};

  ListThingTemplatesResponseBodyData() {}

  explicit ListThingTemplatesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryKey) {
      res["CategoryKey"] = boost::any(*categoryKey);
    }
    if (categoryName) {
      res["CategoryName"] = boost::any(*categoryName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryKey") != m.end() && !m["CategoryKey"].empty()) {
      categoryKey = make_shared<string>(boost::any_cast<string>(m["CategoryKey"]));
    }
    if (m.find("CategoryName") != m.end() && !m["CategoryName"].empty()) {
      categoryName = make_shared<string>(boost::any_cast<string>(m["CategoryName"]));
    }
  }


  virtual ~ListThingTemplatesResponseBodyData() = default;
};
class ListThingTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<ListThingTemplatesResponseBodyData>> data{};

  ListThingTemplatesResponseBody() {}

  explicit ListThingTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListThingTemplatesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListThingTemplatesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListThingTemplatesResponseBodyData>>(expect1);
      }
    }
  }


  virtual ~ListThingTemplatesResponseBody() = default;
};
class ListThingTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListThingTemplatesResponseBody> body{};

  ListThingTemplatesResponse() {}

  explicit ListThingTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListThingTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListThingTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListThingTemplatesResponse() = default;
};
class NotifyAddThingTopoRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> deviceListStr{};
  shared_ptr<string> gwIotId{};
  shared_ptr<string> gwProductKey{};
  shared_ptr<string> gwDeviceName{};

  NotifyAddThingTopoRequest() {}

  explicit NotifyAddThingTopoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (deviceListStr) {
      res["DeviceListStr"] = boost::any(*deviceListStr);
    }
    if (gwIotId) {
      res["GwIotId"] = boost::any(*gwIotId);
    }
    if (gwProductKey) {
      res["GwProductKey"] = boost::any(*gwProductKey);
    }
    if (gwDeviceName) {
      res["GwDeviceName"] = boost::any(*gwDeviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("DeviceListStr") != m.end() && !m["DeviceListStr"].empty()) {
      deviceListStr = make_shared<string>(boost::any_cast<string>(m["DeviceListStr"]));
    }
    if (m.find("GwIotId") != m.end() && !m["GwIotId"].empty()) {
      gwIotId = make_shared<string>(boost::any_cast<string>(m["GwIotId"]));
    }
    if (m.find("GwProductKey") != m.end() && !m["GwProductKey"].empty()) {
      gwProductKey = make_shared<string>(boost::any_cast<string>(m["GwProductKey"]));
    }
    if (m.find("GwDeviceName") != m.end() && !m["GwDeviceName"].empty()) {
      gwDeviceName = make_shared<string>(boost::any_cast<string>(m["GwDeviceName"]));
    }
  }


  virtual ~NotifyAddThingTopoRequest() = default;
};
class NotifyAddThingTopoResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};

  NotifyAddThingTopoResponseBodyData() {}

  explicit NotifyAddThingTopoResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~NotifyAddThingTopoResponseBodyData() = default;
};
class NotifyAddThingTopoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<NotifyAddThingTopoResponseBodyData> data{};

  NotifyAddThingTopoResponseBody() {}

  explicit NotifyAddThingTopoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        NotifyAddThingTopoResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<NotifyAddThingTopoResponseBodyData>(model1);
      }
    }
  }


  virtual ~NotifyAddThingTopoResponseBody() = default;
};
class NotifyAddThingTopoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<NotifyAddThingTopoResponseBody> body{};

  NotifyAddThingTopoResponse() {}

  explicit NotifyAddThingTopoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        NotifyAddThingTopoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<NotifyAddThingTopoResponseBody>(model1);
      }
    }
  }


  virtual ~NotifyAddThingTopoResponse() = default;
};
class OpenIotServiceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};

  OpenIotServiceRequest() {}

  explicit OpenIotServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~OpenIotServiceRequest() = default;
};
class OpenIotServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> orderId{};

  OpenIotServiceResponseBody() {}

  explicit OpenIotServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
  }


  virtual ~OpenIotServiceResponseBody() = default;
};
class OpenIotServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<OpenIotServiceResponseBody> body{};

  OpenIotServiceResponse() {}

  explicit OpenIotServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenIotServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenIotServiceResponseBody>(model1);
      }
    }
  }


  virtual ~OpenIotServiceResponse() = default;
};
class PrintByTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> paramsJsonString{};
  shared_ptr<string> iotId{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> templateBizCode{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};

  PrintByTemplateRequest() {}

  explicit PrintByTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (paramsJsonString) {
      res["ParamsJsonString"] = boost::any(*paramsJsonString);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (projectCode) {
      res["ProjectCode"] = boost::any(*projectCode);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (templateBizCode) {
      res["TemplateBizCode"] = boost::any(*templateBizCode);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParamsJsonString") != m.end() && !m["ParamsJsonString"].empty()) {
      paramsJsonString = make_shared<string>(boost::any_cast<string>(m["ParamsJsonString"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("ProjectCode") != m.end() && !m["ProjectCode"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["ProjectCode"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("TemplateBizCode") != m.end() && !m["TemplateBizCode"].empty()) {
      templateBizCode = make_shared<string>(boost::any_cast<string>(m["TemplateBizCode"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
  }


  virtual ~PrintByTemplateRequest() = default;
};
class PrintByTemplateResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> deviceErrorCode{};
  shared_ptr<string> deviceErrorMessage{};
  shared_ptr<string> id{};
  shared_ptr<long> retryCount{};

  PrintByTemplateResponseBodyData() {}

  explicit PrintByTemplateResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (deviceErrorCode) {
      res["DeviceErrorCode"] = boost::any(*deviceErrorCode);
    }
    if (deviceErrorMessage) {
      res["DeviceErrorMessage"] = boost::any(*deviceErrorMessage);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("DeviceErrorCode") != m.end() && !m["DeviceErrorCode"].empty()) {
      deviceErrorCode = make_shared<string>(boost::any_cast<string>(m["DeviceErrorCode"]));
    }
    if (m.find("DeviceErrorMessage") != m.end() && !m["DeviceErrorMessage"].empty()) {
      deviceErrorMessage = make_shared<string>(boost::any_cast<string>(m["DeviceErrorMessage"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<long>(boost::any_cast<long>(m["RetryCount"]));
    }
  }


  virtual ~PrintByTemplateResponseBodyData() = default;
};
class PrintByTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<PrintByTemplateResponseBodyData> data{};

  PrintByTemplateResponseBody() {}

  explicit PrintByTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        PrintByTemplateResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<PrintByTemplateResponseBodyData>(model1);
      }
    }
  }


  virtual ~PrintByTemplateResponseBody() = default;
};
class PrintByTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<PrintByTemplateResponseBody> body{};

  PrintByTemplateResponse() {}

  explicit PrintByTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PrintByTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PrintByTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~PrintByTemplateResponse() = default;
};
class PubRequestUserProp : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  PubRequestUserProp() {}

  explicit PubRequestUserProp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~PubRequestUserProp() = default;
};
class PubRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<long> qos{};
  shared_ptr<string> topicFullName{};
  shared_ptr<string> messageContent{};
  shared_ptr<string> responseTopic{};
  shared_ptr<string> correlationData{};
  shared_ptr<vector<PubRequestUserProp>> userProp{};

  PubRequest() {}

  explicit PubRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (qos) {
      res["Qos"] = boost::any(*qos);
    }
    if (topicFullName) {
      res["TopicFullName"] = boost::any(*topicFullName);
    }
    if (messageContent) {
      res["MessageContent"] = boost::any(*messageContent);
    }
    if (responseTopic) {
      res["ResponseTopic"] = boost::any(*responseTopic);
    }
    if (correlationData) {
      res["CorrelationData"] = boost::any(*correlationData);
    }
    if (userProp) {
      vector<boost::any> temp1;
      for(auto item1:*userProp){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserProp"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Qos") != m.end() && !m["Qos"].empty()) {
      qos = make_shared<long>(boost::any_cast<long>(m["Qos"]));
    }
    if (m.find("TopicFullName") != m.end() && !m["TopicFullName"].empty()) {
      topicFullName = make_shared<string>(boost::any_cast<string>(m["TopicFullName"]));
    }
    if (m.find("MessageContent") != m.end() && !m["MessageContent"].empty()) {
      messageContent = make_shared<string>(boost::any_cast<string>(m["MessageContent"]));
    }
    if (m.find("ResponseTopic") != m.end() && !m["ResponseTopic"].empty()) {
      responseTopic = make_shared<string>(boost::any_cast<string>(m["ResponseTopic"]));
    }
    if (m.find("CorrelationData") != m.end() && !m["CorrelationData"].empty()) {
      correlationData = make_shared<string>(boost::any_cast<string>(m["CorrelationData"]));
    }
    if (m.find("UserProp") != m.end() && !m["UserProp"].empty()) {
      if (typeid(vector<boost::any>) == m["UserProp"].type()) {
        vector<PubRequestUserProp> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserProp"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PubRequestUserProp model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userProp = make_shared<vector<PubRequestUserProp>>(expect1);
      }
    }
  }


  virtual ~PubRequest() = default;
};
class PubResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> messageId{};

  PubResponseBody() {}

  explicit PubResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~PubResponseBody() = default;
};
class PubResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<PubResponseBody> body{};

  PubResponse() {}

  explicit PubResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PubResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PubResponseBody>(model1);
      }
    }
  }


  virtual ~PubResponse() = default;
};
class PubBroadcastRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> topicFullName{};
  shared_ptr<string> messageContent{};

  PubBroadcastRequest() {}

  explicit PubBroadcastRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (topicFullName) {
      res["TopicFullName"] = boost::any(*topicFullName);
    }
    if (messageContent) {
      res["MessageContent"] = boost::any(*messageContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("TopicFullName") != m.end() && !m["TopicFullName"].empty()) {
      topicFullName = make_shared<string>(boost::any_cast<string>(m["TopicFullName"]));
    }
    if (m.find("MessageContent") != m.end() && !m["MessageContent"].empty()) {
      messageContent = make_shared<string>(boost::any_cast<string>(m["MessageContent"]));
    }
  }


  virtual ~PubBroadcastRequest() = default;
};
class PubBroadcastResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> messageId{};

  PubBroadcastResponseBody() {}

  explicit PubBroadcastResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<long>(boost::any_cast<long>(m["MessageId"]));
    }
  }


  virtual ~PubBroadcastResponseBody() = default;
};
class PubBroadcastResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<PubBroadcastResponseBody> body{};

  PubBroadcastResponse() {}

  explicit PubBroadcastResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PubBroadcastResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PubBroadcastResponseBody>(model1);
      }
    }
  }


  virtual ~PubBroadcastResponse() = default;
};
class PublishThingModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> modelVersion{};
  shared_ptr<string> description{};

  PublishThingModelRequest() {}

  explicit PublishThingModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (modelVersion) {
      res["ModelVersion"] = boost::any(*modelVersion);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ModelVersion") != m.end() && !m["ModelVersion"].empty()) {
      modelVersion = make_shared<string>(boost::any_cast<string>(m["ModelVersion"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~PublishThingModelRequest() = default;
};
class PublishThingModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  PublishThingModelResponseBody() {}

  explicit PublishThingModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~PublishThingModelResponseBody() = default;
};
class PublishThingModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<PublishThingModelResponseBody> body{};

  PublishThingModelResponse() {}

  explicit PublishThingModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublishThingModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublishThingModelResponseBody>(model1);
      }
    }
  }


  virtual ~PublishThingModelResponse() = default;
};
class QueryAppDeviceListRequestTagList : public Darabonba::Model {
public:
  shared_ptr<string> tagName{};
  shared_ptr<string> tagValue{};

  QueryAppDeviceListRequestTagList() {}

  explicit QueryAppDeviceListRequestTagList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~QueryAppDeviceListRequestTagList() = default;
};
class QueryAppDeviceListRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<string>> productKeyList{};
  shared_ptr<vector<string>> categoryKeyList{};
  shared_ptr<string> appKey{};
  shared_ptr<vector<QueryAppDeviceListRequestTagList>> tagList{};
  shared_ptr<long> currentPage{};

  QueryAppDeviceListRequest() {}

  explicit QueryAppDeviceListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKeyList) {
      res["ProductKeyList"] = boost::any(*productKeyList);
    }
    if (categoryKeyList) {
      res["CategoryKeyList"] = boost::any(*categoryKeyList);
    }
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (tagList) {
      vector<boost::any> temp1;
      for(auto item1:*tagList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagList"] = boost::any(temp1);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKeyList") != m.end() && !m["ProductKeyList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProductKeyList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProductKeyList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      productKeyList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CategoryKeyList") != m.end() && !m["CategoryKeyList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CategoryKeyList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CategoryKeyList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      categoryKeyList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("TagList") != m.end() && !m["TagList"].empty()) {
      if (typeid(vector<boost::any>) == m["TagList"].type()) {
        vector<QueryAppDeviceListRequestTagList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryAppDeviceListRequestTagList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagList = make_shared<vector<QueryAppDeviceListRequestTagList>>(expect1);
      }
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~QueryAppDeviceListRequest() = default;
};
class QueryAppDeviceListResponseBodyDataData : public Darabonba::Model {
public:
  shared_ptr<string> productName{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<long> nodeType{};
  shared_ptr<string> status{};
  shared_ptr<string> activeTime{};
  shared_ptr<string> lastOnlineTime{};
  shared_ptr<string> createTime{};
  shared_ptr<long> childDeviceCount{};
  shared_ptr<string> utcActiveTime{};
  shared_ptr<string> utcLastOnlineTime{};
  shared_ptr<string> utcCreateTime{};

  QueryAppDeviceListResponseBodyDataData() {}

  explicit QueryAppDeviceListResponseBodyDataData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (activeTime) {
      res["ActiveTime"] = boost::any(*activeTime);
    }
    if (lastOnlineTime) {
      res["LastOnlineTime"] = boost::any(*lastOnlineTime);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (childDeviceCount) {
      res["ChildDeviceCount"] = boost::any(*childDeviceCount);
    }
    if (utcActiveTime) {
      res["UtcActiveTime"] = boost::any(*utcActiveTime);
    }
    if (utcLastOnlineTime) {
      res["UtcLastOnlineTime"] = boost::any(*utcLastOnlineTime);
    }
    if (utcCreateTime) {
      res["UtcCreateTime"] = boost::any(*utcCreateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<long>(boost::any_cast<long>(m["NodeType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ActiveTime") != m.end() && !m["ActiveTime"].empty()) {
      activeTime = make_shared<string>(boost::any_cast<string>(m["ActiveTime"]));
    }
    if (m.find("LastOnlineTime") != m.end() && !m["LastOnlineTime"].empty()) {
      lastOnlineTime = make_shared<string>(boost::any_cast<string>(m["LastOnlineTime"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ChildDeviceCount") != m.end() && !m["ChildDeviceCount"].empty()) {
      childDeviceCount = make_shared<long>(boost::any_cast<long>(m["ChildDeviceCount"]));
    }
    if (m.find("UtcActiveTime") != m.end() && !m["UtcActiveTime"].empty()) {
      utcActiveTime = make_shared<string>(boost::any_cast<string>(m["UtcActiveTime"]));
    }
    if (m.find("UtcLastOnlineTime") != m.end() && !m["UtcLastOnlineTime"].empty()) {
      utcLastOnlineTime = make_shared<string>(boost::any_cast<string>(m["UtcLastOnlineTime"]));
    }
    if (m.find("UtcCreateTime") != m.end() && !m["UtcCreateTime"].empty()) {
      utcCreateTime = make_shared<string>(boost::any_cast<string>(m["UtcCreateTime"]));
    }
  }


  virtual ~QueryAppDeviceListResponseBodyDataData() = default;
};
class QueryAppDeviceListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryAppDeviceListResponseBodyDataData>> data{};

  QueryAppDeviceListResponseBodyData() {}

  explicit QueryAppDeviceListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<QueryAppDeviceListResponseBodyDataData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryAppDeviceListResponseBodyDataData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<QueryAppDeviceListResponseBodyDataData>>(expect1);
      }
    }
  }


  virtual ~QueryAppDeviceListResponseBodyData() = default;
};
class QueryAppDeviceListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> total{};
  shared_ptr<QueryAppDeviceListResponseBodyData> data{};

  QueryAppDeviceListResponseBody() {}

  explicit QueryAppDeviceListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryAppDeviceListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryAppDeviceListResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryAppDeviceListResponseBody() = default;
};
class QueryAppDeviceListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryAppDeviceListResponseBody> body{};

  QueryAppDeviceListResponse() {}

  explicit QueryAppDeviceListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryAppDeviceListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryAppDeviceListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryAppDeviceListResponse() = default;
};
class QueryBatchRegisterDeviceStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<long> applyId{};

  QueryBatchRegisterDeviceStatusRequest() {}

  explicit QueryBatchRegisterDeviceStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (applyId) {
      res["ApplyId"] = boost::any(*applyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ApplyId") != m.end() && !m["ApplyId"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["ApplyId"]));
    }
  }


  virtual ~QueryBatchRegisterDeviceStatusRequest() = default;
};
class QueryBatchRegisterDeviceStatusResponseBodyDataValidList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> name{};

  QueryBatchRegisterDeviceStatusResponseBodyDataValidList() {}

  explicit QueryBatchRegisterDeviceStatusResponseBodyDataValidList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Name"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Name"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      name = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryBatchRegisterDeviceStatusResponseBodyDataValidList() = default;
};
class QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> name{};

  QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList() {}

  explicit QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Name"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Name"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      name = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList() = default;
};
class QueryBatchRegisterDeviceStatusResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<QueryBatchRegisterDeviceStatusResponseBodyDataValidList> validList{};
  shared_ptr<QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList> invalidList{};

  QueryBatchRegisterDeviceStatusResponseBodyData() {}

  explicit QueryBatchRegisterDeviceStatusResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (validList) {
      res["ValidList"] = validList ? boost::any(validList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (invalidList) {
      res["InvalidList"] = invalidList ? boost::any(invalidList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ValidList") != m.end() && !m["ValidList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ValidList"].type()) {
        QueryBatchRegisterDeviceStatusResponseBodyDataValidList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ValidList"]));
        validList = make_shared<QueryBatchRegisterDeviceStatusResponseBodyDataValidList>(model1);
      }
    }
    if (m.find("InvalidList") != m.end() && !m["InvalidList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvalidList"].type()) {
        QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvalidList"]));
        invalidList = make_shared<QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList>(model1);
      }
    }
  }


  virtual ~QueryBatchRegisterDeviceStatusResponseBodyData() = default;
};
class QueryBatchRegisterDeviceStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryBatchRegisterDeviceStatusResponseBodyData> data{};

  QueryBatchRegisterDeviceStatusResponseBody() {}

  explicit QueryBatchRegisterDeviceStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryBatchRegisterDeviceStatusResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryBatchRegisterDeviceStatusResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryBatchRegisterDeviceStatusResponseBody() = default;
};
class QueryBatchRegisterDeviceStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryBatchRegisterDeviceStatusResponseBody> body{};

  QueryBatchRegisterDeviceStatusResponse() {}

  explicit QueryBatchRegisterDeviceStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryBatchRegisterDeviceStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryBatchRegisterDeviceStatusResponseBody>(model1);
      }
    }
  }


  virtual ~QueryBatchRegisterDeviceStatusResponse() = default;
};
class QueryCertUrlByApplyIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> applyId{};

  QueryCertUrlByApplyIdRequest() {}

  explicit QueryCertUrlByApplyIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (applyId) {
      res["ApplyId"] = boost::any(*applyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ApplyId") != m.end() && !m["ApplyId"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["ApplyId"]));
    }
  }


  virtual ~QueryCertUrlByApplyIdRequest() = default;
};
class QueryCertUrlByApplyIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> certUrl{};

  QueryCertUrlByApplyIdResponseBody() {}

  explicit QueryCertUrlByApplyIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (certUrl) {
      res["CertUrl"] = boost::any(*certUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("CertUrl") != m.end() && !m["CertUrl"].empty()) {
      certUrl = make_shared<string>(boost::any_cast<string>(m["CertUrl"]));
    }
  }


  virtual ~QueryCertUrlByApplyIdResponseBody() = default;
};
class QueryCertUrlByApplyIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryCertUrlByApplyIdResponseBody> body{};

  QueryCertUrlByApplyIdResponse() {}

  explicit QueryCertUrlByApplyIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryCertUrlByApplyIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryCertUrlByApplyIdResponseBody>(model1);
      }
    }
  }


  virtual ~QueryCertUrlByApplyIdResponse() = default;
};
class QueryConsumerGroupByGroupIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> groupId{};

  QueryConsumerGroupByGroupIdRequest() {}

  explicit QueryConsumerGroupByGroupIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~QueryConsumerGroupByGroupIdRequest() = default;
};
class QueryConsumerGroupByGroupIdResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> createTime{};

  QueryConsumerGroupByGroupIdResponseBodyData() {}

  explicit QueryConsumerGroupByGroupIdResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
  }


  virtual ~QueryConsumerGroupByGroupIdResponseBodyData() = default;
};
class QueryConsumerGroupByGroupIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<QueryConsumerGroupByGroupIdResponseBodyData> data{};

  QueryConsumerGroupByGroupIdResponseBody() {}

  explicit QueryConsumerGroupByGroupIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryConsumerGroupByGroupIdResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryConsumerGroupByGroupIdResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryConsumerGroupByGroupIdResponseBody() = default;
};
class QueryConsumerGroupByGroupIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryConsumerGroupByGroupIdResponseBody> body{};

  QueryConsumerGroupByGroupIdResponse() {}

  explicit QueryConsumerGroupByGroupIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryConsumerGroupByGroupIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryConsumerGroupByGroupIdResponseBody>(model1);
      }
    }
  }


  virtual ~QueryConsumerGroupByGroupIdResponse() = default;
};
class QueryConsumerGroupListRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};
  shared_ptr<bool> fuzzy{};
  shared_ptr<string> groupName{};

  QueryConsumerGroupListRequest() {}

  explicit QueryConsumerGroupListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (fuzzy) {
      res["Fuzzy"] = boost::any(*fuzzy);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Fuzzy") != m.end() && !m["Fuzzy"].empty()) {
      fuzzy = make_shared<bool>(boost::any_cast<bool>(m["Fuzzy"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~QueryConsumerGroupListRequest() = default;
};
class QueryConsumerGroupListResponseBodyDataConsumerGroupDTO : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> createTime{};

  QueryConsumerGroupListResponseBodyDataConsumerGroupDTO() {}

  explicit QueryConsumerGroupListResponseBodyDataConsumerGroupDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
  }


  virtual ~QueryConsumerGroupListResponseBodyDataConsumerGroupDTO() = default;
};
class QueryConsumerGroupListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryConsumerGroupListResponseBodyDataConsumerGroupDTO>> consumerGroupDTO{};

  QueryConsumerGroupListResponseBodyData() {}

  explicit QueryConsumerGroupListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consumerGroupDTO) {
      vector<boost::any> temp1;
      for(auto item1:*consumerGroupDTO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConsumerGroupDTO"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsumerGroupDTO") != m.end() && !m["ConsumerGroupDTO"].empty()) {
      if (typeid(vector<boost::any>) == m["ConsumerGroupDTO"].type()) {
        vector<QueryConsumerGroupListResponseBodyDataConsumerGroupDTO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConsumerGroupDTO"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryConsumerGroupListResponseBodyDataConsumerGroupDTO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        consumerGroupDTO = make_shared<vector<QueryConsumerGroupListResponseBodyDataConsumerGroupDTO>>(expect1);
      }
    }
  }


  virtual ~QueryConsumerGroupListResponseBodyData() = default;
};
class QueryConsumerGroupListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> total{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> code{};
  shared_ptr<QueryConsumerGroupListResponseBodyData> data{};

  QueryConsumerGroupListResponseBody() {}

  explicit QueryConsumerGroupListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryConsumerGroupListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryConsumerGroupListResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryConsumerGroupListResponseBody() = default;
};
class QueryConsumerGroupListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryConsumerGroupListResponseBody> body{};

  QueryConsumerGroupListResponse() {}

  explicit QueryConsumerGroupListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryConsumerGroupListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryConsumerGroupListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryConsumerGroupListResponse() = default;
};
class QueryConsumerGroupStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> groupId{};

  QueryConsumerGroupStatusRequest() {}

  explicit QueryConsumerGroupStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~QueryConsumerGroupStatusRequest() = default;
};
class QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo : public Darabonba::Model {
public:
  shared_ptr<string> clientId{};
  shared_ptr<string> clientIpPort{};
  shared_ptr<long> onlineTime{};
  shared_ptr<long> realTimeConsumeCountPerMinute{};
  shared_ptr<long> accumulatedConsumeCountPerMinute{};

  QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo() {}

  explicit QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (clientIpPort) {
      res["ClientIpPort"] = boost::any(*clientIpPort);
    }
    if (onlineTime) {
      res["OnlineTime"] = boost::any(*onlineTime);
    }
    if (realTimeConsumeCountPerMinute) {
      res["RealTimeConsumeCountPerMinute"] = boost::any(*realTimeConsumeCountPerMinute);
    }
    if (accumulatedConsumeCountPerMinute) {
      res["AccumulatedConsumeCountPerMinute"] = boost::any(*accumulatedConsumeCountPerMinute);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
    if (m.find("ClientIpPort") != m.end() && !m["ClientIpPort"].empty()) {
      clientIpPort = make_shared<string>(boost::any_cast<string>(m["ClientIpPort"]));
    }
    if (m.find("OnlineTime") != m.end() && !m["OnlineTime"].empty()) {
      onlineTime = make_shared<long>(boost::any_cast<long>(m["OnlineTime"]));
    }
    if (m.find("RealTimeConsumeCountPerMinute") != m.end() && !m["RealTimeConsumeCountPerMinute"].empty()) {
      realTimeConsumeCountPerMinute = make_shared<long>(boost::any_cast<long>(m["RealTimeConsumeCountPerMinute"]));
    }
    if (m.find("AccumulatedConsumeCountPerMinute") != m.end() && !m["AccumulatedConsumeCountPerMinute"].empty()) {
      accumulatedConsumeCountPerMinute = make_shared<long>(boost::any_cast<long>(m["AccumulatedConsumeCountPerMinute"]));
    }
  }


  virtual ~QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo() = default;
};
class QueryConsumerGroupStatusResponseBodyClientConnectionStatusList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo>> consumerGroupClientConnectionInfo{};

  QueryConsumerGroupStatusResponseBodyClientConnectionStatusList() {}

  explicit QueryConsumerGroupStatusResponseBodyClientConnectionStatusList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consumerGroupClientConnectionInfo) {
      vector<boost::any> temp1;
      for(auto item1:*consumerGroupClientConnectionInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConsumerGroupClientConnectionInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsumerGroupClientConnectionInfo") != m.end() && !m["ConsumerGroupClientConnectionInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ConsumerGroupClientConnectionInfo"].type()) {
        vector<QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConsumerGroupClientConnectionInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        consumerGroupClientConnectionInfo = make_shared<vector<QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo>>(expect1);
      }
    }
  }


  virtual ~QueryConsumerGroupStatusResponseBodyClientConnectionStatusList() = default;
};
class QueryConsumerGroupStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> accumulationCount{};
  shared_ptr<long> consumerSpeed{};
  shared_ptr<string> lastConsumerTime{};
  shared_ptr<string> code{};
  shared_ptr<long> accumulatedConsumeCountPerMinute{};
  shared_ptr<long> realTimeConsumeCountPerMinute{};
  shared_ptr<QueryConsumerGroupStatusResponseBodyClientConnectionStatusList> clientConnectionStatusList{};

  QueryConsumerGroupStatusResponseBody() {}

  explicit QueryConsumerGroupStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (accumulationCount) {
      res["AccumulationCount"] = boost::any(*accumulationCount);
    }
    if (consumerSpeed) {
      res["ConsumerSpeed"] = boost::any(*consumerSpeed);
    }
    if (lastConsumerTime) {
      res["LastConsumerTime"] = boost::any(*lastConsumerTime);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (accumulatedConsumeCountPerMinute) {
      res["AccumulatedConsumeCountPerMinute"] = boost::any(*accumulatedConsumeCountPerMinute);
    }
    if (realTimeConsumeCountPerMinute) {
      res["RealTimeConsumeCountPerMinute"] = boost::any(*realTimeConsumeCountPerMinute);
    }
    if (clientConnectionStatusList) {
      res["ClientConnectionStatusList"] = clientConnectionStatusList ? boost::any(clientConnectionStatusList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("AccumulationCount") != m.end() && !m["AccumulationCount"].empty()) {
      accumulationCount = make_shared<long>(boost::any_cast<long>(m["AccumulationCount"]));
    }
    if (m.find("ConsumerSpeed") != m.end() && !m["ConsumerSpeed"].empty()) {
      consumerSpeed = make_shared<long>(boost::any_cast<long>(m["ConsumerSpeed"]));
    }
    if (m.find("LastConsumerTime") != m.end() && !m["LastConsumerTime"].empty()) {
      lastConsumerTime = make_shared<string>(boost::any_cast<string>(m["LastConsumerTime"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("AccumulatedConsumeCountPerMinute") != m.end() && !m["AccumulatedConsumeCountPerMinute"].empty()) {
      accumulatedConsumeCountPerMinute = make_shared<long>(boost::any_cast<long>(m["AccumulatedConsumeCountPerMinute"]));
    }
    if (m.find("RealTimeConsumeCountPerMinute") != m.end() && !m["RealTimeConsumeCountPerMinute"].empty()) {
      realTimeConsumeCountPerMinute = make_shared<long>(boost::any_cast<long>(m["RealTimeConsumeCountPerMinute"]));
    }
    if (m.find("ClientConnectionStatusList") != m.end() && !m["ClientConnectionStatusList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClientConnectionStatusList"].type()) {
        QueryConsumerGroupStatusResponseBodyClientConnectionStatusList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClientConnectionStatusList"]));
        clientConnectionStatusList = make_shared<QueryConsumerGroupStatusResponseBodyClientConnectionStatusList>(model1);
      }
    }
  }


  virtual ~QueryConsumerGroupStatusResponseBody() = default;
};
class QueryConsumerGroupStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryConsumerGroupStatusResponseBody> body{};

  QueryConsumerGroupStatusResponse() {}

  explicit QueryConsumerGroupStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryConsumerGroupStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryConsumerGroupStatusResponseBody>(model1);
      }
    }
  }


  virtual ~QueryConsumerGroupStatusResponse() = default;
};
class QueryDetailSceneRuleLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> ruleId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> endTime{};
  shared_ptr<string> traceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};

  QueryDetailSceneRuleLogRequest() {}

  explicit QueryDetailSceneRuleLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~QueryDetailSceneRuleLogRequest() = default;
};
class QueryDetailSceneRuleLogResponseBodyDataLogList : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> pkDn{};

  QueryDetailSceneRuleLogResponseBodyDataLogList() {}

  explicit QueryDetailSceneRuleLogResponseBodyDataLogList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pkDn) {
      res["PkDn"] = boost::any(*pkDn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PkDn") != m.end() && !m["PkDn"].empty()) {
      pkDn = make_shared<string>(boost::any_cast<string>(m["PkDn"]));
    }
  }


  virtual ~QueryDetailSceneRuleLogResponseBodyDataLogList() = default;
};
class QueryDetailSceneRuleLogResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> total{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};
  shared_ptr<vector<QueryDetailSceneRuleLogResponseBodyDataLogList>> logList{};

  QueryDetailSceneRuleLogResponseBodyData() {}

  explicit QueryDetailSceneRuleLogResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (logList) {
      vector<boost::any> temp1;
      for(auto item1:*logList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("LogList") != m.end() && !m["LogList"].empty()) {
      if (typeid(vector<boost::any>) == m["LogList"].type()) {
        vector<QueryDetailSceneRuleLogResponseBodyDataLogList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDetailSceneRuleLogResponseBodyDataLogList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logList = make_shared<vector<QueryDetailSceneRuleLogResponseBodyDataLogList>>(expect1);
      }
    }
  }


  virtual ~QueryDetailSceneRuleLogResponseBodyData() = default;
};
class QueryDetailSceneRuleLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<QueryDetailSceneRuleLogResponseBodyData> data{};

  QueryDetailSceneRuleLogResponseBody() {}

  explicit QueryDetailSceneRuleLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDetailSceneRuleLogResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDetailSceneRuleLogResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryDetailSceneRuleLogResponseBody() = default;
};
class QueryDetailSceneRuleLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryDetailSceneRuleLogResponseBody> body{};

  QueryDetailSceneRuleLogResponse() {}

  explicit QueryDetailSceneRuleLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDetailSceneRuleLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDetailSceneRuleLogResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDetailSceneRuleLogResponse() = default;
};
class QueryDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<long> currentPage{};

  QueryDeviceRequest() {}

  explicit QueryDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~QueryDeviceRequest() = default;
};
class QueryDeviceResponseBodyDataDeviceInfo : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceSecret{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceStatus{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceType{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> utcModified{};
  shared_ptr<string> iotId{};
  shared_ptr<string> nickname{};

  QueryDeviceResponseBodyDataDeviceInfo() {}

  explicit QueryDeviceResponseBodyDataDeviceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceSecret) {
      res["DeviceSecret"] = boost::any(*deviceSecret);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceStatus) {
      res["DeviceStatus"] = boost::any(*deviceStatus);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceSecret") != m.end() && !m["DeviceSecret"].empty()) {
      deviceSecret = make_shared<string>(boost::any_cast<string>(m["DeviceSecret"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceStatus") != m.end() && !m["DeviceStatus"].empty()) {
      deviceStatus = make_shared<string>(boost::any_cast<string>(m["DeviceStatus"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
  }


  virtual ~QueryDeviceResponseBodyDataDeviceInfo() = default;
};
class QueryDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceResponseBodyDataDeviceInfo>> deviceInfo{};

  QueryDeviceResponseBodyData() {}

  explicit QueryDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*deviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceInfo") != m.end() && !m["DeviceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceInfo"].type()) {
        vector<QueryDeviceResponseBodyDataDeviceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceResponseBodyDataDeviceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceInfo = make_shared<vector<QueryDeviceResponseBodyDataDeviceInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceResponseBodyData() = default;
};
class QueryDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> total{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> page{};
  shared_ptr<QueryDeviceResponseBodyData> data{};

  QueryDeviceResponseBody() {}

  explicit QueryDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryDeviceResponseBody() = default;
};
class QueryDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryDeviceResponseBody> body{};

  QueryDeviceResponse() {}

  explicit QueryDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceResponse() = default;
};
class QueryDeviceBySQLRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> SQL{};

  QueryDeviceBySQLRequest() {}

  explicit QueryDeviceBySQLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (SQL) {
      res["SQL"] = boost::any(*SQL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("SQL") != m.end() && !m["SQL"].empty()) {
      SQL = make_shared<string>(boost::any_cast<string>(m["SQL"]));
    }
  }


  virtual ~QueryDeviceBySQLRequest() = default;
};
class QueryDeviceBySQLResponseBodyDataGroups : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};

  QueryDeviceBySQLResponseBodyDataGroups() {}

  explicit QueryDeviceBySQLResponseBodyDataGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~QueryDeviceBySQLResponseBodyDataGroups() = default;
};
class QueryDeviceBySQLResponseBodyDataTags : public Darabonba::Model {
public:
  shared_ptr<string> tagName{};
  shared_ptr<string> tagValue{};

  QueryDeviceBySQLResponseBodyDataTags() {}

  explicit QueryDeviceBySQLResponseBodyDataTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~QueryDeviceBySQLResponseBodyDataTags() = default;
};
class QueryDeviceBySQLResponseBodyDataOTAModules : public Darabonba::Model {
public:
  shared_ptr<string> moduleName{};
  shared_ptr<string> firmwareVersion{};

  QueryDeviceBySQLResponseBodyDataOTAModules() {}

  explicit QueryDeviceBySQLResponseBodyDataOTAModules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    if (firmwareVersion) {
      res["FirmwareVersion"] = boost::any(*firmwareVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
    if (m.find("FirmwareVersion") != m.end() && !m["FirmwareVersion"].empty()) {
      firmwareVersion = make_shared<string>(boost::any_cast<string>(m["FirmwareVersion"]));
    }
  }


  virtual ~QueryDeviceBySQLResponseBodyDataOTAModules() = default;
};
class QueryDeviceBySQLResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> nickname{};
  shared_ptr<string> status{};
  shared_ptr<string> activeTime{};
  shared_ptr<string> iotId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<vector<QueryDeviceBySQLResponseBodyDataGroups>> groups{};
  shared_ptr<vector<QueryDeviceBySQLResponseBodyDataTags>> tags{};
  shared_ptr<vector<QueryDeviceBySQLResponseBodyDataOTAModules>> OTAModules{};

  QueryDeviceBySQLResponseBodyData() {}

  explicit QueryDeviceBySQLResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (activeTime) {
      res["ActiveTime"] = boost::any(*activeTime);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (groups) {
      vector<boost::any> temp1;
      for(auto item1:*groups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Groups"] = boost::any(temp1);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (OTAModules) {
      vector<boost::any> temp1;
      for(auto item1:*OTAModules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OTAModules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ActiveTime") != m.end() && !m["ActiveTime"].empty()) {
      activeTime = make_shared<string>(boost::any_cast<string>(m["ActiveTime"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Groups") != m.end() && !m["Groups"].empty()) {
      if (typeid(vector<boost::any>) == m["Groups"].type()) {
        vector<QueryDeviceBySQLResponseBodyDataGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Groups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceBySQLResponseBodyDataGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groups = make_shared<vector<QueryDeviceBySQLResponseBodyDataGroups>>(expect1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<QueryDeviceBySQLResponseBodyDataTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceBySQLResponseBodyDataTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<QueryDeviceBySQLResponseBodyDataTags>>(expect1);
      }
    }
    if (m.find("OTAModules") != m.end() && !m["OTAModules"].empty()) {
      if (typeid(vector<boost::any>) == m["OTAModules"].type()) {
        vector<QueryDeviceBySQLResponseBodyDataOTAModules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OTAModules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceBySQLResponseBodyDataOTAModules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        OTAModules = make_shared<vector<QueryDeviceBySQLResponseBodyDataOTAModules>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceBySQLResponseBodyData() = default;
};
class QueryDeviceBySQLResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<QueryDeviceBySQLResponseBodyData>> data{};

  QueryDeviceBySQLResponseBody() {}

  explicit QueryDeviceBySQLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<QueryDeviceBySQLResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceBySQLResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<QueryDeviceBySQLResponseBodyData>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceBySQLResponseBody() = default;
};
class QueryDeviceBySQLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryDeviceBySQLResponseBody> body{};

  QueryDeviceBySQLResponse() {}

  explicit QueryDeviceBySQLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceBySQLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceBySQLResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceBySQLResponse() = default;
};
class QueryDeviceByStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<long> status{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};

  QueryDeviceByStatusRequest() {}

  explicit QueryDeviceByStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~QueryDeviceByStatusRequest() = default;
};
class QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> status{};
  shared_ptr<string> iotId{};
  shared_ptr<string> nickname{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> utcModified{};
  shared_ptr<string> deviceSecret{};

  QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo() {}

  explicit QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (deviceSecret) {
      res["DeviceSecret"] = boost::any(*deviceSecret);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("DeviceSecret") != m.end() && !m["DeviceSecret"].empty()) {
      deviceSecret = make_shared<string>(boost::any_cast<string>(m["DeviceSecret"]));
    }
  }


  virtual ~QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo() = default;
};
class QueryDeviceByStatusResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo>> simpleDeviceInfo{};

  QueryDeviceByStatusResponseBodyData() {}

  explicit QueryDeviceByStatusResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (simpleDeviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*simpleDeviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SimpleDeviceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SimpleDeviceInfo") != m.end() && !m["SimpleDeviceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SimpleDeviceInfo"].type()) {
        vector<QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SimpleDeviceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        simpleDeviceInfo = make_shared<vector<QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceByStatusResponseBodyData() = default;
};
class QueryDeviceByStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> total{};
  shared_ptr<QueryDeviceByStatusResponseBodyData> data{};

  QueryDeviceByStatusResponseBody() {}

  explicit QueryDeviceByStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceByStatusResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceByStatusResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryDeviceByStatusResponseBody() = default;
};
class QueryDeviceByStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryDeviceByStatusResponseBody> body{};

  QueryDeviceByStatusResponse() {}

  explicit QueryDeviceByStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceByStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceByStatusResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceByStatusResponse() = default;
};
class QueryDeviceByTagsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  QueryDeviceByTagsRequestTag() {}

  explicit QueryDeviceByTagsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~QueryDeviceByTagsRequestTag() = default;
};
class QueryDeviceByTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<QueryDeviceByTagsRequestTag>> tag{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  QueryDeviceByTagsRequest() {}

  explicit QueryDeviceByTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<QueryDeviceByTagsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceByTagsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<QueryDeviceByTagsRequestTag>>(expect1);
      }
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryDeviceByTagsRequest() = default;
};
class QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo : public Darabonba::Model {
public:
  shared_ptr<string> productName{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};

  QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo() {}

  explicit QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo() = default;
};
class QueryDeviceByTagsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo>> simpleDeviceInfo{};

  QueryDeviceByTagsResponseBodyData() {}

  explicit QueryDeviceByTagsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (simpleDeviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*simpleDeviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SimpleDeviceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SimpleDeviceInfo") != m.end() && !m["SimpleDeviceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SimpleDeviceInfo"].type()) {
        vector<QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SimpleDeviceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        simpleDeviceInfo = make_shared<vector<QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceByTagsResponseBodyData() = default;
};
class QueryDeviceByTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> total{};
  shared_ptr<QueryDeviceByTagsResponseBodyData> data{};

  QueryDeviceByTagsResponseBody() {}

  explicit QueryDeviceByTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceByTagsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceByTagsResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryDeviceByTagsResponseBody() = default;
};
class QueryDeviceByTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryDeviceByTagsResponseBody> body{};

  QueryDeviceByTagsResponse() {}

  explicit QueryDeviceByTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceByTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceByTagsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceByTagsResponse() = default;
};
class QueryDeviceCertRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};

  QueryDeviceCertRequest() {}

  explicit QueryDeviceCertRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
  }


  virtual ~QueryDeviceCertRequest() = default;
};
class QueryDeviceCertResponseBodyDeviceCertInfo : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<string> certificate{};
  shared_ptr<string> privateKey{};
  shared_ptr<string> certSN{};

  QueryDeviceCertResponseBodyDeviceCertInfo() {}

  explicit QueryDeviceCertResponseBodyDeviceCertInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (certificate) {
      res["Certificate"] = boost::any(*certificate);
    }
    if (privateKey) {
      res["PrivateKey"] = boost::any(*privateKey);
    }
    if (certSN) {
      res["CertSN"] = boost::any(*certSN);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["Certificate"]));
    }
    if (m.find("PrivateKey") != m.end() && !m["PrivateKey"].empty()) {
      privateKey = make_shared<string>(boost::any_cast<string>(m["PrivateKey"]));
    }
    if (m.find("CertSN") != m.end() && !m["CertSN"].empty()) {
      certSN = make_shared<string>(boost::any_cast<string>(m["CertSN"]));
    }
  }


  virtual ~QueryDeviceCertResponseBodyDeviceCertInfo() = default;
};
class QueryDeviceCertResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceCertResponseBodyDeviceCertInfo> deviceCertInfo{};

  QueryDeviceCertResponseBody() {}

  explicit QueryDeviceCertResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (deviceCertInfo) {
      res["DeviceCertInfo"] = deviceCertInfo ? boost::any(deviceCertInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("DeviceCertInfo") != m.end() && !m["DeviceCertInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeviceCertInfo"].type()) {
        QueryDeviceCertResponseBodyDeviceCertInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeviceCertInfo"]));
        deviceCertInfo = make_shared<QueryDeviceCertResponseBodyDeviceCertInfo>(model1);
      }
    }
  }


  virtual ~QueryDeviceCertResponseBody() = default;
};
class QueryDeviceCertResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryDeviceCertResponseBody> body{};

  QueryDeviceCertResponse() {}

  explicit QueryDeviceCertResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceCertResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceCertResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceCertResponse() = default;
};
class QueryDeviceDesiredPropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<vector<string>> identifier{};
  shared_ptr<string> iotId{};
  shared_ptr<string> functionBlockId{};

  QueryDeviceDesiredPropertyRequest() {}

  explicit QueryDeviceDesiredPropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Identifier"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Identifier"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      identifier = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
  }


  virtual ~QueryDeviceDesiredPropertyRequest() = default;
};
class QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo : public Darabonba::Model {
public:
  shared_ptr<string> unit{};
  shared_ptr<string> identifier{};
  shared_ptr<string> dataType{};
  shared_ptr<string> time{};
  shared_ptr<string> value{};
  shared_ptr<string> name{};
  shared_ptr<long> version{};

  QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo() {}

  explicit QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo() = default;
};
class QueryDeviceDesiredPropertyResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo>> desiredPropertyInfo{};

  QueryDeviceDesiredPropertyResponseBodyDataList() {}

  explicit QueryDeviceDesiredPropertyResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desiredPropertyInfo) {
      vector<boost::any> temp1;
      for(auto item1:*desiredPropertyInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DesiredPropertyInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesiredPropertyInfo") != m.end() && !m["DesiredPropertyInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["DesiredPropertyInfo"].type()) {
        vector<QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DesiredPropertyInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        desiredPropertyInfo = make_shared<vector<QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceDesiredPropertyResponseBodyDataList() = default;
};
class QueryDeviceDesiredPropertyResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QueryDeviceDesiredPropertyResponseBodyDataList> list{};

  QueryDeviceDesiredPropertyResponseBodyData() {}

  explicit QueryDeviceDesiredPropertyResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDeviceDesiredPropertyResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDeviceDesiredPropertyResponseBodyDataList>(model1);
      }
    }
  }


  virtual ~QueryDeviceDesiredPropertyResponseBodyData() = default;
};
class QueryDeviceDesiredPropertyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceDesiredPropertyResponseBodyData> data{};

  QueryDeviceDesiredPropertyResponseBody() {}

  explicit QueryDeviceDesiredPropertyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceDesiredPropertyResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceDesiredPropertyResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryDeviceDesiredPropertyResponseBody() = default;
};
class QueryDeviceDesiredPropertyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryDeviceDesiredPropertyResponseBody> body{};

  QueryDeviceDesiredPropertyResponse() {}

  explicit QueryDeviceDesiredPropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceDesiredPropertyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceDesiredPropertyResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceDesiredPropertyResponse() = default;
};
class QueryDeviceDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};

  QueryDeviceDetailRequest() {}

  explicit QueryDeviceDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~QueryDeviceDetailRequest() = default;
};
class QueryDeviceDetailResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> iotId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceSecret{};
  shared_ptr<string> firmwareVersion{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> gmtActive{};
  shared_ptr<string> utcActive{};
  shared_ptr<string> gmtOnline{};
  shared_ptr<string> utcOnline{};
  shared_ptr<string> status{};
  shared_ptr<string> ipAddress{};
  shared_ptr<long> nodeType{};
  shared_ptr<string> region{};
  shared_ptr<bool> owner{};
  shared_ptr<string> nickname{};

  QueryDeviceDetailResponseBodyData() {}

  explicit QueryDeviceDetailResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceSecret) {
      res["DeviceSecret"] = boost::any(*deviceSecret);
    }
    if (firmwareVersion) {
      res["FirmwareVersion"] = boost::any(*firmwareVersion);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (gmtActive) {
      res["GmtActive"] = boost::any(*gmtActive);
    }
    if (utcActive) {
      res["UtcActive"] = boost::any(*utcActive);
    }
    if (gmtOnline) {
      res["GmtOnline"] = boost::any(*gmtOnline);
    }
    if (utcOnline) {
      res["UtcOnline"] = boost::any(*utcOnline);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceSecret") != m.end() && !m["DeviceSecret"].empty()) {
      deviceSecret = make_shared<string>(boost::any_cast<string>(m["DeviceSecret"]));
    }
    if (m.find("FirmwareVersion") != m.end() && !m["FirmwareVersion"].empty()) {
      firmwareVersion = make_shared<string>(boost::any_cast<string>(m["FirmwareVersion"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("GmtActive") != m.end() && !m["GmtActive"].empty()) {
      gmtActive = make_shared<string>(boost::any_cast<string>(m["GmtActive"]));
    }
    if (m.find("UtcActive") != m.end() && !m["UtcActive"].empty()) {
      utcActive = make_shared<string>(boost::any_cast<string>(m["UtcActive"]));
    }
    if (m.find("GmtOnline") != m.end() && !m["GmtOnline"].empty()) {
      gmtOnline = make_shared<string>(boost::any_cast<string>(m["GmtOnline"]));
    }
    if (m.find("UtcOnline") != m.end() && !m["UtcOnline"].empty()) {
      utcOnline = make_shared<string>(boost::any_cast<string>(m["UtcOnline"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<long>(boost::any_cast<long>(m["NodeType"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<bool>(boost::any_cast<bool>(m["Owner"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
  }


  virtual ~QueryDeviceDetailResponseBodyData() = default;
};
class QueryDeviceDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceDetailResponseBodyData> data{};

  QueryDeviceDetailResponseBody() {}

  explicit QueryDeviceDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceDetailResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceDetailResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryDeviceDetailResponseBody() = default;
};
class QueryDeviceDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryDeviceDetailResponseBody> body{};

  QueryDeviceDetailResponse() {}

  explicit QueryDeviceDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceDetailResponse() = default;
};
class QueryDeviceDistributeDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  QueryDeviceDistributeDetailRequest() {}

  explicit QueryDeviceDistributeDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~QueryDeviceDistributeDetailRequest() = default;
};
class QueryDeviceDistributeDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> file{};

  QueryDeviceDistributeDetailResponseBody() {}

  explicit QueryDeviceDistributeDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (file) {
      res["File"] = boost::any(*file);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      file = make_shared<string>(boost::any_cast<string>(m["File"]));
    }
  }


  virtual ~QueryDeviceDistributeDetailResponseBody() = default;
};
class QueryDeviceDistributeDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryDeviceDistributeDetailResponseBody> body{};

  QueryDeviceDistributeDetailResponse() {}

  explicit QueryDeviceDistributeDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceDistributeDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceDistributeDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceDistributeDetailResponse() = default;
};
class QueryDeviceDistributeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  QueryDeviceDistributeJobRequest() {}

  explicit QueryDeviceDistributeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~QueryDeviceDistributeJobRequest() = default;
};
class QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs : public Darabonba::Model {
public:
  shared_ptr<string> targetInstanceId{};

  QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs() {}

  explicit QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
  }


  virtual ~QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs() = default;
};
class QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs>> targetInstanceConfigs{};

  QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs() {}

  explicit QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetInstanceConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*targetInstanceConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["targetInstanceConfigs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("targetInstanceConfigs") != m.end() && !m["targetInstanceConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["targetInstanceConfigs"].type()) {
        vector<QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["targetInstanceConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targetInstanceConfigs = make_shared<vector<QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs() = default;
};
class QueryDeviceDistributeJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> sourceUid{};
  shared_ptr<string> targetUid{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> productKey{};
  shared_ptr<long> total{};
  shared_ptr<long> status{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> strategy{};
  shared_ptr<QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs> targetInstanceConfigs{};

  QueryDeviceDistributeJobResponseBodyData() {}

  explicit QueryDeviceDistributeJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceUid) {
      res["SourceUid"] = boost::any(*sourceUid);
    }
    if (targetUid) {
      res["TargetUid"] = boost::any(*targetUid);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (strategy) {
      res["Strategy"] = boost::any(*strategy);
    }
    if (targetInstanceConfigs) {
      res["TargetInstanceConfigs"] = targetInstanceConfigs ? boost::any(targetInstanceConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceUid") != m.end() && !m["SourceUid"].empty()) {
      sourceUid = make_shared<string>(boost::any_cast<string>(m["SourceUid"]));
    }
    if (m.find("TargetUid") != m.end() && !m["TargetUid"].empty()) {
      targetUid = make_shared<string>(boost::any_cast<string>(m["TargetUid"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      strategy = make_shared<long>(boost::any_cast<long>(m["Strategy"]));
    }
    if (m.find("TargetInstanceConfigs") != m.end() && !m["TargetInstanceConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["TargetInstanceConfigs"].type()) {
        QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TargetInstanceConfigs"]));
        targetInstanceConfigs = make_shared<QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs>(model1);
      }
    }
  }


  virtual ~QueryDeviceDistributeJobResponseBodyData() = default;
};
class QueryDeviceDistributeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceDistributeJobResponseBodyData> data{};

  QueryDeviceDistributeJobResponseBody() {}

  explicit QueryDeviceDistributeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceDistributeJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceDistributeJobResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryDeviceDistributeJobResponseBody() = default;
};
class QueryDeviceDistributeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryDeviceDistributeJobResponseBody> body{};

  QueryDeviceDistributeJobResponse() {}

  explicit QueryDeviceDistributeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceDistributeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceDistributeJobResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceDistributeJobResponse() = default;
};
class QueryDeviceEventDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<long> startTime{};
  shared_ptr<string> identifier{};
  shared_ptr<string> eventType{};
  shared_ptr<long> asc{};
  shared_ptr<string> iotId{};
  shared_ptr<long> endTime{};

  QueryDeviceEventDataRequest() {}

  explicit QueryDeviceEventDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<long>(boost::any_cast<long>(m["Asc"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
  }


  virtual ~QueryDeviceEventDataRequest() = default;
};
class QueryDeviceEventDataResponseBodyDataListEventInfo : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> identifier{};
  shared_ptr<string> name{};
  shared_ptr<string> eventType{};
  shared_ptr<string> outputData{};

  QueryDeviceEventDataResponseBodyDataListEventInfo() {}

  explicit QueryDeviceEventDataResponseBodyDataListEventInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (outputData) {
      res["OutputData"] = boost::any(*outputData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("OutputData") != m.end() && !m["OutputData"].empty()) {
      outputData = make_shared<string>(boost::any_cast<string>(m["OutputData"]));
    }
  }


  virtual ~QueryDeviceEventDataResponseBodyDataListEventInfo() = default;
};
class QueryDeviceEventDataResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceEventDataResponseBodyDataListEventInfo>> eventInfo{};

  QueryDeviceEventDataResponseBodyDataList() {}

  explicit QueryDeviceEventDataResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventInfo) {
      vector<boost::any> temp1;
      for(auto item1:*eventInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventInfo") != m.end() && !m["EventInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["EventInfo"].type()) {
        vector<QueryDeviceEventDataResponseBodyDataListEventInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceEventDataResponseBodyDataListEventInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventInfo = make_shared<vector<QueryDeviceEventDataResponseBodyDataListEventInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceEventDataResponseBodyDataList() = default;
};
class QueryDeviceEventDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> nextTime{};
  shared_ptr<bool> nextValid{};
  shared_ptr<QueryDeviceEventDataResponseBodyDataList> list{};

  QueryDeviceEventDataResponseBodyData() {}

  explicit QueryDeviceEventDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextTime) {
      res["NextTime"] = boost::any(*nextTime);
    }
    if (nextValid) {
      res["NextValid"] = boost::any(*nextValid);
    }
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextTime") != m.end() && !m["NextTime"].empty()) {
      nextTime = make_shared<long>(boost::any_cast<long>(m["NextTime"]));
    }
    if (m.find("NextValid") != m.end() && !m["NextValid"].empty()) {
      nextValid = make_shared<bool>(boost::any_cast<bool>(m["NextValid"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDeviceEventDataResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDeviceEventDataResponseBodyDataList>(model1);
      }
    }
  }


  virtual ~QueryDeviceEventDataResponseBodyData() = default;
};
class QueryDeviceEventDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceEventDataResponseBodyData> data{};

  QueryDeviceEventDataResponseBody() {}

  explicit QueryDeviceEventDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceEventDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceEventDataResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryDeviceEventDataResponseBody() = default;
};
class QueryDeviceEventDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryDeviceEventDataResponseBody> body{};

  QueryDeviceEventDataResponse() {}

  explicit QueryDeviceEventDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceEventDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceEventDataResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceEventDataResponse() = default;
};
class QueryDeviceFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> fileId{};

  QueryDeviceFileRequest() {}

  explicit QueryDeviceFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
  }


  virtual ~QueryDeviceFileRequest() = default;
};
class QueryDeviceFileResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> fileId{};
  shared_ptr<string> name{};
  shared_ptr<string> size{};
  shared_ptr<string> utcCreatedOn{};
  shared_ptr<string> downloadUrl{};

  QueryDeviceFileResponseBodyData() {}

  explicit QueryDeviceFileResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (utcCreatedOn) {
      res["UtcCreatedOn"] = boost::any(*utcCreatedOn);
    }
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("UtcCreatedOn") != m.end() && !m["UtcCreatedOn"].empty()) {
      utcCreatedOn = make_shared<string>(boost::any_cast<string>(m["UtcCreatedOn"]));
    }
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
  }


  virtual ~QueryDeviceFileResponseBodyData() = default;
};
class QueryDeviceFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceFileResponseBodyData> data{};

  QueryDeviceFileResponseBody() {}

  explicit QueryDeviceFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceFileResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceFileResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryDeviceFileResponseBody() = default;
};
class QueryDeviceFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryDeviceFileResponseBody> body{};

  QueryDeviceFileResponse() {}

  explicit QueryDeviceFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceFileResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceFileResponse() = default;
};
class QueryDeviceFileListRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<long> currentPage{};

  QueryDeviceFileListRequest() {}

  explicit QueryDeviceFileListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~QueryDeviceFileListRequest() = default;
};
class QueryDeviceFileListResponseBodyDataFileSummary : public Darabonba::Model {
public:
  shared_ptr<string> fileId{};
  shared_ptr<string> name{};
  shared_ptr<string> size{};
  shared_ptr<string> utcCreatedOn{};

  QueryDeviceFileListResponseBodyDataFileSummary() {}

  explicit QueryDeviceFileListResponseBodyDataFileSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (utcCreatedOn) {
      res["UtcCreatedOn"] = boost::any(*utcCreatedOn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("UtcCreatedOn") != m.end() && !m["UtcCreatedOn"].empty()) {
      utcCreatedOn = make_shared<string>(boost::any_cast<string>(m["UtcCreatedOn"]));
    }
  }


  virtual ~QueryDeviceFileListResponseBodyDataFileSummary() = default;
};
class QueryDeviceFileListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceFileListResponseBodyDataFileSummary>> fileSummary{};

  QueryDeviceFileListResponseBodyData() {}

  explicit QueryDeviceFileListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileSummary) {
      vector<boost::any> temp1;
      for(auto item1:*fileSummary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileSummary"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileSummary") != m.end() && !m["FileSummary"].empty()) {
      if (typeid(vector<boost::any>) == m["FileSummary"].type()) {
        vector<QueryDeviceFileListResponseBodyDataFileSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileSummary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceFileListResponseBodyDataFileSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileSummary = make_shared<vector<QueryDeviceFileListResponseBodyDataFileSummary>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceFileListResponseBodyData() = default;
};
class QueryDeviceFileListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};
  shared_ptr<QueryDeviceFileListResponseBodyData> data{};

  QueryDeviceFileListResponseBody() {}

  explicit QueryDeviceFileListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceFileListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceFileListResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryDeviceFileListResponseBody() = default;
};
class QueryDeviceFileListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryDeviceFileListResponseBody> body{};

  QueryDeviceFileListResponse() {}

  explicit QueryDeviceFileListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceFileListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceFileListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceFileListResponse() = default;
};
class QueryDeviceGroupByDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};

  QueryDeviceGroupByDeviceRequest() {}

  explicit QueryDeviceGroupByDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
  }


  virtual ~QueryDeviceGroupByDeviceRequest() = default;
};
class QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> groupDesc{};

  QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo() {}

  explicit QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (groupDesc) {
      res["GroupDesc"] = boost::any(*groupDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("GroupDesc") != m.end() && !m["GroupDesc"].empty()) {
      groupDesc = make_shared<string>(boost::any_cast<string>(m["GroupDesc"]));
    }
  }


  virtual ~QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo() = default;
};
class QueryDeviceGroupByDeviceResponseBodyGroupInfos : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo>> groupInfo{};

  QueryDeviceGroupByDeviceResponseBodyGroupInfos() {}

  explicit QueryDeviceGroupByDeviceResponseBodyGroupInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupInfo) {
      vector<boost::any> temp1;
      for(auto item1:*groupInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupInfo") != m.end() && !m["GroupInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupInfo"].type()) {
        vector<QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupInfo = make_shared<vector<QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceGroupByDeviceResponseBodyGroupInfos() = default;
};
class QueryDeviceGroupByDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceGroupByDeviceResponseBodyGroupInfos> groupInfos{};

  QueryDeviceGroupByDeviceResponseBody() {}

  explicit QueryDeviceGroupByDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (groupInfos) {
      res["GroupInfos"] = groupInfos ? boost::any(groupInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("GroupInfos") != m.end() && !m["GroupInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["GroupInfos"].type()) {
        QueryDeviceGroupByDeviceResponseBodyGroupInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GroupInfos"]));
        groupInfos = make_shared<QueryDeviceGroupByDeviceResponseBodyGroupInfos>(model1);
      }
    }
  }


  virtual ~QueryDeviceGroupByDeviceResponseBody() = default;
};
class QueryDeviceGroupByDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryDeviceGroupByDeviceResponseBody> body{};

  QueryDeviceGroupByDeviceResponse() {}

  explicit QueryDeviceGroupByDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceGroupByDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceGroupByDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceGroupByDeviceResponse() = default;
};
class QueryDeviceGroupByTagsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  QueryDeviceGroupByTagsRequestTag() {}

  explicit QueryDeviceGroupByTagsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~QueryDeviceGroupByTagsRequestTag() = default;
};
class QueryDeviceGroupByTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<QueryDeviceGroupByTagsRequestTag>> tag{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  QueryDeviceGroupByTagsRequest() {}

  explicit QueryDeviceGroupByTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<QueryDeviceGroupByTagsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceGroupByTagsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<QueryDeviceGroupByTagsRequestTag>>(expect1);
      }
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryDeviceGroupByTagsRequest() = default;
};
class QueryDeviceGroupByTagsResponseBodyDataDeviceGroup : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};

  QueryDeviceGroupByTagsResponseBodyDataDeviceGroup() {}

  explicit QueryDeviceGroupByTagsResponseBodyDataDeviceGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~QueryDeviceGroupByTagsResponseBodyDataDeviceGroup() = default;
};
class QueryDeviceGroupByTagsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceGroupByTagsResponseBodyDataDeviceGroup>> deviceGroup{};

  QueryDeviceGroupByTagsResponseBodyData() {}

  explicit QueryDeviceGroupByTagsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceGroup) {
      vector<boost::any> temp1;
      for(auto item1:*deviceGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceGroup") != m.end() && !m["DeviceGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceGroup"].type()) {
        vector<QueryDeviceGroupByTagsResponseBodyDataDeviceGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceGroupByTagsResponseBodyDataDeviceGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceGroup = make_shared<vector<QueryDeviceGroupByTagsResponseBodyDataDeviceGroup>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceGroupByTagsResponseBodyData() = default;
};
class QueryDeviceGroupByTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> total{};
  shared_ptr<QueryDeviceGroupByTagsResponseBodyData> data{};

  QueryDeviceGroupByTagsResponseBody() {}

  explicit QueryDeviceGroupByTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceGroupByTagsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceGroupByTagsResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryDeviceGroupByTagsResponseBody() = default;
};
class QueryDeviceGroupByTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryDeviceGroupByTagsResponseBody> body{};

  QueryDeviceGroupByTagsResponse() {}

  explicit QueryDeviceGroupByTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceGroupByTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceGroupByTagsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceGroupByTagsResponse() = default;
};
class QueryDeviceGroupInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> groupId{};

  QueryDeviceGroupInfoRequest() {}

  explicit QueryDeviceGroupInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~QueryDeviceGroupInfoRequest() = default;
};
class QueryDeviceGroupInfoResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> groupName{};
  shared_ptr<string> groupDesc{};
  shared_ptr<long> deviceCount{};
  shared_ptr<long> deviceActive{};
  shared_ptr<long> deviceOnline{};

  QueryDeviceGroupInfoResponseBodyData() {}

  explicit QueryDeviceGroupInfoResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupDesc) {
      res["GroupDesc"] = boost::any(*groupDesc);
    }
    if (deviceCount) {
      res["DeviceCount"] = boost::any(*deviceCount);
    }
    if (deviceActive) {
      res["DeviceActive"] = boost::any(*deviceActive);
    }
    if (deviceOnline) {
      res["DeviceOnline"] = boost::any(*deviceOnline);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupDesc") != m.end() && !m["GroupDesc"].empty()) {
      groupDesc = make_shared<string>(boost::any_cast<string>(m["GroupDesc"]));
    }
    if (m.find("DeviceCount") != m.end() && !m["DeviceCount"].empty()) {
      deviceCount = make_shared<long>(boost::any_cast<long>(m["DeviceCount"]));
    }
    if (m.find("DeviceActive") != m.end() && !m["DeviceActive"].empty()) {
      deviceActive = make_shared<long>(boost::any_cast<long>(m["DeviceActive"]));
    }
    if (m.find("DeviceOnline") != m.end() && !m["DeviceOnline"].empty()) {
      deviceOnline = make_shared<long>(boost::any_cast<long>(m["DeviceOnline"]));
    }
  }


  virtual ~QueryDeviceGroupInfoResponseBodyData() = default;
};
class QueryDeviceGroupInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceGroupInfoResponseBodyData> data{};

  QueryDeviceGroupInfoResponseBody() {}

  explicit QueryDeviceGroupInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceGroupInfoResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceGroupInfoResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryDeviceGroupInfoResponseBody() = default;
};
class QueryDeviceGroupInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryDeviceGroupInfoResponseBody> body{};

  QueryDeviceGroupInfoResponse() {}

  explicit QueryDeviceGroupInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceGroupInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceGroupInfoResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceGroupInfoResponse() = default;
};
class QueryDeviceGroupListRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> superGroupId{};
  shared_ptr<string> groupName{};
  shared_ptr<long> currentPage{};

  QueryDeviceGroupListRequest() {}

  explicit QueryDeviceGroupListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (superGroupId) {
      res["SuperGroupId"] = boost::any(*superGroupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SuperGroupId") != m.end() && !m["SuperGroupId"].empty()) {
      superGroupId = make_shared<string>(boost::any_cast<string>(m["SuperGroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~QueryDeviceGroupListRequest() = default;
};
class QueryDeviceGroupListResponseBodyDataGroupInfo : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> groupName{};
  shared_ptr<string> groupDesc{};

  QueryDeviceGroupListResponseBodyDataGroupInfo() {}

  explicit QueryDeviceGroupListResponseBodyDataGroupInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupDesc) {
      res["GroupDesc"] = boost::any(*groupDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupDesc") != m.end() && !m["GroupDesc"].empty()) {
      groupDesc = make_shared<string>(boost::any_cast<string>(m["GroupDesc"]));
    }
  }


  virtual ~QueryDeviceGroupListResponseBodyDataGroupInfo() = default;
};
class QueryDeviceGroupListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceGroupListResponseBodyDataGroupInfo>> groupInfo{};

  QueryDeviceGroupListResponseBodyData() {}

  explicit QueryDeviceGroupListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupInfo) {
      vector<boost::any> temp1;
      for(auto item1:*groupInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupInfo") != m.end() && !m["GroupInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupInfo"].type()) {
        vector<QueryDeviceGroupListResponseBodyDataGroupInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceGroupListResponseBodyDataGroupInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupInfo = make_shared<vector<QueryDeviceGroupListResponseBodyDataGroupInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceGroupListResponseBodyData() = default;
};
class QueryDeviceGroupListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};
  shared_ptr<QueryDeviceGroupListResponseBodyData> data{};

  QueryDeviceGroupListResponseBody() {}

  explicit QueryDeviceGroupListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceGroupListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceGroupListResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryDeviceGroupListResponseBody() = default;
};
class QueryDeviceGroupListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryDeviceGroupListResponseBody> body{};

  QueryDeviceGroupListResponse() {}

  explicit QueryDeviceGroupListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceGroupListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceGroupListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceGroupListResponse() = default;
};
class QueryDeviceGroupTagListRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> groupId{};

  QueryDeviceGroupTagListRequest() {}

  explicit QueryDeviceGroupTagListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~QueryDeviceGroupTagListRequest() = default;
};
class QueryDeviceGroupTagListResponseBodyDataGroupTagInfo : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  QueryDeviceGroupTagListResponseBodyDataGroupTagInfo() {}

  explicit QueryDeviceGroupTagListResponseBodyDataGroupTagInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~QueryDeviceGroupTagListResponseBodyDataGroupTagInfo() = default;
};
class QueryDeviceGroupTagListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceGroupTagListResponseBodyDataGroupTagInfo>> groupTagInfo{};

  QueryDeviceGroupTagListResponseBodyData() {}

  explicit QueryDeviceGroupTagListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupTagInfo) {
      vector<boost::any> temp1;
      for(auto item1:*groupTagInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupTagInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupTagInfo") != m.end() && !m["GroupTagInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupTagInfo"].type()) {
        vector<QueryDeviceGroupTagListResponseBodyDataGroupTagInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupTagInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceGroupTagListResponseBodyDataGroupTagInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupTagInfo = make_shared<vector<QueryDeviceGroupTagListResponseBodyDataGroupTagInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceGroupTagListResponseBodyData() = default;
};
class QueryDeviceGroupTagListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceGroupTagListResponseBodyData> data{};

  QueryDeviceGroupTagListResponseBody() {}

  explicit QueryDeviceGroupTagListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceGroupTagListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceGroupTagListResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryDeviceGroupTagListResponseBody() = default;
};
class QueryDeviceGroupTagListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryDeviceGroupTagListResponseBody> body{};

  QueryDeviceGroupTagListResponse() {}

  explicit QueryDeviceGroupTagListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceGroupTagListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceGroupTagListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceGroupTagListResponse() = default;
};
class QueryDeviceListByDeviceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};

  QueryDeviceListByDeviceGroupRequest() {}

  explicit QueryDeviceListByDeviceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~QueryDeviceListByDeviceGroupRequest() = default;
};
class QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo : public Darabonba::Model {
public:
  shared_ptr<string> productName{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};

  QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo() {}

  explicit QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo() = default;
};
class QueryDeviceListByDeviceGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo>> simpleDeviceInfo{};

  QueryDeviceListByDeviceGroupResponseBodyData() {}

  explicit QueryDeviceListByDeviceGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (simpleDeviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*simpleDeviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SimpleDeviceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SimpleDeviceInfo") != m.end() && !m["SimpleDeviceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SimpleDeviceInfo"].type()) {
        vector<QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SimpleDeviceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        simpleDeviceInfo = make_shared<vector<QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceListByDeviceGroupResponseBodyData() = default;
};
class QueryDeviceListByDeviceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> total{};
  shared_ptr<QueryDeviceListByDeviceGroupResponseBodyData> data{};

  QueryDeviceListByDeviceGroupResponseBody() {}

  explicit QueryDeviceListByDeviceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceListByDeviceGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceListByDeviceGroupResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryDeviceListByDeviceGroupResponseBody() = default;
};
class QueryDeviceListByDeviceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryDeviceListByDeviceGroupResponseBody> body{};

  QueryDeviceListByDeviceGroupResponse() {}

  explicit QueryDeviceListByDeviceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceListByDeviceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceListByDeviceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceListByDeviceGroupResponse() = default;
};
class QueryDeviceOriginalEventDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> startTime{};
  shared_ptr<string> identifier{};
  shared_ptr<long> asc{};
  shared_ptr<string> iotId{};
  shared_ptr<long> endTime{};

  QueryDeviceOriginalEventDataRequest() {}

  explicit QueryDeviceOriginalEventDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<long>(boost::any_cast<long>(m["Asc"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
  }


  virtual ~QueryDeviceOriginalEventDataRequest() = default;
};
class QueryDeviceOriginalEventDataResponseBodyDataListEventInfo : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> identifier{};
  shared_ptr<string> name{};
  shared_ptr<string> eventType{};
  shared_ptr<string> outputData{};

  QueryDeviceOriginalEventDataResponseBodyDataListEventInfo() {}

  explicit QueryDeviceOriginalEventDataResponseBodyDataListEventInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (outputData) {
      res["OutputData"] = boost::any(*outputData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("OutputData") != m.end() && !m["OutputData"].empty()) {
      outputData = make_shared<string>(boost::any_cast<string>(m["OutputData"]));
    }
  }


  virtual ~QueryDeviceOriginalEventDataResponseBodyDataListEventInfo() = default;
};
class QueryDeviceOriginalEventDataResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceOriginalEventDataResponseBodyDataListEventInfo>> eventInfo{};

  QueryDeviceOriginalEventDataResponseBodyDataList() {}

  explicit QueryDeviceOriginalEventDataResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventInfo) {
      vector<boost::any> temp1;
      for(auto item1:*eventInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventInfo") != m.end() && !m["EventInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["EventInfo"].type()) {
        vector<QueryDeviceOriginalEventDataResponseBodyDataListEventInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceOriginalEventDataResponseBodyDataListEventInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventInfo = make_shared<vector<QueryDeviceOriginalEventDataResponseBodyDataListEventInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceOriginalEventDataResponseBodyDataList() = default;
};
class QueryDeviceOriginalEventDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> nextPageToken{};
  shared_ptr<bool> nextValid{};
  shared_ptr<QueryDeviceOriginalEventDataResponseBodyDataList> list{};

  QueryDeviceOriginalEventDataResponseBodyData() {}

  explicit QueryDeviceOriginalEventDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (nextValid) {
      res["NextValid"] = boost::any(*nextValid);
    }
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("NextValid") != m.end() && !m["NextValid"].empty()) {
      nextValid = make_shared<bool>(boost::any_cast<bool>(m["NextValid"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDeviceOriginalEventDataResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDeviceOriginalEventDataResponseBodyDataList>(model1);
      }
    }
  }


  virtual ~QueryDeviceOriginalEventDataResponseBodyData() = default;
};
class QueryDeviceOriginalEventDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceOriginalEventDataResponseBodyData> data{};

  QueryDeviceOriginalEventDataResponseBody() {}

  explicit QueryDeviceOriginalEventDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceOriginalEventDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceOriginalEventDataResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryDeviceOriginalEventDataResponseBody() = default;
};
class QueryDeviceOriginalEventDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryDeviceOriginalEventDataResponseBody> body{};

  QueryDeviceOriginalEventDataResponse() {}

  explicit QueryDeviceOriginalEventDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceOriginalEventDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceOriginalEventDataResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceOriginalEventDataResponse() = default;
};
class QueryDeviceOriginalPropertyDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> startTime{};
  shared_ptr<string> identifier{};
  shared_ptr<long> asc{};
  shared_ptr<string> iotId{};
  shared_ptr<long> endTime{};

  QueryDeviceOriginalPropertyDataRequest() {}

  explicit QueryDeviceOriginalPropertyDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<long>(boost::any_cast<long>(m["Asc"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
  }


  virtual ~QueryDeviceOriginalPropertyDataRequest() = default;
};
class QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> value{};

  QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo() {}

  explicit QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo() = default;
};
class QueryDeviceOriginalPropertyDataResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo>> propertyInfo{};

  QueryDeviceOriginalPropertyDataResponseBodyDataList() {}

  explicit QueryDeviceOriginalPropertyDataResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertyInfo) {
      vector<boost::any> temp1;
      for(auto item1:*propertyInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertyInfo") != m.end() && !m["PropertyInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyInfo"].type()) {
        vector<QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyInfo = make_shared<vector<QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceOriginalPropertyDataResponseBodyDataList() = default;
};
class QueryDeviceOriginalPropertyDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> nextValid{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<QueryDeviceOriginalPropertyDataResponseBodyDataList> list{};

  QueryDeviceOriginalPropertyDataResponseBodyData() {}

  explicit QueryDeviceOriginalPropertyDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextValid) {
      res["NextValid"] = boost::any(*nextValid);
    }
    if (nextPageToken) {
      res["nextPageToken"] = boost::any(*nextPageToken);
    }
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextValid") != m.end() && !m["NextValid"].empty()) {
      nextValid = make_shared<bool>(boost::any_cast<bool>(m["NextValid"]));
    }
    if (m.find("nextPageToken") != m.end() && !m["nextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["nextPageToken"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDeviceOriginalPropertyDataResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDeviceOriginalPropertyDataResponseBodyDataList>(model1);
      }
    }
  }


  virtual ~QueryDeviceOriginalPropertyDataResponseBodyData() = default;
};
class QueryDeviceOriginalPropertyDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceOriginalPropertyDataResponseBodyData> data{};

  QueryDeviceOriginalPropertyDataResponseBody() {}

  explicit QueryDeviceOriginalPropertyDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceOriginalPropertyDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceOriginalPropertyDataResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryDeviceOriginalPropertyDataResponseBody() = default;
};
class QueryDeviceOriginalPropertyDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryDeviceOriginalPropertyDataResponseBody> body{};

  QueryDeviceOriginalPropertyDataResponse() {}

  explicit QueryDeviceOriginalPropertyDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceOriginalPropertyDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceOriginalPropertyDataResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceOriginalPropertyDataResponse() = default;
};
class QueryDeviceOriginalPropertyStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> iotId{};
  shared_ptr<long> asc{};

  QueryDeviceOriginalPropertyStatusRequest() {}

  explicit QueryDeviceOriginalPropertyStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<long>(boost::any_cast<long>(m["Asc"]));
    }
  }


  virtual ~QueryDeviceOriginalPropertyStatusRequest() = default;
};
class QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo : public Darabonba::Model {
public:
  shared_ptr<string> identifier{};
  shared_ptr<string> value{};
  shared_ptr<long> time{};

  QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo() {}

  explicit QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
  }


  virtual ~QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo() = default;
};
class QueryDeviceOriginalPropertyStatusResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo>> propertyStatusDataInfo{};

  QueryDeviceOriginalPropertyStatusResponseBodyDataList() {}

  explicit QueryDeviceOriginalPropertyStatusResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertyStatusDataInfo) {
      vector<boost::any> temp1;
      for(auto item1:*propertyStatusDataInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyStatusDataInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertyStatusDataInfo") != m.end() && !m["PropertyStatusDataInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyStatusDataInfo"].type()) {
        vector<QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyStatusDataInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyStatusDataInfo = make_shared<vector<QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceOriginalPropertyStatusResponseBodyDataList() = default;
};
class QueryDeviceOriginalPropertyStatusResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> nextValid{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<QueryDeviceOriginalPropertyStatusResponseBodyDataList> list{};

  QueryDeviceOriginalPropertyStatusResponseBodyData() {}

  explicit QueryDeviceOriginalPropertyStatusResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextValid) {
      res["NextValid"] = boost::any(*nextValid);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextValid") != m.end() && !m["NextValid"].empty()) {
      nextValid = make_shared<bool>(boost::any_cast<bool>(m["NextValid"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDeviceOriginalPropertyStatusResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDeviceOriginalPropertyStatusResponseBodyDataList>(model1);
      }
    }
  }


  virtual ~QueryDeviceOriginalPropertyStatusResponseBodyData() = default;
};
class QueryDeviceOriginalPropertyStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceOriginalPropertyStatusResponseBodyData> data{};

  QueryDeviceOriginalPropertyStatusResponseBody() {}

  explicit QueryDeviceOriginalPropertyStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceOriginalPropertyStatusResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceOriginalPropertyStatusResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryDeviceOriginalPropertyStatusResponseBody() = default;
};
class QueryDeviceOriginalPropertyStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryDeviceOriginalPropertyStatusResponseBody> body{};

  QueryDeviceOriginalPropertyStatusResponse() {}

  explicit QueryDeviceOriginalPropertyStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceOriginalPropertyStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceOriginalPropertyStatusResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceOriginalPropertyStatusResponse() = default;
};
class QueryDeviceOriginalServiceDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> startTime{};
  shared_ptr<string> identifier{};
  shared_ptr<long> asc{};
  shared_ptr<string> iotId{};
  shared_ptr<long> endTime{};

  QueryDeviceOriginalServiceDataRequest() {}

  explicit QueryDeviceOriginalServiceDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<long>(boost::any_cast<long>(m["Asc"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
  }


  virtual ~QueryDeviceOriginalServiceDataRequest() = default;
};
class QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> identifier{};
  shared_ptr<string> name{};
  shared_ptr<string> inputData{};
  shared_ptr<string> outputData{};

  QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo() {}

  explicit QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (inputData) {
      res["InputData"] = boost::any(*inputData);
    }
    if (outputData) {
      res["OutputData"] = boost::any(*outputData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("InputData") != m.end() && !m["InputData"].empty()) {
      inputData = make_shared<string>(boost::any_cast<string>(m["InputData"]));
    }
    if (m.find("OutputData") != m.end() && !m["OutputData"].empty()) {
      outputData = make_shared<string>(boost::any_cast<string>(m["OutputData"]));
    }
  }


  virtual ~QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo() = default;
};
class QueryDeviceOriginalServiceDataResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo>> serviceInfo{};

  QueryDeviceOriginalServiceDataResponseBodyDataList() {}

  explicit QueryDeviceOriginalServiceDataResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*serviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceInfo") != m.end() && !m["ServiceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceInfo"].type()) {
        vector<QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceInfo = make_shared<vector<QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceOriginalServiceDataResponseBodyDataList() = default;
};
class QueryDeviceOriginalServiceDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> nextPageToken{};
  shared_ptr<bool> nextValid{};
  shared_ptr<QueryDeviceOriginalServiceDataResponseBodyDataList> list{};

  QueryDeviceOriginalServiceDataResponseBodyData() {}

  explicit QueryDeviceOriginalServiceDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (nextValid) {
      res["NextValid"] = boost::any(*nextValid);
    }
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("NextValid") != m.end() && !m["NextValid"].empty()) {
      nextValid = make_shared<bool>(boost::any_cast<bool>(m["NextValid"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDeviceOriginalServiceDataResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDeviceOriginalServiceDataResponseBodyDataList>(model1);
      }
    }
  }


  virtual ~QueryDeviceOriginalServiceDataResponseBodyData() = default;
};
class QueryDeviceOriginalServiceDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceOriginalServiceDataResponseBodyData> data{};

  QueryDeviceOriginalServiceDataResponseBody() {}

  explicit QueryDeviceOriginalServiceDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceOriginalServiceDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceOriginalServiceDataResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryDeviceOriginalServiceDataResponseBody() = default;
};
class QueryDeviceOriginalServiceDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryDeviceOriginalServiceDataResponseBody> body{};

  QueryDeviceOriginalServiceDataResponse() {}

  explicit QueryDeviceOriginalServiceDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceOriginalServiceDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceOriginalServiceDataResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceOriginalServiceDataResponse() = default;
};
class QueryDevicePropRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};

  QueryDevicePropRequest() {}

  explicit QueryDevicePropRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~QueryDevicePropRequest() = default;
};
class QueryDevicePropResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> props{};

  QueryDevicePropResponseBody() {}

  explicit QueryDevicePropResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (props) {
      res["Props"] = boost::any(*props);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Props") != m.end() && !m["Props"].empty()) {
      props = make_shared<string>(boost::any_cast<string>(m["Props"]));
    }
  }


  virtual ~QueryDevicePropResponseBody() = default;
};
class QueryDevicePropResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryDevicePropResponseBody> body{};

  QueryDevicePropResponse() {}

  explicit QueryDevicePropResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDevicePropResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDevicePropResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDevicePropResponse() = default;
};
class QueryDevicePropertiesDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<long> startTime{};
  shared_ptr<vector<string>> identifier{};
  shared_ptr<long> asc{};
  shared_ptr<string> iotId{};
  shared_ptr<long> endTime{};

  QueryDevicePropertiesDataRequest() {}

  explicit QueryDevicePropertiesDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Identifier"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Identifier"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      identifier = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<long>(boost::any_cast<long>(m["Asc"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
  }


  virtual ~QueryDevicePropertiesDataRequest() = default;
};
class QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo : public Darabonba::Model {
public:
  shared_ptr<long> time{};
  shared_ptr<string> value{};

  QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo() {}

  explicit QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo() = default;
};
class QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo>> propertyInfo{};

  QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList() {}

  explicit QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertyInfo) {
      vector<boost::any> temp1;
      for(auto item1:*propertyInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertyInfo") != m.end() && !m["PropertyInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyInfo"].type()) {
        vector<QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyInfo = make_shared<vector<QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList() = default;
};
class QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo : public Darabonba::Model {
public:
  shared_ptr<string> identifier{};
  shared_ptr<QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList> list{};

  QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo() {}

  explicit QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList>(model1);
      }
    }
  }


  virtual ~QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo() = default;
};
class QueryDevicePropertiesDataResponseBodyPropertyDataInfos : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo>> propertyDataInfo{};

  QueryDevicePropertiesDataResponseBodyPropertyDataInfos() {}

  explicit QueryDevicePropertiesDataResponseBodyPropertyDataInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertyDataInfo) {
      vector<boost::any> temp1;
      for(auto item1:*propertyDataInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyDataInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertyDataInfo") != m.end() && !m["PropertyDataInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyDataInfo"].type()) {
        vector<QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyDataInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyDataInfo = make_shared<vector<QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDevicePropertiesDataResponseBodyPropertyDataInfos() = default;
};
class QueryDevicePropertiesDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> nextValid{};
  shared_ptr<long> nextTime{};
  shared_ptr<QueryDevicePropertiesDataResponseBodyPropertyDataInfos> propertyDataInfos{};

  QueryDevicePropertiesDataResponseBody() {}

  explicit QueryDevicePropertiesDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (nextValid) {
      res["NextValid"] = boost::any(*nextValid);
    }
    if (nextTime) {
      res["NextTime"] = boost::any(*nextTime);
    }
    if (propertyDataInfos) {
      res["PropertyDataInfos"] = propertyDataInfos ? boost::any(propertyDataInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NextValid") != m.end() && !m["NextValid"].empty()) {
      nextValid = make_shared<bool>(boost::any_cast<bool>(m["NextValid"]));
    }
    if (m.find("NextTime") != m.end() && !m["NextTime"].empty()) {
      nextTime = make_shared<long>(boost::any_cast<long>(m["NextTime"]));
    }
    if (m.find("PropertyDataInfos") != m.end() && !m["PropertyDataInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["PropertyDataInfos"].type()) {
        QueryDevicePropertiesDataResponseBodyPropertyDataInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PropertyDataInfos"]));
        propertyDataInfos = make_shared<QueryDevicePropertiesDataResponseBodyPropertyDataInfos>(model1);
      }
    }
  }


  virtual ~QueryDevicePropertiesDataResponseBody() = default;
};
class QueryDevicePropertiesDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryDevicePropertiesDataResponseBody> body{};

  QueryDevicePropertiesDataResponse() {}

  explicit QueryDevicePropertiesDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDevicePropertiesDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDevicePropertiesDataResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDevicePropertiesDataResponse() = default;
};
class QueryDevicePropertyDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<long> startTime{};
  shared_ptr<string> identifier{};
  shared_ptr<long> asc{};
  shared_ptr<string> iotId{};
  shared_ptr<long> endTime{};

  QueryDevicePropertyDataRequest() {}

  explicit QueryDevicePropertyDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<long>(boost::any_cast<long>(m["Asc"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
  }


  virtual ~QueryDevicePropertyDataRequest() = default;
};
class QueryDevicePropertyDataResponseBodyDataListPropertyInfo : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> value{};

  QueryDevicePropertyDataResponseBodyDataListPropertyInfo() {}

  explicit QueryDevicePropertyDataResponseBodyDataListPropertyInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryDevicePropertyDataResponseBodyDataListPropertyInfo() = default;
};
class QueryDevicePropertyDataResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDevicePropertyDataResponseBodyDataListPropertyInfo>> propertyInfo{};

  QueryDevicePropertyDataResponseBodyDataList() {}

  explicit QueryDevicePropertyDataResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertyInfo) {
      vector<boost::any> temp1;
      for(auto item1:*propertyInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertyInfo") != m.end() && !m["PropertyInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyInfo"].type()) {
        vector<QueryDevicePropertyDataResponseBodyDataListPropertyInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDevicePropertyDataResponseBodyDataListPropertyInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyInfo = make_shared<vector<QueryDevicePropertyDataResponseBodyDataListPropertyInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDevicePropertyDataResponseBodyDataList() = default;
};
class QueryDevicePropertyDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> nextValid{};
  shared_ptr<long> nextTime{};
  shared_ptr<QueryDevicePropertyDataResponseBodyDataList> list{};

  QueryDevicePropertyDataResponseBodyData() {}

  explicit QueryDevicePropertyDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextValid) {
      res["NextValid"] = boost::any(*nextValid);
    }
    if (nextTime) {
      res["NextTime"] = boost::any(*nextTime);
    }
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextValid") != m.end() && !m["NextValid"].empty()) {
      nextValid = make_shared<bool>(boost::any_cast<bool>(m["NextValid"]));
    }
    if (m.find("NextTime") != m.end() && !m["NextTime"].empty()) {
      nextTime = make_shared<long>(boost::any_cast<long>(m["NextTime"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDevicePropertyDataResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDevicePropertyDataResponseBodyDataList>(model1);
      }
    }
  }


  virtual ~QueryDevicePropertyDataResponseBodyData() = default;
};
class QueryDevicePropertyDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDevicePropertyDataResponseBodyData> data{};

  QueryDevicePropertyDataResponseBody() {}

  explicit QueryDevicePropertyDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDevicePropertyDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDevicePropertyDataResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryDevicePropertyDataResponseBody() = default;
};
class QueryDevicePropertyDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryDevicePropertyDataResponseBody> body{};

  QueryDevicePropertyDataResponse() {}

  explicit QueryDevicePropertyDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDevicePropertyDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDevicePropertyDataResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDevicePropertyDataResponse() = default;
};
class QueryDevicePropertyStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> functionBlockId{};

  QueryDevicePropertyStatusRequest() {}

  explicit QueryDevicePropertyStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
  }


  virtual ~QueryDevicePropertyStatusRequest() = default;
};
class QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo : public Darabonba::Model {
public:
  shared_ptr<string> unit{};
  shared_ptr<string> identifier{};
  shared_ptr<string> dataType{};
  shared_ptr<string> time{};
  shared_ptr<string> value{};
  shared_ptr<string> name{};

  QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo() {}

  explicit QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo() = default;
};
class QueryDevicePropertyStatusResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo>> propertyStatusInfo{};

  QueryDevicePropertyStatusResponseBodyDataList() {}

  explicit QueryDevicePropertyStatusResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertyStatusInfo) {
      vector<boost::any> temp1;
      for(auto item1:*propertyStatusInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyStatusInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertyStatusInfo") != m.end() && !m["PropertyStatusInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyStatusInfo"].type()) {
        vector<QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyStatusInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyStatusInfo = make_shared<vector<QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDevicePropertyStatusResponseBodyDataList() = default;
};
class QueryDevicePropertyStatusResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<QueryDevicePropertyStatusResponseBodyDataList> list{};

  QueryDevicePropertyStatusResponseBodyData() {}

  explicit QueryDevicePropertyStatusResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDevicePropertyStatusResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDevicePropertyStatusResponseBodyDataList>(model1);
      }
    }
  }


  virtual ~QueryDevicePropertyStatusResponseBodyData() = default;
};
class QueryDevicePropertyStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDevicePropertyStatusResponseBodyData> data{};

  QueryDevicePropertyStatusResponseBody() {}

  explicit QueryDevicePropertyStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDevicePropertyStatusResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDevicePropertyStatusResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryDevicePropertyStatusResponseBody() = default;
};
class QueryDevicePropertyStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryDevicePropertyStatusResponseBody> body{};

  QueryDevicePropertyStatusResponse() {}

  explicit QueryDevicePropertyStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDevicePropertyStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDevicePropertyStatusResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDevicePropertyStatusResponse() = default;
};
class QueryDeviceServiceDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<long> startTime{};
  shared_ptr<string> identifier{};
  shared_ptr<long> asc{};
  shared_ptr<string> iotId{};
  shared_ptr<long> endTime{};

  QueryDeviceServiceDataRequest() {}

  explicit QueryDeviceServiceDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<long>(boost::any_cast<long>(m["Asc"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
  }


  virtual ~QueryDeviceServiceDataRequest() = default;
};
class QueryDeviceServiceDataResponseBodyDataListServiceInfo : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> identifier{};
  shared_ptr<string> name{};
  shared_ptr<string> inputData{};
  shared_ptr<string> outputData{};

  QueryDeviceServiceDataResponseBodyDataListServiceInfo() {}

  explicit QueryDeviceServiceDataResponseBodyDataListServiceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (inputData) {
      res["InputData"] = boost::any(*inputData);
    }
    if (outputData) {
      res["OutputData"] = boost::any(*outputData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("InputData") != m.end() && !m["InputData"].empty()) {
      inputData = make_shared<string>(boost::any_cast<string>(m["InputData"]));
    }
    if (m.find("OutputData") != m.end() && !m["OutputData"].empty()) {
      outputData = make_shared<string>(boost::any_cast<string>(m["OutputData"]));
    }
  }


  virtual ~QueryDeviceServiceDataResponseBodyDataListServiceInfo() = default;
};
class QueryDeviceServiceDataResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceServiceDataResponseBodyDataListServiceInfo>> serviceInfo{};

  QueryDeviceServiceDataResponseBodyDataList() {}

  explicit QueryDeviceServiceDataResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*serviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceInfo") != m.end() && !m["ServiceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceInfo"].type()) {
        vector<QueryDeviceServiceDataResponseBodyDataListServiceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceServiceDataResponseBodyDataListServiceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceInfo = make_shared<vector<QueryDeviceServiceDataResponseBodyDataListServiceInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceServiceDataResponseBodyDataList() = default;
};
class QueryDeviceServiceDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> nextTime{};
  shared_ptr<bool> nextValid{};
  shared_ptr<QueryDeviceServiceDataResponseBodyDataList> list{};

  QueryDeviceServiceDataResponseBodyData() {}

  explicit QueryDeviceServiceDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextTime) {
      res["NextTime"] = boost::any(*nextTime);
    }
    if (nextValid) {
      res["NextValid"] = boost::any(*nextValid);
    }
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextTime") != m.end() && !m["NextTime"].empty()) {
      nextTime = make_shared<long>(boost::any_cast<long>(m["NextTime"]));
    }
    if (m.find("NextValid") != m.end() && !m["NextValid"].empty()) {
      nextValid = make_shared<bool>(boost::any_cast<bool>(m["NextValid"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDeviceServiceDataResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDeviceServiceDataResponseBodyDataList>(model1);
      }
    }
  }


  virtual ~QueryDeviceServiceDataResponseBodyData() = default;
};
class QueryDeviceServiceDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceServiceDataResponseBodyData> data{};

  QueryDeviceServiceDataResponseBody() {}

  explicit QueryDeviceServiceDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceServiceDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceServiceDataResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryDeviceServiceDataResponseBody() = default;
};
class QueryDeviceServiceDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryDeviceServiceDataResponseBody> body{};

  QueryDeviceServiceDataResponse() {}

  explicit QueryDeviceServiceDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceServiceDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceServiceDataResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceServiceDataResponse() = default;
};
class QueryDeviceStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> groupId{};

  QueryDeviceStatisticsRequest() {}

  explicit QueryDeviceStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~QueryDeviceStatisticsRequest() = default;
};
class QueryDeviceStatisticsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> deviceCount{};
  shared_ptr<long> onlineCount{};
  shared_ptr<long> activeCount{};

  QueryDeviceStatisticsResponseBodyData() {}

  explicit QueryDeviceStatisticsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceCount) {
      res["deviceCount"] = boost::any(*deviceCount);
    }
    if (onlineCount) {
      res["onlineCount"] = boost::any(*onlineCount);
    }
    if (activeCount) {
      res["activeCount"] = boost::any(*activeCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("deviceCount") != m.end() && !m["deviceCount"].empty()) {
      deviceCount = make_shared<long>(boost::any_cast<long>(m["deviceCount"]));
    }
    if (m.find("onlineCount") != m.end() && !m["onlineCount"].empty()) {
      onlineCount = make_shared<long>(boost::any_cast<long>(m["onlineCount"]));
    }
    if (m.find("activeCount") != m.end() && !m["activeCount"].empty()) {
      activeCount = make_shared<long>(boost::any_cast<long>(m["activeCount"]));
    }
  }


  virtual ~QueryDeviceStatisticsResponseBodyData() = default;
};
class QueryDeviceStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceStatisticsResponseBodyData> data{};

  QueryDeviceStatisticsResponseBody() {}

  explicit QueryDeviceStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceStatisticsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceStatisticsResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryDeviceStatisticsResponseBody() = default;
};
class QueryDeviceStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryDeviceStatisticsResponseBody> body{};

  QueryDeviceStatisticsResponse() {}

  explicit QueryDeviceStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDeviceStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDeviceStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDeviceStatisticsResponse() = default;
};
class QueryEdgeDriverRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> type{};
  shared_ptr<string> driverName{};

  QueryEdgeDriverRequest() {}

  explicit QueryEdgeDriverRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (driverName) {
      res["DriverName"] = boost::any(*driverName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("DriverName") != m.end() && !m["DriverName"].empty()) {
      driverName = make_shared<string>(boost::any_cast<string>(m["DriverName"]));
    }
  }


  virtual ~QueryEdgeDriverRequest() = default;
};
class QueryEdgeDriverResponseBodyDataDriverList : public Darabonba::Model {
public:
  shared_ptr<string> driverId{};
  shared_ptr<string> driverName{};
  shared_ptr<string> driverProtocol{};
  shared_ptr<string> runtime{};
  shared_ptr<string> cpuArch{};
  shared_ptr<long> type{};
  shared_ptr<bool> isBuiltIn{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<long> gmtModifiedTimestamp{};

  QueryEdgeDriverResponseBodyDataDriverList() {}

  explicit QueryEdgeDriverResponseBodyDataDriverList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverName) {
      res["DriverName"] = boost::any(*driverName);
    }
    if (driverProtocol) {
      res["DriverProtocol"] = boost::any(*driverProtocol);
    }
    if (runtime) {
      res["Runtime"] = boost::any(*runtime);
    }
    if (cpuArch) {
      res["CpuArch"] = boost::any(*cpuArch);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (isBuiltIn) {
      res["IsBuiltIn"] = boost::any(*isBuiltIn);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverName") != m.end() && !m["DriverName"].empty()) {
      driverName = make_shared<string>(boost::any_cast<string>(m["DriverName"]));
    }
    if (m.find("DriverProtocol") != m.end() && !m["DriverProtocol"].empty()) {
      driverProtocol = make_shared<string>(boost::any_cast<string>(m["DriverProtocol"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      runtime = make_shared<string>(boost::any_cast<string>(m["Runtime"]));
    }
    if (m.find("CpuArch") != m.end() && !m["CpuArch"].empty()) {
      cpuArch = make_shared<string>(boost::any_cast<string>(m["CpuArch"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("IsBuiltIn") != m.end() && !m["IsBuiltIn"].empty()) {
      isBuiltIn = make_shared<bool>(boost::any_cast<bool>(m["IsBuiltIn"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
  }


  virtual ~QueryEdgeDriverResponseBodyDataDriverList() = default;
};
class QueryEdgeDriverResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> total{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};
  shared_ptr<vector<QueryEdgeDriverResponseBodyDataDriverList>> driverList{};

  QueryEdgeDriverResponseBodyData() {}

  explicit QueryEdgeDriverResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (driverList) {
      vector<boost::any> temp1;
      for(auto item1:*driverList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DriverList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DriverList") != m.end() && !m["DriverList"].empty()) {
      if (typeid(vector<boost::any>) == m["DriverList"].type()) {
        vector<QueryEdgeDriverResponseBodyDataDriverList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DriverList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeDriverResponseBodyDataDriverList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        driverList = make_shared<vector<QueryEdgeDriverResponseBodyDataDriverList>>(expect1);
      }
    }
  }


  virtual ~QueryEdgeDriverResponseBodyData() = default;
};
class QueryEdgeDriverResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryEdgeDriverResponseBodyData> data{};

  QueryEdgeDriverResponseBody() {}

  explicit QueryEdgeDriverResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEdgeDriverResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEdgeDriverResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryEdgeDriverResponseBody() = default;
};
class QueryEdgeDriverResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryEdgeDriverResponseBody> body{};

  QueryEdgeDriverResponse() {}

  explicit QueryEdgeDriverResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryEdgeDriverResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryEdgeDriverResponseBody>(model1);
      }
    }
  }


  virtual ~QueryEdgeDriverResponse() = default;
};
class QueryEdgeDriverVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};
  shared_ptr<long> versionState{};

  QueryEdgeDriverVersionRequest() {}

  explicit QueryEdgeDriverVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    if (versionState) {
      res["VersionState"] = boost::any(*versionState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
    if (m.find("VersionState") != m.end() && !m["VersionState"].empty()) {
      versionState = make_shared<long>(boost::any_cast<long>(m["VersionState"]));
    }
  }


  virtual ~QueryEdgeDriverVersionRequest() = default;
};
class QueryEdgeDriverVersionResponseBodyDataDriverVersionList : public Darabonba::Model {
public:
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};
  shared_ptr<string> versionState{};
  shared_ptr<string> edgeVersion{};
  shared_ptr<string> description{};
  shared_ptr<string> sourceConfig{};
  shared_ptr<string> driverConfig{};
  shared_ptr<string> containerConfig{};
  shared_ptr<string> configCheckRule{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<string> argument{};

  QueryEdgeDriverVersionResponseBodyDataDriverVersionList() {}

  explicit QueryEdgeDriverVersionResponseBodyDataDriverVersionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    if (versionState) {
      res["VersionState"] = boost::any(*versionState);
    }
    if (edgeVersion) {
      res["EdgeVersion"] = boost::any(*edgeVersion);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (sourceConfig) {
      res["SourceConfig"] = boost::any(*sourceConfig);
    }
    if (driverConfig) {
      res["DriverConfig"] = boost::any(*driverConfig);
    }
    if (containerConfig) {
      res["ContainerConfig"] = boost::any(*containerConfig);
    }
    if (configCheckRule) {
      res["ConfigCheckRule"] = boost::any(*configCheckRule);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (argument) {
      res["Argument"] = boost::any(*argument);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
    if (m.find("VersionState") != m.end() && !m["VersionState"].empty()) {
      versionState = make_shared<string>(boost::any_cast<string>(m["VersionState"]));
    }
    if (m.find("EdgeVersion") != m.end() && !m["EdgeVersion"].empty()) {
      edgeVersion = make_shared<string>(boost::any_cast<string>(m["EdgeVersion"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SourceConfig") != m.end() && !m["SourceConfig"].empty()) {
      sourceConfig = make_shared<string>(boost::any_cast<string>(m["SourceConfig"]));
    }
    if (m.find("DriverConfig") != m.end() && !m["DriverConfig"].empty()) {
      driverConfig = make_shared<string>(boost::any_cast<string>(m["DriverConfig"]));
    }
    if (m.find("ContainerConfig") != m.end() && !m["ContainerConfig"].empty()) {
      containerConfig = make_shared<string>(boost::any_cast<string>(m["ContainerConfig"]));
    }
    if (m.find("ConfigCheckRule") != m.end() && !m["ConfigCheckRule"].empty()) {
      configCheckRule = make_shared<string>(boost::any_cast<string>(m["ConfigCheckRule"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("Argument") != m.end() && !m["Argument"].empty()) {
      argument = make_shared<string>(boost::any_cast<string>(m["Argument"]));
    }
  }


  virtual ~QueryEdgeDriverVersionResponseBodyDataDriverVersionList() = default;
};
class QueryEdgeDriverVersionResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> total{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};
  shared_ptr<vector<QueryEdgeDriverVersionResponseBodyDataDriverVersionList>> driverVersionList{};

  QueryEdgeDriverVersionResponseBodyData() {}

  explicit QueryEdgeDriverVersionResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (driverVersionList) {
      vector<boost::any> temp1;
      for(auto item1:*driverVersionList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DriverVersionList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DriverVersionList") != m.end() && !m["DriverVersionList"].empty()) {
      if (typeid(vector<boost::any>) == m["DriverVersionList"].type()) {
        vector<QueryEdgeDriverVersionResponseBodyDataDriverVersionList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DriverVersionList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeDriverVersionResponseBodyDataDriverVersionList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        driverVersionList = make_shared<vector<QueryEdgeDriverVersionResponseBodyDataDriverVersionList>>(expect1);
      }
    }
  }


  virtual ~QueryEdgeDriverVersionResponseBodyData() = default;
};
class QueryEdgeDriverVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryEdgeDriverVersionResponseBodyData> data{};

  QueryEdgeDriverVersionResponseBody() {}

  explicit QueryEdgeDriverVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEdgeDriverVersionResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEdgeDriverVersionResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryEdgeDriverVersionResponseBody() = default;
};
class QueryEdgeDriverVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryEdgeDriverVersionResponseBody> body{};

  QueryEdgeDriverVersionResponse() {}

  explicit QueryEdgeDriverVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryEdgeDriverVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryEdgeDriverVersionResponseBody>(model1);
      }
    }
  }


  virtual ~QueryEdgeDriverVersionResponse() = default;
};
class QueryEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> name{};

  QueryEdgeInstanceRequest() {}

  explicit QueryEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~QueryEdgeInstanceRequest() = default;
};
class QueryEdgeInstanceResponseBodyDataInstanceList : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> tags{};
  shared_ptr<long> type{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> roleName{};
  shared_ptr<string> roleAttachTime{};
  shared_ptr<long> spec{};
  shared_ptr<bool> bizEnable{};
  shared_ptr<long> latestDeploymentStatus{};
  shared_ptr<string> latestDeploymentType{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<long> roleAttachTimestamp{};

  QueryEdgeInstanceResponseBodyDataInstanceList() {}

  explicit QueryEdgeInstanceResponseBodyDataInstanceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (roleAttachTime) {
      res["RoleAttachTime"] = boost::any(*roleAttachTime);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (bizEnable) {
      res["BizEnable"] = boost::any(*bizEnable);
    }
    if (latestDeploymentStatus) {
      res["LatestDeploymentStatus"] = boost::any(*latestDeploymentStatus);
    }
    if (latestDeploymentType) {
      res["LatestDeploymentType"] = boost::any(*latestDeploymentType);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (roleAttachTimestamp) {
      res["RoleAttachTimestamp"] = boost::any(*roleAttachTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("RoleAttachTime") != m.end() && !m["RoleAttachTime"].empty()) {
      roleAttachTime = make_shared<string>(boost::any_cast<string>(m["RoleAttachTime"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<long>(boost::any_cast<long>(m["Spec"]));
    }
    if (m.find("BizEnable") != m.end() && !m["BizEnable"].empty()) {
      bizEnable = make_shared<bool>(boost::any_cast<bool>(m["BizEnable"]));
    }
    if (m.find("LatestDeploymentStatus") != m.end() && !m["LatestDeploymentStatus"].empty()) {
      latestDeploymentStatus = make_shared<long>(boost::any_cast<long>(m["LatestDeploymentStatus"]));
    }
    if (m.find("LatestDeploymentType") != m.end() && !m["LatestDeploymentType"].empty()) {
      latestDeploymentType = make_shared<string>(boost::any_cast<string>(m["LatestDeploymentType"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("RoleAttachTimestamp") != m.end() && !m["RoleAttachTimestamp"].empty()) {
      roleAttachTimestamp = make_shared<long>(boost::any_cast<long>(m["RoleAttachTimestamp"]));
    }
  }


  virtual ~QueryEdgeInstanceResponseBodyDataInstanceList() = default;
};
class QueryEdgeInstanceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> total{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};
  shared_ptr<vector<QueryEdgeInstanceResponseBodyDataInstanceList>> instanceList{};

  QueryEdgeInstanceResponseBodyData() {}

  explicit QueryEdgeInstanceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (instanceList) {
      vector<boost::any> temp1;
      for(auto item1:*instanceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("InstanceList") != m.end() && !m["InstanceList"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceList"].type()) {
        vector<QueryEdgeInstanceResponseBodyDataInstanceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeInstanceResponseBodyDataInstanceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceList = make_shared<vector<QueryEdgeInstanceResponseBodyDataInstanceList>>(expect1);
      }
    }
  }


  virtual ~QueryEdgeInstanceResponseBodyData() = default;
};
class QueryEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryEdgeInstanceResponseBodyData> data{};

  QueryEdgeInstanceResponseBody() {}

  explicit QueryEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEdgeInstanceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEdgeInstanceResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceResponseBody() = default;
};
class QueryEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryEdgeInstanceResponseBody> body{};

  QueryEdgeInstanceResponse() {}

  explicit QueryEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceResponse() = default;
};
class QueryEdgeInstanceChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<string> channelName{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  QueryEdgeInstanceChannelRequest() {}

  explicit QueryEdgeInstanceChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryEdgeInstanceChannelRequest() = default;
};
class QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<string> format{};
  shared_ptr<string> content{};
  shared_ptr<string> key{};

  QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig() {}

  explicit QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig() = default;
};
class QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig>> config{};

  QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList() {}

  explicit QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      vector<boost::any> temp1;
      for(auto item1:*config){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Config"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(vector<boost::any>) == m["Config"].type()) {
        vector<QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Config"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        config = make_shared<vector<QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig>>(expect1);
      }
    }
  }


  virtual ~QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList() = default;
};
class QueryEdgeInstanceChannelResponseBodyDataChannelListChannel : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> channelName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList> configList{};

  QueryEdgeInstanceChannelResponseBodyDataChannelListChannel() {}

  explicit QueryEdgeInstanceChannelResponseBodyDataChannelListChannel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (configList) {
      res["ConfigList"] = configList ? boost::any(configList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("ConfigList") != m.end() && !m["ConfigList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigList"].type()) {
        QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigList"]));
        configList = make_shared<QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceChannelResponseBodyDataChannelListChannel() = default;
};
class QueryEdgeInstanceChannelResponseBodyDataChannelList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEdgeInstanceChannelResponseBodyDataChannelListChannel>> channel{};

  QueryEdgeInstanceChannelResponseBodyDataChannelList() {}

  explicit QueryEdgeInstanceChannelResponseBodyDataChannelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channel) {
      vector<boost::any> temp1;
      for(auto item1:*channel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Channel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      if (typeid(vector<boost::any>) == m["Channel"].type()) {
        vector<QueryEdgeInstanceChannelResponseBodyDataChannelListChannel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Channel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeInstanceChannelResponseBodyDataChannelListChannel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channel = make_shared<vector<QueryEdgeInstanceChannelResponseBodyDataChannelListChannel>>(expect1);
      }
    }
  }


  virtual ~QueryEdgeInstanceChannelResponseBodyDataChannelList() = default;
};
class QueryEdgeInstanceChannelResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> total{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};
  shared_ptr<QueryEdgeInstanceChannelResponseBodyDataChannelList> channelList{};

  QueryEdgeInstanceChannelResponseBodyData() {}

  explicit QueryEdgeInstanceChannelResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (channelList) {
      res["ChannelList"] = channelList ? boost::any(channelList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("ChannelList") != m.end() && !m["ChannelList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ChannelList"].type()) {
        QueryEdgeInstanceChannelResponseBodyDataChannelList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ChannelList"]));
        channelList = make_shared<QueryEdgeInstanceChannelResponseBodyDataChannelList>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceChannelResponseBodyData() = default;
};
class QueryEdgeInstanceChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryEdgeInstanceChannelResponseBodyData> data{};

  QueryEdgeInstanceChannelResponseBody() {}

  explicit QueryEdgeInstanceChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEdgeInstanceChannelResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEdgeInstanceChannelResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceChannelResponseBody() = default;
};
class QueryEdgeInstanceChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryEdgeInstanceChannelResponseBody> body{};

  QueryEdgeInstanceChannelResponse() {}

  explicit QueryEdgeInstanceChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryEdgeInstanceChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryEdgeInstanceChannelResponseBody>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceChannelResponse() = default;
};
class QueryEdgeInstanceDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  QueryEdgeInstanceDeviceRequest() {}

  explicit QueryEdgeInstanceDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryEdgeInstanceDeviceRequest() = default;
};
class QueryEdgeInstanceDeviceResponseBodyDataDeviceList : public Darabonba::Model {
public:
  shared_ptr<string> iotId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> driverId{};

  QueryEdgeInstanceDeviceResponseBodyDataDeviceList() {}

  explicit QueryEdgeInstanceDeviceResponseBodyDataDeviceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
  }


  virtual ~QueryEdgeInstanceDeviceResponseBodyDataDeviceList() = default;
};
class QueryEdgeInstanceDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> total{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};
  shared_ptr<vector<QueryEdgeInstanceDeviceResponseBodyDataDeviceList>> deviceList{};

  QueryEdgeInstanceDeviceResponseBodyData() {}

  explicit QueryEdgeInstanceDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (deviceList) {
      vector<boost::any> temp1;
      for(auto item1:*deviceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DeviceList") != m.end() && !m["DeviceList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceList"].type()) {
        vector<QueryEdgeInstanceDeviceResponseBodyDataDeviceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeInstanceDeviceResponseBodyDataDeviceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceList = make_shared<vector<QueryEdgeInstanceDeviceResponseBodyDataDeviceList>>(expect1);
      }
    }
  }


  virtual ~QueryEdgeInstanceDeviceResponseBodyData() = default;
};
class QueryEdgeInstanceDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryEdgeInstanceDeviceResponseBodyData> data{};

  QueryEdgeInstanceDeviceResponseBody() {}

  explicit QueryEdgeInstanceDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEdgeInstanceDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEdgeInstanceDeviceResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceDeviceResponseBody() = default;
};
class QueryEdgeInstanceDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryEdgeInstanceDeviceResponseBody> body{};

  QueryEdgeInstanceDeviceResponse() {}

  explicit QueryEdgeInstanceDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryEdgeInstanceDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryEdgeInstanceDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceDeviceResponse() = default;
};
class QueryEdgeInstanceDeviceByDriverRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> driverId{};
  shared_ptr<long> currentPage{};

  QueryEdgeInstanceDeviceByDriverRequest() {}

  explicit QueryEdgeInstanceDeviceByDriverRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~QueryEdgeInstanceDeviceByDriverRequest() = default;
};
class QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList : public Darabonba::Model {
public:
  shared_ptr<string> iotId{};

  QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList() {}

  explicit QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList() = default;
};
class QueryEdgeInstanceDeviceByDriverResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> total{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};
  shared_ptr<vector<QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList>> deviceList{};

  QueryEdgeInstanceDeviceByDriverResponseBodyData() {}

  explicit QueryEdgeInstanceDeviceByDriverResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (deviceList) {
      vector<boost::any> temp1;
      for(auto item1:*deviceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DeviceList") != m.end() && !m["DeviceList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceList"].type()) {
        vector<QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceList = make_shared<vector<QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList>>(expect1);
      }
    }
  }


  virtual ~QueryEdgeInstanceDeviceByDriverResponseBodyData() = default;
};
class QueryEdgeInstanceDeviceByDriverResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryEdgeInstanceDeviceByDriverResponseBodyData> data{};

  QueryEdgeInstanceDeviceByDriverResponseBody() {}

  explicit QueryEdgeInstanceDeviceByDriverResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEdgeInstanceDeviceByDriverResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEdgeInstanceDeviceByDriverResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceDeviceByDriverResponseBody() = default;
};
class QueryEdgeInstanceDeviceByDriverResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryEdgeInstanceDeviceByDriverResponseBody> body{};

  QueryEdgeInstanceDeviceByDriverResponse() {}

  explicit QueryEdgeInstanceDeviceByDriverResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryEdgeInstanceDeviceByDriverResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryEdgeInstanceDeviceByDriverResponseBody>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceDeviceByDriverResponse() = default;
};
class QueryEdgeInstanceDriverRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  QueryEdgeInstanceDriverRequest() {}

  explicit QueryEdgeInstanceDriverRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryEdgeInstanceDriverRequest() = default;
};
class QueryEdgeInstanceDriverResponseBodyDataDriverList : public Darabonba::Model {
public:
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};
  shared_ptr<string> orderId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};

  QueryEdgeInstanceDriverResponseBodyDataDriverList() {}

  explicit QueryEdgeInstanceDriverResponseBodyDataDriverList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
  }


  virtual ~QueryEdgeInstanceDriverResponseBodyDataDriverList() = default;
};
class QueryEdgeInstanceDriverResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> total{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};
  shared_ptr<vector<QueryEdgeInstanceDriverResponseBodyDataDriverList>> driverList{};

  QueryEdgeInstanceDriverResponseBodyData() {}

  explicit QueryEdgeInstanceDriverResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (driverList) {
      vector<boost::any> temp1;
      for(auto item1:*driverList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DriverList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DriverList") != m.end() && !m["DriverList"].empty()) {
      if (typeid(vector<boost::any>) == m["DriverList"].type()) {
        vector<QueryEdgeInstanceDriverResponseBodyDataDriverList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DriverList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeInstanceDriverResponseBodyDataDriverList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        driverList = make_shared<vector<QueryEdgeInstanceDriverResponseBodyDataDriverList>>(expect1);
      }
    }
  }


  virtual ~QueryEdgeInstanceDriverResponseBodyData() = default;
};
class QueryEdgeInstanceDriverResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryEdgeInstanceDriverResponseBodyData> data{};

  QueryEdgeInstanceDriverResponseBody() {}

  explicit QueryEdgeInstanceDriverResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEdgeInstanceDriverResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEdgeInstanceDriverResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceDriverResponseBody() = default;
};
class QueryEdgeInstanceDriverResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryEdgeInstanceDriverResponseBody> body{};

  QueryEdgeInstanceDriverResponse() {}

  explicit QueryEdgeInstanceDriverResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryEdgeInstanceDriverResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryEdgeInstanceDriverResponseBody>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceDriverResponse() = default;
};
class QueryEdgeInstanceGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};

  QueryEdgeInstanceGatewayRequest() {}

  explicit QueryEdgeInstanceGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~QueryEdgeInstanceGatewayRequest() = default;
};
class QueryEdgeInstanceGatewayResponseBodyGatewayList : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> edgeVersion{};

  QueryEdgeInstanceGatewayResponseBodyGatewayList() {}

  explicit QueryEdgeInstanceGatewayResponseBodyGatewayList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (edgeVersion) {
      res["EdgeVersion"] = boost::any(*edgeVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("EdgeVersion") != m.end() && !m["EdgeVersion"].empty()) {
      edgeVersion = make_shared<string>(boost::any_cast<string>(m["EdgeVersion"]));
    }
  }


  virtual ~QueryEdgeInstanceGatewayResponseBodyGatewayList() = default;
};
class QueryEdgeInstanceGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<QueryEdgeInstanceGatewayResponseBodyGatewayList>> gatewayList{};

  QueryEdgeInstanceGatewayResponseBody() {}

  explicit QueryEdgeInstanceGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (gatewayList) {
      vector<boost::any> temp1;
      for(auto item1:*gatewayList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GatewayList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("GatewayList") != m.end() && !m["GatewayList"].empty()) {
      if (typeid(vector<boost::any>) == m["GatewayList"].type()) {
        vector<QueryEdgeInstanceGatewayResponseBodyGatewayList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GatewayList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeInstanceGatewayResponseBodyGatewayList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        gatewayList = make_shared<vector<QueryEdgeInstanceGatewayResponseBodyGatewayList>>(expect1);
      }
    }
  }


  virtual ~QueryEdgeInstanceGatewayResponseBody() = default;
};
class QueryEdgeInstanceGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryEdgeInstanceGatewayResponseBody> body{};

  QueryEdgeInstanceGatewayResponse() {}

  explicit QueryEdgeInstanceGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryEdgeInstanceGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryEdgeInstanceGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceGatewayResponse() = default;
};
class QueryEdgeInstanceHistoricDeploymentRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};
  shared_ptr<long> endTime{};

  QueryEdgeInstanceHistoricDeploymentRequest() {}

  explicit QueryEdgeInstanceHistoricDeploymentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
  }


  virtual ~QueryEdgeInstanceHistoricDeploymentRequest() = default;
};
class QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> gmtCompleted{};
  shared_ptr<string> deploymentId{};
  shared_ptr<string> description{};
  shared_ptr<long> status{};
  shared_ptr<string> type{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<long> gmtCompletedTimestamp{};

  QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList() {}

  explicit QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtCompleted) {
      res["GmtCompleted"] = boost::any(*gmtCompleted);
    }
    if (deploymentId) {
      res["DeploymentId"] = boost::any(*deploymentId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (gmtCompletedTimestamp) {
      res["GmtCompletedTimestamp"] = boost::any(*gmtCompletedTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtCompleted") != m.end() && !m["GmtCompleted"].empty()) {
      gmtCompleted = make_shared<string>(boost::any_cast<string>(m["GmtCompleted"]));
    }
    if (m.find("DeploymentId") != m.end() && !m["DeploymentId"].empty()) {
      deploymentId = make_shared<string>(boost::any_cast<string>(m["DeploymentId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("GmtCompletedTimestamp") != m.end() && !m["GmtCompletedTimestamp"].empty()) {
      gmtCompletedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCompletedTimestamp"]));
    }
  }


  virtual ~QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList() = default;
};
class QueryEdgeInstanceHistoricDeploymentResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> total{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};
  shared_ptr<vector<QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList>> deploymentList{};

  QueryEdgeInstanceHistoricDeploymentResponseBodyData() {}

  explicit QueryEdgeInstanceHistoricDeploymentResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (deploymentList) {
      vector<boost::any> temp1;
      for(auto item1:*deploymentList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeploymentList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DeploymentList") != m.end() && !m["DeploymentList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeploymentList"].type()) {
        vector<QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeploymentList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deploymentList = make_shared<vector<QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList>>(expect1);
      }
    }
  }


  virtual ~QueryEdgeInstanceHistoricDeploymentResponseBodyData() = default;
};
class QueryEdgeInstanceHistoricDeploymentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryEdgeInstanceHistoricDeploymentResponseBodyData> data{};

  QueryEdgeInstanceHistoricDeploymentResponseBody() {}

  explicit QueryEdgeInstanceHistoricDeploymentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEdgeInstanceHistoricDeploymentResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEdgeInstanceHistoricDeploymentResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceHistoricDeploymentResponseBody() = default;
};
class QueryEdgeInstanceHistoricDeploymentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryEdgeInstanceHistoricDeploymentResponseBody> body{};

  QueryEdgeInstanceHistoricDeploymentResponse() {}

  explicit QueryEdgeInstanceHistoricDeploymentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryEdgeInstanceHistoricDeploymentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryEdgeInstanceHistoricDeploymentResponseBody>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceHistoricDeploymentResponse() = default;
};
class QueryEdgeInstanceMessageRoutingRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  QueryEdgeInstanceMessageRoutingRequest() {}

  explicit QueryEdgeInstanceMessageRoutingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryEdgeInstanceMessageRoutingRequest() = default;
};
class QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext : public Darabonba::Model {
public:
  shared_ptr<string> sourceFcServiceName{};
  shared_ptr<string> sourceFcFunctionName{};
  shared_ptr<string> sourceApplicationName{};
  shared_ptr<string> targetFcServiceName{};
  shared_ptr<string> targetFcFunctionName{};
  shared_ptr<string> targetApplicationName{};
  shared_ptr<string> qos{};

  QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext() {}

  explicit QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceFcServiceName) {
      res["SourceFcServiceName"] = boost::any(*sourceFcServiceName);
    }
    if (sourceFcFunctionName) {
      res["SourceFcFunctionName"] = boost::any(*sourceFcFunctionName);
    }
    if (sourceApplicationName) {
      res["SourceApplicationName"] = boost::any(*sourceApplicationName);
    }
    if (targetFcServiceName) {
      res["TargetFcServiceName"] = boost::any(*targetFcServiceName);
    }
    if (targetFcFunctionName) {
      res["TargetFcFunctionName"] = boost::any(*targetFcFunctionName);
    }
    if (targetApplicationName) {
      res["TargetApplicationName"] = boost::any(*targetApplicationName);
    }
    if (qos) {
      res["Qos"] = boost::any(*qos);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceFcServiceName") != m.end() && !m["SourceFcServiceName"].empty()) {
      sourceFcServiceName = make_shared<string>(boost::any_cast<string>(m["SourceFcServiceName"]));
    }
    if (m.find("SourceFcFunctionName") != m.end() && !m["SourceFcFunctionName"].empty()) {
      sourceFcFunctionName = make_shared<string>(boost::any_cast<string>(m["SourceFcFunctionName"]));
    }
    if (m.find("SourceApplicationName") != m.end() && !m["SourceApplicationName"].empty()) {
      sourceApplicationName = make_shared<string>(boost::any_cast<string>(m["SourceApplicationName"]));
    }
    if (m.find("TargetFcServiceName") != m.end() && !m["TargetFcServiceName"].empty()) {
      targetFcServiceName = make_shared<string>(boost::any_cast<string>(m["TargetFcServiceName"]));
    }
    if (m.find("TargetFcFunctionName") != m.end() && !m["TargetFcFunctionName"].empty()) {
      targetFcFunctionName = make_shared<string>(boost::any_cast<string>(m["TargetFcFunctionName"]));
    }
    if (m.find("TargetApplicationName") != m.end() && !m["TargetApplicationName"].empty()) {
      targetApplicationName = make_shared<string>(boost::any_cast<string>(m["TargetApplicationName"]));
    }
    if (m.find("Qos") != m.end() && !m["Qos"].empty()) {
      qos = make_shared<string>(boost::any_cast<string>(m["Qos"]));
    }
  }


  virtual ~QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext() = default;
};
class QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute : public Darabonba::Model {
public:
  shared_ptr<long> routeId{};
  shared_ptr<string> name{};
  shared_ptr<string> topicFilter{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> sourceData{};
  shared_ptr<string> targetType{};
  shared_ptr<string> targetData{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext> routeContext{};

  QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute() {}

  explicit QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (topicFilter) {
      res["TopicFilter"] = boost::any(*topicFilter);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (sourceData) {
      res["SourceData"] = boost::any(*sourceData);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (targetData) {
      res["TargetData"] = boost::any(*targetData);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (routeContext) {
      res["RouteContext"] = routeContext ? boost::any(routeContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<long>(boost::any_cast<long>(m["RouteId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TopicFilter") != m.end() && !m["TopicFilter"].empty()) {
      topicFilter = make_shared<string>(boost::any_cast<string>(m["TopicFilter"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("SourceData") != m.end() && !m["SourceData"].empty()) {
      sourceData = make_shared<string>(boost::any_cast<string>(m["SourceData"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("TargetData") != m.end() && !m["TargetData"].empty()) {
      targetData = make_shared<string>(boost::any_cast<string>(m["TargetData"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("RouteContext") != m.end() && !m["RouteContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["RouteContext"].type()) {
        QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RouteContext"]));
        routeContext = make_shared<QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute() = default;
};
class QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute>> messageRoute{};

  QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList() {}

  explicit QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageRoute) {
      vector<boost::any> temp1;
      for(auto item1:*messageRoute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MessageRoute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageRoute") != m.end() && !m["MessageRoute"].empty()) {
      if (typeid(vector<boost::any>) == m["MessageRoute"].type()) {
        vector<QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MessageRoute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        messageRoute = make_shared<vector<QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute>>(expect1);
      }
    }
  }


  virtual ~QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList() = default;
};
class QueryEdgeInstanceMessageRoutingResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> total{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};
  shared_ptr<QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList> messageRouteList{};

  QueryEdgeInstanceMessageRoutingResponseBodyData() {}

  explicit QueryEdgeInstanceMessageRoutingResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (messageRouteList) {
      res["MessageRouteList"] = messageRouteList ? boost::any(messageRouteList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("MessageRouteList") != m.end() && !m["MessageRouteList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MessageRouteList"].type()) {
        QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MessageRouteList"]));
        messageRouteList = make_shared<QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceMessageRoutingResponseBodyData() = default;
};
class QueryEdgeInstanceMessageRoutingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryEdgeInstanceMessageRoutingResponseBodyData> data{};

  QueryEdgeInstanceMessageRoutingResponseBody() {}

  explicit QueryEdgeInstanceMessageRoutingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEdgeInstanceMessageRoutingResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEdgeInstanceMessageRoutingResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceMessageRoutingResponseBody() = default;
};
class QueryEdgeInstanceMessageRoutingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryEdgeInstanceMessageRoutingResponseBody> body{};

  QueryEdgeInstanceMessageRoutingResponse() {}

  explicit QueryEdgeInstanceMessageRoutingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryEdgeInstanceMessageRoutingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryEdgeInstanceMessageRoutingResponseBody>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceMessageRoutingResponse() = default;
};
class QueryEdgeInstanceSceneRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  QueryEdgeInstanceSceneRuleRequest() {}

  explicit QueryEdgeInstanceSceneRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryEdgeInstanceSceneRuleRequest() = default;
};
class QueryEdgeInstanceSceneRuleResponseBodyDataRuleList : public Darabonba::Model {
public:
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> status{};
  shared_ptr<long> isExisted{};

  QueryEdgeInstanceSceneRuleResponseBodyDataRuleList() {}

  explicit QueryEdgeInstanceSceneRuleResponseBodyDataRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (isExisted) {
      res["IsExisted"] = boost::any(*isExisted);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("IsExisted") != m.end() && !m["IsExisted"].empty()) {
      isExisted = make_shared<long>(boost::any_cast<long>(m["IsExisted"]));
    }
  }


  virtual ~QueryEdgeInstanceSceneRuleResponseBodyDataRuleList() = default;
};
class QueryEdgeInstanceSceneRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> total{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};
  shared_ptr<vector<QueryEdgeInstanceSceneRuleResponseBodyDataRuleList>> ruleList{};

  QueryEdgeInstanceSceneRuleResponseBodyData() {}

  explicit QueryEdgeInstanceSceneRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (ruleList) {
      vector<boost::any> temp1;
      for(auto item1:*ruleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("RuleList") != m.end() && !m["RuleList"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleList"].type()) {
        vector<QueryEdgeInstanceSceneRuleResponseBodyDataRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeInstanceSceneRuleResponseBodyDataRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleList = make_shared<vector<QueryEdgeInstanceSceneRuleResponseBodyDataRuleList>>(expect1);
      }
    }
  }


  virtual ~QueryEdgeInstanceSceneRuleResponseBodyData() = default;
};
class QueryEdgeInstanceSceneRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryEdgeInstanceSceneRuleResponseBodyData> data{};

  QueryEdgeInstanceSceneRuleResponseBody() {}

  explicit QueryEdgeInstanceSceneRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEdgeInstanceSceneRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEdgeInstanceSceneRuleResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceSceneRuleResponseBody() = default;
};
class QueryEdgeInstanceSceneRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryEdgeInstanceSceneRuleResponseBody> body{};

  QueryEdgeInstanceSceneRuleResponse() {}

  explicit QueryEdgeInstanceSceneRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryEdgeInstanceSceneRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryEdgeInstanceSceneRuleResponseBody>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceSceneRuleResponse() = default;
};
class QueryJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobId{};

  QueryJobRequest() {}

  explicit QueryJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~QueryJobRequest() = default;
};
class QueryJobResponseBodyDataRolloutConfig : public Darabonba::Model {
public:
  shared_ptr<long> maximumPerMinute{};

  QueryJobResponseBodyDataRolloutConfig() {}

  explicit QueryJobResponseBodyDataRolloutConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maximumPerMinute) {
      res["MaximumPerMinute"] = boost::any(*maximumPerMinute);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaximumPerMinute") != m.end() && !m["MaximumPerMinute"].empty()) {
      maximumPerMinute = make_shared<long>(boost::any_cast<long>(m["MaximumPerMinute"]));
    }
  }


  virtual ~QueryJobResponseBodyDataRolloutConfig() = default;
};
class QueryJobResponseBodyDataTimeoutConfig : public Darabonba::Model {
public:
  shared_ptr<long> inProgressTimeoutInMinutes{};

  QueryJobResponseBodyDataTimeoutConfig() {}

  explicit QueryJobResponseBodyDataTimeoutConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inProgressTimeoutInMinutes) {
      res["InProgressTimeoutInMinutes"] = boost::any(*inProgressTimeoutInMinutes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InProgressTimeoutInMinutes") != m.end() && !m["InProgressTimeoutInMinutes"].empty()) {
      inProgressTimeoutInMinutes = make_shared<long>(boost::any_cast<long>(m["InProgressTimeoutInMinutes"]));
    }
  }


  virtual ~QueryJobResponseBodyDataTimeoutConfig() = default;
};
class QueryJobResponseBodyDataJobFile : public Darabonba::Model {
public:
  shared_ptr<string> fileUrl{};
  shared_ptr<string> signMethod{};
  shared_ptr<string> sign{};

  QueryJobResponseBodyDataJobFile() {}

  explicit QueryJobResponseBodyDataJobFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (signMethod) {
      res["SignMethod"] = boost::any(*signMethod);
    }
    if (sign) {
      res["Sign"] = boost::any(*sign);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("SignMethod") != m.end() && !m["SignMethod"].empty()) {
      signMethod = make_shared<string>(boost::any_cast<string>(m["SignMethod"]));
    }
    if (m.find("Sign") != m.end() && !m["Sign"].empty()) {
      sign = make_shared<string>(boost::any_cast<string>(m["Sign"]));
    }
  }


  virtual ~QueryJobResponseBodyDataJobFile() = default;
};
class QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};

  QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices() {}

  explicit QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
  }


  virtual ~QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices() = default;
};
class QueryJobResponseBodyDataTargetConfigTargetDevices : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices>> targetDevices{};

  QueryJobResponseBodyDataTargetConfigTargetDevices() {}

  explicit QueryJobResponseBodyDataTargetConfigTargetDevices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetDevices) {
      vector<boost::any> temp1;
      for(auto item1:*targetDevices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["targetDevices"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("targetDevices") != m.end() && !m["targetDevices"].empty()) {
      if (typeid(vector<boost::any>) == m["targetDevices"].type()) {
        vector<QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["targetDevices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targetDevices = make_shared<vector<QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices>>(expect1);
      }
    }
  }


  virtual ~QueryJobResponseBodyDataTargetConfigTargetDevices() = default;
};
class QueryJobResponseBodyDataTargetConfig : public Darabonba::Model {
public:
  shared_ptr<string> targetGroup{};
  shared_ptr<string> targetProduct{};
  shared_ptr<string> targetType{};
  shared_ptr<QueryJobResponseBodyDataTargetConfigTargetDevices> targetDevices{};

  QueryJobResponseBodyDataTargetConfig() {}

  explicit QueryJobResponseBodyDataTargetConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetGroup) {
      res["TargetGroup"] = boost::any(*targetGroup);
    }
    if (targetProduct) {
      res["TargetProduct"] = boost::any(*targetProduct);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (targetDevices) {
      res["TargetDevices"] = targetDevices ? boost::any(targetDevices->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetGroup") != m.end() && !m["TargetGroup"].empty()) {
      targetGroup = make_shared<string>(boost::any_cast<string>(m["TargetGroup"]));
    }
    if (m.find("TargetProduct") != m.end() && !m["TargetProduct"].empty()) {
      targetProduct = make_shared<string>(boost::any_cast<string>(m["TargetProduct"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("TargetDevices") != m.end() && !m["TargetDevices"].empty()) {
      if (typeid(map<string, boost::any>) == m["TargetDevices"].type()) {
        QueryJobResponseBodyDataTargetConfigTargetDevices model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TargetDevices"]));
        targetDevices = make_shared<QueryJobResponseBodyDataTargetConfigTargetDevices>(model1);
      }
    }
  }


  virtual ~QueryJobResponseBodyDataTargetConfig() = default;
};
class QueryJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> jobName{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> status{};
  shared_ptr<string> description{};
  shared_ptr<string> type{};
  shared_ptr<string> jobDocument{};
  shared_ptr<string> utcModified{};
  shared_ptr<QueryJobResponseBodyDataRolloutConfig> rolloutConfig{};
  shared_ptr<QueryJobResponseBodyDataTimeoutConfig> timeoutConfig{};
  shared_ptr<QueryJobResponseBodyDataJobFile> jobFile{};
  shared_ptr<QueryJobResponseBodyDataTargetConfig> targetConfig{};

  QueryJobResponseBodyData() {}

  explicit QueryJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (jobDocument) {
      res["JobDocument"] = boost::any(*jobDocument);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (rolloutConfig) {
      res["RolloutConfig"] = rolloutConfig ? boost::any(rolloutConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeoutConfig) {
      res["TimeoutConfig"] = timeoutConfig ? boost::any(timeoutConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobFile) {
      res["JobFile"] = jobFile ? boost::any(jobFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (targetConfig) {
      res["TargetConfig"] = targetConfig ? boost::any(targetConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("JobDocument") != m.end() && !m["JobDocument"].empty()) {
      jobDocument = make_shared<string>(boost::any_cast<string>(m["JobDocument"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("RolloutConfig") != m.end() && !m["RolloutConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RolloutConfig"].type()) {
        QueryJobResponseBodyDataRolloutConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RolloutConfig"]));
        rolloutConfig = make_shared<QueryJobResponseBodyDataRolloutConfig>(model1);
      }
    }
    if (m.find("TimeoutConfig") != m.end() && !m["TimeoutConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeoutConfig"].type()) {
        QueryJobResponseBodyDataTimeoutConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeoutConfig"]));
        timeoutConfig = make_shared<QueryJobResponseBodyDataTimeoutConfig>(model1);
      }
    }
    if (m.find("JobFile") != m.end() && !m["JobFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobFile"].type()) {
        QueryJobResponseBodyDataJobFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobFile"]));
        jobFile = make_shared<QueryJobResponseBodyDataJobFile>(model1);
      }
    }
    if (m.find("TargetConfig") != m.end() && !m["TargetConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TargetConfig"].type()) {
        QueryJobResponseBodyDataTargetConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TargetConfig"]));
        targetConfig = make_shared<QueryJobResponseBodyDataTargetConfig>(model1);
      }
    }
  }


  virtual ~QueryJobResponseBodyData() = default;
};
class QueryJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryJobResponseBodyData> data{};

  QueryJobResponseBody() {}

  explicit QueryJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryJobResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryJobResponseBody() = default;
};
class QueryJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryJobResponseBody> body{};

  QueryJobResponse() {}

  explicit QueryJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryJobResponseBody>(model1);
      }
    }
  }


  virtual ~QueryJobResponse() = default;
};
class QueryJobStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobId{};

  QueryJobStatisticsRequest() {}

  explicit QueryJobStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~QueryJobStatisticsRequest() = default;
};
class QueryJobStatisticsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> total{};
  shared_ptr<long> queued{};
  shared_ptr<long> sent{};
  shared_ptr<long> inProgress{};
  shared_ptr<long> succeeded{};
  shared_ptr<long> failed{};
  shared_ptr<long> rejected{};
  shared_ptr<long> timeOut{};
  shared_ptr<long> cancelled{};

  QueryJobStatisticsResponseBodyData() {}

  explicit QueryJobStatisticsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (queued) {
      res["Queued"] = boost::any(*queued);
    }
    if (sent) {
      res["Sent"] = boost::any(*sent);
    }
    if (inProgress) {
      res["InProgress"] = boost::any(*inProgress);
    }
    if (succeeded) {
      res["Succeeded"] = boost::any(*succeeded);
    }
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (rejected) {
      res["Rejected"] = boost::any(*rejected);
    }
    if (timeOut) {
      res["TimeOut"] = boost::any(*timeOut);
    }
    if (cancelled) {
      res["Cancelled"] = boost::any(*cancelled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Queued") != m.end() && !m["Queued"].empty()) {
      queued = make_shared<long>(boost::any_cast<long>(m["Queued"]));
    }
    if (m.find("Sent") != m.end() && !m["Sent"].empty()) {
      sent = make_shared<long>(boost::any_cast<long>(m["Sent"]));
    }
    if (m.find("InProgress") != m.end() && !m["InProgress"].empty()) {
      inProgress = make_shared<long>(boost::any_cast<long>(m["InProgress"]));
    }
    if (m.find("Succeeded") != m.end() && !m["Succeeded"].empty()) {
      succeeded = make_shared<long>(boost::any_cast<long>(m["Succeeded"]));
    }
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Rejected") != m.end() && !m["Rejected"].empty()) {
      rejected = make_shared<long>(boost::any_cast<long>(m["Rejected"]));
    }
    if (m.find("TimeOut") != m.end() && !m["TimeOut"].empty()) {
      timeOut = make_shared<long>(boost::any_cast<long>(m["TimeOut"]));
    }
    if (m.find("Cancelled") != m.end() && !m["Cancelled"].empty()) {
      cancelled = make_shared<long>(boost::any_cast<long>(m["Cancelled"]));
    }
  }


  virtual ~QueryJobStatisticsResponseBodyData() = default;
};
class QueryJobStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryJobStatisticsResponseBodyData> data{};

  QueryJobStatisticsResponseBody() {}

  explicit QueryJobStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryJobStatisticsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryJobStatisticsResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryJobStatisticsResponseBody() = default;
};
class QueryJobStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryJobStatisticsResponseBody> body{};

  QueryJobStatisticsResponse() {}

  explicit QueryJobStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryJobStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryJobStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryJobStatisticsResponse() = default;
};
class QueryLoRaJoinPermissionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};

  QueryLoRaJoinPermissionsRequest() {}

  explicit QueryLoRaJoinPermissionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~QueryLoRaJoinPermissionsRequest() = default;
};
class QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission : public Darabonba::Model {
public:
  shared_ptr<string> joinPermissionId{};
  shared_ptr<string> joinPermissionName{};
  shared_ptr<string> joinPermissionType{};
  shared_ptr<string> ownerAliyunPk{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> classMode{};

  QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission() {}

  explicit QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (joinPermissionId) {
      res["JoinPermissionId"] = boost::any(*joinPermissionId);
    }
    if (joinPermissionName) {
      res["JoinPermissionName"] = boost::any(*joinPermissionName);
    }
    if (joinPermissionType) {
      res["JoinPermissionType"] = boost::any(*joinPermissionType);
    }
    if (ownerAliyunPk) {
      res["OwnerAliyunPk"] = boost::any(*ownerAliyunPk);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (classMode) {
      res["ClassMode"] = boost::any(*classMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JoinPermissionId") != m.end() && !m["JoinPermissionId"].empty()) {
      joinPermissionId = make_shared<string>(boost::any_cast<string>(m["JoinPermissionId"]));
    }
    if (m.find("JoinPermissionName") != m.end() && !m["JoinPermissionName"].empty()) {
      joinPermissionName = make_shared<string>(boost::any_cast<string>(m["JoinPermissionName"]));
    }
    if (m.find("JoinPermissionType") != m.end() && !m["JoinPermissionType"].empty()) {
      joinPermissionType = make_shared<string>(boost::any_cast<string>(m["JoinPermissionType"]));
    }
    if (m.find("OwnerAliyunPk") != m.end() && !m["OwnerAliyunPk"].empty()) {
      ownerAliyunPk = make_shared<string>(boost::any_cast<string>(m["OwnerAliyunPk"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("ClassMode") != m.end() && !m["ClassMode"].empty()) {
      classMode = make_shared<string>(boost::any_cast<string>(m["ClassMode"]));
    }
  }


  virtual ~QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission() = default;
};
class QueryLoRaJoinPermissionsResponseBodyJoinPermissions : public Darabonba::Model {
public:
  shared_ptr<vector<QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission>> joinPermission{};

  QueryLoRaJoinPermissionsResponseBodyJoinPermissions() {}

  explicit QueryLoRaJoinPermissionsResponseBodyJoinPermissions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (joinPermission) {
      vector<boost::any> temp1;
      for(auto item1:*joinPermission){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JoinPermission"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JoinPermission") != m.end() && !m["JoinPermission"].empty()) {
      if (typeid(vector<boost::any>) == m["JoinPermission"].type()) {
        vector<QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JoinPermission"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        joinPermission = make_shared<vector<QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission>>(expect1);
      }
    }
  }


  virtual ~QueryLoRaJoinPermissionsResponseBodyJoinPermissions() = default;
};
class QueryLoRaJoinPermissionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> productKey{};
  shared_ptr<QueryLoRaJoinPermissionsResponseBodyJoinPermissions> joinPermissions{};

  QueryLoRaJoinPermissionsResponseBody() {}

  explicit QueryLoRaJoinPermissionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (joinPermissions) {
      res["JoinPermissions"] = joinPermissions ? boost::any(joinPermissions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("JoinPermissions") != m.end() && !m["JoinPermissions"].empty()) {
      if (typeid(map<string, boost::any>) == m["JoinPermissions"].type()) {
        QueryLoRaJoinPermissionsResponseBodyJoinPermissions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JoinPermissions"]));
        joinPermissions = make_shared<QueryLoRaJoinPermissionsResponseBodyJoinPermissions>(model1);
      }
    }
  }


  virtual ~QueryLoRaJoinPermissionsResponseBody() = default;
};
class QueryLoRaJoinPermissionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryLoRaJoinPermissionsResponseBody> body{};

  QueryLoRaJoinPermissionsResponse() {}

  explicit QueryLoRaJoinPermissionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryLoRaJoinPermissionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryLoRaJoinPermissionsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryLoRaJoinPermissionsResponse() = default;
};
class QueryOTAFirmwareRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> firmwareId{};

  QueryOTAFirmwareRequest() {}

  explicit QueryOTAFirmwareRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
  }


  virtual ~QueryOTAFirmwareRequest() = default;
};
class QueryOTAFirmwareResponseBodyFirmwareInfo : public Darabonba::Model {
public:
  shared_ptr<string> firmwareName{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> srcVersion{};
  shared_ptr<string> destVersion{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> utcModified{};
  shared_ptr<long> status{};
  shared_ptr<string> firmwareDesc{};
  shared_ptr<string> firmwareSign{};
  shared_ptr<long> firmwareSize{};
  shared_ptr<string> firmwareUrl{};
  shared_ptr<string> productKey{};
  shared_ptr<string> signMethod{};
  shared_ptr<string> productName{};
  shared_ptr<long> type{};
  shared_ptr<long> verifyProgress{};
  shared_ptr<string> moduleName{};

  QueryOTAFirmwareResponseBodyFirmwareInfo() {}

  explicit QueryOTAFirmwareResponseBodyFirmwareInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (firmwareName) {
      res["FirmwareName"] = boost::any(*firmwareName);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (srcVersion) {
      res["SrcVersion"] = boost::any(*srcVersion);
    }
    if (destVersion) {
      res["DestVersion"] = boost::any(*destVersion);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (firmwareDesc) {
      res["FirmwareDesc"] = boost::any(*firmwareDesc);
    }
    if (firmwareSign) {
      res["FirmwareSign"] = boost::any(*firmwareSign);
    }
    if (firmwareSize) {
      res["FirmwareSize"] = boost::any(*firmwareSize);
    }
    if (firmwareUrl) {
      res["FirmwareUrl"] = boost::any(*firmwareUrl);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (signMethod) {
      res["SignMethod"] = boost::any(*signMethod);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (verifyProgress) {
      res["VerifyProgress"] = boost::any(*verifyProgress);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FirmwareName") != m.end() && !m["FirmwareName"].empty()) {
      firmwareName = make_shared<string>(boost::any_cast<string>(m["FirmwareName"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("SrcVersion") != m.end() && !m["SrcVersion"].empty()) {
      srcVersion = make_shared<string>(boost::any_cast<string>(m["SrcVersion"]));
    }
    if (m.find("DestVersion") != m.end() && !m["DestVersion"].empty()) {
      destVersion = make_shared<string>(boost::any_cast<string>(m["DestVersion"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("FirmwareDesc") != m.end() && !m["FirmwareDesc"].empty()) {
      firmwareDesc = make_shared<string>(boost::any_cast<string>(m["FirmwareDesc"]));
    }
    if (m.find("FirmwareSign") != m.end() && !m["FirmwareSign"].empty()) {
      firmwareSign = make_shared<string>(boost::any_cast<string>(m["FirmwareSign"]));
    }
    if (m.find("FirmwareSize") != m.end() && !m["FirmwareSize"].empty()) {
      firmwareSize = make_shared<long>(boost::any_cast<long>(m["FirmwareSize"]));
    }
    if (m.find("FirmwareUrl") != m.end() && !m["FirmwareUrl"].empty()) {
      firmwareUrl = make_shared<string>(boost::any_cast<string>(m["FirmwareUrl"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("SignMethod") != m.end() && !m["SignMethod"].empty()) {
      signMethod = make_shared<string>(boost::any_cast<string>(m["SignMethod"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("VerifyProgress") != m.end() && !m["VerifyProgress"].empty()) {
      verifyProgress = make_shared<long>(boost::any_cast<long>(m["VerifyProgress"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
  }


  virtual ~QueryOTAFirmwareResponseBodyFirmwareInfo() = default;
};
class QueryOTAFirmwareResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryOTAFirmwareResponseBodyFirmwareInfo> firmwareInfo{};

  QueryOTAFirmwareResponseBody() {}

  explicit QueryOTAFirmwareResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (firmwareInfo) {
      res["FirmwareInfo"] = firmwareInfo ? boost::any(firmwareInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("FirmwareInfo") != m.end() && !m["FirmwareInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FirmwareInfo"].type()) {
        QueryOTAFirmwareResponseBodyFirmwareInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FirmwareInfo"]));
        firmwareInfo = make_shared<QueryOTAFirmwareResponseBodyFirmwareInfo>(model1);
      }
    }
  }


  virtual ~QueryOTAFirmwareResponseBody() = default;
};
class QueryOTAFirmwareResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryOTAFirmwareResponseBody> body{};

  QueryOTAFirmwareResponse() {}

  explicit QueryOTAFirmwareResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryOTAFirmwareResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryOTAFirmwareResponseBody>(model1);
      }
    }
  }


  virtual ~QueryOTAFirmwareResponse() = default;
};
class QueryOTAJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobId{};

  QueryOTAJobRequest() {}

  explicit QueryOTAJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~QueryOTAJobRequest() = default;
};
class QueryOTAJobResponseBodyDataSrcVersions : public Darabonba::Model {
public:
  shared_ptr<vector<string>> srcVersion{};

  QueryOTAJobResponseBodyDataSrcVersions() {}

  explicit QueryOTAJobResponseBodyDataSrcVersions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (srcVersion) {
      res["SrcVersion"] = boost::any(*srcVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SrcVersion") != m.end() && !m["SrcVersion"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SrcVersion"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SrcVersion"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      srcVersion = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryOTAJobResponseBodyDataSrcVersions() = default;
};
class QueryOTAJobResponseBodyDataTagsOtaTagDTO : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  QueryOTAJobResponseBodyDataTagsOtaTagDTO() {}

  explicit QueryOTAJobResponseBodyDataTagsOtaTagDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryOTAJobResponseBodyDataTagsOtaTagDTO() = default;
};
class QueryOTAJobResponseBodyDataTags : public Darabonba::Model {
public:
  shared_ptr<vector<QueryOTAJobResponseBodyDataTagsOtaTagDTO>> otaTagDTO{};

  QueryOTAJobResponseBodyDataTags() {}

  explicit QueryOTAJobResponseBodyDataTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (otaTagDTO) {
      vector<boost::any> temp1;
      for(auto item1:*otaTagDTO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OtaTagDTO"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OtaTagDTO") != m.end() && !m["OtaTagDTO"].empty()) {
      if (typeid(vector<boost::any>) == m["OtaTagDTO"].type()) {
        vector<QueryOTAJobResponseBodyDataTagsOtaTagDTO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OtaTagDTO"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOTAJobResponseBodyDataTagsOtaTagDTO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        otaTagDTO = make_shared<vector<QueryOTAJobResponseBodyDataTagsOtaTagDTO>>(expect1);
      }
    }
  }


  virtual ~QueryOTAJobResponseBodyDataTags() = default;
};
class QueryOTAJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> utcModified{};
  shared_ptr<string> productKey{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> utcStartTime{};
  shared_ptr<string> utcEndTime{};
  shared_ptr<string> jobStatus{};
  shared_ptr<string> jobType{};
  shared_ptr<string> jobDesc{};
  shared_ptr<string> name{};
  shared_ptr<string> utcScheduleTime{};
  shared_ptr<long> retryInterval{};
  shared_ptr<long> retryCount{};
  shared_ptr<long> timeoutInMinutes{};
  shared_ptr<string> targetSelection{};
  shared_ptr<string> selectionType{};
  shared_ptr<string> grayPercent{};
  shared_ptr<long> maximumPerMinute{};
  shared_ptr<string> destVersion{};
  shared_ptr<string> utcScheduleFinishTime{};
  shared_ptr<long> overwriteMode{};
  shared_ptr<long> dynamicMode{};
  shared_ptr<QueryOTAJobResponseBodyDataSrcVersions> srcVersions{};
  shared_ptr<QueryOTAJobResponseBodyDataTags> tags{};

  QueryOTAJobResponseBodyData() {}

  explicit QueryOTAJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (utcStartTime) {
      res["UtcStartTime"] = boost::any(*utcStartTime);
    }
    if (utcEndTime) {
      res["UtcEndTime"] = boost::any(*utcEndTime);
    }
    if (jobStatus) {
      res["JobStatus"] = boost::any(*jobStatus);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (jobDesc) {
      res["JobDesc"] = boost::any(*jobDesc);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (utcScheduleTime) {
      res["UtcScheduleTime"] = boost::any(*utcScheduleTime);
    }
    if (retryInterval) {
      res["RetryInterval"] = boost::any(*retryInterval);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (timeoutInMinutes) {
      res["TimeoutInMinutes"] = boost::any(*timeoutInMinutes);
    }
    if (targetSelection) {
      res["TargetSelection"] = boost::any(*targetSelection);
    }
    if (selectionType) {
      res["SelectionType"] = boost::any(*selectionType);
    }
    if (grayPercent) {
      res["GrayPercent"] = boost::any(*grayPercent);
    }
    if (maximumPerMinute) {
      res["MaximumPerMinute"] = boost::any(*maximumPerMinute);
    }
    if (destVersion) {
      res["DestVersion"] = boost::any(*destVersion);
    }
    if (utcScheduleFinishTime) {
      res["UtcScheduleFinishTime"] = boost::any(*utcScheduleFinishTime);
    }
    if (overwriteMode) {
      res["OverwriteMode"] = boost::any(*overwriteMode);
    }
    if (dynamicMode) {
      res["DynamicMode"] = boost::any(*dynamicMode);
    }
    if (srcVersions) {
      res["SrcVersions"] = srcVersions ? boost::any(srcVersions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("UtcStartTime") != m.end() && !m["UtcStartTime"].empty()) {
      utcStartTime = make_shared<string>(boost::any_cast<string>(m["UtcStartTime"]));
    }
    if (m.find("UtcEndTime") != m.end() && !m["UtcEndTime"].empty()) {
      utcEndTime = make_shared<string>(boost::any_cast<string>(m["UtcEndTime"]));
    }
    if (m.find("JobStatus") != m.end() && !m["JobStatus"].empty()) {
      jobStatus = make_shared<string>(boost::any_cast<string>(m["JobStatus"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("JobDesc") != m.end() && !m["JobDesc"].empty()) {
      jobDesc = make_shared<string>(boost::any_cast<string>(m["JobDesc"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UtcScheduleTime") != m.end() && !m["UtcScheduleTime"].empty()) {
      utcScheduleTime = make_shared<string>(boost::any_cast<string>(m["UtcScheduleTime"]));
    }
    if (m.find("RetryInterval") != m.end() && !m["RetryInterval"].empty()) {
      retryInterval = make_shared<long>(boost::any_cast<long>(m["RetryInterval"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<long>(boost::any_cast<long>(m["RetryCount"]));
    }
    if (m.find("TimeoutInMinutes") != m.end() && !m["TimeoutInMinutes"].empty()) {
      timeoutInMinutes = make_shared<long>(boost::any_cast<long>(m["TimeoutInMinutes"]));
    }
    if (m.find("TargetSelection") != m.end() && !m["TargetSelection"].empty()) {
      targetSelection = make_shared<string>(boost::any_cast<string>(m["TargetSelection"]));
    }
    if (m.find("SelectionType") != m.end() && !m["SelectionType"].empty()) {
      selectionType = make_shared<string>(boost::any_cast<string>(m["SelectionType"]));
    }
    if (m.find("GrayPercent") != m.end() && !m["GrayPercent"].empty()) {
      grayPercent = make_shared<string>(boost::any_cast<string>(m["GrayPercent"]));
    }
    if (m.find("MaximumPerMinute") != m.end() && !m["MaximumPerMinute"].empty()) {
      maximumPerMinute = make_shared<long>(boost::any_cast<long>(m["MaximumPerMinute"]));
    }
    if (m.find("DestVersion") != m.end() && !m["DestVersion"].empty()) {
      destVersion = make_shared<string>(boost::any_cast<string>(m["DestVersion"]));
    }
    if (m.find("UtcScheduleFinishTime") != m.end() && !m["UtcScheduleFinishTime"].empty()) {
      utcScheduleFinishTime = make_shared<string>(boost::any_cast<string>(m["UtcScheduleFinishTime"]));
    }
    if (m.find("OverwriteMode") != m.end() && !m["OverwriteMode"].empty()) {
      overwriteMode = make_shared<long>(boost::any_cast<long>(m["OverwriteMode"]));
    }
    if (m.find("DynamicMode") != m.end() && !m["DynamicMode"].empty()) {
      dynamicMode = make_shared<long>(boost::any_cast<long>(m["DynamicMode"]));
    }
    if (m.find("SrcVersions") != m.end() && !m["SrcVersions"].empty()) {
      if (typeid(map<string, boost::any>) == m["SrcVersions"].type()) {
        QueryOTAJobResponseBodyDataSrcVersions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SrcVersions"]));
        srcVersions = make_shared<QueryOTAJobResponseBodyDataSrcVersions>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        QueryOTAJobResponseBodyDataTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<QueryOTAJobResponseBodyDataTags>(model1);
      }
    }
  }


  virtual ~QueryOTAJobResponseBodyData() = default;
};
class QueryOTAJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryOTAJobResponseBodyData> data{};

  QueryOTAJobResponseBody() {}

  explicit QueryOTAJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryOTAJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryOTAJobResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryOTAJobResponseBody() = default;
};
class QueryOTAJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryOTAJobResponseBody> body{};

  QueryOTAJobResponse() {}

  explicit QueryOTAJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryOTAJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryOTAJobResponseBody>(model1);
      }
    }
  }


  virtual ~QueryOTAJobResponse() = default;
};
class QueryPageByApplyIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> applyId{};
  shared_ptr<long> currentPage{};

  QueryPageByApplyIdRequest() {}

  explicit QueryPageByApplyIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (applyId) {
      res["ApplyId"] = boost::any(*applyId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ApplyId") != m.end() && !m["ApplyId"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["ApplyId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~QueryPageByApplyIdRequest() = default;
};
class QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceSecret{};
  shared_ptr<string> iotId{};

  QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo() {}

  explicit QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceSecret) {
      res["DeviceSecret"] = boost::any(*deviceSecret);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceSecret") != m.end() && !m["DeviceSecret"].empty()) {
      deviceSecret = make_shared<string>(boost::any_cast<string>(m["DeviceSecret"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo() = default;
};
class QueryPageByApplyIdResponseBodyApplyDeviceList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo>> applyDeviceInfo{};

  QueryPageByApplyIdResponseBodyApplyDeviceList() {}

  explicit QueryPageByApplyIdResponseBodyApplyDeviceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyDeviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*applyDeviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApplyDeviceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyDeviceInfo") != m.end() && !m["ApplyDeviceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ApplyDeviceInfo"].type()) {
        vector<QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApplyDeviceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applyDeviceInfo = make_shared<vector<QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo>>(expect1);
      }
    }
  }


  virtual ~QueryPageByApplyIdResponseBodyApplyDeviceList() = default;
};
class QueryPageByApplyIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> page{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> total{};
  shared_ptr<QueryPageByApplyIdResponseBodyApplyDeviceList> applyDeviceList{};

  QueryPageByApplyIdResponseBody() {}

  explicit QueryPageByApplyIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (applyDeviceList) {
      res["ApplyDeviceList"] = applyDeviceList ? boost::any(applyDeviceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("ApplyDeviceList") != m.end() && !m["ApplyDeviceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApplyDeviceList"].type()) {
        QueryPageByApplyIdResponseBodyApplyDeviceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApplyDeviceList"]));
        applyDeviceList = make_shared<QueryPageByApplyIdResponseBodyApplyDeviceList>(model1);
      }
    }
  }


  virtual ~QueryPageByApplyIdResponseBody() = default;
};
class QueryPageByApplyIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryPageByApplyIdResponseBody> body{};

  QueryPageByApplyIdResponse() {}

  explicit QueryPageByApplyIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryPageByApplyIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryPageByApplyIdResponseBody>(model1);
      }
    }
  }


  virtual ~QueryPageByApplyIdResponse() = default;
};
class QueryProductRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  QueryProductRequest() {}

  explicit QueryProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryProductRequest() = default;
};
class QueryProductResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> dataFormat{};
  shared_ptr<string> description{};
  shared_ptr<long> deviceCount{};
  shared_ptr<long> nodeType{};
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};
  shared_ptr<string> productSecret{};
  shared_ptr<string> categoryName{};
  shared_ptr<string> categoryKey{};
  shared_ptr<string> aliyunCommodityCode{};
  shared_ptr<bool> id2{};
  shared_ptr<string> protocolType{};
  shared_ptr<string> productStatus{};
  shared_ptr<bool> owner{};
  shared_ptr<long> netType{};
  shared_ptr<string> authType{};
  shared_ptr<long> validateType{};

  QueryProductResponseBodyData() {}

  explicit QueryProductResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (dataFormat) {
      res["DataFormat"] = boost::any(*dataFormat);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (deviceCount) {
      res["DeviceCount"] = boost::any(*deviceCount);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (productSecret) {
      res["ProductSecret"] = boost::any(*productSecret);
    }
    if (categoryName) {
      res["CategoryName"] = boost::any(*categoryName);
    }
    if (categoryKey) {
      res["CategoryKey"] = boost::any(*categoryKey);
    }
    if (aliyunCommodityCode) {
      res["AliyunCommodityCode"] = boost::any(*aliyunCommodityCode);
    }
    if (id2) {
      res["Id2"] = boost::any(*id2);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (productStatus) {
      res["ProductStatus"] = boost::any(*productStatus);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (validateType) {
      res["ValidateType"] = boost::any(*validateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("DataFormat") != m.end() && !m["DataFormat"].empty()) {
      dataFormat = make_shared<long>(boost::any_cast<long>(m["DataFormat"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DeviceCount") != m.end() && !m["DeviceCount"].empty()) {
      deviceCount = make_shared<long>(boost::any_cast<long>(m["DeviceCount"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<long>(boost::any_cast<long>(m["NodeType"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("ProductSecret") != m.end() && !m["ProductSecret"].empty()) {
      productSecret = make_shared<string>(boost::any_cast<string>(m["ProductSecret"]));
    }
    if (m.find("CategoryName") != m.end() && !m["CategoryName"].empty()) {
      categoryName = make_shared<string>(boost::any_cast<string>(m["CategoryName"]));
    }
    if (m.find("CategoryKey") != m.end() && !m["CategoryKey"].empty()) {
      categoryKey = make_shared<string>(boost::any_cast<string>(m["CategoryKey"]));
    }
    if (m.find("AliyunCommodityCode") != m.end() && !m["AliyunCommodityCode"].empty()) {
      aliyunCommodityCode = make_shared<string>(boost::any_cast<string>(m["AliyunCommodityCode"]));
    }
    if (m.find("Id2") != m.end() && !m["Id2"].empty()) {
      id2 = make_shared<bool>(boost::any_cast<bool>(m["Id2"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("ProductStatus") != m.end() && !m["ProductStatus"].empty()) {
      productStatus = make_shared<string>(boost::any_cast<string>(m["ProductStatus"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<bool>(boost::any_cast<bool>(m["Owner"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<long>(boost::any_cast<long>(m["NetType"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("ValidateType") != m.end() && !m["ValidateType"].empty()) {
      validateType = make_shared<long>(boost::any_cast<long>(m["ValidateType"]));
    }
  }


  virtual ~QueryProductResponseBodyData() = default;
};
class QueryProductResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryProductResponseBodyData> data{};

  QueryProductResponseBody() {}

  explicit QueryProductResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryProductResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryProductResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryProductResponseBody() = default;
};
class QueryProductResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryProductResponseBody> body{};

  QueryProductResponse() {}

  explicit QueryProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryProductResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryProductResponseBody>(model1);
      }
    }
  }


  virtual ~QueryProductResponse() = default;
};
class QueryProductCertInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  QueryProductCertInfoRequest() {}

  explicit QueryProductCertInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryProductCertInfoRequest() = default;
};
class QueryProductCertInfoResponseBodyProductCertInfo : public Darabonba::Model {
public:
  shared_ptr<long> issueModel{};

  QueryProductCertInfoResponseBodyProductCertInfo() {}

  explicit QueryProductCertInfoResponseBodyProductCertInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (issueModel) {
      res["IssueModel"] = boost::any(*issueModel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IssueModel") != m.end() && !m["IssueModel"].empty()) {
      issueModel = make_shared<long>(boost::any_cast<long>(m["IssueModel"]));
    }
  }


  virtual ~QueryProductCertInfoResponseBodyProductCertInfo() = default;
};
class QueryProductCertInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryProductCertInfoResponseBodyProductCertInfo> productCertInfo{};

  QueryProductCertInfoResponseBody() {}

  explicit QueryProductCertInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (productCertInfo) {
      res["ProductCertInfo"] = productCertInfo ? boost::any(productCertInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ProductCertInfo") != m.end() && !m["ProductCertInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProductCertInfo"].type()) {
        QueryProductCertInfoResponseBodyProductCertInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProductCertInfo"]));
        productCertInfo = make_shared<QueryProductCertInfoResponseBodyProductCertInfo>(model1);
      }
    }
  }


  virtual ~QueryProductCertInfoResponseBody() = default;
};
class QueryProductCertInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryProductCertInfoResponseBody> body{};

  QueryProductCertInfoResponse() {}

  explicit QueryProductCertInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryProductCertInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryProductCertInfoResponseBody>(model1);
      }
    }
  }


  virtual ~QueryProductCertInfoResponse() = default;
};
class QueryProductListRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> aliyunCommodityCode{};
  shared_ptr<long> currentPage{};

  QueryProductListRequest() {}

  explicit QueryProductListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (aliyunCommodityCode) {
      res["AliyunCommodityCode"] = boost::any(*aliyunCommodityCode);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("AliyunCommodityCode") != m.end() && !m["AliyunCommodityCode"].empty()) {
      aliyunCommodityCode = make_shared<string>(boost::any_cast<string>(m["AliyunCommodityCode"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~QueryProductListRequest() = default;
};
class QueryProductListResponseBodyDataListProductInfo : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> dataFormat{};
  shared_ptr<string> description{};
  shared_ptr<long> deviceCount{};
  shared_ptr<long> nodeType{};
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};
  shared_ptr<string> authType{};

  QueryProductListResponseBodyDataListProductInfo() {}

  explicit QueryProductListResponseBodyDataListProductInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (dataFormat) {
      res["DataFormat"] = boost::any(*dataFormat);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (deviceCount) {
      res["DeviceCount"] = boost::any(*deviceCount);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("DataFormat") != m.end() && !m["DataFormat"].empty()) {
      dataFormat = make_shared<long>(boost::any_cast<long>(m["DataFormat"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DeviceCount") != m.end() && !m["DeviceCount"].empty()) {
      deviceCount = make_shared<long>(boost::any_cast<long>(m["DeviceCount"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<long>(boost::any_cast<long>(m["NodeType"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
  }


  virtual ~QueryProductListResponseBodyDataListProductInfo() = default;
};
class QueryProductListResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryProductListResponseBodyDataListProductInfo>> productInfo{};

  QueryProductListResponseBodyDataList() {}

  explicit QueryProductListResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productInfo) {
      vector<boost::any> temp1;
      for(auto item1:*productInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProductInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductInfo") != m.end() && !m["ProductInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ProductInfo"].type()) {
        vector<QueryProductListResponseBodyDataListProductInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProductInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryProductListResponseBodyDataListProductInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        productInfo = make_shared<vector<QueryProductListResponseBodyDataListProductInfo>>(expect1);
      }
    }
  }


  virtual ~QueryProductListResponseBodyDataList() = default;
};
class QueryProductListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};
  shared_ptr<QueryProductListResponseBodyDataList> list{};

  QueryProductListResponseBodyData() {}

  explicit QueryProductListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryProductListResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryProductListResponseBodyDataList>(model1);
      }
    }
  }


  virtual ~QueryProductListResponseBodyData() = default;
};
class QueryProductListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryProductListResponseBodyData> data{};

  QueryProductListResponseBody() {}

  explicit QueryProductListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryProductListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryProductListResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryProductListResponseBody() = default;
};
class QueryProductListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryProductListResponseBody> body{};

  QueryProductListResponse() {}

  explicit QueryProductListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryProductListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryProductListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryProductListResponse() = default;
};
class QueryProductTopicRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  QueryProductTopicRequest() {}

  explicit QueryProductTopicRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryProductTopicRequest() = default;
};
class QueryProductTopicResponseBodyDataProductTopicInfo : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> topicShortName{};
  shared_ptr<string> operation{};
  shared_ptr<string> desc{};
  shared_ptr<string> id{};

  QueryProductTopicResponseBodyDataProductTopicInfo() {}

  explicit QueryProductTopicResponseBodyDataProductTopicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (topicShortName) {
      res["TopicShortName"] = boost::any(*topicShortName);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("TopicShortName") != m.end() && !m["TopicShortName"].empty()) {
      topicShortName = make_shared<string>(boost::any_cast<string>(m["TopicShortName"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~QueryProductTopicResponseBodyDataProductTopicInfo() = default;
};
class QueryProductTopicResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryProductTopicResponseBodyDataProductTopicInfo>> productTopicInfo{};

  QueryProductTopicResponseBodyData() {}

  explicit QueryProductTopicResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productTopicInfo) {
      vector<boost::any> temp1;
      for(auto item1:*productTopicInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProductTopicInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductTopicInfo") != m.end() && !m["ProductTopicInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ProductTopicInfo"].type()) {
        vector<QueryProductTopicResponseBodyDataProductTopicInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProductTopicInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryProductTopicResponseBodyDataProductTopicInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        productTopicInfo = make_shared<vector<QueryProductTopicResponseBodyDataProductTopicInfo>>(expect1);
      }
    }
  }


  virtual ~QueryProductTopicResponseBodyData() = default;
};
class QueryProductTopicResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryProductTopicResponseBodyData> data{};

  QueryProductTopicResponseBody() {}

  explicit QueryProductTopicResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryProductTopicResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryProductTopicResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryProductTopicResponseBody() = default;
};
class QueryProductTopicResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryProductTopicResponseBody> body{};

  QueryProductTopicResponse() {}

  explicit QueryProductTopicResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryProductTopicResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryProductTopicResponseBody>(model1);
      }
    }
  }


  virtual ~QueryProductTopicResponse() = default;
};
class QuerySceneRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};

  QuerySceneRuleRequest() {}

  explicit QuerySceneRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~QuerySceneRuleRequest() = default;
};
class QuerySceneRuleResponseBodyDataRuleList : public Darabonba::Model {
public:
  shared_ptr<string> ruleId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleDescription{};
  shared_ptr<long> ruleStatus{};

  QuerySceneRuleResponseBodyDataRuleList() {}

  explicit QuerySceneRuleResponseBodyDataRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleDescription) {
      res["RuleDescription"] = boost::any(*ruleDescription);
    }
    if (ruleStatus) {
      res["RuleStatus"] = boost::any(*ruleStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleDescription") != m.end() && !m["RuleDescription"].empty()) {
      ruleDescription = make_shared<string>(boost::any_cast<string>(m["RuleDescription"]));
    }
    if (m.find("RuleStatus") != m.end() && !m["RuleStatus"].empty()) {
      ruleStatus = make_shared<long>(boost::any_cast<long>(m["RuleStatus"]));
    }
  }


  virtual ~QuerySceneRuleResponseBodyDataRuleList() = default;
};
class QuerySceneRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> total{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};
  shared_ptr<vector<QuerySceneRuleResponseBodyDataRuleList>> ruleList{};

  QuerySceneRuleResponseBodyData() {}

  explicit QuerySceneRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (ruleList) {
      vector<boost::any> temp1;
      for(auto item1:*ruleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("RuleList") != m.end() && !m["RuleList"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleList"].type()) {
        vector<QuerySceneRuleResponseBodyDataRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySceneRuleResponseBodyDataRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleList = make_shared<vector<QuerySceneRuleResponseBodyDataRuleList>>(expect1);
      }
    }
  }


  virtual ~QuerySceneRuleResponseBodyData() = default;
};
class QuerySceneRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QuerySceneRuleResponseBodyData> data{};

  QuerySceneRuleResponseBody() {}

  explicit QuerySceneRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QuerySceneRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QuerySceneRuleResponseBodyData>(model1);
      }
    }
  }


  virtual ~QuerySceneRuleResponseBody() = default;
};
class QuerySceneRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QuerySceneRuleResponseBody> body{};

  QuerySceneRuleResponse() {}

  explicit QuerySceneRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySceneRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySceneRuleResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySceneRuleResponse() = default;
};
class QuerySubscribeRelationRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> type{};

  QuerySubscribeRelationRequest() {}

  explicit QuerySubscribeRelationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QuerySubscribeRelationRequest() = default;
};
class QuerySubscribeRelationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> productKey{};
  shared_ptr<string> type{};
  shared_ptr<bool> deviceDataFlag{};
  shared_ptr<bool> deviceLifeCycleFlag{};
  shared_ptr<bool> deviceStatusChangeFlag{};
  shared_ptr<bool> deviceTopoLifeCycleFlag{};
  shared_ptr<bool> foundDeviceListFlag{};
  shared_ptr<bool> otaEventFlag{};
  shared_ptr<bool> thingHistoryFlag{};
  shared_ptr<string> mnsConfiguration{};
  shared_ptr<bool> deviceTagFlag{};
  shared_ptr<bool> otaVersionFlag{};
  shared_ptr<bool> otaJobFlag{};
  shared_ptr<vector<string>> consumerGroupIds{};

  QuerySubscribeRelationResponseBody() {}

  explicit QuerySubscribeRelationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (deviceDataFlag) {
      res["DeviceDataFlag"] = boost::any(*deviceDataFlag);
    }
    if (deviceLifeCycleFlag) {
      res["DeviceLifeCycleFlag"] = boost::any(*deviceLifeCycleFlag);
    }
    if (deviceStatusChangeFlag) {
      res["DeviceStatusChangeFlag"] = boost::any(*deviceStatusChangeFlag);
    }
    if (deviceTopoLifeCycleFlag) {
      res["DeviceTopoLifeCycleFlag"] = boost::any(*deviceTopoLifeCycleFlag);
    }
    if (foundDeviceListFlag) {
      res["FoundDeviceListFlag"] = boost::any(*foundDeviceListFlag);
    }
    if (otaEventFlag) {
      res["OtaEventFlag"] = boost::any(*otaEventFlag);
    }
    if (thingHistoryFlag) {
      res["ThingHistoryFlag"] = boost::any(*thingHistoryFlag);
    }
    if (mnsConfiguration) {
      res["MnsConfiguration"] = boost::any(*mnsConfiguration);
    }
    if (deviceTagFlag) {
      res["DeviceTagFlag"] = boost::any(*deviceTagFlag);
    }
    if (otaVersionFlag) {
      res["OtaVersionFlag"] = boost::any(*otaVersionFlag);
    }
    if (otaJobFlag) {
      res["OtaJobFlag"] = boost::any(*otaJobFlag);
    }
    if (consumerGroupIds) {
      res["ConsumerGroupIds"] = boost::any(*consumerGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("DeviceDataFlag") != m.end() && !m["DeviceDataFlag"].empty()) {
      deviceDataFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceDataFlag"]));
    }
    if (m.find("DeviceLifeCycleFlag") != m.end() && !m["DeviceLifeCycleFlag"].empty()) {
      deviceLifeCycleFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceLifeCycleFlag"]));
    }
    if (m.find("DeviceStatusChangeFlag") != m.end() && !m["DeviceStatusChangeFlag"].empty()) {
      deviceStatusChangeFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceStatusChangeFlag"]));
    }
    if (m.find("DeviceTopoLifeCycleFlag") != m.end() && !m["DeviceTopoLifeCycleFlag"].empty()) {
      deviceTopoLifeCycleFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceTopoLifeCycleFlag"]));
    }
    if (m.find("FoundDeviceListFlag") != m.end() && !m["FoundDeviceListFlag"].empty()) {
      foundDeviceListFlag = make_shared<bool>(boost::any_cast<bool>(m["FoundDeviceListFlag"]));
    }
    if (m.find("OtaEventFlag") != m.end() && !m["OtaEventFlag"].empty()) {
      otaEventFlag = make_shared<bool>(boost::any_cast<bool>(m["OtaEventFlag"]));
    }
    if (m.find("ThingHistoryFlag") != m.end() && !m["ThingHistoryFlag"].empty()) {
      thingHistoryFlag = make_shared<bool>(boost::any_cast<bool>(m["ThingHistoryFlag"]));
    }
    if (m.find("MnsConfiguration") != m.end() && !m["MnsConfiguration"].empty()) {
      mnsConfiguration = make_shared<string>(boost::any_cast<string>(m["MnsConfiguration"]));
    }
    if (m.find("DeviceTagFlag") != m.end() && !m["DeviceTagFlag"].empty()) {
      deviceTagFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceTagFlag"]));
    }
    if (m.find("OtaVersionFlag") != m.end() && !m["OtaVersionFlag"].empty()) {
      otaVersionFlag = make_shared<bool>(boost::any_cast<bool>(m["OtaVersionFlag"]));
    }
    if (m.find("OtaJobFlag") != m.end() && !m["OtaJobFlag"].empty()) {
      otaJobFlag = make_shared<bool>(boost::any_cast<bool>(m["OtaJobFlag"]));
    }
    if (m.find("ConsumerGroupIds") != m.end() && !m["ConsumerGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ConsumerGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ConsumerGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      consumerGroupIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QuerySubscribeRelationResponseBody() = default;
};
class QuerySubscribeRelationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QuerySubscribeRelationResponseBody> body{};

  QuerySubscribeRelationResponse() {}

  explicit QuerySubscribeRelationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySubscribeRelationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySubscribeRelationResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySubscribeRelationResponse() = default;
};
class QuerySummarySceneRuleLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> ruleId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> endTime{};
  shared_ptr<string> status{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};

  QuerySummarySceneRuleLogRequest() {}

  explicit QuerySummarySceneRuleLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~QuerySummarySceneRuleLogRequest() = default;
};
class QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo : public Darabonba::Model {
public:
  shared_ptr<long> logTime{};
  shared_ptr<string> result{};
  shared_ptr<string> traceId{};

  QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo() {}

  explicit QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logTime) {
      res["LogTime"] = boost::any(*logTime);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogTime") != m.end() && !m["LogTime"].empty()) {
      logTime = make_shared<long>(boost::any_cast<long>(m["LogTime"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo() = default;
};
class QuerySummarySceneRuleLogResponseBodyDataLogList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo>> logInfo{};

  QuerySummarySceneRuleLogResponseBodyDataLogList() {}

  explicit QuerySummarySceneRuleLogResponseBodyDataLogList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logInfo) {
      vector<boost::any> temp1;
      for(auto item1:*logInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogInfo") != m.end() && !m["LogInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["LogInfo"].type()) {
        vector<QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logInfo = make_shared<vector<QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo>>(expect1);
      }
    }
  }


  virtual ~QuerySummarySceneRuleLogResponseBodyDataLogList() = default;
};
class QuerySummarySceneRuleLogResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> total{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};
  shared_ptr<QuerySummarySceneRuleLogResponseBodyDataLogList> logList{};

  QuerySummarySceneRuleLogResponseBodyData() {}

  explicit QuerySummarySceneRuleLogResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (logList) {
      res["LogList"] = logList ? boost::any(logList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("LogList") != m.end() && !m["LogList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogList"].type()) {
        QuerySummarySceneRuleLogResponseBodyDataLogList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogList"]));
        logList = make_shared<QuerySummarySceneRuleLogResponseBodyDataLogList>(model1);
      }
    }
  }


  virtual ~QuerySummarySceneRuleLogResponseBodyData() = default;
};
class QuerySummarySceneRuleLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<QuerySummarySceneRuleLogResponseBodyData> data{};

  QuerySummarySceneRuleLogResponseBody() {}

  explicit QuerySummarySceneRuleLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QuerySummarySceneRuleLogResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QuerySummarySceneRuleLogResponseBodyData>(model1);
      }
    }
  }


  virtual ~QuerySummarySceneRuleLogResponseBody() = default;
};
class QuerySummarySceneRuleLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QuerySummarySceneRuleLogResponseBody> body{};

  QuerySummarySceneRuleLogResponse() {}

  explicit QuerySummarySceneRuleLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySummarySceneRuleLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySummarySceneRuleLogResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySummarySceneRuleLogResponse() = default;
};
class QuerySuperDeviceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> groupId{};

  QuerySuperDeviceGroupRequest() {}

  explicit QuerySuperDeviceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~QuerySuperDeviceGroupRequest() = default;
};
class QuerySuperDeviceGroupResponseBodyDataGroupInfo : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> groupDesc{};

  QuerySuperDeviceGroupResponseBodyDataGroupInfo() {}

  explicit QuerySuperDeviceGroupResponseBodyDataGroupInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupDesc) {
      res["GroupDesc"] = boost::any(*groupDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupDesc") != m.end() && !m["GroupDesc"].empty()) {
      groupDesc = make_shared<string>(boost::any_cast<string>(m["GroupDesc"]));
    }
  }


  virtual ~QuerySuperDeviceGroupResponseBodyDataGroupInfo() = default;
};
class QuerySuperDeviceGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySuperDeviceGroupResponseBodyDataGroupInfo>> groupInfo{};

  QuerySuperDeviceGroupResponseBodyData() {}

  explicit QuerySuperDeviceGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupInfo) {
      vector<boost::any> temp1;
      for(auto item1:*groupInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupInfo") != m.end() && !m["GroupInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupInfo"].type()) {
        vector<QuerySuperDeviceGroupResponseBodyDataGroupInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySuperDeviceGroupResponseBodyDataGroupInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupInfo = make_shared<vector<QuerySuperDeviceGroupResponseBodyDataGroupInfo>>(expect1);
      }
    }
  }


  virtual ~QuerySuperDeviceGroupResponseBodyData() = default;
};
class QuerySuperDeviceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QuerySuperDeviceGroupResponseBodyData> data{};

  QuerySuperDeviceGroupResponseBody() {}

  explicit QuerySuperDeviceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QuerySuperDeviceGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QuerySuperDeviceGroupResponseBodyData>(model1);
      }
    }
  }


  virtual ~QuerySuperDeviceGroupResponseBody() = default;
};
class QuerySuperDeviceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QuerySuperDeviceGroupResponseBody> body{};

  QuerySuperDeviceGroupResponse() {}

  explicit QuerySuperDeviceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySuperDeviceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySuperDeviceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySuperDeviceGroupResponse() = default;
};
class QueryTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> taskId{};

  QueryTaskRequest() {}

  explicit QueryTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~QueryTaskRequest() = default;
};
class QueryTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> jobName{};
  shared_ptr<string> taskId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> progress{};
  shared_ptr<string> utcQueueTime{};
  shared_ptr<string> utcModified{};
  shared_ptr<string> statusDetail{};
  shared_ptr<string> status{};
  shared_ptr<string> message{};

  QueryTaskResponseBodyData() {}

  explicit QueryTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (utcQueueTime) {
      res["UtcQueueTime"] = boost::any(*utcQueueTime);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (statusDetail) {
      res["StatusDetail"] = boost::any(*statusDetail);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("UtcQueueTime") != m.end() && !m["UtcQueueTime"].empty()) {
      utcQueueTime = make_shared<string>(boost::any_cast<string>(m["UtcQueueTime"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("StatusDetail") != m.end() && !m["StatusDetail"].empty()) {
      statusDetail = make_shared<string>(boost::any_cast<string>(m["StatusDetail"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~QueryTaskResponseBodyData() = default;
};
class QueryTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryTaskResponseBodyData> data{};

  QueryTaskResponseBody() {}

  explicit QueryTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryTaskResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryTaskResponseBody() = default;
};
class QueryTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryTaskResponseBody> body{};

  QueryTaskResponse() {}

  explicit QueryTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTaskResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTaskResponse() = default;
};
class QueryThingModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> modelVersion{};
  shared_ptr<string> functionBlockId{};

  QueryThingModelRequest() {}

  explicit QueryThingModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (modelVersion) {
      res["ModelVersion"] = boost::any(*modelVersion);
    }
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ModelVersion") != m.end() && !m["ModelVersion"].empty()) {
      modelVersion = make_shared<string>(boost::any_cast<string>(m["ModelVersion"]));
    }
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
  }


  virtual ~QueryThingModelRequest() = default;
};
class QueryThingModelResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> thingModelJson{};

  QueryThingModelResponseBodyData() {}

  explicit QueryThingModelResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (thingModelJson) {
      res["ThingModelJson"] = boost::any(*thingModelJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ThingModelJson") != m.end() && !m["ThingModelJson"].empty()) {
      thingModelJson = make_shared<string>(boost::any_cast<string>(m["ThingModelJson"]));
    }
  }


  virtual ~QueryThingModelResponseBodyData() = default;
};
class QueryThingModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> productKey{};
  shared_ptr<QueryThingModelResponseBodyData> data{};

  QueryThingModelResponseBody() {}

  explicit QueryThingModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryThingModelResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryThingModelResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryThingModelResponseBody() = default;
};
class QueryThingModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryThingModelResponseBody> body{};

  QueryThingModelResponse() {}

  explicit QueryThingModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryThingModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryThingModelResponseBody>(model1);
      }
    }
  }


  virtual ~QueryThingModelResponse() = default;
};
class QueryThingModelExtendConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> modelVersion{};
  shared_ptr<string> functionBlockId{};

  QueryThingModelExtendConfigRequest() {}

  explicit QueryThingModelExtendConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (modelVersion) {
      res["ModelVersion"] = boost::any(*modelVersion);
    }
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ModelVersion") != m.end() && !m["ModelVersion"].empty()) {
      modelVersion = make_shared<string>(boost::any_cast<string>(m["ModelVersion"]));
    }
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
  }


  virtual ~QueryThingModelExtendConfigRequest() = default;
};
class QueryThingModelExtendConfigResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> configuration{};

  QueryThingModelExtendConfigResponseBodyData() {}

  explicit QueryThingModelExtendConfigResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configuration) {
      res["Configuration"] = boost::any(*configuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configuration = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
  }


  virtual ~QueryThingModelExtendConfigResponseBodyData() = default;
};
class QueryThingModelExtendConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryThingModelExtendConfigResponseBodyData> data{};

  QueryThingModelExtendConfigResponseBody() {}

  explicit QueryThingModelExtendConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryThingModelExtendConfigResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryThingModelExtendConfigResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryThingModelExtendConfigResponseBody() = default;
};
class QueryThingModelExtendConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryThingModelExtendConfigResponseBody> body{};

  QueryThingModelExtendConfigResponse() {}

  explicit QueryThingModelExtendConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryThingModelExtendConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryThingModelExtendConfigResponseBody>(model1);
      }
    }
  }


  virtual ~QueryThingModelExtendConfigResponse() = default;
};
class QueryThingModelExtendConfigPublishedRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> modelVersion{};
  shared_ptr<string> functionBlockId{};

  QueryThingModelExtendConfigPublishedRequest() {}

  explicit QueryThingModelExtendConfigPublishedRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (modelVersion) {
      res["ModelVersion"] = boost::any(*modelVersion);
    }
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ModelVersion") != m.end() && !m["ModelVersion"].empty()) {
      modelVersion = make_shared<string>(boost::any_cast<string>(m["ModelVersion"]));
    }
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
  }


  virtual ~QueryThingModelExtendConfigPublishedRequest() = default;
};
class QueryThingModelExtendConfigPublishedResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> configuration{};

  QueryThingModelExtendConfigPublishedResponseBodyData() {}

  explicit QueryThingModelExtendConfigPublishedResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configuration) {
      res["Configuration"] = boost::any(*configuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configuration = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
  }


  virtual ~QueryThingModelExtendConfigPublishedResponseBodyData() = default;
};
class QueryThingModelExtendConfigPublishedResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryThingModelExtendConfigPublishedResponseBodyData> data{};

  QueryThingModelExtendConfigPublishedResponseBody() {}

  explicit QueryThingModelExtendConfigPublishedResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryThingModelExtendConfigPublishedResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryThingModelExtendConfigPublishedResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryThingModelExtendConfigPublishedResponseBody() = default;
};
class QueryThingModelExtendConfigPublishedResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryThingModelExtendConfigPublishedResponseBody> body{};

  QueryThingModelExtendConfigPublishedResponse() {}

  explicit QueryThingModelExtendConfigPublishedResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryThingModelExtendConfigPublishedResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryThingModelExtendConfigPublishedResponseBody>(model1);
      }
    }
  }


  virtual ~QueryThingModelExtendConfigPublishedResponse() = default;
};
class QueryThingModelPublishedRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> modelVersion{};
  shared_ptr<string> functionBlockId{};

  QueryThingModelPublishedRequest() {}

  explicit QueryThingModelPublishedRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (modelVersion) {
      res["ModelVersion"] = boost::any(*modelVersion);
    }
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ModelVersion") != m.end() && !m["ModelVersion"].empty()) {
      modelVersion = make_shared<string>(boost::any_cast<string>(m["ModelVersion"]));
    }
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
  }


  virtual ~QueryThingModelPublishedRequest() = default;
};
class QueryThingModelPublishedResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> thingModelJson{};

  QueryThingModelPublishedResponseBodyData() {}

  explicit QueryThingModelPublishedResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (thingModelJson) {
      res["ThingModelJson"] = boost::any(*thingModelJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ThingModelJson") != m.end() && !m["ThingModelJson"].empty()) {
      thingModelJson = make_shared<string>(boost::any_cast<string>(m["ThingModelJson"]));
    }
  }


  virtual ~QueryThingModelPublishedResponseBodyData() = default;
};
class QueryThingModelPublishedResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> productKey{};
  shared_ptr<QueryThingModelPublishedResponseBodyData> data{};

  QueryThingModelPublishedResponseBody() {}

  explicit QueryThingModelPublishedResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryThingModelPublishedResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryThingModelPublishedResponseBodyData>(model1);
      }
    }
  }


  virtual ~QueryThingModelPublishedResponseBody() = default;
};
class QueryThingModelPublishedResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryThingModelPublishedResponseBody> body{};

  QueryThingModelPublishedResponse() {}

  explicit QueryThingModelPublishedResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryThingModelPublishedResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryThingModelPublishedResponseBody>(model1);
      }
    }
  }


  virtual ~QueryThingModelPublishedResponse() = default;
};
class QueryTopicReverseRouteTableRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> topic{};

  QueryTopicReverseRouteTableRequest() {}

  explicit QueryTopicReverseRouteTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~QueryTopicReverseRouteTableRequest() = default;
};
class QueryTopicReverseRouteTableResponseBodySrcTopics : public Darabonba::Model {
public:
  shared_ptr<vector<map<string, string>>> topic{};

  QueryTopicReverseRouteTableResponseBodySrcTopics() {}

  explicit QueryTopicReverseRouteTableResponseBodySrcTopics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      vector<map<string, string>> toVec1;
      if (typeid(vector<boost::any>) == m["Topic"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Topic"]);
        for (auto item:vec1) {
          map<string, string> map2 = boost::any_cast<map<string, string>>(item);
          map<string, string> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      topic = make_shared<vector<map<string, string>>>(toVec1);
    }
  }


  virtual ~QueryTopicReverseRouteTableResponseBodySrcTopics() = default;
};
class QueryTopicReverseRouteTableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryTopicReverseRouteTableResponseBodySrcTopics> srcTopics{};

  QueryTopicReverseRouteTableResponseBody() {}

  explicit QueryTopicReverseRouteTableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (srcTopics) {
      res["SrcTopics"] = srcTopics ? boost::any(srcTopics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("SrcTopics") != m.end() && !m["SrcTopics"].empty()) {
      if (typeid(map<string, boost::any>) == m["SrcTopics"].type()) {
        QueryTopicReverseRouteTableResponseBodySrcTopics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SrcTopics"]));
        srcTopics = make_shared<QueryTopicReverseRouteTableResponseBodySrcTopics>(model1);
      }
    }
  }


  virtual ~QueryTopicReverseRouteTableResponseBody() = default;
};
class QueryTopicReverseRouteTableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryTopicReverseRouteTableResponseBody> body{};

  QueryTopicReverseRouteTableResponse() {}

  explicit QueryTopicReverseRouteTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTopicReverseRouteTableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTopicReverseRouteTableResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTopicReverseRouteTableResponse() = default;
};
class QueryTopicRouteTableRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> topic{};

  QueryTopicRouteTableRequest() {}

  explicit QueryTopicRouteTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~QueryTopicRouteTableRequest() = default;
};
class QueryTopicRouteTableResponseBodyDstTopics : public Darabonba::Model {
public:
  shared_ptr<vector<map<string, string>>> topic{};

  QueryTopicRouteTableResponseBodyDstTopics() {}

  explicit QueryTopicRouteTableResponseBodyDstTopics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      vector<map<string, string>> toVec1;
      if (typeid(vector<boost::any>) == m["Topic"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Topic"]);
        for (auto item:vec1) {
          map<string, string> map2 = boost::any_cast<map<string, string>>(item);
          map<string, string> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      topic = make_shared<vector<map<string, string>>>(toVec1);
    }
  }


  virtual ~QueryTopicRouteTableResponseBodyDstTopics() = default;
};
class QueryTopicRouteTableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryTopicRouteTableResponseBodyDstTopics> dstTopics{};

  QueryTopicRouteTableResponseBody() {}

  explicit QueryTopicRouteTableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (dstTopics) {
      res["DstTopics"] = dstTopics ? boost::any(dstTopics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("DstTopics") != m.end() && !m["DstTopics"].empty()) {
      if (typeid(map<string, boost::any>) == m["DstTopics"].type()) {
        QueryTopicRouteTableResponseBodyDstTopics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DstTopics"]));
        dstTopics = make_shared<QueryTopicRouteTableResponseBodyDstTopics>(model1);
      }
    }
  }


  virtual ~QueryTopicRouteTableResponseBody() = default;
};
class QueryTopicRouteTableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryTopicRouteTableResponseBody> body{};

  QueryTopicRouteTableResponse() {}

  explicit QueryTopicRouteTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTopicRouteTableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTopicRouteTableResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTopicRouteTableResponse() = default;
};
class RefreshDeviceTunnelSharePasswordRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};

  RefreshDeviceTunnelSharePasswordRequest() {}

  explicit RefreshDeviceTunnelSharePasswordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
  }


  virtual ~RefreshDeviceTunnelSharePasswordRequest() = default;
};
class RefreshDeviceTunnelSharePasswordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<string> password{};

  RefreshDeviceTunnelSharePasswordResponseBody() {}

  explicit RefreshDeviceTunnelSharePasswordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
  }


  virtual ~RefreshDeviceTunnelSharePasswordResponseBody() = default;
};
class RefreshDeviceTunnelSharePasswordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RefreshDeviceTunnelSharePasswordResponseBody> body{};

  RefreshDeviceTunnelSharePasswordResponse() {}

  explicit RefreshDeviceTunnelSharePasswordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefreshDeviceTunnelSharePasswordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefreshDeviceTunnelSharePasswordResponseBody>(model1);
      }
    }
  }


  virtual ~RefreshDeviceTunnelSharePasswordResponse() = default;
};
class RegisterDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> devEui{};
  shared_ptr<string> nickname{};
  shared_ptr<string> pinCode{};
  shared_ptr<string> joinEui{};
  shared_ptr<string> appKey{};
  shared_ptr<string> loraNodeType{};

  RegisterDeviceRequest() {}

  explicit RegisterDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (devEui) {
      res["DevEui"] = boost::any(*devEui);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    if (pinCode) {
      res["PinCode"] = boost::any(*pinCode);
    }
    if (joinEui) {
      res["JoinEui"] = boost::any(*joinEui);
    }
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (loraNodeType) {
      res["LoraNodeType"] = boost::any(*loraNodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DevEui") != m.end() && !m["DevEui"].empty()) {
      devEui = make_shared<string>(boost::any_cast<string>(m["DevEui"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
    if (m.find("PinCode") != m.end() && !m["PinCode"].empty()) {
      pinCode = make_shared<string>(boost::any_cast<string>(m["PinCode"]));
    }
    if (m.find("JoinEui") != m.end() && !m["JoinEui"].empty()) {
      joinEui = make_shared<string>(boost::any_cast<string>(m["JoinEui"]));
    }
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("LoraNodeType") != m.end() && !m["LoraNodeType"].empty()) {
      loraNodeType = make_shared<string>(boost::any_cast<string>(m["LoraNodeType"]));
    }
  }


  virtual ~RegisterDeviceRequest() = default;
};
class RegisterDeviceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> iotId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceSecret{};
  shared_ptr<string> devEui{};
  shared_ptr<string> joinEui{};
  shared_ptr<string> nickname{};

  RegisterDeviceResponseBodyData() {}

  explicit RegisterDeviceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceSecret) {
      res["DeviceSecret"] = boost::any(*deviceSecret);
    }
    if (devEui) {
      res["DevEui"] = boost::any(*devEui);
    }
    if (joinEui) {
      res["JoinEui"] = boost::any(*joinEui);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceSecret") != m.end() && !m["DeviceSecret"].empty()) {
      deviceSecret = make_shared<string>(boost::any_cast<string>(m["DeviceSecret"]));
    }
    if (m.find("DevEui") != m.end() && !m["DevEui"].empty()) {
      devEui = make_shared<string>(boost::any_cast<string>(m["DevEui"]));
    }
    if (m.find("JoinEui") != m.end() && !m["JoinEui"].empty()) {
      joinEui = make_shared<string>(boost::any_cast<string>(m["JoinEui"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
  }


  virtual ~RegisterDeviceResponseBodyData() = default;
};
class RegisterDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<RegisterDeviceResponseBodyData> data{};

  RegisterDeviceResponseBody() {}

  explicit RegisterDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        RegisterDeviceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<RegisterDeviceResponseBodyData>(model1);
      }
    }
  }


  virtual ~RegisterDeviceResponseBody() = default;
};
class RegisterDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RegisterDeviceResponseBody> body{};

  RegisterDeviceResponse() {}

  explicit RegisterDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RegisterDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RegisterDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~RegisterDeviceResponse() = default;
};
class ReleaseEdgeDriverVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};

  ReleaseEdgeDriverVersionRequest() {}

  explicit ReleaseEdgeDriverVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
  }


  virtual ~ReleaseEdgeDriverVersionRequest() = default;
};
class ReleaseEdgeDriverVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  ReleaseEdgeDriverVersionResponseBody() {}

  explicit ReleaseEdgeDriverVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~ReleaseEdgeDriverVersionResponseBody() = default;
};
class ReleaseEdgeDriverVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReleaseEdgeDriverVersionResponseBody> body{};

  ReleaseEdgeDriverVersionResponse() {}

  explicit ReleaseEdgeDriverVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseEdgeDriverVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseEdgeDriverVersionResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseEdgeDriverVersionResponse() = default;
};
class RemoveThingTopoRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};

  RemoveThingTopoRequest() {}

  explicit RemoveThingTopoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~RemoveThingTopoRequest() = default;
};
class RemoveThingTopoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> data{};

  RemoveThingTopoResponseBody() {}

  explicit RemoveThingTopoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~RemoveThingTopoResponseBody() = default;
};
class RemoveThingTopoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RemoveThingTopoResponseBody> body{};

  RemoveThingTopoResponse() {}

  explicit RemoveThingTopoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveThingTopoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveThingTopoResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveThingTopoResponse() = default;
};
class ReplaceEdgeInstanceGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> currentGatewayId{};
  shared_ptr<string> newGatewayId{};

  ReplaceEdgeInstanceGatewayRequest() {}

  explicit ReplaceEdgeInstanceGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (currentGatewayId) {
      res["CurrentGatewayId"] = boost::any(*currentGatewayId);
    }
    if (newGatewayId) {
      res["NewGatewayId"] = boost::any(*newGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("CurrentGatewayId") != m.end() && !m["CurrentGatewayId"].empty()) {
      currentGatewayId = make_shared<string>(boost::any_cast<string>(m["CurrentGatewayId"]));
    }
    if (m.find("NewGatewayId") != m.end() && !m["NewGatewayId"].empty()) {
      newGatewayId = make_shared<string>(boost::any_cast<string>(m["NewGatewayId"]));
    }
  }


  virtual ~ReplaceEdgeInstanceGatewayRequest() = default;
};
class ReplaceEdgeInstanceGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  ReplaceEdgeInstanceGatewayResponseBody() {}

  explicit ReplaceEdgeInstanceGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~ReplaceEdgeInstanceGatewayResponseBody() = default;
};
class ReplaceEdgeInstanceGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReplaceEdgeInstanceGatewayResponseBody> body{};

  ReplaceEdgeInstanceGatewayResponse() {}

  explicit ReplaceEdgeInstanceGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReplaceEdgeInstanceGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReplaceEdgeInstanceGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~ReplaceEdgeInstanceGatewayResponse() = default;
};
class ResetConsumerGroupPositionRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> groupId{};

  ResetConsumerGroupPositionRequest() {}

  explicit ResetConsumerGroupPositionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~ResetConsumerGroupPositionRequest() = default;
};
class ResetConsumerGroupPositionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};

  ResetConsumerGroupPositionResponseBody() {}

  explicit ResetConsumerGroupPositionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~ResetConsumerGroupPositionResponseBody() = default;
};
class ResetConsumerGroupPositionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ResetConsumerGroupPositionResponseBody> body{};

  ResetConsumerGroupPositionResponse() {}

  explicit ResetConsumerGroupPositionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetConsumerGroupPositionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetConsumerGroupPositionResponseBody>(model1);
      }
    }
  }


  virtual ~ResetConsumerGroupPositionResponse() = default;
};
class ResetThingRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};

  ResetThingRequest() {}

  explicit ResetThingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~ResetThingRequest() = default;
};
class ResetThingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  ResetThingResponseBody() {}

  explicit ResetThingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~ResetThingResponseBody() = default;
};
class ResetThingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ResetThingResponseBody> body{};

  ResetThingResponse() {}

  explicit ResetThingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetThingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetThingResponseBody>(model1);
      }
    }
  }


  virtual ~ResetThingResponse() = default;
};
class RRpcRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<long> timeout{};
  shared_ptr<string> requestBase64Byte{};
  shared_ptr<string> topic{};

  RRpcRequest() {}

  explicit RRpcRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (requestBase64Byte) {
      res["RequestBase64Byte"] = boost::any(*requestBase64Byte);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("RequestBase64Byte") != m.end() && !m["RequestBase64Byte"].empty()) {
      requestBase64Byte = make_shared<string>(boost::any_cast<string>(m["RequestBase64Byte"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~RRpcRequest() = default;
};
class RRpcResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> rrpcCode{};
  shared_ptr<string> payloadBase64Byte{};
  shared_ptr<long> messageId{};

  RRpcResponseBody() {}

  explicit RRpcResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (rrpcCode) {
      res["RrpcCode"] = boost::any(*rrpcCode);
    }
    if (payloadBase64Byte) {
      res["PayloadBase64Byte"] = boost::any(*payloadBase64Byte);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RrpcCode") != m.end() && !m["RrpcCode"].empty()) {
      rrpcCode = make_shared<string>(boost::any_cast<string>(m["RrpcCode"]));
    }
    if (m.find("PayloadBase64Byte") != m.end() && !m["PayloadBase64Byte"].empty()) {
      payloadBase64Byte = make_shared<string>(boost::any_cast<string>(m["PayloadBase64Byte"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<long>(boost::any_cast<long>(m["MessageId"]));
    }
  }


  virtual ~RRpcResponseBody() = default;
};
class RRpcResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RRpcResponseBody> body{};

  RRpcResponse() {}

  explicit RRpcResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RRpcResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RRpcResponseBody>(model1);
      }
    }
  }


  virtual ~RRpcResponse() = default;
};
class SaveDevicePropRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> props{};
  shared_ptr<string> iotId{};

  SaveDevicePropRequest() {}

  explicit SaveDevicePropRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (props) {
      res["Props"] = boost::any(*props);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Props") != m.end() && !m["Props"].empty()) {
      props = make_shared<string>(boost::any_cast<string>(m["Props"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~SaveDevicePropRequest() = default;
};
class SaveDevicePropResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  SaveDevicePropResponseBody() {}

  explicit SaveDevicePropResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~SaveDevicePropResponseBody() = default;
};
class SaveDevicePropResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SaveDevicePropResponseBody> body{};

  SaveDevicePropResponse() {}

  explicit SaveDevicePropResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveDevicePropResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveDevicePropResponseBody>(model1);
      }
    }
  }


  virtual ~SaveDevicePropResponse() = default;
};
class SetDeviceDesiredPropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> iotId{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> productKey{};
  shared_ptr<string> items{};
  shared_ptr<string> versions{};

  SetDeviceDesiredPropertyRequest() {}

  explicit SetDeviceDesiredPropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (items) {
      res["Items"] = boost::any(*items);
    }
    if (versions) {
      res["Versions"] = boost::any(*versions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      items = make_shared<string>(boost::any_cast<string>(m["Items"]));
    }
    if (m.find("Versions") != m.end() && !m["Versions"].empty()) {
      versions = make_shared<string>(boost::any_cast<string>(m["Versions"]));
    }
  }


  virtual ~SetDeviceDesiredPropertyRequest() = default;
};
class SetDeviceDesiredPropertyResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};
  shared_ptr<string> versions{};

  SetDeviceDesiredPropertyResponseBodyData() {}

  explicit SetDeviceDesiredPropertyResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (versions) {
      res["Versions"] = boost::any(*versions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("Versions") != m.end() && !m["Versions"].empty()) {
      versions = make_shared<string>(boost::any_cast<string>(m["Versions"]));
    }
  }


  virtual ~SetDeviceDesiredPropertyResponseBodyData() = default;
};
class SetDeviceDesiredPropertyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<SetDeviceDesiredPropertyResponseBodyData> data{};

  SetDeviceDesiredPropertyResponseBody() {}

  explicit SetDeviceDesiredPropertyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SetDeviceDesiredPropertyResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SetDeviceDesiredPropertyResponseBodyData>(model1);
      }
    }
  }


  virtual ~SetDeviceDesiredPropertyResponseBody() = default;
};
class SetDeviceDesiredPropertyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SetDeviceDesiredPropertyResponseBody> body{};

  SetDeviceDesiredPropertyResponse() {}

  explicit SetDeviceDesiredPropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDeviceDesiredPropertyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDeviceDesiredPropertyResponseBody>(model1);
      }
    }
  }


  virtual ~SetDeviceDesiredPropertyResponse() = default;
};
class SetDeviceGroupTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> tagString{};

  SetDeviceGroupTagsRequest() {}

  explicit SetDeviceGroupTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (tagString) {
      res["TagString"] = boost::any(*tagString);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("TagString") != m.end() && !m["TagString"].empty()) {
      tagString = make_shared<string>(boost::any_cast<string>(m["TagString"]));
    }
  }


  virtual ~SetDeviceGroupTagsRequest() = default;
};
class SetDeviceGroupTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  SetDeviceGroupTagsResponseBody() {}

  explicit SetDeviceGroupTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~SetDeviceGroupTagsResponseBody() = default;
};
class SetDeviceGroupTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SetDeviceGroupTagsResponseBody> body{};

  SetDeviceGroupTagsResponse() {}

  explicit SetDeviceGroupTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDeviceGroupTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDeviceGroupTagsResponseBody>(model1);
      }
    }
  }


  virtual ~SetDeviceGroupTagsResponse() = default;
};
class SetDevicePropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> items{};

  SetDevicePropertyRequest() {}

  explicit SetDevicePropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (items) {
      res["Items"] = boost::any(*items);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      items = make_shared<string>(boost::any_cast<string>(m["Items"]));
    }
  }


  virtual ~SetDevicePropertyRequest() = default;
};
class SetDevicePropertyResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};

  SetDevicePropertyResponseBodyData() {}

  explicit SetDevicePropertyResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~SetDevicePropertyResponseBodyData() = default;
};
class SetDevicePropertyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<SetDevicePropertyResponseBodyData> data{};

  SetDevicePropertyResponseBody() {}

  explicit SetDevicePropertyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SetDevicePropertyResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SetDevicePropertyResponseBodyData>(model1);
      }
    }
  }


  virtual ~SetDevicePropertyResponseBody() = default;
};
class SetDevicePropertyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SetDevicePropertyResponseBody> body{};

  SetDevicePropertyResponse() {}

  explicit SetDevicePropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDevicePropertyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDevicePropertyResponseBody>(model1);
      }
    }
  }


  virtual ~SetDevicePropertyResponse() = default;
};
class SetDevicesPropertyRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> items{};

  SetDevicesPropertyRequest() {}

  explicit SetDevicesPropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (items) {
      res["Items"] = boost::any(*items);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      items = make_shared<string>(boost::any_cast<string>(m["Items"]));
    }
  }


  virtual ~SetDevicesPropertyRequest() = default;
};
class SetDevicesPropertyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};

  SetDevicesPropertyResponseBody() {}

  explicit SetDevicesPropertyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~SetDevicesPropertyResponseBody() = default;
};
class SetDevicesPropertyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SetDevicesPropertyResponseBody> body{};

  SetDevicesPropertyResponse() {}

  explicit SetDevicesPropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDevicesPropertyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDevicesPropertyResponseBody>(model1);
      }
    }
  }


  virtual ~SetDevicesPropertyResponse() = default;
};
class SetEdgeInstanceDriverConfigsRequestConfigs : public Darabonba::Model {
public:
  shared_ptr<string> format{};
  shared_ptr<string> content{};
  shared_ptr<string> key{};

  SetEdgeInstanceDriverConfigsRequestConfigs() {}

  explicit SetEdgeInstanceDriverConfigsRequestConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~SetEdgeInstanceDriverConfigsRequestConfigs() = default;
};
class SetEdgeInstanceDriverConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<vector<SetEdgeInstanceDriverConfigsRequestConfigs>> configs{};

  SetEdgeInstanceDriverConfigsRequest() {}

  explicit SetEdgeInstanceDriverConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (configs) {
      vector<boost::any> temp1;
      for(auto item1:*configs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Configs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("Configs") != m.end() && !m["Configs"].empty()) {
      if (typeid(vector<boost::any>) == m["Configs"].type()) {
        vector<SetEdgeInstanceDriverConfigsRequestConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Configs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SetEdgeInstanceDriverConfigsRequestConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configs = make_shared<vector<SetEdgeInstanceDriverConfigsRequestConfigs>>(expect1);
      }
    }
  }


  virtual ~SetEdgeInstanceDriverConfigsRequest() = default;
};
class SetEdgeInstanceDriverConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  SetEdgeInstanceDriverConfigsResponseBody() {}

  explicit SetEdgeInstanceDriverConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~SetEdgeInstanceDriverConfigsResponseBody() = default;
};
class SetEdgeInstanceDriverConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SetEdgeInstanceDriverConfigsResponseBody> body{};

  SetEdgeInstanceDriverConfigsResponse() {}

  explicit SetEdgeInstanceDriverConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetEdgeInstanceDriverConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetEdgeInstanceDriverConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~SetEdgeInstanceDriverConfigsResponse() = default;
};
class SetProductCertInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<long> issueModel{};

  SetProductCertInfoRequest() {}

  explicit SetProductCertInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (issueModel) {
      res["IssueModel"] = boost::any(*issueModel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("IssueModel") != m.end() && !m["IssueModel"].empty()) {
      issueModel = make_shared<long>(boost::any_cast<long>(m["IssueModel"]));
    }
  }


  virtual ~SetProductCertInfoRequest() = default;
};
class SetProductCertInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  SetProductCertInfoResponseBody() {}

  explicit SetProductCertInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~SetProductCertInfoResponseBody() = default;
};
class SetProductCertInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SetProductCertInfoResponseBody> body{};

  SetProductCertInfoResponse() {}

  explicit SetProductCertInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetProductCertInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetProductCertInfoResponseBody>(model1);
      }
    }
  }


  virtual ~SetProductCertInfoResponse() = default;
};
class SpeechByCombinationRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> combinationList{};
  shared_ptr<string> iotId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotInstanceId{};

  SpeechByCombinationRequest() {}

  explicit SpeechByCombinationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (combinationList) {
      res["CombinationList"] = boost::any(*combinationList);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CombinationList") != m.end() && !m["CombinationList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CombinationList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CombinationList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      combinationList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~SpeechByCombinationRequest() = default;
};
class SpeechByCombinationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  SpeechByCombinationResponseBody() {}

  explicit SpeechByCombinationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~SpeechByCombinationResponseBody() = default;
};
class SpeechByCombinationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SpeechByCombinationResponseBody> body{};

  SpeechByCombinationResponse() {}

  explicit SpeechByCombinationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SpeechByCombinationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SpeechByCombinationResponseBody>(model1);
      }
    }
  }


  virtual ~SpeechByCombinationResponse() = default;
};
class StartCpuRequest : public Darabonba::Model {
public:
  shared_ptr<string> targetValue{};
  shared_ptr<string> iotId{};
  shared_ptr<string> iotInstanceId{};

  StartCpuRequest() {}

  explicit StartCpuRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetValue) {
      res["TargetValue"] = boost::any(*targetValue);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetValue") != m.end() && !m["TargetValue"].empty()) {
      targetValue = make_shared<string>(boost::any_cast<string>(m["TargetValue"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~StartCpuRequest() = default;
};
class StartCpuResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> timeZone{};
  shared_ptr<string> iotInstanceId{};

  StartCpuResponseBodyData() {}

  explicit StartCpuResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~StartCpuResponseBodyData() = default;
};
class StartCpuResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<StartCpuResponseBodyData> data{};

  StartCpuResponseBody() {}

  explicit StartCpuResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        StartCpuResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<StartCpuResponseBodyData>(model1);
      }
    }
  }


  virtual ~StartCpuResponseBody() = default;
};
class StartCpuResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StartCpuResponseBody> body{};

  StartCpuResponse() {}

  explicit StartCpuResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartCpuResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartCpuResponseBody>(model1);
      }
    }
  }


  virtual ~StartCpuResponse() = default;
};
class StartRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> ruleId{};

  StartRuleRequest() {}

  explicit StartRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~StartRuleRequest() = default;
};
class StartRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  StartRuleResponseBody() {}

  explicit StartRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~StartRuleResponseBody() = default;
};
class StartRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StartRuleResponseBody> body{};

  StartRuleResponse() {}

  explicit StartRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartRuleResponseBody>(model1);
      }
    }
  }


  virtual ~StartRuleResponse() = default;
};
class StopRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> ruleId{};

  StopRuleRequest() {}

  explicit StopRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~StopRuleRequest() = default;
};
class StopRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  StopRuleResponseBody() {}

  explicit StopRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~StopRuleResponseBody() = default;
};
class StopRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StopRuleResponseBody> body{};

  StopRuleResponse() {}

  explicit StopRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopRuleResponseBody>(model1);
      }
    }
  }


  virtual ~StopRuleResponse() = default;
};
class SyncSpeechByCombinationRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> combinationList{};
  shared_ptr<string> iotId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotInstanceId{};

  SyncSpeechByCombinationRequest() {}

  explicit SyncSpeechByCombinationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (combinationList) {
      res["CombinationList"] = boost::any(*combinationList);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CombinationList") != m.end() && !m["CombinationList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CombinationList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CombinationList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      combinationList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~SyncSpeechByCombinationRequest() = default;
};
class SyncSpeechByCombinationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> retryCount{};

  SyncSpeechByCombinationResponseBodyData() {}

  explicit SyncSpeechByCombinationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<long>(boost::any_cast<long>(m["RetryCount"]));
    }
  }


  virtual ~SyncSpeechByCombinationResponseBodyData() = default;
};
class SyncSpeechByCombinationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<SyncSpeechByCombinationResponseBodyData> data{};

  SyncSpeechByCombinationResponseBody() {}

  explicit SyncSpeechByCombinationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SyncSpeechByCombinationResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SyncSpeechByCombinationResponseBodyData>(model1);
      }
    }
  }


  virtual ~SyncSpeechByCombinationResponseBody() = default;
};
class SyncSpeechByCombinationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SyncSpeechByCombinationResponseBody> body{};

  SyncSpeechByCombinationResponse() {}

  explicit SyncSpeechByCombinationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SyncSpeechByCombinationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SyncSpeechByCombinationResponseBody>(model1);
      }
    }
  }


  virtual ~SyncSpeechByCombinationResponse() = default;
};
class TriggerSceneRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> instanceId{};

  TriggerSceneRuleRequest() {}

  explicit TriggerSceneRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~TriggerSceneRuleRequest() = default;
};
class TriggerSceneRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};

  TriggerSceneRuleResponseBody() {}

  explicit TriggerSceneRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~TriggerSceneRuleResponseBody() = default;
};
class TriggerSceneRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<TriggerSceneRuleResponseBody> body{};

  TriggerSceneRuleResponse() {}

  explicit TriggerSceneRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TriggerSceneRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TriggerSceneRuleResponseBody>(model1);
      }
    }
  }


  virtual ~TriggerSceneRuleResponse() = default;
};
class UnbindApplicationFromEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> applicationId{};

  UnbindApplicationFromEdgeInstanceRequest() {}

  explicit UnbindApplicationFromEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
  }


  virtual ~UnbindApplicationFromEdgeInstanceRequest() = default;
};
class UnbindApplicationFromEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UnbindApplicationFromEdgeInstanceResponseBody() {}

  explicit UnbindApplicationFromEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UnbindApplicationFromEdgeInstanceResponseBody() = default;
};
class UnbindApplicationFromEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UnbindApplicationFromEdgeInstanceResponseBody> body{};

  UnbindApplicationFromEdgeInstanceResponse() {}

  explicit UnbindApplicationFromEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindApplicationFromEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindApplicationFromEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindApplicationFromEdgeInstanceResponse() = default;
};
class UnbindDriverFromEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> driverId{};

  UnbindDriverFromEdgeInstanceRequest() {}

  explicit UnbindDriverFromEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
  }


  virtual ~UnbindDriverFromEdgeInstanceRequest() = default;
};
class UnbindDriverFromEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UnbindDriverFromEdgeInstanceResponseBody() {}

  explicit UnbindDriverFromEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UnbindDriverFromEdgeInstanceResponseBody() = default;
};
class UnbindDriverFromEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UnbindDriverFromEdgeInstanceResponseBody> body{};

  UnbindDriverFromEdgeInstanceResponse() {}

  explicit UnbindDriverFromEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindDriverFromEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindDriverFromEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindDriverFromEdgeInstanceResponse() = default;
};
class UnbindRoleFromEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};

  UnbindRoleFromEdgeInstanceRequest() {}

  explicit UnbindRoleFromEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~UnbindRoleFromEdgeInstanceRequest() = default;
};
class UnbindRoleFromEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UnbindRoleFromEdgeInstanceResponseBody() {}

  explicit UnbindRoleFromEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UnbindRoleFromEdgeInstanceResponseBody() = default;
};
class UnbindRoleFromEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UnbindRoleFromEdgeInstanceResponseBody> body{};

  UnbindRoleFromEdgeInstanceResponse() {}

  explicit UnbindRoleFromEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindRoleFromEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindRoleFromEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindRoleFromEdgeInstanceResponse() = default;
};
class UnbindSceneRuleFromEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ruleId{};

  UnbindSceneRuleFromEdgeInstanceRequest() {}

  explicit UnbindSceneRuleFromEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~UnbindSceneRuleFromEdgeInstanceRequest() = default;
};
class UnbindSceneRuleFromEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UnbindSceneRuleFromEdgeInstanceResponseBody() {}

  explicit UnbindSceneRuleFromEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UnbindSceneRuleFromEdgeInstanceResponseBody() = default;
};
class UnbindSceneRuleFromEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UnbindSceneRuleFromEdgeInstanceResponseBody> body{};

  UnbindSceneRuleFromEdgeInstanceResponse() {}

  explicit UnbindSceneRuleFromEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindSceneRuleFromEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindSceneRuleFromEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindSceneRuleFromEdgeInstanceResponse() = default;
};
class UpdateConsumerGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> newGroupName{};
  shared_ptr<string> groupId{};

  UpdateConsumerGroupRequest() {}

  explicit UpdateConsumerGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (newGroupName) {
      res["NewGroupName"] = boost::any(*newGroupName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("NewGroupName") != m.end() && !m["NewGroupName"].empty()) {
      newGroupName = make_shared<string>(boost::any_cast<string>(m["NewGroupName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~UpdateConsumerGroupRequest() = default;
};
class UpdateConsumerGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};

  UpdateConsumerGroupResponseBody() {}

  explicit UpdateConsumerGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~UpdateConsumerGroupResponseBody() = default;
};
class UpdateConsumerGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateConsumerGroupResponseBody> body{};

  UpdateConsumerGroupResponse() {}

  explicit UpdateConsumerGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateConsumerGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateConsumerGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateConsumerGroupResponse() = default;
};
class UpdateDeviceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupDesc{};

  UpdateDeviceGroupRequest() {}

  explicit UpdateDeviceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupDesc) {
      res["GroupDesc"] = boost::any(*groupDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupDesc") != m.end() && !m["GroupDesc"].empty()) {
      groupDesc = make_shared<string>(boost::any_cast<string>(m["GroupDesc"]));
    }
  }


  virtual ~UpdateDeviceGroupRequest() = default;
};
class UpdateDeviceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateDeviceGroupResponseBody() {}

  explicit UpdateDeviceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateDeviceGroupResponseBody() = default;
};
class UpdateDeviceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateDeviceGroupResponseBody> body{};

  UpdateDeviceGroupResponse() {}

  explicit UpdateDeviceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDeviceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDeviceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDeviceGroupResponse() = default;
};
class UpdateDeviceShadowRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> shadowMessage{};
  shared_ptr<bool> deltaUpdate{};

  UpdateDeviceShadowRequest() {}

  explicit UpdateDeviceShadowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (shadowMessage) {
      res["ShadowMessage"] = boost::any(*shadowMessage);
    }
    if (deltaUpdate) {
      res["DeltaUpdate"] = boost::any(*deltaUpdate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("ShadowMessage") != m.end() && !m["ShadowMessage"].empty()) {
      shadowMessage = make_shared<string>(boost::any_cast<string>(m["ShadowMessage"]));
    }
    if (m.find("DeltaUpdate") != m.end() && !m["DeltaUpdate"].empty()) {
      deltaUpdate = make_shared<bool>(boost::any_cast<bool>(m["DeltaUpdate"]));
    }
  }


  virtual ~UpdateDeviceShadowRequest() = default;
};
class UpdateDeviceShadowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateDeviceShadowResponseBody() {}

  explicit UpdateDeviceShadowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateDeviceShadowResponseBody() = default;
};
class UpdateDeviceShadowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateDeviceShadowResponseBody> body{};

  UpdateDeviceShadowResponse() {}

  explicit UpdateDeviceShadowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDeviceShadowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDeviceShadowResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDeviceShadowResponse() = default;
};
class UpdateEdgeDriverVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};
  shared_ptr<string> edgeVersion{};
  shared_ptr<string> description{};
  shared_ptr<string> sourceConfig{};
  shared_ptr<string> driverConfig{};
  shared_ptr<string> containerConfig{};
  shared_ptr<string> configCheckRule{};
  shared_ptr<string> argument{};

  UpdateEdgeDriverVersionRequest() {}

  explicit UpdateEdgeDriverVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    if (edgeVersion) {
      res["EdgeVersion"] = boost::any(*edgeVersion);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (sourceConfig) {
      res["SourceConfig"] = boost::any(*sourceConfig);
    }
    if (driverConfig) {
      res["DriverConfig"] = boost::any(*driverConfig);
    }
    if (containerConfig) {
      res["ContainerConfig"] = boost::any(*containerConfig);
    }
    if (configCheckRule) {
      res["ConfigCheckRule"] = boost::any(*configCheckRule);
    }
    if (argument) {
      res["Argument"] = boost::any(*argument);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
    if (m.find("EdgeVersion") != m.end() && !m["EdgeVersion"].empty()) {
      edgeVersion = make_shared<string>(boost::any_cast<string>(m["EdgeVersion"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SourceConfig") != m.end() && !m["SourceConfig"].empty()) {
      sourceConfig = make_shared<string>(boost::any_cast<string>(m["SourceConfig"]));
    }
    if (m.find("DriverConfig") != m.end() && !m["DriverConfig"].empty()) {
      driverConfig = make_shared<string>(boost::any_cast<string>(m["DriverConfig"]));
    }
    if (m.find("ContainerConfig") != m.end() && !m["ContainerConfig"].empty()) {
      containerConfig = make_shared<string>(boost::any_cast<string>(m["ContainerConfig"]));
    }
    if (m.find("ConfigCheckRule") != m.end() && !m["ConfigCheckRule"].empty()) {
      configCheckRule = make_shared<string>(boost::any_cast<string>(m["ConfigCheckRule"]));
    }
    if (m.find("Argument") != m.end() && !m["Argument"].empty()) {
      argument = make_shared<string>(boost::any_cast<string>(m["Argument"]));
    }
  }


  virtual ~UpdateEdgeDriverVersionRequest() = default;
};
class UpdateEdgeDriverVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateEdgeDriverVersionResponseBody() {}

  explicit UpdateEdgeDriverVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateEdgeDriverVersionResponseBody() = default;
};
class UpdateEdgeDriverVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateEdgeDriverVersionResponseBody> body{};

  UpdateEdgeDriverVersionResponse() {}

  explicit UpdateEdgeDriverVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateEdgeDriverVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateEdgeDriverVersionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateEdgeDriverVersionResponse() = default;
};
class UpdateEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> tags{};
  shared_ptr<long> spec{};
  shared_ptr<bool> bizEnable{};

  UpdateEdgeInstanceRequest() {}

  explicit UpdateEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (bizEnable) {
      res["BizEnable"] = boost::any(*bizEnable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<long>(boost::any_cast<long>(m["Spec"]));
    }
    if (m.find("BizEnable") != m.end() && !m["BizEnable"].empty()) {
      bizEnable = make_shared<bool>(boost::any_cast<bool>(m["BizEnable"]));
    }
  }


  virtual ~UpdateEdgeInstanceRequest() = default;
};
class UpdateEdgeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateEdgeInstanceResponseBody() {}

  explicit UpdateEdgeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateEdgeInstanceResponseBody() = default;
};
class UpdateEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateEdgeInstanceResponseBody> body{};

  UpdateEdgeInstanceResponse() {}

  explicit UpdateEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateEdgeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateEdgeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateEdgeInstanceResponse() = default;
};
class UpdateEdgeInstanceChannelRequestConfigs : public Darabonba::Model {
public:
  shared_ptr<string> format{};
  shared_ptr<string> content{};
  shared_ptr<string> key{};

  UpdateEdgeInstanceChannelRequestConfigs() {}

  explicit UpdateEdgeInstanceChannelRequestConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~UpdateEdgeInstanceChannelRequestConfigs() = default;
};
class UpdateEdgeInstanceChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelName{};
  shared_ptr<vector<UpdateEdgeInstanceChannelRequestConfigs>> configs{};

  UpdateEdgeInstanceChannelRequest() {}

  explicit UpdateEdgeInstanceChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (configs) {
      vector<boost::any> temp1;
      for(auto item1:*configs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Configs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("Configs") != m.end() && !m["Configs"].empty()) {
      if (typeid(vector<boost::any>) == m["Configs"].type()) {
        vector<UpdateEdgeInstanceChannelRequestConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Configs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateEdgeInstanceChannelRequestConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configs = make_shared<vector<UpdateEdgeInstanceChannelRequestConfigs>>(expect1);
      }
    }
  }


  virtual ~UpdateEdgeInstanceChannelRequest() = default;
};
class UpdateEdgeInstanceChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateEdgeInstanceChannelResponseBody() {}

  explicit UpdateEdgeInstanceChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateEdgeInstanceChannelResponseBody() = default;
};
class UpdateEdgeInstanceChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateEdgeInstanceChannelResponseBody> body{};

  UpdateEdgeInstanceChannelResponse() {}

  explicit UpdateEdgeInstanceChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateEdgeInstanceChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateEdgeInstanceChannelResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateEdgeInstanceChannelResponse() = default;
};
class UpdateEdgeInstanceMessageRoutingRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> routeId{};
  shared_ptr<string> name{};
  shared_ptr<string> topicFilter{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> sourceData{};
  shared_ptr<string> targetType{};
  shared_ptr<string> targetData{};
  shared_ptr<long> targetIotHubQos{};

  UpdateEdgeInstanceMessageRoutingRequest() {}

  explicit UpdateEdgeInstanceMessageRoutingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (topicFilter) {
      res["TopicFilter"] = boost::any(*topicFilter);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (sourceData) {
      res["SourceData"] = boost::any(*sourceData);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (targetData) {
      res["TargetData"] = boost::any(*targetData);
    }
    if (targetIotHubQos) {
      res["TargetIotHubQos"] = boost::any(*targetIotHubQos);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<long>(boost::any_cast<long>(m["RouteId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TopicFilter") != m.end() && !m["TopicFilter"].empty()) {
      topicFilter = make_shared<string>(boost::any_cast<string>(m["TopicFilter"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("SourceData") != m.end() && !m["SourceData"].empty()) {
      sourceData = make_shared<string>(boost::any_cast<string>(m["SourceData"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("TargetData") != m.end() && !m["TargetData"].empty()) {
      targetData = make_shared<string>(boost::any_cast<string>(m["TargetData"]));
    }
    if (m.find("TargetIotHubQos") != m.end() && !m["TargetIotHubQos"].empty()) {
      targetIotHubQos = make_shared<long>(boost::any_cast<long>(m["TargetIotHubQos"]));
    }
  }


  virtual ~UpdateEdgeInstanceMessageRoutingRequest() = default;
};
class UpdateEdgeInstanceMessageRoutingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateEdgeInstanceMessageRoutingResponseBody() {}

  explicit UpdateEdgeInstanceMessageRoutingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateEdgeInstanceMessageRoutingResponseBody() = default;
};
class UpdateEdgeInstanceMessageRoutingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateEdgeInstanceMessageRoutingResponseBody> body{};

  UpdateEdgeInstanceMessageRoutingResponse() {}

  explicit UpdateEdgeInstanceMessageRoutingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateEdgeInstanceMessageRoutingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateEdgeInstanceMessageRoutingResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateEdgeInstanceMessageRoutingResponse() = default;
};
class UpdateJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> description{};
  shared_ptr<string> timeoutConfig{};
  shared_ptr<string> rolloutConfig{};
  shared_ptr<string> jobId{};

  UpdateJobRequest() {}

  explicit UpdateJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (timeoutConfig) {
      res["TimeoutConfig"] = boost::any(*timeoutConfig);
    }
    if (rolloutConfig) {
      res["RolloutConfig"] = boost::any(*rolloutConfig);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("TimeoutConfig") != m.end() && !m["TimeoutConfig"].empty()) {
      timeoutConfig = make_shared<string>(boost::any_cast<string>(m["TimeoutConfig"]));
    }
    if (m.find("RolloutConfig") != m.end() && !m["RolloutConfig"].empty()) {
      rolloutConfig = make_shared<string>(boost::any_cast<string>(m["RolloutConfig"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~UpdateJobRequest() = default;
};
class UpdateJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateJobResponseBody() {}

  explicit UpdateJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateJobResponseBody() = default;
};
class UpdateJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateJobResponseBody> body{};

  UpdateJobResponse() {}

  explicit UpdateJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateJobResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateJobResponse() = default;
};
class UpdateOTAModuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> moduleName{};
  shared_ptr<string> desc{};
  shared_ptr<string> productKey{};

  UpdateOTAModuleRequest() {}

  explicit UpdateOTAModuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~UpdateOTAModuleRequest() = default;
};
class UpdateOTAModuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateOTAModuleResponseBody() {}

  explicit UpdateOTAModuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateOTAModuleResponseBody() = default;
};
class UpdateOTAModuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateOTAModuleResponseBody> body{};

  UpdateOTAModuleResponse() {}

  explicit UpdateOTAModuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateOTAModuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateOTAModuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateOTAModuleResponse() = default;
};
class UpdateProductRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> description{};
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};

  UpdateProductRequest() {}

  explicit UpdateProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
  }


  virtual ~UpdateProductRequest() = default;
};
class UpdateProductResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateProductResponseBody() {}

  explicit UpdateProductResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateProductResponseBody() = default;
};
class UpdateProductResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateProductResponseBody> body{};

  UpdateProductResponse() {}

  explicit UpdateProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateProductResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateProductResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateProductResponse() = default;
};
class UpdateProductFilterConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<bool> propertyTimestampFilter{};
  shared_ptr<bool> propertyValueFilter{};

  UpdateProductFilterConfigRequest() {}

  explicit UpdateProductFilterConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (propertyTimestampFilter) {
      res["PropertyTimestampFilter"] = boost::any(*propertyTimestampFilter);
    }
    if (propertyValueFilter) {
      res["PropertyValueFilter"] = boost::any(*propertyValueFilter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("PropertyTimestampFilter") != m.end() && !m["PropertyTimestampFilter"].empty()) {
      propertyTimestampFilter = make_shared<bool>(boost::any_cast<bool>(m["PropertyTimestampFilter"]));
    }
    if (m.find("PropertyValueFilter") != m.end() && !m["PropertyValueFilter"].empty()) {
      propertyValueFilter = make_shared<bool>(boost::any_cast<bool>(m["PropertyValueFilter"]));
    }
  }


  virtual ~UpdateProductFilterConfigRequest() = default;
};
class UpdateProductFilterConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateProductFilterConfigResponseBody() {}

  explicit UpdateProductFilterConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateProductFilterConfigResponseBody() = default;
};
class UpdateProductFilterConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateProductFilterConfigResponseBody> body{};

  UpdateProductFilterConfigResponse() {}

  explicit UpdateProductFilterConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateProductFilterConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateProductFilterConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateProductFilterConfigResponse() = default;
};
class UpdateProductTagsRequestProductTag : public Darabonba::Model {
public:
  shared_ptr<string> tagValue{};
  shared_ptr<string> tagKey{};

  UpdateProductTagsRequestProductTag() {}

  explicit UpdateProductTagsRequestProductTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~UpdateProductTagsRequestProductTag() = default;
};
class UpdateProductTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<vector<UpdateProductTagsRequestProductTag>> productTag{};

  UpdateProductTagsRequest() {}

  explicit UpdateProductTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productTag) {
      vector<boost::any> temp1;
      for(auto item1:*productTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProductTag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductTag") != m.end() && !m["ProductTag"].empty()) {
      if (typeid(vector<boost::any>) == m["ProductTag"].type()) {
        vector<UpdateProductTagsRequestProductTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProductTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateProductTagsRequestProductTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        productTag = make_shared<vector<UpdateProductTagsRequestProductTag>>(expect1);
      }
    }
  }


  virtual ~UpdateProductTagsRequest() = default;
};
class UpdateProductTagsResponseBodyInvalidProductTagsProductTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  UpdateProductTagsResponseBodyInvalidProductTagsProductTag() {}

  explicit UpdateProductTagsResponseBodyInvalidProductTagsProductTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~UpdateProductTagsResponseBodyInvalidProductTagsProductTag() = default;
};
class UpdateProductTagsResponseBodyInvalidProductTags : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateProductTagsResponseBodyInvalidProductTagsProductTag>> productTag{};

  UpdateProductTagsResponseBodyInvalidProductTags() {}

  explicit UpdateProductTagsResponseBodyInvalidProductTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productTag) {
      vector<boost::any> temp1;
      for(auto item1:*productTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProductTag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductTag") != m.end() && !m["ProductTag"].empty()) {
      if (typeid(vector<boost::any>) == m["ProductTag"].type()) {
        vector<UpdateProductTagsResponseBodyInvalidProductTagsProductTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProductTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateProductTagsResponseBodyInvalidProductTagsProductTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        productTag = make_shared<vector<UpdateProductTagsResponseBodyInvalidProductTagsProductTag>>(expect1);
      }
    }
  }


  virtual ~UpdateProductTagsResponseBodyInvalidProductTags() = default;
};
class UpdateProductTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<UpdateProductTagsResponseBodyInvalidProductTags> invalidProductTags{};

  UpdateProductTagsResponseBody() {}

  explicit UpdateProductTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (invalidProductTags) {
      res["InvalidProductTags"] = invalidProductTags ? boost::any(invalidProductTags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("InvalidProductTags") != m.end() && !m["InvalidProductTags"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvalidProductTags"].type()) {
        UpdateProductTagsResponseBodyInvalidProductTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvalidProductTags"]));
        invalidProductTags = make_shared<UpdateProductTagsResponseBodyInvalidProductTags>(model1);
      }
    }
  }


  virtual ~UpdateProductTagsResponseBody() = default;
};
class UpdateProductTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateProductTagsResponseBody> body{};

  UpdateProductTagsResponse() {}

  explicit UpdateProductTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateProductTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateProductTagsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateProductTagsResponse() = default;
};
class UpdateProductTopicRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> desc{};
  shared_ptr<string> operation{};
  shared_ptr<string> topicShortName{};
  shared_ptr<string> topicId{};

  UpdateProductTopicRequest() {}

  explicit UpdateProductTopicRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (topicShortName) {
      res["TopicShortName"] = boost::any(*topicShortName);
    }
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("TopicShortName") != m.end() && !m["TopicShortName"].empty()) {
      topicShortName = make_shared<string>(boost::any_cast<string>(m["TopicShortName"]));
    }
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<string>(boost::any_cast<string>(m["TopicId"]));
    }
  }


  virtual ~UpdateProductTopicRequest() = default;
};
class UpdateProductTopicResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateProductTopicResponseBody() {}

  explicit UpdateProductTopicResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateProductTopicResponseBody() = default;
};
class UpdateProductTopicResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateProductTopicResponseBody> body{};

  UpdateProductTopicResponse() {}

  explicit UpdateProductTopicResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateProductTopicResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateProductTopicResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateProductTopicResponse() = default;
};
class UpdateRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> select{};
  shared_ptr<string> shortTopic{};
  shared_ptr<string> where{};
  shared_ptr<string> productKey{};
  shared_ptr<string> name{};
  shared_ptr<string> ruleDesc{};
  shared_ptr<long> topicType{};
  shared_ptr<string> topic{};

  UpdateRuleRequest() {}

  explicit UpdateRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (select) {
      res["Select"] = boost::any(*select);
    }
    if (shortTopic) {
      res["ShortTopic"] = boost::any(*shortTopic);
    }
    if (where) {
      res["Where"] = boost::any(*where);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ruleDesc) {
      res["RuleDesc"] = boost::any(*ruleDesc);
    }
    if (topicType) {
      res["TopicType"] = boost::any(*topicType);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("Select") != m.end() && !m["Select"].empty()) {
      select = make_shared<string>(boost::any_cast<string>(m["Select"]));
    }
    if (m.find("ShortTopic") != m.end() && !m["ShortTopic"].empty()) {
      shortTopic = make_shared<string>(boost::any_cast<string>(m["ShortTopic"]));
    }
    if (m.find("Where") != m.end() && !m["Where"].empty()) {
      where = make_shared<string>(boost::any_cast<string>(m["Where"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RuleDesc") != m.end() && !m["RuleDesc"].empty()) {
      ruleDesc = make_shared<string>(boost::any_cast<string>(m["RuleDesc"]));
    }
    if (m.find("TopicType") != m.end() && !m["TopicType"].empty()) {
      topicType = make_shared<long>(boost::any_cast<long>(m["TopicType"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~UpdateRuleRequest() = default;
};
class UpdateRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateRuleResponseBody() {}

  explicit UpdateRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateRuleResponseBody() = default;
};
class UpdateRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateRuleResponseBody> body{};

  UpdateRuleResponse() {}

  explicit UpdateRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateRuleResponse() = default;
};
class UpdateRuleActionRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> actionId{};
  shared_ptr<string> type{};
  shared_ptr<string> configuration{};

  UpdateRuleActionRequest() {}

  explicit UpdateRuleActionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (actionId) {
      res["ActionId"] = boost::any(*actionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (configuration) {
      res["Configuration"] = boost::any(*configuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ActionId") != m.end() && !m["ActionId"].empty()) {
      actionId = make_shared<long>(boost::any_cast<long>(m["ActionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configuration = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
  }


  virtual ~UpdateRuleActionRequest() = default;
};
class UpdateRuleActionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};

  UpdateRuleActionResponseBody() {}

  explicit UpdateRuleActionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateRuleActionResponseBody() = default;
};
class UpdateRuleActionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateRuleActionResponseBody> body{};

  UpdateRuleActionResponse() {}

  explicit UpdateRuleActionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateRuleActionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateRuleActionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateRuleActionResponse() = default;
};
class UpdateSceneRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleContent{};
  shared_ptr<string> ruleDescription{};

  UpdateSceneRuleRequest() {}

  explicit UpdateSceneRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleContent) {
      res["RuleContent"] = boost::any(*ruleContent);
    }
    if (ruleDescription) {
      res["RuleDescription"] = boost::any(*ruleDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleContent") != m.end() && !m["RuleContent"].empty()) {
      ruleContent = make_shared<string>(boost::any_cast<string>(m["RuleContent"]));
    }
    if (m.find("RuleDescription") != m.end() && !m["RuleDescription"].empty()) {
      ruleDescription = make_shared<string>(boost::any_cast<string>(m["RuleDescription"]));
    }
  }


  virtual ~UpdateSceneRuleRequest() = default;
};
class UpdateSceneRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateSceneRuleResponseBody() {}

  explicit UpdateSceneRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateSceneRuleResponseBody() = default;
};
class UpdateSceneRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateSceneRuleResponseBody> body{};

  UpdateSceneRuleResponse() {}

  explicit UpdateSceneRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSceneRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSceneRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSceneRuleResponse() = default;
};
class UpdateSubscribeRelationRequest : public Darabonba::Model {
public:
  shared_ptr<bool> deviceStatusChangeFlag{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<bool> thingHistoryFlag{};
  shared_ptr<string> productKey{};
  shared_ptr<string> type{};
  shared_ptr<bool> deviceDataFlag{};
  shared_ptr<vector<string>> consumerGroupIds{};
  shared_ptr<bool> deviceTopoLifeCycleFlag{};
  shared_ptr<bool> foundDeviceListFlag{};
  shared_ptr<bool> otaEventFlag{};
  shared_ptr<bool> deviceLifeCycleFlag{};
  shared_ptr<string> mnsConfiguration{};
  shared_ptr<bool> deviceTagFlag{};
  shared_ptr<bool> otaVersionFlag{};
  shared_ptr<bool> otaJobFlag{};

  UpdateSubscribeRelationRequest() {}

  explicit UpdateSubscribeRelationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceStatusChangeFlag) {
      res["DeviceStatusChangeFlag"] = boost::any(*deviceStatusChangeFlag);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (thingHistoryFlag) {
      res["ThingHistoryFlag"] = boost::any(*thingHistoryFlag);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (deviceDataFlag) {
      res["DeviceDataFlag"] = boost::any(*deviceDataFlag);
    }
    if (consumerGroupIds) {
      res["ConsumerGroupIds"] = boost::any(*consumerGroupIds);
    }
    if (deviceTopoLifeCycleFlag) {
      res["DeviceTopoLifeCycleFlag"] = boost::any(*deviceTopoLifeCycleFlag);
    }
    if (foundDeviceListFlag) {
      res["FoundDeviceListFlag"] = boost::any(*foundDeviceListFlag);
    }
    if (otaEventFlag) {
      res["OtaEventFlag"] = boost::any(*otaEventFlag);
    }
    if (deviceLifeCycleFlag) {
      res["DeviceLifeCycleFlag"] = boost::any(*deviceLifeCycleFlag);
    }
    if (mnsConfiguration) {
      res["MnsConfiguration"] = boost::any(*mnsConfiguration);
    }
    if (deviceTagFlag) {
      res["DeviceTagFlag"] = boost::any(*deviceTagFlag);
    }
    if (otaVersionFlag) {
      res["OtaVersionFlag"] = boost::any(*otaVersionFlag);
    }
    if (otaJobFlag) {
      res["OtaJobFlag"] = boost::any(*otaJobFlag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceStatusChangeFlag") != m.end() && !m["DeviceStatusChangeFlag"].empty()) {
      deviceStatusChangeFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceStatusChangeFlag"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ThingHistoryFlag") != m.end() && !m["ThingHistoryFlag"].empty()) {
      thingHistoryFlag = make_shared<bool>(boost::any_cast<bool>(m["ThingHistoryFlag"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("DeviceDataFlag") != m.end() && !m["DeviceDataFlag"].empty()) {
      deviceDataFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceDataFlag"]));
    }
    if (m.find("ConsumerGroupIds") != m.end() && !m["ConsumerGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ConsumerGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ConsumerGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      consumerGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DeviceTopoLifeCycleFlag") != m.end() && !m["DeviceTopoLifeCycleFlag"].empty()) {
      deviceTopoLifeCycleFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceTopoLifeCycleFlag"]));
    }
    if (m.find("FoundDeviceListFlag") != m.end() && !m["FoundDeviceListFlag"].empty()) {
      foundDeviceListFlag = make_shared<bool>(boost::any_cast<bool>(m["FoundDeviceListFlag"]));
    }
    if (m.find("OtaEventFlag") != m.end() && !m["OtaEventFlag"].empty()) {
      otaEventFlag = make_shared<bool>(boost::any_cast<bool>(m["OtaEventFlag"]));
    }
    if (m.find("DeviceLifeCycleFlag") != m.end() && !m["DeviceLifeCycleFlag"].empty()) {
      deviceLifeCycleFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceLifeCycleFlag"]));
    }
    if (m.find("MnsConfiguration") != m.end() && !m["MnsConfiguration"].empty()) {
      mnsConfiguration = make_shared<string>(boost::any_cast<string>(m["MnsConfiguration"]));
    }
    if (m.find("DeviceTagFlag") != m.end() && !m["DeviceTagFlag"].empty()) {
      deviceTagFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceTagFlag"]));
    }
    if (m.find("OtaVersionFlag") != m.end() && !m["OtaVersionFlag"].empty()) {
      otaVersionFlag = make_shared<bool>(boost::any_cast<bool>(m["OtaVersionFlag"]));
    }
    if (m.find("OtaJobFlag") != m.end() && !m["OtaJobFlag"].empty()) {
      otaJobFlag = make_shared<bool>(boost::any_cast<bool>(m["OtaJobFlag"]));
    }
  }


  virtual ~UpdateSubscribeRelationRequest() = default;
};
class UpdateSubscribeRelationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateSubscribeRelationResponseBody() {}

  explicit UpdateSubscribeRelationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateSubscribeRelationResponseBody() = default;
};
class UpdateSubscribeRelationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateSubscribeRelationResponseBody> body{};

  UpdateSubscribeRelationResponse() {}

  explicit UpdateSubscribeRelationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSubscribeRelationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSubscribeRelationResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSubscribeRelationResponse() = default;
};
class UpdateThingModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> identifier{};
  shared_ptr<string> thingModelJson{};
  shared_ptr<string> functionBlockId{};
  shared_ptr<string> functionBlockName{};

  UpdateThingModelRequest() {}

  explicit UpdateThingModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (thingModelJson) {
      res["ThingModelJson"] = boost::any(*thingModelJson);
    }
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    if (functionBlockName) {
      res["FunctionBlockName"] = boost::any(*functionBlockName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("ThingModelJson") != m.end() && !m["ThingModelJson"].empty()) {
      thingModelJson = make_shared<string>(boost::any_cast<string>(m["ThingModelJson"]));
    }
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
    if (m.find("FunctionBlockName") != m.end() && !m["FunctionBlockName"].empty()) {
      functionBlockName = make_shared<string>(boost::any_cast<string>(m["FunctionBlockName"]));
    }
  }


  virtual ~UpdateThingModelRequest() = default;
};
class UpdateThingModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateThingModelResponseBody() {}

  explicit UpdateThingModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateThingModelResponseBody() = default;
};
class UpdateThingModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateThingModelResponseBody> body{};

  UpdateThingModelResponse() {}

  explicit UpdateThingModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateThingModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateThingModelResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateThingModelResponse() = default;
};
class UpdateThingModelValidationConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> validateType{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  UpdateThingModelValidationConfigRequest() {}

  explicit UpdateThingModelValidationConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (validateType) {
      res["ValidateType"] = boost::any(*validateType);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ValidateType") != m.end() && !m["ValidateType"].empty()) {
      validateType = make_shared<long>(boost::any_cast<long>(m["ValidateType"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~UpdateThingModelValidationConfigRequest() = default;
};
class UpdateThingModelValidationConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateThingModelValidationConfigResponseBody() {}

  explicit UpdateThingModelValidationConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateThingModelValidationConfigResponseBody() = default;
};
class UpdateThingModelValidationConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateThingModelValidationConfigResponseBody> body{};

  UpdateThingModelValidationConfigResponse() {}

  explicit UpdateThingModelValidationConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateThingModelValidationConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateThingModelValidationConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateThingModelValidationConfigResponse() = default;
};
class UpdateThingScriptRequest : public Darabonba::Model {
public:
  shared_ptr<string> scriptContent{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> scriptType{};

  UpdateThingScriptRequest() {}

  explicit UpdateThingScriptRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scriptContent) {
      res["ScriptContent"] = boost::any(*scriptContent);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (scriptType) {
      res["ScriptType"] = boost::any(*scriptType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScriptContent") != m.end() && !m["ScriptContent"].empty()) {
      scriptContent = make_shared<string>(boost::any_cast<string>(m["ScriptContent"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ScriptType") != m.end() && !m["ScriptType"].empty()) {
      scriptType = make_shared<string>(boost::any_cast<string>(m["ScriptType"]));
    }
  }


  virtual ~UpdateThingScriptRequest() = default;
};
class UpdateThingScriptResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateThingScriptResponseBody() {}

  explicit UpdateThingScriptResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateThingScriptResponseBody() = default;
};
class UpdateThingScriptResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateThingScriptResponseBody> body{};

  UpdateThingScriptResponse() {}

  explicit UpdateThingScriptResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateThingScriptResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateThingScriptResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateThingScriptResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  BatchAddDeviceGroupRelationsResponse batchAddDeviceGroupRelationsWithOptions(shared_ptr<BatchAddDeviceGroupRelationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchAddDeviceGroupRelationsResponse batchAddDeviceGroupRelations(shared_ptr<BatchAddDeviceGroupRelationsRequest> request);
  BatchAddThingTopoResponse batchAddThingTopoWithOptions(shared_ptr<BatchAddThingTopoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchAddThingTopoResponse batchAddThingTopo(shared_ptr<BatchAddThingTopoRequest> request);
  BatchBindDevicesIntoProjectResponse batchBindDevicesIntoProjectWithOptions(shared_ptr<BatchBindDevicesIntoProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchBindDevicesIntoProjectResponse batchBindDevicesIntoProject(shared_ptr<BatchBindDevicesIntoProjectRequest> request);
  BatchBindDeviceToEdgeInstanceWithDriverResponse batchBindDeviceToEdgeInstanceWithDriverWithOptions(shared_ptr<BatchBindDeviceToEdgeInstanceWithDriverRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchBindDeviceToEdgeInstanceWithDriverResponse batchBindDeviceToEdgeInstanceWithDriver(shared_ptr<BatchBindDeviceToEdgeInstanceWithDriverRequest> request);
  BatchBindProductsIntoProjectResponse batchBindProductsIntoProjectWithOptions(shared_ptr<BatchBindProductsIntoProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchBindProductsIntoProjectResponse batchBindProductsIntoProject(shared_ptr<BatchBindProductsIntoProjectRequest> request);
  BatchCheckDeviceNamesResponse batchCheckDeviceNamesWithOptions(shared_ptr<BatchCheckDeviceNamesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchCheckDeviceNamesResponse batchCheckDeviceNames(shared_ptr<BatchCheckDeviceNamesRequest> request);
  BatchClearEdgeInstanceDeviceConfigResponse batchClearEdgeInstanceDeviceConfigWithOptions(shared_ptr<BatchClearEdgeInstanceDeviceConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchClearEdgeInstanceDeviceConfigResponse batchClearEdgeInstanceDeviceConfig(shared_ptr<BatchClearEdgeInstanceDeviceConfigRequest> request);
  BatchDeleteDeviceGroupRelationsResponse batchDeleteDeviceGroupRelationsWithOptions(shared_ptr<BatchDeleteDeviceGroupRelationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchDeleteDeviceGroupRelationsResponse batchDeleteDeviceGroupRelations(shared_ptr<BatchDeleteDeviceGroupRelationsRequest> request);
  BatchDeleteEdgeInstanceChannelResponse batchDeleteEdgeInstanceChannelWithOptions(shared_ptr<BatchDeleteEdgeInstanceChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchDeleteEdgeInstanceChannelResponse batchDeleteEdgeInstanceChannel(shared_ptr<BatchDeleteEdgeInstanceChannelRequest> request);
  BatchGetDeviceBindStatusResponse batchGetDeviceBindStatusWithOptions(shared_ptr<BatchGetDeviceBindStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetDeviceBindStatusResponse batchGetDeviceBindStatus(shared_ptr<BatchGetDeviceBindStatusRequest> request);
  BatchGetDeviceStateResponse batchGetDeviceStateWithOptions(shared_ptr<BatchGetDeviceStateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetDeviceStateResponse batchGetDeviceState(shared_ptr<BatchGetDeviceStateRequest> request);
  BatchGetEdgeDriverResponse batchGetEdgeDriverWithOptions(shared_ptr<BatchGetEdgeDriverRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetEdgeDriverResponse batchGetEdgeDriver(shared_ptr<BatchGetEdgeDriverRequest> request);
  BatchGetEdgeInstanceChannelResponse batchGetEdgeInstanceChannelWithOptions(shared_ptr<BatchGetEdgeInstanceChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetEdgeInstanceChannelResponse batchGetEdgeInstanceChannel(shared_ptr<BatchGetEdgeInstanceChannelRequest> request);
  BatchGetEdgeInstanceDeviceChannelResponse batchGetEdgeInstanceDeviceChannelWithOptions(shared_ptr<BatchGetEdgeInstanceDeviceChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetEdgeInstanceDeviceChannelResponse batchGetEdgeInstanceDeviceChannel(shared_ptr<BatchGetEdgeInstanceDeviceChannelRequest> request);
  BatchGetEdgeInstanceDeviceConfigResponse batchGetEdgeInstanceDeviceConfigWithOptions(shared_ptr<BatchGetEdgeInstanceDeviceConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetEdgeInstanceDeviceConfigResponse batchGetEdgeInstanceDeviceConfig(shared_ptr<BatchGetEdgeInstanceDeviceConfigRequest> request);
  BatchGetEdgeInstanceDeviceDriverResponse batchGetEdgeInstanceDeviceDriverWithOptions(shared_ptr<BatchGetEdgeInstanceDeviceDriverRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetEdgeInstanceDeviceDriverResponse batchGetEdgeInstanceDeviceDriver(shared_ptr<BatchGetEdgeInstanceDeviceDriverRequest> request);
  BatchGetEdgeInstanceDriverConfigsResponse batchGetEdgeInstanceDriverConfigsWithOptions(shared_ptr<BatchGetEdgeInstanceDriverConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetEdgeInstanceDriverConfigsResponse batchGetEdgeInstanceDriverConfigs(shared_ptr<BatchGetEdgeInstanceDriverConfigsRequest> request);
  BatchPubResponse batchPubWithOptions(shared_ptr<BatchPubRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchPubResponse batchPub(shared_ptr<BatchPubRequest> request);
  BatchQueryDeviceDetailResponse batchQueryDeviceDetailWithOptions(shared_ptr<BatchQueryDeviceDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchQueryDeviceDetailResponse batchQueryDeviceDetail(shared_ptr<BatchQueryDeviceDetailRequest> request);
  BatchRegisterDeviceResponse batchRegisterDeviceWithOptions(shared_ptr<BatchRegisterDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchRegisterDeviceResponse batchRegisterDevice(shared_ptr<BatchRegisterDeviceRequest> request);
  BatchRegisterDeviceWithApplyIdResponse batchRegisterDeviceWithApplyIdWithOptions(shared_ptr<BatchRegisterDeviceWithApplyIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchRegisterDeviceWithApplyIdResponse batchRegisterDeviceWithApplyId(shared_ptr<BatchRegisterDeviceWithApplyIdRequest> request);
  BatchSetEdgeInstanceDeviceChannelResponse batchSetEdgeInstanceDeviceChannelWithOptions(shared_ptr<BatchSetEdgeInstanceDeviceChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchSetEdgeInstanceDeviceChannelResponse batchSetEdgeInstanceDeviceChannel(shared_ptr<BatchSetEdgeInstanceDeviceChannelRequest> request);
  BatchSetEdgeInstanceDeviceConfigResponse batchSetEdgeInstanceDeviceConfigWithOptions(shared_ptr<BatchSetEdgeInstanceDeviceConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchSetEdgeInstanceDeviceConfigResponse batchSetEdgeInstanceDeviceConfig(shared_ptr<BatchSetEdgeInstanceDeviceConfigRequest> request);
  BatchUnbindDeviceFromEdgeInstanceResponse batchUnbindDeviceFromEdgeInstanceWithOptions(shared_ptr<BatchUnbindDeviceFromEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchUnbindDeviceFromEdgeInstanceResponse batchUnbindDeviceFromEdgeInstance(shared_ptr<BatchUnbindDeviceFromEdgeInstanceRequest> request);
  BatchUnbindProjectDevicesResponse batchUnbindProjectDevicesWithOptions(shared_ptr<BatchUnbindProjectDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchUnbindProjectDevicesResponse batchUnbindProjectDevices(shared_ptr<BatchUnbindProjectDevicesRequest> request);
  BatchUnbindProjectProductsResponse batchUnbindProjectProductsWithOptions(shared_ptr<BatchUnbindProjectProductsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchUnbindProjectProductsResponse batchUnbindProjectProducts(shared_ptr<BatchUnbindProjectProductsRequest> request);
  BatchUpdateDeviceNicknameResponse batchUpdateDeviceNicknameWithOptions(shared_ptr<BatchUpdateDeviceNicknameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchUpdateDeviceNicknameResponse batchUpdateDeviceNickname(shared_ptr<BatchUpdateDeviceNicknameRequest> request);
  BindApplicationToEdgeInstanceResponse bindApplicationToEdgeInstanceWithOptions(shared_ptr<BindApplicationToEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindApplicationToEdgeInstanceResponse bindApplicationToEdgeInstance(shared_ptr<BindApplicationToEdgeInstanceRequest> request);
  BindDriverToEdgeInstanceResponse bindDriverToEdgeInstanceWithOptions(shared_ptr<BindDriverToEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindDriverToEdgeInstanceResponse bindDriverToEdgeInstance(shared_ptr<BindDriverToEdgeInstanceRequest> request);
  BindGatewayToEdgeInstanceResponse bindGatewayToEdgeInstanceWithOptions(shared_ptr<BindGatewayToEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindGatewayToEdgeInstanceResponse bindGatewayToEdgeInstance(shared_ptr<BindGatewayToEdgeInstanceRequest> request);
  BindRoleToEdgeInstanceResponse bindRoleToEdgeInstanceWithOptions(shared_ptr<BindRoleToEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindRoleToEdgeInstanceResponse bindRoleToEdgeInstance(shared_ptr<BindRoleToEdgeInstanceRequest> request);
  BindSceneRuleToEdgeInstanceResponse bindSceneRuleToEdgeInstanceWithOptions(shared_ptr<BindSceneRuleToEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindSceneRuleToEdgeInstanceResponse bindSceneRuleToEdgeInstance(shared_ptr<BindSceneRuleToEdgeInstanceRequest> request);
  CancelJobResponse cancelJobWithOptions(shared_ptr<CancelJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelJobResponse cancelJob(shared_ptr<CancelJobRequest> request);
  CancelOTAStrategyByJobResponse cancelOTAStrategyByJobWithOptions(shared_ptr<CancelOTAStrategyByJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelOTAStrategyByJobResponse cancelOTAStrategyByJob(shared_ptr<CancelOTAStrategyByJobRequest> request);
  CancelOTATaskByDeviceResponse cancelOTATaskByDeviceWithOptions(shared_ptr<CancelOTATaskByDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelOTATaskByDeviceResponse cancelOTATaskByDevice(shared_ptr<CancelOTATaskByDeviceRequest> request);
  CancelOTATaskByJobResponse cancelOTATaskByJobWithOptions(shared_ptr<CancelOTATaskByJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelOTATaskByJobResponse cancelOTATaskByJob(shared_ptr<CancelOTATaskByJobRequest> request);
  ClearEdgeInstanceDriverConfigsResponse clearEdgeInstanceDriverConfigsWithOptions(shared_ptr<ClearEdgeInstanceDriverConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ClearEdgeInstanceDriverConfigsResponse clearEdgeInstanceDriverConfigs(shared_ptr<ClearEdgeInstanceDriverConfigsRequest> request);
  CloseEdgeInstanceDeploymentResponse closeEdgeInstanceDeploymentWithOptions(shared_ptr<CloseEdgeInstanceDeploymentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CloseEdgeInstanceDeploymentResponse closeEdgeInstanceDeployment(shared_ptr<CloseEdgeInstanceDeploymentRequest> request);
  CopyThingModelResponse copyThingModelWithOptions(shared_ptr<CopyThingModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CopyThingModelResponse copyThingModel(shared_ptr<CopyThingModelRequest> request);
  CreateConsumerGroupResponse createConsumerGroupWithOptions(shared_ptr<CreateConsumerGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateConsumerGroupResponse createConsumerGroup(shared_ptr<CreateConsumerGroupRequest> request);
  CreateConsumerGroupSubscribeRelationResponse createConsumerGroupSubscribeRelationWithOptions(shared_ptr<CreateConsumerGroupSubscribeRelationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateConsumerGroupSubscribeRelationResponse createConsumerGroupSubscribeRelation(shared_ptr<CreateConsumerGroupSubscribeRelationRequest> request);
  CreateDataAPIServiceResponse createDataAPIServiceWithOptions(shared_ptr<CreateDataAPIServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataAPIServiceResponse createDataAPIService(shared_ptr<CreateDataAPIServiceRequest> request);
  CreateDeviceDistributeJobResponse createDeviceDistributeJobWithOptions(shared_ptr<CreateDeviceDistributeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDeviceDistributeJobResponse createDeviceDistributeJob(shared_ptr<CreateDeviceDistributeJobRequest> request);
  CreateDeviceGroupResponse createDeviceGroupWithOptions(shared_ptr<CreateDeviceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDeviceGroupResponse createDeviceGroup(shared_ptr<CreateDeviceGroupRequest> request);
  CreateEdgeDriverResponse createEdgeDriverWithOptions(shared_ptr<CreateEdgeDriverRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEdgeDriverResponse createEdgeDriver(shared_ptr<CreateEdgeDriverRequest> request);
  CreateEdgeDriverVersionResponse createEdgeDriverVersionWithOptions(shared_ptr<CreateEdgeDriverVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEdgeDriverVersionResponse createEdgeDriverVersion(shared_ptr<CreateEdgeDriverVersionRequest> request);
  CreateEdgeInstanceResponse createEdgeInstanceWithOptions(shared_ptr<CreateEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEdgeInstanceResponse createEdgeInstance(shared_ptr<CreateEdgeInstanceRequest> request);
  CreateEdgeInstanceChannelResponse createEdgeInstanceChannelWithOptions(shared_ptr<CreateEdgeInstanceChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEdgeInstanceChannelResponse createEdgeInstanceChannel(shared_ptr<CreateEdgeInstanceChannelRequest> request);
  CreateEdgeInstanceDeploymentResponse createEdgeInstanceDeploymentWithOptions(shared_ptr<CreateEdgeInstanceDeploymentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEdgeInstanceDeploymentResponse createEdgeInstanceDeployment(shared_ptr<CreateEdgeInstanceDeploymentRequest> request);
  CreateEdgeInstanceMessageRoutingResponse createEdgeInstanceMessageRoutingWithOptions(shared_ptr<CreateEdgeInstanceMessageRoutingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEdgeInstanceMessageRoutingResponse createEdgeInstanceMessageRouting(shared_ptr<CreateEdgeInstanceMessageRoutingRequest> request);
  CreateEdgeOssPreSignedAddressResponse createEdgeOssPreSignedAddressWithOptions(shared_ptr<CreateEdgeOssPreSignedAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEdgeOssPreSignedAddressResponse createEdgeOssPreSignedAddress(shared_ptr<CreateEdgeOssPreSignedAddressRequest> request);
  CreateJobResponse createJobWithOptions(shared_ptr<CreateJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateJobResponse createJob(shared_ptr<CreateJobRequest> request);
  CreateLoRaNodesTaskResponse createLoRaNodesTaskWithOptions(shared_ptr<CreateLoRaNodesTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLoRaNodesTaskResponse createLoRaNodesTask(shared_ptr<CreateLoRaNodesTaskRequest> request);
  CreateOTADynamicUpgradeJobResponse createOTADynamicUpgradeJobWithOptions(shared_ptr<CreateOTADynamicUpgradeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOTADynamicUpgradeJobResponse createOTADynamicUpgradeJob(shared_ptr<CreateOTADynamicUpgradeJobRequest> request);
  CreateOTAFirmwareResponse createOTAFirmwareWithOptions(shared_ptr<CreateOTAFirmwareRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOTAFirmwareResponse createOTAFirmware(shared_ptr<CreateOTAFirmwareRequest> request);
  CreateOTAModuleResponse createOTAModuleWithOptions(shared_ptr<CreateOTAModuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOTAModuleResponse createOTAModule(shared_ptr<CreateOTAModuleRequest> request);
  CreateOTAStaticUpgradeJobResponse createOTAStaticUpgradeJobWithOptions(shared_ptr<CreateOTAStaticUpgradeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOTAStaticUpgradeJobResponse createOTAStaticUpgradeJob(shared_ptr<CreateOTAStaticUpgradeJobRequest> request);
  CreateOTAVerifyJobResponse createOTAVerifyJobWithOptions(shared_ptr<CreateOTAVerifyJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOTAVerifyJobResponse createOTAVerifyJob(shared_ptr<CreateOTAVerifyJobRequest> request);
  CreateProductResponse createProductWithOptions(shared_ptr<CreateProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProductResponse createProduct(shared_ptr<CreateProductRequest> request);
  CreateProductDistributeJobResponse createProductDistributeJobWithOptions(shared_ptr<CreateProductDistributeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProductDistributeJobResponse createProductDistributeJob(shared_ptr<CreateProductDistributeJobRequest> request);
  CreateProductTagsResponse createProductTagsWithOptions(shared_ptr<CreateProductTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProductTagsResponse createProductTags(shared_ptr<CreateProductTagsRequest> request);
  CreateProductTopicResponse createProductTopicWithOptions(shared_ptr<CreateProductTopicRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProductTopicResponse createProductTopic(shared_ptr<CreateProductTopicRequest> request);
  CreateRuleResponse createRuleWithOptions(shared_ptr<CreateRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRuleResponse createRule(shared_ptr<CreateRuleRequest> request);
  CreateRuleActionResponse createRuleActionWithOptions(shared_ptr<CreateRuleActionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRuleActionResponse createRuleAction(shared_ptr<CreateRuleActionRequest> request);
  CreateRulengDistributeJobResponse createRulengDistributeJobWithOptions(shared_ptr<CreateRulengDistributeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRulengDistributeJobResponse createRulengDistributeJob(shared_ptr<CreateRulengDistributeJobRequest> request);
  CreateSceneRuleResponse createSceneRuleWithOptions(shared_ptr<CreateSceneRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSceneRuleResponse createSceneRule(shared_ptr<CreateSceneRuleRequest> request);
  CreateSubscribeRelationResponse createSubscribeRelationWithOptions(shared_ptr<CreateSubscribeRelationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSubscribeRelationResponse createSubscribeRelation(shared_ptr<CreateSubscribeRelationRequest> request);
  CreateThingModelResponse createThingModelWithOptions(shared_ptr<CreateThingModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateThingModelResponse createThingModel(shared_ptr<CreateThingModelRequest> request);
  CreateThingScriptResponse createThingScriptWithOptions(shared_ptr<CreateThingScriptRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateThingScriptResponse createThingScript(shared_ptr<CreateThingScriptRequest> request);
  CreateTopicRouteTableResponse createTopicRouteTableWithOptions(shared_ptr<CreateTopicRouteTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTopicRouteTableResponse createTopicRouteTable(shared_ptr<CreateTopicRouteTableRequest> request);
  DeleteConsumerGroupResponse deleteConsumerGroupWithOptions(shared_ptr<DeleteConsumerGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteConsumerGroupResponse deleteConsumerGroup(shared_ptr<DeleteConsumerGroupRequest> request);
  DeleteConsumerGroupSubscribeRelationResponse deleteConsumerGroupSubscribeRelationWithOptions(shared_ptr<DeleteConsumerGroupSubscribeRelationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteConsumerGroupSubscribeRelationResponse deleteConsumerGroupSubscribeRelation(shared_ptr<DeleteConsumerGroupSubscribeRelationRequest> request);
  DeleteDeviceResponse deleteDeviceWithOptions(shared_ptr<DeleteDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDeviceResponse deleteDevice(shared_ptr<DeleteDeviceRequest> request);
  DeleteDeviceDistributeJobResponse deleteDeviceDistributeJobWithOptions(shared_ptr<DeleteDeviceDistributeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDeviceDistributeJobResponse deleteDeviceDistributeJob(shared_ptr<DeleteDeviceDistributeJobRequest> request);
  DeleteDeviceFileResponse deleteDeviceFileWithOptions(shared_ptr<DeleteDeviceFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDeviceFileResponse deleteDeviceFile(shared_ptr<DeleteDeviceFileRequest> request);
  DeleteDeviceGroupResponse deleteDeviceGroupWithOptions(shared_ptr<DeleteDeviceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDeviceGroupResponse deleteDeviceGroup(shared_ptr<DeleteDeviceGroupRequest> request);
  DeleteDevicePropResponse deleteDevicePropWithOptions(shared_ptr<DeleteDevicePropRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDevicePropResponse deleteDeviceProp(shared_ptr<DeleteDevicePropRequest> request);
  DeleteEdgeDriverResponse deleteEdgeDriverWithOptions(shared_ptr<DeleteEdgeDriverRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEdgeDriverResponse deleteEdgeDriver(shared_ptr<DeleteEdgeDriverRequest> request);
  DeleteEdgeDriverVersionResponse deleteEdgeDriverVersionWithOptions(shared_ptr<DeleteEdgeDriverVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEdgeDriverVersionResponse deleteEdgeDriverVersion(shared_ptr<DeleteEdgeDriverVersionRequest> request);
  DeleteEdgeInstanceResponse deleteEdgeInstanceWithOptions(shared_ptr<DeleteEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEdgeInstanceResponse deleteEdgeInstance(shared_ptr<DeleteEdgeInstanceRequest> request);
  DeleteEdgeInstanceMessageRoutingResponse deleteEdgeInstanceMessageRoutingWithOptions(shared_ptr<DeleteEdgeInstanceMessageRoutingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEdgeInstanceMessageRoutingResponse deleteEdgeInstanceMessageRouting(shared_ptr<DeleteEdgeInstanceMessageRoutingRequest> request);
  DeleteJobResponse deleteJobWithOptions(shared_ptr<DeleteJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteJobResponse deleteJob(shared_ptr<DeleteJobRequest> request);
  DeleteOTAFirmwareResponse deleteOTAFirmwareWithOptions(shared_ptr<DeleteOTAFirmwareRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteOTAFirmwareResponse deleteOTAFirmware(shared_ptr<DeleteOTAFirmwareRequest> request);
  DeleteOTAModuleResponse deleteOTAModuleWithOptions(shared_ptr<DeleteOTAModuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteOTAModuleResponse deleteOTAModule(shared_ptr<DeleteOTAModuleRequest> request);
  DeleteProductResponse deleteProductWithOptions(shared_ptr<DeleteProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteProductResponse deleteProduct(shared_ptr<DeleteProductRequest> request);
  DeleteProductTagsResponse deleteProductTagsWithOptions(shared_ptr<DeleteProductTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteProductTagsResponse deleteProductTags(shared_ptr<DeleteProductTagsRequest> request);
  DeleteProductTopicResponse deleteProductTopicWithOptions(shared_ptr<DeleteProductTopicRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteProductTopicResponse deleteProductTopic(shared_ptr<DeleteProductTopicRequest> request);
  DeleteRuleResponse deleteRuleWithOptions(shared_ptr<DeleteRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRuleResponse deleteRule(shared_ptr<DeleteRuleRequest> request);
  DeleteRuleActionResponse deleteRuleActionWithOptions(shared_ptr<DeleteRuleActionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRuleActionResponse deleteRuleAction(shared_ptr<DeleteRuleActionRequest> request);
  DeleteSceneRuleResponse deleteSceneRuleWithOptions(shared_ptr<DeleteSceneRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSceneRuleResponse deleteSceneRule(shared_ptr<DeleteSceneRuleRequest> request);
  DeleteSubscribeRelationResponse deleteSubscribeRelationWithOptions(shared_ptr<DeleteSubscribeRelationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSubscribeRelationResponse deleteSubscribeRelation(shared_ptr<DeleteSubscribeRelationRequest> request);
  DeleteThingModelResponse deleteThingModelWithOptions(shared_ptr<DeleteThingModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteThingModelResponse deleteThingModel(shared_ptr<DeleteThingModelRequest> request);
  DeleteTopicRouteTableResponse deleteTopicRouteTableWithOptions(shared_ptr<DeleteTopicRouteTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTopicRouteTableResponse deleteTopicRouteTable(shared_ptr<DeleteTopicRouteTableRequest> request);
  DisableDeviceTunnelResponse disableDeviceTunnelWithOptions(shared_ptr<DisableDeviceTunnelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableDeviceTunnelResponse disableDeviceTunnel(shared_ptr<DisableDeviceTunnelRequest> request);
  DisableDeviceTunnelShareResponse disableDeviceTunnelShareWithOptions(shared_ptr<DisableDeviceTunnelShareRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableDeviceTunnelShareResponse disableDeviceTunnelShare(shared_ptr<DisableDeviceTunnelShareRequest> request);
  DisableSceneRuleResponse disableSceneRuleWithOptions(shared_ptr<DisableSceneRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableSceneRuleResponse disableSceneRule(shared_ptr<DisableSceneRuleRequest> request);
  DisableThingResponse disableThingWithOptions(shared_ptr<DisableThingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableThingResponse disableThing(shared_ptr<DisableThingRequest> request);
  EnableDeviceTunnelResponse enableDeviceTunnelWithOptions(shared_ptr<EnableDeviceTunnelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableDeviceTunnelResponse enableDeviceTunnel(shared_ptr<EnableDeviceTunnelRequest> request);
  EnableDeviceTunnelShareResponse enableDeviceTunnelShareWithOptions(shared_ptr<EnableDeviceTunnelShareRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableDeviceTunnelShareResponse enableDeviceTunnelShare(shared_ptr<EnableDeviceTunnelShareRequest> request);
  EnableSceneRuleResponse enableSceneRuleWithOptions(shared_ptr<EnableSceneRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableSceneRuleResponse enableSceneRule(shared_ptr<EnableSceneRuleRequest> request);
  EnableThingResponse enableThingWithOptions(shared_ptr<EnableThingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableThingResponse enableThing(shared_ptr<EnableThingRequest> request);
  GenerateDeviceNameListURLResponse generateDeviceNameListURLWithOptions(shared_ptr<GenerateDeviceNameListURLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateDeviceNameListURLResponse generateDeviceNameListURL(shared_ptr<GenerateDeviceNameListURLRequest> request);
  GenerateFileUploadURLResponse generateFileUploadURLWithOptions(shared_ptr<GenerateFileUploadURLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateFileUploadURLResponse generateFileUploadURL(shared_ptr<GenerateFileUploadURLRequest> request);
  GenerateOTAUploadURLResponse generateOTAUploadURLWithOptions(shared_ptr<GenerateOTAUploadURLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateOTAUploadURLResponse generateOTAUploadURL(shared_ptr<GenerateOTAUploadURLRequest> request);
  GetDataAPIServiceDetailResponse getDataAPIServiceDetailWithOptions(shared_ptr<GetDataAPIServiceDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataAPIServiceDetailResponse getDataAPIServiceDetail(shared_ptr<GetDataAPIServiceDetailRequest> request);
  GetDeviceShadowResponse getDeviceShadowWithOptions(shared_ptr<GetDeviceShadowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDeviceShadowResponse getDeviceShadow(shared_ptr<GetDeviceShadowRequest> request);
  GetDeviceStatusResponse getDeviceStatusWithOptions(shared_ptr<GetDeviceStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDeviceStatusResponse getDeviceStatus(shared_ptr<GetDeviceStatusRequest> request);
  GetDeviceTunnelShareStatusResponse getDeviceTunnelShareStatusWithOptions(shared_ptr<GetDeviceTunnelShareStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDeviceTunnelShareStatusResponse getDeviceTunnelShareStatus(shared_ptr<GetDeviceTunnelShareStatusRequest> request);
  GetDeviceTunnelStatusResponse getDeviceTunnelStatusWithOptions(shared_ptr<GetDeviceTunnelStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDeviceTunnelStatusResponse getDeviceTunnelStatus(shared_ptr<GetDeviceTunnelStatusRequest> request);
  GetEdgeDriverVersionResponse getEdgeDriverVersionWithOptions(shared_ptr<GetEdgeDriverVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEdgeDriverVersionResponse getEdgeDriverVersion(shared_ptr<GetEdgeDriverVersionRequest> request);
  GetEdgeInstanceResponse getEdgeInstanceWithOptions(shared_ptr<GetEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEdgeInstanceResponse getEdgeInstance(shared_ptr<GetEdgeInstanceRequest> request);
  GetEdgeInstanceDeploymentResponse getEdgeInstanceDeploymentWithOptions(shared_ptr<GetEdgeInstanceDeploymentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEdgeInstanceDeploymentResponse getEdgeInstanceDeployment(shared_ptr<GetEdgeInstanceDeploymentRequest> request);
  GetEdgeInstanceMessageRoutingResponse getEdgeInstanceMessageRoutingWithOptions(shared_ptr<GetEdgeInstanceMessageRoutingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEdgeInstanceMessageRoutingResponse getEdgeInstanceMessageRouting(shared_ptr<GetEdgeInstanceMessageRoutingRequest> request);
  GetGatewayBySubDeviceResponse getGatewayBySubDeviceWithOptions(shared_ptr<GetGatewayBySubDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetGatewayBySubDeviceResponse getGatewayBySubDevice(shared_ptr<GetGatewayBySubDeviceRequest> request);
  GetLoraNodesTaskResponse getLoraNodesTaskWithOptions(shared_ptr<GetLoraNodesTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLoraNodesTaskResponse getLoraNodesTask(shared_ptr<GetLoraNodesTaskRequest> request);
  GetNodesAddingTaskResponse getNodesAddingTaskWithOptions(shared_ptr<GetNodesAddingTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNodesAddingTaskResponse getNodesAddingTask(shared_ptr<GetNodesAddingTaskRequest> request);
  GetRuleResponse getRuleWithOptions(shared_ptr<GetRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRuleResponse getRule(shared_ptr<GetRuleRequest> request);
  GetRuleActionResponse getRuleActionWithOptions(shared_ptr<GetRuleActionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRuleActionResponse getRuleAction(shared_ptr<GetRuleActionRequest> request);
  GetSceneRuleResponse getSceneRuleWithOptions(shared_ptr<GetSceneRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSceneRuleResponse getSceneRule(shared_ptr<GetSceneRuleRequest> request);
  GetThingModelTslResponse getThingModelTslWithOptions(shared_ptr<GetThingModelTslRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetThingModelTslResponse getThingModelTsl(shared_ptr<GetThingModelTslRequest> request);
  GetThingModelTslPublishedResponse getThingModelTslPublishedWithOptions(shared_ptr<GetThingModelTslPublishedRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetThingModelTslPublishedResponse getThingModelTslPublished(shared_ptr<GetThingModelTslPublishedRequest> request);
  GetThingScriptResponse getThingScriptWithOptions(shared_ptr<GetThingScriptRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetThingScriptResponse getThingScript(shared_ptr<GetThingScriptRequest> request);
  GetThingTemplateResponse getThingTemplateWithOptions(shared_ptr<GetThingTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetThingTemplateResponse getThingTemplate(shared_ptr<GetThingTemplateRequest> request);
  GetThingTopoResponse getThingTopoWithOptions(shared_ptr<GetThingTopoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetThingTopoResponse getThingTopo(shared_ptr<GetThingTopoRequest> request);
  ImportThingModelTslResponse importThingModelTslWithOptions(shared_ptr<ImportThingModelTslRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportThingModelTslResponse importThingModelTsl(shared_ptr<ImportThingModelTslRequest> request);
  InvokeDataAPIServiceResponse invokeDataAPIServiceWithOptions(shared_ptr<InvokeDataAPIServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InvokeDataAPIServiceResponse invokeDataAPIService(shared_ptr<InvokeDataAPIServiceRequest> request);
  InvokeThingServiceResponse invokeThingServiceWithOptions(shared_ptr<InvokeThingServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InvokeThingServiceResponse invokeThingService(shared_ptr<InvokeThingServiceRequest> request);
  InvokeThingsServiceResponse invokeThingsServiceWithOptions(shared_ptr<InvokeThingsServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InvokeThingsServiceResponse invokeThingsService(shared_ptr<InvokeThingsServiceRequest> request);
  ListAnalyticsDataResponse listAnalyticsDataWithOptions(shared_ptr<ListAnalyticsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAnalyticsDataResponse listAnalyticsData(shared_ptr<ListAnalyticsDataRequest> request);
  ListDeviceDistributeJobResponse listDeviceDistributeJobWithOptions(shared_ptr<ListDeviceDistributeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDeviceDistributeJobResponse listDeviceDistributeJob(shared_ptr<ListDeviceDistributeJobRequest> request);
  ListDistributedDeviceResponse listDistributedDeviceWithOptions(shared_ptr<ListDistributedDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDistributedDeviceResponse listDistributedDevice(shared_ptr<ListDistributedDeviceRequest> request);
  ListDistributedProductResponse listDistributedProductWithOptions(shared_ptr<ListDistributedProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDistributedProductResponse listDistributedProduct(shared_ptr<ListDistributedProductRequest> request);
  ListJobResponse listJobWithOptions(shared_ptr<ListJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListJobResponse listJob(shared_ptr<ListJobRequest> request);
  ListOTAFirmwareResponse listOTAFirmwareWithOptions(shared_ptr<ListOTAFirmwareRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOTAFirmwareResponse listOTAFirmware(shared_ptr<ListOTAFirmwareRequest> request);
  ListOTAJobByDeviceResponse listOTAJobByDeviceWithOptions(shared_ptr<ListOTAJobByDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOTAJobByDeviceResponse listOTAJobByDevice(shared_ptr<ListOTAJobByDeviceRequest> request);
  ListOTAJobByFirmwareResponse listOTAJobByFirmwareWithOptions(shared_ptr<ListOTAJobByFirmwareRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOTAJobByFirmwareResponse listOTAJobByFirmware(shared_ptr<ListOTAJobByFirmwareRequest> request);
  ListOTAModuleByProductResponse listOTAModuleByProductWithOptions(shared_ptr<ListOTAModuleByProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOTAModuleByProductResponse listOTAModuleByProduct(shared_ptr<ListOTAModuleByProductRequest> request);
  ListOTAModuleVersionsByDeviceResponse listOTAModuleVersionsByDeviceWithOptions(shared_ptr<ListOTAModuleVersionsByDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOTAModuleVersionsByDeviceResponse listOTAModuleVersionsByDevice(shared_ptr<ListOTAModuleVersionsByDeviceRequest> request);
  ListOTATaskByJobResponse listOTATaskByJobWithOptions(shared_ptr<ListOTATaskByJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOTATaskByJobResponse listOTATaskByJob(shared_ptr<ListOTATaskByJobRequest> request);
  ListProductByTagsResponse listProductByTagsWithOptions(shared_ptr<ListProductByTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProductByTagsResponse listProductByTags(shared_ptr<ListProductByTagsRequest> request);
  ListProductTagsResponse listProductTagsWithOptions(shared_ptr<ListProductTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProductTagsResponse listProductTags(shared_ptr<ListProductTagsRequest> request);
  ListRuleResponse listRuleWithOptions(shared_ptr<ListRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRuleResponse listRule(shared_ptr<ListRuleRequest> request);
  ListRuleActionsResponse listRuleActionsWithOptions(shared_ptr<ListRuleActionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRuleActionsResponse listRuleActions(shared_ptr<ListRuleActionsRequest> request);
  ListTaskResponse listTaskWithOptions(shared_ptr<ListTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTaskResponse listTask(shared_ptr<ListTaskRequest> request);
  ListTaskByPageResponse listTaskByPageWithOptions(shared_ptr<ListTaskByPageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTaskByPageResponse listTaskByPage(shared_ptr<ListTaskByPageRequest> request);
  ListThingModelVersionResponse listThingModelVersionWithOptions(shared_ptr<ListThingModelVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListThingModelVersionResponse listThingModelVersion(shared_ptr<ListThingModelVersionRequest> request);
  ListThingTemplatesResponse listThingTemplatesWithOptions(shared_ptr<ListThingTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListThingTemplatesResponse listThingTemplates(shared_ptr<ListThingTemplatesRequest> request);
  NotifyAddThingTopoResponse notifyAddThingTopoWithOptions(shared_ptr<NotifyAddThingTopoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  NotifyAddThingTopoResponse notifyAddThingTopo(shared_ptr<NotifyAddThingTopoRequest> request);
  OpenIotServiceResponse openIotServiceWithOptions(shared_ptr<OpenIotServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenIotServiceResponse openIotService(shared_ptr<OpenIotServiceRequest> request);
  PrintByTemplateResponse printByTemplateWithOptions(shared_ptr<PrintByTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PrintByTemplateResponse printByTemplate(shared_ptr<PrintByTemplateRequest> request);
  PubResponse pubWithOptions(shared_ptr<PubRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PubResponse pub(shared_ptr<PubRequest> request);
  PubBroadcastResponse pubBroadcastWithOptions(shared_ptr<PubBroadcastRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PubBroadcastResponse pubBroadcast(shared_ptr<PubBroadcastRequest> request);
  PublishThingModelResponse publishThingModelWithOptions(shared_ptr<PublishThingModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublishThingModelResponse publishThingModel(shared_ptr<PublishThingModelRequest> request);
  QueryAppDeviceListResponse queryAppDeviceListWithOptions(shared_ptr<QueryAppDeviceListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryAppDeviceListResponse queryAppDeviceList(shared_ptr<QueryAppDeviceListRequest> request);
  QueryBatchRegisterDeviceStatusResponse queryBatchRegisterDeviceStatusWithOptions(shared_ptr<QueryBatchRegisterDeviceStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryBatchRegisterDeviceStatusResponse queryBatchRegisterDeviceStatus(shared_ptr<QueryBatchRegisterDeviceStatusRequest> request);
  QueryCertUrlByApplyIdResponse queryCertUrlByApplyIdWithOptions(shared_ptr<QueryCertUrlByApplyIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryCertUrlByApplyIdResponse queryCertUrlByApplyId(shared_ptr<QueryCertUrlByApplyIdRequest> request);
  QueryConsumerGroupByGroupIdResponse queryConsumerGroupByGroupIdWithOptions(shared_ptr<QueryConsumerGroupByGroupIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryConsumerGroupByGroupIdResponse queryConsumerGroupByGroupId(shared_ptr<QueryConsumerGroupByGroupIdRequest> request);
  QueryConsumerGroupListResponse queryConsumerGroupListWithOptions(shared_ptr<QueryConsumerGroupListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryConsumerGroupListResponse queryConsumerGroupList(shared_ptr<QueryConsumerGroupListRequest> request);
  QueryConsumerGroupStatusResponse queryConsumerGroupStatusWithOptions(shared_ptr<QueryConsumerGroupStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryConsumerGroupStatusResponse queryConsumerGroupStatus(shared_ptr<QueryConsumerGroupStatusRequest> request);
  QueryDetailSceneRuleLogResponse queryDetailSceneRuleLogWithOptions(shared_ptr<QueryDetailSceneRuleLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDetailSceneRuleLogResponse queryDetailSceneRuleLog(shared_ptr<QueryDetailSceneRuleLogRequest> request);
  QueryDeviceResponse queryDeviceWithOptions(shared_ptr<QueryDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceResponse queryDevice(shared_ptr<QueryDeviceRequest> request);
  QueryDeviceBySQLResponse queryDeviceBySQLWithOptions(shared_ptr<QueryDeviceBySQLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceBySQLResponse queryDeviceBySQL(shared_ptr<QueryDeviceBySQLRequest> request);
  QueryDeviceByStatusResponse queryDeviceByStatusWithOptions(shared_ptr<QueryDeviceByStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceByStatusResponse queryDeviceByStatus(shared_ptr<QueryDeviceByStatusRequest> request);
  QueryDeviceByTagsResponse queryDeviceByTagsWithOptions(shared_ptr<QueryDeviceByTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceByTagsResponse queryDeviceByTags(shared_ptr<QueryDeviceByTagsRequest> request);
  QueryDeviceCertResponse queryDeviceCertWithOptions(shared_ptr<QueryDeviceCertRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceCertResponse queryDeviceCert(shared_ptr<QueryDeviceCertRequest> request);
  QueryDeviceDesiredPropertyResponse queryDeviceDesiredPropertyWithOptions(shared_ptr<QueryDeviceDesiredPropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceDesiredPropertyResponse queryDeviceDesiredProperty(shared_ptr<QueryDeviceDesiredPropertyRequest> request);
  QueryDeviceDetailResponse queryDeviceDetailWithOptions(shared_ptr<QueryDeviceDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceDetailResponse queryDeviceDetail(shared_ptr<QueryDeviceDetailRequest> request);
  QueryDeviceDistributeDetailResponse queryDeviceDistributeDetailWithOptions(shared_ptr<QueryDeviceDistributeDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceDistributeDetailResponse queryDeviceDistributeDetail(shared_ptr<QueryDeviceDistributeDetailRequest> request);
  QueryDeviceDistributeJobResponse queryDeviceDistributeJobWithOptions(shared_ptr<QueryDeviceDistributeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceDistributeJobResponse queryDeviceDistributeJob(shared_ptr<QueryDeviceDistributeJobRequest> request);
  QueryDeviceEventDataResponse queryDeviceEventDataWithOptions(shared_ptr<QueryDeviceEventDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceEventDataResponse queryDeviceEventData(shared_ptr<QueryDeviceEventDataRequest> request);
  QueryDeviceFileResponse queryDeviceFileWithOptions(shared_ptr<QueryDeviceFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceFileResponse queryDeviceFile(shared_ptr<QueryDeviceFileRequest> request);
  QueryDeviceFileListResponse queryDeviceFileListWithOptions(shared_ptr<QueryDeviceFileListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceFileListResponse queryDeviceFileList(shared_ptr<QueryDeviceFileListRequest> request);
  QueryDeviceGroupByDeviceResponse queryDeviceGroupByDeviceWithOptions(shared_ptr<QueryDeviceGroupByDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceGroupByDeviceResponse queryDeviceGroupByDevice(shared_ptr<QueryDeviceGroupByDeviceRequest> request);
  QueryDeviceGroupByTagsResponse queryDeviceGroupByTagsWithOptions(shared_ptr<QueryDeviceGroupByTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceGroupByTagsResponse queryDeviceGroupByTags(shared_ptr<QueryDeviceGroupByTagsRequest> request);
  QueryDeviceGroupInfoResponse queryDeviceGroupInfoWithOptions(shared_ptr<QueryDeviceGroupInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceGroupInfoResponse queryDeviceGroupInfo(shared_ptr<QueryDeviceGroupInfoRequest> request);
  QueryDeviceGroupListResponse queryDeviceGroupListWithOptions(shared_ptr<QueryDeviceGroupListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceGroupListResponse queryDeviceGroupList(shared_ptr<QueryDeviceGroupListRequest> request);
  QueryDeviceGroupTagListResponse queryDeviceGroupTagListWithOptions(shared_ptr<QueryDeviceGroupTagListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceGroupTagListResponse queryDeviceGroupTagList(shared_ptr<QueryDeviceGroupTagListRequest> request);
  QueryDeviceListByDeviceGroupResponse queryDeviceListByDeviceGroupWithOptions(shared_ptr<QueryDeviceListByDeviceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceListByDeviceGroupResponse queryDeviceListByDeviceGroup(shared_ptr<QueryDeviceListByDeviceGroupRequest> request);
  QueryDeviceOriginalEventDataResponse queryDeviceOriginalEventDataWithOptions(shared_ptr<QueryDeviceOriginalEventDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceOriginalEventDataResponse queryDeviceOriginalEventData(shared_ptr<QueryDeviceOriginalEventDataRequest> request);
  QueryDeviceOriginalPropertyDataResponse queryDeviceOriginalPropertyDataWithOptions(shared_ptr<QueryDeviceOriginalPropertyDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceOriginalPropertyDataResponse queryDeviceOriginalPropertyData(shared_ptr<QueryDeviceOriginalPropertyDataRequest> request);
  QueryDeviceOriginalPropertyStatusResponse queryDeviceOriginalPropertyStatusWithOptions(shared_ptr<QueryDeviceOriginalPropertyStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceOriginalPropertyStatusResponse queryDeviceOriginalPropertyStatus(shared_ptr<QueryDeviceOriginalPropertyStatusRequest> request);
  QueryDeviceOriginalServiceDataResponse queryDeviceOriginalServiceDataWithOptions(shared_ptr<QueryDeviceOriginalServiceDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceOriginalServiceDataResponse queryDeviceOriginalServiceData(shared_ptr<QueryDeviceOriginalServiceDataRequest> request);
  QueryDevicePropResponse queryDevicePropWithOptions(shared_ptr<QueryDevicePropRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDevicePropResponse queryDeviceProp(shared_ptr<QueryDevicePropRequest> request);
  QueryDevicePropertiesDataResponse queryDevicePropertiesDataWithOptions(shared_ptr<QueryDevicePropertiesDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDevicePropertiesDataResponse queryDevicePropertiesData(shared_ptr<QueryDevicePropertiesDataRequest> request);
  QueryDevicePropertyDataResponse queryDevicePropertyDataWithOptions(shared_ptr<QueryDevicePropertyDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDevicePropertyDataResponse queryDevicePropertyData(shared_ptr<QueryDevicePropertyDataRequest> request);
  QueryDevicePropertyStatusResponse queryDevicePropertyStatusWithOptions(shared_ptr<QueryDevicePropertyStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDevicePropertyStatusResponse queryDevicePropertyStatus(shared_ptr<QueryDevicePropertyStatusRequest> request);
  QueryDeviceServiceDataResponse queryDeviceServiceDataWithOptions(shared_ptr<QueryDeviceServiceDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceServiceDataResponse queryDeviceServiceData(shared_ptr<QueryDeviceServiceDataRequest> request);
  QueryDeviceStatisticsResponse queryDeviceStatisticsWithOptions(shared_ptr<QueryDeviceStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceStatisticsResponse queryDeviceStatistics(shared_ptr<QueryDeviceStatisticsRequest> request);
  QueryEdgeDriverResponse queryEdgeDriverWithOptions(shared_ptr<QueryEdgeDriverRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeDriverResponse queryEdgeDriver(shared_ptr<QueryEdgeDriverRequest> request);
  QueryEdgeDriverVersionResponse queryEdgeDriverVersionWithOptions(shared_ptr<QueryEdgeDriverVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeDriverVersionResponse queryEdgeDriverVersion(shared_ptr<QueryEdgeDriverVersionRequest> request);
  QueryEdgeInstanceResponse queryEdgeInstanceWithOptions(shared_ptr<QueryEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeInstanceResponse queryEdgeInstance(shared_ptr<QueryEdgeInstanceRequest> request);
  QueryEdgeInstanceChannelResponse queryEdgeInstanceChannelWithOptions(shared_ptr<QueryEdgeInstanceChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeInstanceChannelResponse queryEdgeInstanceChannel(shared_ptr<QueryEdgeInstanceChannelRequest> request);
  QueryEdgeInstanceDeviceResponse queryEdgeInstanceDeviceWithOptions(shared_ptr<QueryEdgeInstanceDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeInstanceDeviceResponse queryEdgeInstanceDevice(shared_ptr<QueryEdgeInstanceDeviceRequest> request);
  QueryEdgeInstanceDeviceByDriverResponse queryEdgeInstanceDeviceByDriverWithOptions(shared_ptr<QueryEdgeInstanceDeviceByDriverRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeInstanceDeviceByDriverResponse queryEdgeInstanceDeviceByDriver(shared_ptr<QueryEdgeInstanceDeviceByDriverRequest> request);
  QueryEdgeInstanceDriverResponse queryEdgeInstanceDriverWithOptions(shared_ptr<QueryEdgeInstanceDriverRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeInstanceDriverResponse queryEdgeInstanceDriver(shared_ptr<QueryEdgeInstanceDriverRequest> request);
  QueryEdgeInstanceGatewayResponse queryEdgeInstanceGatewayWithOptions(shared_ptr<QueryEdgeInstanceGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeInstanceGatewayResponse queryEdgeInstanceGateway(shared_ptr<QueryEdgeInstanceGatewayRequest> request);
  QueryEdgeInstanceHistoricDeploymentResponse queryEdgeInstanceHistoricDeploymentWithOptions(shared_ptr<QueryEdgeInstanceHistoricDeploymentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeInstanceHistoricDeploymentResponse queryEdgeInstanceHistoricDeployment(shared_ptr<QueryEdgeInstanceHistoricDeploymentRequest> request);
  QueryEdgeInstanceMessageRoutingResponse queryEdgeInstanceMessageRoutingWithOptions(shared_ptr<QueryEdgeInstanceMessageRoutingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeInstanceMessageRoutingResponse queryEdgeInstanceMessageRouting(shared_ptr<QueryEdgeInstanceMessageRoutingRequest> request);
  QueryEdgeInstanceSceneRuleResponse queryEdgeInstanceSceneRuleWithOptions(shared_ptr<QueryEdgeInstanceSceneRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeInstanceSceneRuleResponse queryEdgeInstanceSceneRule(shared_ptr<QueryEdgeInstanceSceneRuleRequest> request);
  QueryJobResponse queryJobWithOptions(shared_ptr<QueryJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryJobResponse queryJob(shared_ptr<QueryJobRequest> request);
  QueryJobStatisticsResponse queryJobStatisticsWithOptions(shared_ptr<QueryJobStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryJobStatisticsResponse queryJobStatistics(shared_ptr<QueryJobStatisticsRequest> request);
  QueryLoRaJoinPermissionsResponse queryLoRaJoinPermissionsWithOptions(shared_ptr<QueryLoRaJoinPermissionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryLoRaJoinPermissionsResponse queryLoRaJoinPermissions(shared_ptr<QueryLoRaJoinPermissionsRequest> request);
  QueryOTAFirmwareResponse queryOTAFirmwareWithOptions(shared_ptr<QueryOTAFirmwareRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryOTAFirmwareResponse queryOTAFirmware(shared_ptr<QueryOTAFirmwareRequest> request);
  QueryOTAJobResponse queryOTAJobWithOptions(shared_ptr<QueryOTAJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryOTAJobResponse queryOTAJob(shared_ptr<QueryOTAJobRequest> request);
  QueryPageByApplyIdResponse queryPageByApplyIdWithOptions(shared_ptr<QueryPageByApplyIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryPageByApplyIdResponse queryPageByApplyId(shared_ptr<QueryPageByApplyIdRequest> request);
  QueryProductResponse queryProductWithOptions(shared_ptr<QueryProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryProductResponse queryProduct(shared_ptr<QueryProductRequest> request);
  QueryProductCertInfoResponse queryProductCertInfoWithOptions(shared_ptr<QueryProductCertInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryProductCertInfoResponse queryProductCertInfo(shared_ptr<QueryProductCertInfoRequest> request);
  QueryProductListResponse queryProductListWithOptions(shared_ptr<QueryProductListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryProductListResponse queryProductList(shared_ptr<QueryProductListRequest> request);
  QueryProductTopicResponse queryProductTopicWithOptions(shared_ptr<QueryProductTopicRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryProductTopicResponse queryProductTopic(shared_ptr<QueryProductTopicRequest> request);
  QuerySceneRuleResponse querySceneRuleWithOptions(shared_ptr<QuerySceneRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySceneRuleResponse querySceneRule(shared_ptr<QuerySceneRuleRequest> request);
  QuerySubscribeRelationResponse querySubscribeRelationWithOptions(shared_ptr<QuerySubscribeRelationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySubscribeRelationResponse querySubscribeRelation(shared_ptr<QuerySubscribeRelationRequest> request);
  QuerySummarySceneRuleLogResponse querySummarySceneRuleLogWithOptions(shared_ptr<QuerySummarySceneRuleLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySummarySceneRuleLogResponse querySummarySceneRuleLog(shared_ptr<QuerySummarySceneRuleLogRequest> request);
  QuerySuperDeviceGroupResponse querySuperDeviceGroupWithOptions(shared_ptr<QuerySuperDeviceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySuperDeviceGroupResponse querySuperDeviceGroup(shared_ptr<QuerySuperDeviceGroupRequest> request);
  QueryTaskResponse queryTaskWithOptions(shared_ptr<QueryTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTaskResponse queryTask(shared_ptr<QueryTaskRequest> request);
  QueryThingModelResponse queryThingModelWithOptions(shared_ptr<QueryThingModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryThingModelResponse queryThingModel(shared_ptr<QueryThingModelRequest> request);
  QueryThingModelExtendConfigResponse queryThingModelExtendConfigWithOptions(shared_ptr<QueryThingModelExtendConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryThingModelExtendConfigResponse queryThingModelExtendConfig(shared_ptr<QueryThingModelExtendConfigRequest> request);
  QueryThingModelExtendConfigPublishedResponse queryThingModelExtendConfigPublishedWithOptions(shared_ptr<QueryThingModelExtendConfigPublishedRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryThingModelExtendConfigPublishedResponse queryThingModelExtendConfigPublished(shared_ptr<QueryThingModelExtendConfigPublishedRequest> request);
  QueryThingModelPublishedResponse queryThingModelPublishedWithOptions(shared_ptr<QueryThingModelPublishedRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryThingModelPublishedResponse queryThingModelPublished(shared_ptr<QueryThingModelPublishedRequest> request);
  QueryTopicReverseRouteTableResponse queryTopicReverseRouteTableWithOptions(shared_ptr<QueryTopicReverseRouteTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTopicReverseRouteTableResponse queryTopicReverseRouteTable(shared_ptr<QueryTopicReverseRouteTableRequest> request);
  QueryTopicRouteTableResponse queryTopicRouteTableWithOptions(shared_ptr<QueryTopicRouteTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTopicRouteTableResponse queryTopicRouteTable(shared_ptr<QueryTopicRouteTableRequest> request);
  RefreshDeviceTunnelSharePasswordResponse refreshDeviceTunnelSharePasswordWithOptions(shared_ptr<RefreshDeviceTunnelSharePasswordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefreshDeviceTunnelSharePasswordResponse refreshDeviceTunnelSharePassword(shared_ptr<RefreshDeviceTunnelSharePasswordRequest> request);
  RegisterDeviceResponse registerDeviceWithOptions(shared_ptr<RegisterDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RegisterDeviceResponse registerDevice(shared_ptr<RegisterDeviceRequest> request);
  ReleaseEdgeDriverVersionResponse releaseEdgeDriverVersionWithOptions(shared_ptr<ReleaseEdgeDriverVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseEdgeDriverVersionResponse releaseEdgeDriverVersion(shared_ptr<ReleaseEdgeDriverVersionRequest> request);
  RemoveThingTopoResponse removeThingTopoWithOptions(shared_ptr<RemoveThingTopoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveThingTopoResponse removeThingTopo(shared_ptr<RemoveThingTopoRequest> request);
  ReplaceEdgeInstanceGatewayResponse replaceEdgeInstanceGatewayWithOptions(shared_ptr<ReplaceEdgeInstanceGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReplaceEdgeInstanceGatewayResponse replaceEdgeInstanceGateway(shared_ptr<ReplaceEdgeInstanceGatewayRequest> request);
  ResetConsumerGroupPositionResponse resetConsumerGroupPositionWithOptions(shared_ptr<ResetConsumerGroupPositionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetConsumerGroupPositionResponse resetConsumerGroupPosition(shared_ptr<ResetConsumerGroupPositionRequest> request);
  ResetThingResponse resetThingWithOptions(shared_ptr<ResetThingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetThingResponse resetThing(shared_ptr<ResetThingRequest> request);
  RRpcResponse rRpcWithOptions(shared_ptr<RRpcRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RRpcResponse rRpc(shared_ptr<RRpcRequest> request);
  SaveDevicePropResponse saveDevicePropWithOptions(shared_ptr<SaveDevicePropRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveDevicePropResponse saveDeviceProp(shared_ptr<SaveDevicePropRequest> request);
  SetDeviceDesiredPropertyResponse setDeviceDesiredPropertyWithOptions(shared_ptr<SetDeviceDesiredPropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDeviceDesiredPropertyResponse setDeviceDesiredProperty(shared_ptr<SetDeviceDesiredPropertyRequest> request);
  SetDeviceGroupTagsResponse setDeviceGroupTagsWithOptions(shared_ptr<SetDeviceGroupTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDeviceGroupTagsResponse setDeviceGroupTags(shared_ptr<SetDeviceGroupTagsRequest> request);
  SetDevicePropertyResponse setDevicePropertyWithOptions(shared_ptr<SetDevicePropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDevicePropertyResponse setDeviceProperty(shared_ptr<SetDevicePropertyRequest> request);
  SetDevicesPropertyResponse setDevicesPropertyWithOptions(shared_ptr<SetDevicesPropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDevicesPropertyResponse setDevicesProperty(shared_ptr<SetDevicesPropertyRequest> request);
  SetEdgeInstanceDriverConfigsResponse setEdgeInstanceDriverConfigsWithOptions(shared_ptr<SetEdgeInstanceDriverConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetEdgeInstanceDriverConfigsResponse setEdgeInstanceDriverConfigs(shared_ptr<SetEdgeInstanceDriverConfigsRequest> request);
  SetProductCertInfoResponse setProductCertInfoWithOptions(shared_ptr<SetProductCertInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetProductCertInfoResponse setProductCertInfo(shared_ptr<SetProductCertInfoRequest> request);
  SpeechByCombinationResponse speechByCombinationWithOptions(shared_ptr<SpeechByCombinationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SpeechByCombinationResponse speechByCombination(shared_ptr<SpeechByCombinationRequest> request);
  StartCpuResponse startCpuWithOptions(shared_ptr<StartCpuRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartCpuResponse startCpu(shared_ptr<StartCpuRequest> request);
  StartRuleResponse startRuleWithOptions(shared_ptr<StartRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartRuleResponse startRule(shared_ptr<StartRuleRequest> request);
  StopRuleResponse stopRuleWithOptions(shared_ptr<StopRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopRuleResponse stopRule(shared_ptr<StopRuleRequest> request);
  SyncSpeechByCombinationResponse syncSpeechByCombinationWithOptions(shared_ptr<SyncSpeechByCombinationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SyncSpeechByCombinationResponse syncSpeechByCombination(shared_ptr<SyncSpeechByCombinationRequest> request);
  TriggerSceneRuleResponse triggerSceneRuleWithOptions(shared_ptr<TriggerSceneRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TriggerSceneRuleResponse triggerSceneRule(shared_ptr<TriggerSceneRuleRequest> request);
  UnbindApplicationFromEdgeInstanceResponse unbindApplicationFromEdgeInstanceWithOptions(shared_ptr<UnbindApplicationFromEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindApplicationFromEdgeInstanceResponse unbindApplicationFromEdgeInstance(shared_ptr<UnbindApplicationFromEdgeInstanceRequest> request);
  UnbindDriverFromEdgeInstanceResponse unbindDriverFromEdgeInstanceWithOptions(shared_ptr<UnbindDriverFromEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindDriverFromEdgeInstanceResponse unbindDriverFromEdgeInstance(shared_ptr<UnbindDriverFromEdgeInstanceRequest> request);
  UnbindRoleFromEdgeInstanceResponse unbindRoleFromEdgeInstanceWithOptions(shared_ptr<UnbindRoleFromEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindRoleFromEdgeInstanceResponse unbindRoleFromEdgeInstance(shared_ptr<UnbindRoleFromEdgeInstanceRequest> request);
  UnbindSceneRuleFromEdgeInstanceResponse unbindSceneRuleFromEdgeInstanceWithOptions(shared_ptr<UnbindSceneRuleFromEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindSceneRuleFromEdgeInstanceResponse unbindSceneRuleFromEdgeInstance(shared_ptr<UnbindSceneRuleFromEdgeInstanceRequest> request);
  UpdateConsumerGroupResponse updateConsumerGroupWithOptions(shared_ptr<UpdateConsumerGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateConsumerGroupResponse updateConsumerGroup(shared_ptr<UpdateConsumerGroupRequest> request);
  UpdateDeviceGroupResponse updateDeviceGroupWithOptions(shared_ptr<UpdateDeviceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDeviceGroupResponse updateDeviceGroup(shared_ptr<UpdateDeviceGroupRequest> request);
  UpdateDeviceShadowResponse updateDeviceShadowWithOptions(shared_ptr<UpdateDeviceShadowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDeviceShadowResponse updateDeviceShadow(shared_ptr<UpdateDeviceShadowRequest> request);
  UpdateEdgeDriverVersionResponse updateEdgeDriverVersionWithOptions(shared_ptr<UpdateEdgeDriverVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEdgeDriverVersionResponse updateEdgeDriverVersion(shared_ptr<UpdateEdgeDriverVersionRequest> request);
  UpdateEdgeInstanceResponse updateEdgeInstanceWithOptions(shared_ptr<UpdateEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEdgeInstanceResponse updateEdgeInstance(shared_ptr<UpdateEdgeInstanceRequest> request);
  UpdateEdgeInstanceChannelResponse updateEdgeInstanceChannelWithOptions(shared_ptr<UpdateEdgeInstanceChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEdgeInstanceChannelResponse updateEdgeInstanceChannel(shared_ptr<UpdateEdgeInstanceChannelRequest> request);
  UpdateEdgeInstanceMessageRoutingResponse updateEdgeInstanceMessageRoutingWithOptions(shared_ptr<UpdateEdgeInstanceMessageRoutingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEdgeInstanceMessageRoutingResponse updateEdgeInstanceMessageRouting(shared_ptr<UpdateEdgeInstanceMessageRoutingRequest> request);
  UpdateJobResponse updateJobWithOptions(shared_ptr<UpdateJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateJobResponse updateJob(shared_ptr<UpdateJobRequest> request);
  UpdateOTAModuleResponse updateOTAModuleWithOptions(shared_ptr<UpdateOTAModuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateOTAModuleResponse updateOTAModule(shared_ptr<UpdateOTAModuleRequest> request);
  UpdateProductResponse updateProductWithOptions(shared_ptr<UpdateProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProductResponse updateProduct(shared_ptr<UpdateProductRequest> request);
  UpdateProductFilterConfigResponse updateProductFilterConfigWithOptions(shared_ptr<UpdateProductFilterConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProductFilterConfigResponse updateProductFilterConfig(shared_ptr<UpdateProductFilterConfigRequest> request);
  UpdateProductTagsResponse updateProductTagsWithOptions(shared_ptr<UpdateProductTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProductTagsResponse updateProductTags(shared_ptr<UpdateProductTagsRequest> request);
  UpdateProductTopicResponse updateProductTopicWithOptions(shared_ptr<UpdateProductTopicRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProductTopicResponse updateProductTopic(shared_ptr<UpdateProductTopicRequest> request);
  UpdateRuleResponse updateRuleWithOptions(shared_ptr<UpdateRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRuleResponse updateRule(shared_ptr<UpdateRuleRequest> request);
  UpdateRuleActionResponse updateRuleActionWithOptions(shared_ptr<UpdateRuleActionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRuleActionResponse updateRuleAction(shared_ptr<UpdateRuleActionRequest> request);
  UpdateSceneRuleResponse updateSceneRuleWithOptions(shared_ptr<UpdateSceneRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSceneRuleResponse updateSceneRule(shared_ptr<UpdateSceneRuleRequest> request);
  UpdateSubscribeRelationResponse updateSubscribeRelationWithOptions(shared_ptr<UpdateSubscribeRelationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSubscribeRelationResponse updateSubscribeRelation(shared_ptr<UpdateSubscribeRelationRequest> request);
  UpdateThingModelResponse updateThingModelWithOptions(shared_ptr<UpdateThingModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateThingModelResponse updateThingModel(shared_ptr<UpdateThingModelRequest> request);
  UpdateThingModelValidationConfigResponse updateThingModelValidationConfigWithOptions(shared_ptr<UpdateThingModelValidationConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateThingModelValidationConfigResponse updateThingModelValidationConfig(shared_ptr<UpdateThingModelValidationConfigRequest> request);
  UpdateThingScriptResponse updateThingScriptWithOptions(shared_ptr<UpdateThingScriptRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateThingScriptResponse updateThingScript(shared_ptr<UpdateThingScriptRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Iot20180120

#endif
