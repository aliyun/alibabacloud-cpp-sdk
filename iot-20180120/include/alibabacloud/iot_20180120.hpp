// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_IOT20180120_H_
#define ALIBABACLOUD_IOT20180120_H_

#include <alibabacloud/rpc.hpp>
#include <boost/any.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Iot20180120 {
class ListAnalyticsDataRequestCondition : public Darabonba::Model {
public:
  shared_ptr<string> fieldName{};
  shared_ptr<string> operate{};
  shared_ptr<string> value{};
  shared_ptr<string> betweenStart{};
  shared_ptr<string> betweenEnd{};

  ListAnalyticsDataRequestCondition() {}

  explicit ListAnalyticsDataRequestCondition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!fieldName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fieldName is required.")));
    }
    if (!operate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("operate is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    if (operate) {
      res["Operate"] = boost::any(*operate);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (betweenStart) {
      res["BetweenStart"] = boost::any(*betweenStart);
    }
    if (betweenEnd) {
      res["BetweenEnd"] = boost::any(*betweenEnd);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
    if (m.find("Operate") != m.end() && !m["Operate"].empty()) {
      operate = make_shared<string>(boost::any_cast<string>(m["Operate"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("BetweenStart") != m.end() && !m["BetweenStart"].empty()) {
      betweenStart = make_shared<string>(boost::any_cast<string>(m["BetweenStart"]));
    }
    if (m.find("BetweenEnd") != m.end() && !m["BetweenEnd"].empty()) {
      betweenEnd = make_shared<string>(boost::any_cast<string>(m["BetweenEnd"]));
    }
  }


  virtual ~ListAnalyticsDataRequestCondition() = default;
};
class ListAnalyticsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> isoId{};
  shared_ptr<string> apiPath{};
  shared_ptr<int> pageSize{};
  shared_ptr<vector<ListAnalyticsDataRequestCondition>> condition{};
  shared_ptr<int> pageNum{};

  ListAnalyticsDataRequest() {}

  explicit ListAnalyticsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!iotInstanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotInstanceId is required.")));
    }
    if (!apiPath) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiPath is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (isoId) {
      res["IsoId"] = boost::any(*isoId);
    }
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (condition) {
      vector<boost::any> temp1;
      for(auto item1:*condition){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Condition"] = boost::any(temp1);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("IsoId") != m.end() && !m["IsoId"].empty()) {
      isoId = make_shared<string>(boost::any_cast<string>(m["IsoId"]));
    }
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      if (typeid(vector<boost::any>) == m["Condition"].type()) {
        vector<ListAnalyticsDataRequestCondition> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Condition"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAnalyticsDataRequestCondition model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        condition = make_shared<vector<ListAnalyticsDataRequestCondition>>(expect1);
      }
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<int>(boost::any_cast<int>(m["PageNum"]));
    }
  }


  virtual ~ListAnalyticsDataRequest() = default;
};
class ListAnalyticsDataResponseData : public Darabonba::Model {
public:
  shared_ptr<bool> hasNext{};
  shared_ptr<string> resultJson{};
  shared_ptr<long> count{};
  shared_ptr<int> pageNum{};
  shared_ptr<int> pageSize{};

  ListAnalyticsDataResponseData() {}

  explicit ListAnalyticsDataResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!hasNext) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("hasNext is required.")));
    }
    if (!resultJson) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("resultJson is required.")));
    }
    if (!count) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("count is required.")));
    }
    if (!pageNum) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNum is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasNext) {
      res["HasNext"] = boost::any(*hasNext);
    }
    if (resultJson) {
      res["ResultJson"] = boost::any(*resultJson);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HasNext") != m.end() && !m["HasNext"].empty()) {
      hasNext = make_shared<bool>(boost::any_cast<bool>(m["HasNext"]));
    }
    if (m.find("ResultJson") != m.end() && !m["ResultJson"].empty()) {
      resultJson = make_shared<string>(boost::any_cast<string>(m["ResultJson"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<int>(boost::any_cast<int>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
  }


  virtual ~ListAnalyticsDataResponseData() = default;
};
class ListAnalyticsDataResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<ListAnalyticsDataResponseData> data{};

  ListAnalyticsDataResponse() {}

  explicit ListAnalyticsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListAnalyticsDataResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListAnalyticsDataResponseData>(model1);
      }
    }
  }


  virtual ~ListAnalyticsDataResponse() = default;
};
class BatchBindDevicesIntoProjectRequestDevices : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};

  BatchBindDevicesIntoProjectRequestDevices() {}

  explicit BatchBindDevicesIntoProjectRequestDevices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
  }


  virtual ~BatchBindDevicesIntoProjectRequestDevices() = default;
};
class BatchBindDevicesIntoProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<BatchBindDevicesIntoProjectRequestDevices>> devices{};
  shared_ptr<string> projectId{};

  BatchBindDevicesIntoProjectRequest() {}

  explicit BatchBindDevicesIntoProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!devices) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("devices is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (devices) {
      vector<boost::any> temp1;
      for(auto item1:*devices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Devices"] = boost::any(temp1);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Devices") != m.end() && !m["Devices"].empty()) {
      if (typeid(vector<boost::any>) == m["Devices"].type()) {
        vector<BatchBindDevicesIntoProjectRequestDevices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Devices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchBindDevicesIntoProjectRequestDevices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        devices = make_shared<vector<BatchBindDevicesIntoProjectRequestDevices>>(expect1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~BatchBindDevicesIntoProjectRequest() = default;
};
class BatchBindDevicesIntoProjectResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> data{};

  BatchBindDevicesIntoProjectResponse() {}

  explicit BatchBindDevicesIntoProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~BatchBindDevicesIntoProjectResponse() = default;
};
class BatchBindProductsIntoProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<string>> productKeys{};
  shared_ptr<string> projectId{};

  BatchBindProductsIntoProjectRequest() {}

  explicit BatchBindProductsIntoProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKeys) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKeys is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKeys) {
      res["ProductKeys"] = boost::any(*productKeys);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKeys") != m.end() && !m["ProductKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProductKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProductKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      productKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~BatchBindProductsIntoProjectRequest() = default;
};
class BatchBindProductsIntoProjectResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> data{};

  BatchBindProductsIntoProjectResponse() {}

  explicit BatchBindProductsIntoProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~BatchBindProductsIntoProjectResponse() = default;
};
class BatchUnbindProjectDevicesRequestDevices : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};

  BatchUnbindProjectDevicesRequestDevices() {}

  explicit BatchUnbindProjectDevicesRequestDevices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
  }


  virtual ~BatchUnbindProjectDevicesRequestDevices() = default;
};
class BatchUnbindProjectDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<BatchUnbindProjectDevicesRequestDevices>> devices{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> projectId{};

  BatchUnbindProjectDevicesRequest() {}

  explicit BatchUnbindProjectDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!devices) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("devices is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (devices) {
      vector<boost::any> temp1;
      for(auto item1:*devices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Devices"] = boost::any(temp1);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Devices") != m.end() && !m["Devices"].empty()) {
      if (typeid(vector<boost::any>) == m["Devices"].type()) {
        vector<BatchUnbindProjectDevicesRequestDevices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Devices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchUnbindProjectDevicesRequestDevices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        devices = make_shared<vector<BatchUnbindProjectDevicesRequestDevices>>(expect1);
      }
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~BatchUnbindProjectDevicesRequest() = default;
};
class BatchUnbindProjectDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> data{};

  BatchUnbindProjectDevicesResponse() {}

  explicit BatchUnbindProjectDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~BatchUnbindProjectDevicesResponse() = default;
};
class BatchUnbindProjectProductsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<string>> productKeys{};
  shared_ptr<string> projectId{};

  BatchUnbindProjectProductsRequest() {}

  explicit BatchUnbindProjectProductsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKeys) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKeys is required.")));
    }
    if (!projectId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("projectId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKeys) {
      res["ProductKeys"] = boost::any(*productKeys);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKeys") != m.end() && !m["ProductKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProductKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProductKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      productKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~BatchUnbindProjectProductsRequest() = default;
};
class BatchUnbindProjectProductsResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> data{};

  BatchUnbindProjectProductsResponse() {}

  explicit BatchUnbindProjectProductsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~BatchUnbindProjectProductsResponse() = default;
};
class SyncSpeechByCombinationRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> combinationList{};
  shared_ptr<string> iotId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotInstanceId{};

  SyncSpeechByCombinationRequest() {}

  explicit SyncSpeechByCombinationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!combinationList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("combinationList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (combinationList) {
      res["CombinationList"] = boost::any(*combinationList);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CombinationList") != m.end() && !m["CombinationList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CombinationList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CombinationList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      combinationList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~SyncSpeechByCombinationRequest() = default;
};
class SyncSpeechByCombinationResponseData : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<int> retryCount{};

  SyncSpeechByCombinationResponseData() {}

  explicit SyncSpeechByCombinationResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!id) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("id is required.")));
    }
    if (!retryCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("retryCount is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<int>(boost::any_cast<int>(m["RetryCount"]));
    }
  }


  virtual ~SyncSpeechByCombinationResponseData() = default;
};
class SyncSpeechByCombinationResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<SyncSpeechByCombinationResponseData> data{};

  SyncSpeechByCombinationResponse() {}

  explicit SyncSpeechByCombinationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SyncSpeechByCombinationResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SyncSpeechByCombinationResponseData>(model1);
      }
    }
  }


  virtual ~SyncSpeechByCombinationResponse() = default;
};
class OpenIotServiceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};

  OpenIotServiceRequest() {}

  explicit OpenIotServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~OpenIotServiceRequest() = default;
};
class OpenIotServiceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> orderId{};

  OpenIotServiceResponse() {}

  explicit OpenIotServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!orderId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("orderId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
  }


  virtual ~OpenIotServiceResponse() = default;
};
class CreateRulengDistributeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> targetInstanceId{};

  CreateRulengDistributeJobRequest() {}

  explicit CreateRulengDistributeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!sourceInstanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sourceInstanceId is required.")));
    }
    if (!targetInstanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetInstanceId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
  }


  virtual ~CreateRulengDistributeJobRequest() = default;
};
class CreateRulengDistributeJobResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  CreateRulengDistributeJobResponse() {}

  explicit CreateRulengDistributeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CreateRulengDistributeJobResponse() = default;
};
class ListTaskByPageRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> pageNo{};
  shared_ptr<string> jobId{};
  shared_ptr<map<string, boost::any>> device{};
  shared_ptr<string> status{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> jobName{};

  ListTaskByPageRequest() {}

  explicit ListTaskByPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!pageNo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<string>(boost::any_cast<string>(m["PageNo"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Device"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      device = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
  }


  virtual ~ListTaskByPageRequest() = default;
};
class ListTaskByPageShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> pageNo{};
  shared_ptr<string> jobId{};
  shared_ptr<string> deviceShrink{};
  shared_ptr<string> status{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> jobName{};

  ListTaskByPageShrinkRequest() {}

  explicit ListTaskByPageShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!pageNo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (deviceShrink) {
      res["Device"] = boost::any(*deviceShrink);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<string>(boost::any_cast<string>(m["PageNo"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      deviceShrink = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
  }


  virtual ~ListTaskByPageShrinkRequest() = default;
};
class ListTaskByPageResponseDataData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> jobName{};
  shared_ptr<string> taskId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<int> progress{};
  shared_ptr<string> utcQueueTime{};
  shared_ptr<string> utcModified{};
  shared_ptr<string> statusDetail{};
  shared_ptr<string> status{};
  shared_ptr<string> productName{};

  ListTaskByPageResponseDataData() {}

  explicit ListTaskByPageResponseDataData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
    if (!jobName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobName is required.")));
    }
    if (!taskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskId is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!iotId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotId is required.")));
    }
    if (!progress) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("progress is required.")));
    }
    if (!utcQueueTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcQueueTime is required.")));
    }
    if (!utcModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcModified is required.")));
    }
    if (!statusDetail) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusDetail is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!productName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (utcQueueTime) {
      res["UtcQueueTime"] = boost::any(*utcQueueTime);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (statusDetail) {
      res["StatusDetail"] = boost::any(*statusDetail);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<int>(boost::any_cast<int>(m["Progress"]));
    }
    if (m.find("UtcQueueTime") != m.end() && !m["UtcQueueTime"].empty()) {
      utcQueueTime = make_shared<string>(boost::any_cast<string>(m["UtcQueueTime"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("StatusDetail") != m.end() && !m["StatusDetail"].empty()) {
      statusDetail = make_shared<string>(boost::any_cast<string>(m["StatusDetail"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
  }


  virtual ~ListTaskByPageResponseDataData() = default;
};
class ListTaskByPageResponseData : public Darabonba::Model {
public:
  shared_ptr<vector<ListTaskByPageResponseDataData>> data{};

  ListTaskByPageResponseData() {}

  explicit ListTaskByPageResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListTaskByPageResponseDataData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTaskByPageResponseDataData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListTaskByPageResponseDataData>>(expect1);
      }
    }
  }


  virtual ~ListTaskByPageResponseData() = default;
};
class ListTaskByPageResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> total{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> pageCount{};
  shared_ptr<int> page{};
  shared_ptr<ListTaskByPageResponseData> data{};

  ListTaskByPageResponse() {}

  explicit ListTaskByPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!pageCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageCount is required.")));
    }
    if (!page) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("page is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<int>(boost::any_cast<int>(m["PageCount"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<int>(boost::any_cast<int>(m["Page"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListTaskByPageResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListTaskByPageResponseData>(model1);
      }
    }
  }


  virtual ~ListTaskByPageResponse() = default;
};
class ListTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<int> limit{};
  shared_ptr<string> jobId{};
  shared_ptr<string> nextToken{};
  shared_ptr<map<string, boost::any>> device{};
  shared_ptr<string> status{};

  ListTaskRequest() {}

  explicit ListTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!limit) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("limit is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<int>(boost::any_cast<int>(m["Limit"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Device"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      device = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListTaskRequest() = default;
};
class ListTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<int> limit{};
  shared_ptr<string> jobId{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> deviceShrink{};
  shared_ptr<string> status{};

  ListTaskShrinkRequest() {}

  explicit ListTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!limit) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("limit is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (deviceShrink) {
      res["Device"] = boost::any(*deviceShrink);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<int>(boost::any_cast<int>(m["Limit"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      deviceShrink = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListTaskShrinkRequest() = default;
};
class ListTaskResponseDataData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> jobName{};
  shared_ptr<string> taskId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> progress{};
  shared_ptr<string> utcQueueTime{};
  shared_ptr<string> utcModified{};
  shared_ptr<string> status{};

  ListTaskResponseDataData() {}

  explicit ListTaskResponseDataData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
    if (!jobName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobName is required.")));
    }
    if (!taskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskId is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!iotId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotId is required.")));
    }
    if (!progress) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("progress is required.")));
    }
    if (!utcQueueTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcQueueTime is required.")));
    }
    if (!utcModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcModified is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (utcQueueTime) {
      res["UtcQueueTime"] = boost::any(*utcQueueTime);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("UtcQueueTime") != m.end() && !m["UtcQueueTime"].empty()) {
      utcQueueTime = make_shared<string>(boost::any_cast<string>(m["UtcQueueTime"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListTaskResponseDataData() = default;
};
class ListTaskResponseData : public Darabonba::Model {
public:
  shared_ptr<vector<ListTaskResponseDataData>> data{};

  ListTaskResponseData() {}

  explicit ListTaskResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListTaskResponseDataData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTaskResponseDataData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListTaskResponseDataData>>(expect1);
      }
    }
  }


  virtual ~ListTaskResponseData() = default;
};
class ListTaskResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> nextToken{};
  shared_ptr<ListTaskResponseData> data{};

  ListTaskResponse() {}

  explicit ListTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!nextToken) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nextToken is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListTaskResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListTaskResponseData>(model1);
      }
    }
  }


  virtual ~ListTaskResponse() = default;
};
class QueryJobStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobId{};

  QueryJobStatisticsRequest() {}

  explicit QueryJobStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~QueryJobStatisticsRequest() = default;
};
class QueryJobStatisticsResponseData : public Darabonba::Model {
public:
  shared_ptr<int> total{};
  shared_ptr<int> queued{};
  shared_ptr<int> sent{};
  shared_ptr<int> inProgress{};
  shared_ptr<int> succeeded{};
  shared_ptr<int> failed{};
  shared_ptr<int> rejected{};
  shared_ptr<int> timeOut{};
  shared_ptr<int> cancelled{};

  QueryJobStatisticsResponseData() {}

  explicit QueryJobStatisticsResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!queued) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("queued is required.")));
    }
    if (!sent) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sent is required.")));
    }
    if (!inProgress) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("inProgress is required.")));
    }
    if (!succeeded) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("succeeded is required.")));
    }
    if (!failed) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("failed is required.")));
    }
    if (!rejected) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("rejected is required.")));
    }
    if (!timeOut) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("timeOut is required.")));
    }
    if (!cancelled) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("cancelled is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (queued) {
      res["Queued"] = boost::any(*queued);
    }
    if (sent) {
      res["Sent"] = boost::any(*sent);
    }
    if (inProgress) {
      res["InProgress"] = boost::any(*inProgress);
    }
    if (succeeded) {
      res["Succeeded"] = boost::any(*succeeded);
    }
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (rejected) {
      res["Rejected"] = boost::any(*rejected);
    }
    if (timeOut) {
      res["TimeOut"] = boost::any(*timeOut);
    }
    if (cancelled) {
      res["Cancelled"] = boost::any(*cancelled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("Queued") != m.end() && !m["Queued"].empty()) {
      queued = make_shared<int>(boost::any_cast<int>(m["Queued"]));
    }
    if (m.find("Sent") != m.end() && !m["Sent"].empty()) {
      sent = make_shared<int>(boost::any_cast<int>(m["Sent"]));
    }
    if (m.find("InProgress") != m.end() && !m["InProgress"].empty()) {
      inProgress = make_shared<int>(boost::any_cast<int>(m["InProgress"]));
    }
    if (m.find("Succeeded") != m.end() && !m["Succeeded"].empty()) {
      succeeded = make_shared<int>(boost::any_cast<int>(m["Succeeded"]));
    }
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<int>(boost::any_cast<int>(m["Failed"]));
    }
    if (m.find("Rejected") != m.end() && !m["Rejected"].empty()) {
      rejected = make_shared<int>(boost::any_cast<int>(m["Rejected"]));
    }
    if (m.find("TimeOut") != m.end() && !m["TimeOut"].empty()) {
      timeOut = make_shared<int>(boost::any_cast<int>(m["TimeOut"]));
    }
    if (m.find("Cancelled") != m.end() && !m["Cancelled"].empty()) {
      cancelled = make_shared<int>(boost::any_cast<int>(m["Cancelled"]));
    }
  }


  virtual ~QueryJobStatisticsResponseData() = default;
};
class QueryJobStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryJobStatisticsResponseData> data{};

  QueryJobStatisticsResponse() {}

  explicit QueryJobStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryJobStatisticsResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryJobStatisticsResponseData>(model1);
      }
    }
  }


  virtual ~QueryJobStatisticsResponse() = default;
};
class DeleteJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobId{};

  DeleteJobRequest() {}

  explicit DeleteJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~DeleteJobRequest() = default;
};
class DeleteJobResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteJobResponse() {}

  explicit DeleteJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteJobResponse() = default;
};
class CancelJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobId{};

  CancelJobRequest() {}

  explicit CancelJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~CancelJobRequest() = default;
};
class CancelJobResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  CancelJobResponse() {}

  explicit CancelJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CancelJobResponse() = default;
};
class ListJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> status{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> currentPage{};

  ListJobRequest() {}

  explicit ListJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
  }


  virtual ~ListJobRequest() = default;
};
class ListJobResponseDataData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> jobName{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> utcModified{};
  shared_ptr<string> status{};
  shared_ptr<string> description{};
  shared_ptr<string> type{};

  ListJobResponseDataData() {}

  explicit ListJobResponseDataData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
    if (!jobName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobName is required.")));
    }
    if (!utcCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcCreate is required.")));
    }
    if (!utcModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcModified is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!description) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("description is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListJobResponseDataData() = default;
};
class ListJobResponseData : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseDataData>> data{};

  ListJobResponseData() {}

  explicit ListJobResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListJobResponseDataData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseDataData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListJobResponseDataData>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseData() = default;
};
class ListJobResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> total{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> page{};
  shared_ptr<ListJobResponseData> data{};

  ListJobResponse() {}

  explicit ListJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!page) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("page is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<int>(boost::any_cast<int>(m["Page"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListJobResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListJobResponseData>(model1);
      }
    }
  }


  virtual ~ListJobResponse() = default;
};
class QueryJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobId{};

  QueryJobRequest() {}

  explicit QueryJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~QueryJobRequest() = default;
};
class QueryJobResponseDataRolloutConfig : public Darabonba::Model {
public:
  shared_ptr<int> maximumPerMinute{};

  QueryJobResponseDataRolloutConfig() {}

  explicit QueryJobResponseDataRolloutConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!maximumPerMinute) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("maximumPerMinute is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maximumPerMinute) {
      res["MaximumPerMinute"] = boost::any(*maximumPerMinute);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaximumPerMinute") != m.end() && !m["MaximumPerMinute"].empty()) {
      maximumPerMinute = make_shared<int>(boost::any_cast<int>(m["MaximumPerMinute"]));
    }
  }


  virtual ~QueryJobResponseDataRolloutConfig() = default;
};
class QueryJobResponseDataTimeoutConfig : public Darabonba::Model {
public:
  shared_ptr<int> inProgressTimeoutInMinutes{};

  QueryJobResponseDataTimeoutConfig() {}

  explicit QueryJobResponseDataTimeoutConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!inProgressTimeoutInMinutes) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("inProgressTimeoutInMinutes is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inProgressTimeoutInMinutes) {
      res["InProgressTimeoutInMinutes"] = boost::any(*inProgressTimeoutInMinutes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InProgressTimeoutInMinutes") != m.end() && !m["InProgressTimeoutInMinutes"].empty()) {
      inProgressTimeoutInMinutes = make_shared<int>(boost::any_cast<int>(m["InProgressTimeoutInMinutes"]));
    }
  }


  virtual ~QueryJobResponseDataTimeoutConfig() = default;
};
class QueryJobResponseDataJobFile : public Darabonba::Model {
public:
  shared_ptr<string> fileUrl{};
  shared_ptr<string> signMethod{};
  shared_ptr<string> sign{};

  QueryJobResponseDataJobFile() {}

  explicit QueryJobResponseDataJobFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!fileUrl) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileUrl is required.")));
    }
    if (!signMethod) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("signMethod is required.")));
    }
    if (!sign) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sign is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (signMethod) {
      res["SignMethod"] = boost::any(*signMethod);
    }
    if (sign) {
      res["Sign"] = boost::any(*sign);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("SignMethod") != m.end() && !m["SignMethod"].empty()) {
      signMethod = make_shared<string>(boost::any_cast<string>(m["SignMethod"]));
    }
    if (m.find("Sign") != m.end() && !m["Sign"].empty()) {
      sign = make_shared<string>(boost::any_cast<string>(m["Sign"]));
    }
  }


  virtual ~QueryJobResponseDataJobFile() = default;
};
class QueryJobResponseDataTargetConfigTargetDevicesTargetDevices : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};

  QueryJobResponseDataTargetConfigTargetDevicesTargetDevices() {}

  explicit QueryJobResponseDataTargetConfigTargetDevicesTargetDevices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
  }


  virtual ~QueryJobResponseDataTargetConfigTargetDevicesTargetDevices() = default;
};
class QueryJobResponseDataTargetConfigTargetDevices : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobResponseDataTargetConfigTargetDevicesTargetDevices>> targetDevices{};

  QueryJobResponseDataTargetConfigTargetDevices() {}

  explicit QueryJobResponseDataTargetConfigTargetDevices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!targetDevices) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetDevices is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetDevices) {
      vector<boost::any> temp1;
      for(auto item1:*targetDevices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["targetDevices"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("targetDevices") != m.end() && !m["targetDevices"].empty()) {
      if (typeid(vector<boost::any>) == m["targetDevices"].type()) {
        vector<QueryJobResponseDataTargetConfigTargetDevicesTargetDevices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["targetDevices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobResponseDataTargetConfigTargetDevicesTargetDevices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targetDevices = make_shared<vector<QueryJobResponseDataTargetConfigTargetDevicesTargetDevices>>(expect1);
      }
    }
  }


  virtual ~QueryJobResponseDataTargetConfigTargetDevices() = default;
};
class QueryJobResponseDataTargetConfig : public Darabonba::Model {
public:
  shared_ptr<string> targetGroup{};
  shared_ptr<string> targetProduct{};
  shared_ptr<string> targetType{};
  shared_ptr<QueryJobResponseDataTargetConfigTargetDevices> targetDevices{};

  QueryJobResponseDataTargetConfig() {}

  explicit QueryJobResponseDataTargetConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!targetGroup) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetGroup is required.")));
    }
    if (!targetProduct) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetProduct is required.")));
    }
    if (!targetType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetType is required.")));
    }
    if (!targetDevices) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetDevices is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetGroup) {
      res["TargetGroup"] = boost::any(*targetGroup);
    }
    if (targetProduct) {
      res["TargetProduct"] = boost::any(*targetProduct);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (targetDevices) {
      res["TargetDevices"] = targetDevices ? boost::any(targetDevices->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetGroup") != m.end() && !m["TargetGroup"].empty()) {
      targetGroup = make_shared<string>(boost::any_cast<string>(m["TargetGroup"]));
    }
    if (m.find("TargetProduct") != m.end() && !m["TargetProduct"].empty()) {
      targetProduct = make_shared<string>(boost::any_cast<string>(m["TargetProduct"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("TargetDevices") != m.end() && !m["TargetDevices"].empty()) {
      if (typeid(map<string, boost::any>) == m["TargetDevices"].type()) {
        QueryJobResponseDataTargetConfigTargetDevices model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TargetDevices"]));
        targetDevices = make_shared<QueryJobResponseDataTargetConfigTargetDevices>(model1);
      }
    }
  }


  virtual ~QueryJobResponseDataTargetConfig() = default;
};
class QueryJobResponseData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> jobName{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> status{};
  shared_ptr<string> description{};
  shared_ptr<string> type{};
  shared_ptr<string> jobDocument{};
  shared_ptr<string> utcModified{};
  shared_ptr<QueryJobResponseDataRolloutConfig> rolloutConfig{};
  shared_ptr<QueryJobResponseDataTimeoutConfig> timeoutConfig{};
  shared_ptr<QueryJobResponseDataJobFile> jobFile{};
  shared_ptr<QueryJobResponseDataTargetConfig> targetConfig{};

  QueryJobResponseData() {}

  explicit QueryJobResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
    if (!jobName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobName is required.")));
    }
    if (!utcCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcCreate is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!description) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("description is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
    if (!jobDocument) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobDocument is required.")));
    }
    if (!utcModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcModified is required.")));
    }
    if (!rolloutConfig) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("rolloutConfig is required.")));
    }
    if (!timeoutConfig) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("timeoutConfig is required.")));
    }
    if (!jobFile) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobFile is required.")));
    }
    if (!targetConfig) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetConfig is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (jobDocument) {
      res["JobDocument"] = boost::any(*jobDocument);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (rolloutConfig) {
      res["RolloutConfig"] = rolloutConfig ? boost::any(rolloutConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeoutConfig) {
      res["TimeoutConfig"] = timeoutConfig ? boost::any(timeoutConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobFile) {
      res["JobFile"] = jobFile ? boost::any(jobFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (targetConfig) {
      res["TargetConfig"] = targetConfig ? boost::any(targetConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("JobDocument") != m.end() && !m["JobDocument"].empty()) {
      jobDocument = make_shared<string>(boost::any_cast<string>(m["JobDocument"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("RolloutConfig") != m.end() && !m["RolloutConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RolloutConfig"].type()) {
        QueryJobResponseDataRolloutConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RolloutConfig"]));
        rolloutConfig = make_shared<QueryJobResponseDataRolloutConfig>(model1);
      }
    }
    if (m.find("TimeoutConfig") != m.end() && !m["TimeoutConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeoutConfig"].type()) {
        QueryJobResponseDataTimeoutConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeoutConfig"]));
        timeoutConfig = make_shared<QueryJobResponseDataTimeoutConfig>(model1);
      }
    }
    if (m.find("JobFile") != m.end() && !m["JobFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobFile"].type()) {
        QueryJobResponseDataJobFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobFile"]));
        jobFile = make_shared<QueryJobResponseDataJobFile>(model1);
      }
    }
    if (m.find("TargetConfig") != m.end() && !m["TargetConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TargetConfig"].type()) {
        QueryJobResponseDataTargetConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TargetConfig"]));
        targetConfig = make_shared<QueryJobResponseDataTargetConfig>(model1);
      }
    }
  }


  virtual ~QueryJobResponseData() = default;
};
class QueryJobResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryJobResponseData> data{};

  QueryJobResponse() {}

  explicit QueryJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryJobResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryJobResponseData>(model1);
      }
    }
  }


  virtual ~QueryJobResponse() = default;
};
class UpdateJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> description{};
  shared_ptr<map<string, boost::any>> timeoutConfig{};
  shared_ptr<map<string, boost::any>> rolloutConfig{};
  shared_ptr<string> jobId{};

  UpdateJobRequest() {}

  explicit UpdateJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (timeoutConfig) {
      res["TimeoutConfig"] = boost::any(*timeoutConfig);
    }
    if (rolloutConfig) {
      res["RolloutConfig"] = boost::any(*rolloutConfig);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("TimeoutConfig") != m.end() && !m["TimeoutConfig"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["TimeoutConfig"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      timeoutConfig = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RolloutConfig") != m.end() && !m["RolloutConfig"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["RolloutConfig"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      rolloutConfig = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~UpdateJobRequest() = default;
};
class UpdateJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> description{};
  shared_ptr<string> timeoutConfigShrink{};
  shared_ptr<string> rolloutConfigShrink{};
  shared_ptr<string> jobId{};

  UpdateJobShrinkRequest() {}

  explicit UpdateJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (timeoutConfigShrink) {
      res["TimeoutConfig"] = boost::any(*timeoutConfigShrink);
    }
    if (rolloutConfigShrink) {
      res["RolloutConfig"] = boost::any(*rolloutConfigShrink);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("TimeoutConfig") != m.end() && !m["TimeoutConfig"].empty()) {
      timeoutConfigShrink = make_shared<string>(boost::any_cast<string>(m["TimeoutConfig"]));
    }
    if (m.find("RolloutConfig") != m.end() && !m["RolloutConfig"].empty()) {
      rolloutConfigShrink = make_shared<string>(boost::any_cast<string>(m["RolloutConfig"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~UpdateJobShrinkRequest() = default;
};
class UpdateJobResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateJobResponse() {}

  explicit UpdateJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateJobResponse() = default;
};
class CreateJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> description{};
  shared_ptr<string> jobDocument{};
  shared_ptr<string> type{};
  shared_ptr<map<string, boost::any>> jobFile{};
  shared_ptr<string> jobName{};
  shared_ptr<map<string, boost::any>> timeoutConfig{};
  shared_ptr<map<string, boost::any>> rolloutConfig{};
  shared_ptr<map<string, boost::any>> targetConfig{};

  CreateJobRequest() {}

  explicit CreateJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!jobDocument) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobDocument is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
    if (!jobName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobName is required.")));
    }
    if (!targetConfig) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetConfig is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (jobDocument) {
      res["JobDocument"] = boost::any(*jobDocument);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (jobFile) {
      res["JobFile"] = boost::any(*jobFile);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (timeoutConfig) {
      res["TimeoutConfig"] = boost::any(*timeoutConfig);
    }
    if (rolloutConfig) {
      res["RolloutConfig"] = boost::any(*rolloutConfig);
    }
    if (targetConfig) {
      res["TargetConfig"] = boost::any(*targetConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("JobDocument") != m.end() && !m["JobDocument"].empty()) {
      jobDocument = make_shared<string>(boost::any_cast<string>(m["JobDocument"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("JobFile") != m.end() && !m["JobFile"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["JobFile"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      jobFile = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("TimeoutConfig") != m.end() && !m["TimeoutConfig"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["TimeoutConfig"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      timeoutConfig = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RolloutConfig") != m.end() && !m["RolloutConfig"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["RolloutConfig"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      rolloutConfig = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("TargetConfig") != m.end() && !m["TargetConfig"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["TargetConfig"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      targetConfig = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~CreateJobRequest() = default;
};
class CreateJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> description{};
  shared_ptr<string> jobDocument{};
  shared_ptr<string> type{};
  shared_ptr<string> jobFileShrink{};
  shared_ptr<string> jobName{};
  shared_ptr<string> timeoutConfigShrink{};
  shared_ptr<string> rolloutConfigShrink{};
  shared_ptr<string> targetConfigShrink{};

  CreateJobShrinkRequest() {}

  explicit CreateJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!jobDocument) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobDocument is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
    if (!jobName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobName is required.")));
    }
    if (!targetConfigShrink) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetConfigShrink is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (jobDocument) {
      res["JobDocument"] = boost::any(*jobDocument);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (jobFileShrink) {
      res["JobFile"] = boost::any(*jobFileShrink);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (timeoutConfigShrink) {
      res["TimeoutConfig"] = boost::any(*timeoutConfigShrink);
    }
    if (rolloutConfigShrink) {
      res["RolloutConfig"] = boost::any(*rolloutConfigShrink);
    }
    if (targetConfigShrink) {
      res["TargetConfig"] = boost::any(*targetConfigShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("JobDocument") != m.end() && !m["JobDocument"].empty()) {
      jobDocument = make_shared<string>(boost::any_cast<string>(m["JobDocument"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("JobFile") != m.end() && !m["JobFile"].empty()) {
      jobFileShrink = make_shared<string>(boost::any_cast<string>(m["JobFile"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("TimeoutConfig") != m.end() && !m["TimeoutConfig"].empty()) {
      timeoutConfigShrink = make_shared<string>(boost::any_cast<string>(m["TimeoutConfig"]));
    }
    if (m.find("RolloutConfig") != m.end() && !m["RolloutConfig"].empty()) {
      rolloutConfigShrink = make_shared<string>(boost::any_cast<string>(m["RolloutConfig"]));
    }
    if (m.find("TargetConfig") != m.end() && !m["TargetConfig"].empty()) {
      targetConfigShrink = make_shared<string>(boost::any_cast<string>(m["TargetConfig"]));
    }
  }


  virtual ~CreateJobShrinkRequest() = default;
};
class CreateJobResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> jobId{};

  CreateJobResponse() {}

  explicit CreateJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~CreateJobResponse() = default;
};
class GenerateFileUploadURLRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> fileSuffix{};
  shared_ptr<string> bizCode{};

  GenerateFileUploadURLRequest() {}

  explicit GenerateFileUploadURLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!fileSuffix) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileSuffix is required.")));
    }
    if (!bizCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizCode is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (fileSuffix) {
      res["FileSuffix"] = boost::any(*fileSuffix);
    }
    if (bizCode) {
      res["BizCode"] = boost::any(*bizCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("FileSuffix") != m.end() && !m["FileSuffix"].empty()) {
      fileSuffix = make_shared<string>(boost::any_cast<string>(m["FileSuffix"]));
    }
    if (m.find("BizCode") != m.end() && !m["BizCode"].empty()) {
      bizCode = make_shared<string>(boost::any_cast<string>(m["BizCode"]));
    }
  }


  virtual ~GenerateFileUploadURLRequest() = default;
};
class GenerateFileUploadURLResponseData : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> host{};
  shared_ptr<string> policy{};
  shared_ptr<string> ossAccessKeyId{};
  shared_ptr<string> signature{};
  shared_ptr<string> objectStorage{};

  GenerateFileUploadURLResponseData() {}

  explicit GenerateFileUploadURLResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!key) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("key is required.")));
    }
    if (!host) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("host is required.")));
    }
    if (!policy) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("policy is required.")));
    }
    if (!ossAccessKeyId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ossAccessKeyId is required.")));
    }
    if (!signature) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("signature is required.")));
    }
    if (!objectStorage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("objectStorage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (ossAccessKeyId) {
      res["OssAccessKeyId"] = boost::any(*ossAccessKeyId);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    if (objectStorage) {
      res["ObjectStorage"] = boost::any(*objectStorage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("OssAccessKeyId") != m.end() && !m["OssAccessKeyId"].empty()) {
      ossAccessKeyId = make_shared<string>(boost::any_cast<string>(m["OssAccessKeyId"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
    if (m.find("ObjectStorage") != m.end() && !m["ObjectStorage"].empty()) {
      objectStorage = make_shared<string>(boost::any_cast<string>(m["ObjectStorage"]));
    }
  }


  virtual ~GenerateFileUploadURLResponseData() = default;
};
class GenerateFileUploadURLResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GenerateFileUploadURLResponseData> data{};

  GenerateFileUploadURLResponse() {}

  explicit GenerateFileUploadURLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GenerateFileUploadURLResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GenerateFileUploadURLResponseData>(model1);
      }
    }
  }


  virtual ~GenerateFileUploadURLResponse() = default;
};
class CreateProductDistributeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> targetInstanceId{};
  shared_ptr<string> targetUid{};
  shared_ptr<string> targetAliyunId{};

  CreateProductDistributeJobRequest() {}

  explicit CreateProductDistributeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!sourceInstanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sourceInstanceId is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!targetInstanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetInstanceId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    if (targetUid) {
      res["TargetUid"] = boost::any(*targetUid);
    }
    if (targetAliyunId) {
      res["TargetAliyunId"] = boost::any(*targetAliyunId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
    if (m.find("TargetUid") != m.end() && !m["TargetUid"].empty()) {
      targetUid = make_shared<string>(boost::any_cast<string>(m["TargetUid"]));
    }
    if (m.find("TargetAliyunId") != m.end() && !m["TargetAliyunId"].empty()) {
      targetAliyunId = make_shared<string>(boost::any_cast<string>(m["TargetAliyunId"]));
    }
  }


  virtual ~CreateProductDistributeJobRequest() = default;
};
class CreateProductDistributeJobResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> jobId{};

  CreateProductDistributeJobResponse() {}

  explicit CreateProductDistributeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~CreateProductDistributeJobResponse() = default;
};
class QueryDeviceOriginalPropertyDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> startTime{};
  shared_ptr<string> identifier{};
  shared_ptr<int> asc{};
  shared_ptr<string> iotId{};
  shared_ptr<long> endTime{};

  QueryDeviceOriginalPropertyDataRequest() {}

  explicit QueryDeviceOriginalPropertyDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!startTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("startTime is required.")));
    }
    if (!identifier) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("identifier is required.")));
    }
    if (!asc) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("asc is required.")));
    }
    if (!endTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endTime is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<int>(boost::any_cast<int>(m["Asc"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
  }


  virtual ~QueryDeviceOriginalPropertyDataRequest() = default;
};
class QueryDeviceOriginalPropertyDataResponseDataListPropertyInfo : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> value{};

  QueryDeviceOriginalPropertyDataResponseDataListPropertyInfo() {}

  explicit QueryDeviceOriginalPropertyDataResponseDataListPropertyInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!time) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("time is required.")));
    }
    if (!value) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("value is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryDeviceOriginalPropertyDataResponseDataListPropertyInfo() = default;
};
class QueryDeviceOriginalPropertyDataResponseDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceOriginalPropertyDataResponseDataListPropertyInfo>> propertyInfo{};

  QueryDeviceOriginalPropertyDataResponseDataList() {}

  explicit QueryDeviceOriginalPropertyDataResponseDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!propertyInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("propertyInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertyInfo) {
      vector<boost::any> temp1;
      for(auto item1:*propertyInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertyInfo") != m.end() && !m["PropertyInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyInfo"].type()) {
        vector<QueryDeviceOriginalPropertyDataResponseDataListPropertyInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceOriginalPropertyDataResponseDataListPropertyInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyInfo = make_shared<vector<QueryDeviceOriginalPropertyDataResponseDataListPropertyInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceOriginalPropertyDataResponseDataList() = default;
};
class QueryDeviceOriginalPropertyDataResponseData : public Darabonba::Model {
public:
  shared_ptr<bool> nextValid{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<QueryDeviceOriginalPropertyDataResponseDataList> list{};

  QueryDeviceOriginalPropertyDataResponseData() {}

  explicit QueryDeviceOriginalPropertyDataResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nextValid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nextValid is required.")));
    }
    if (!nextPageToken) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nextPageToken is required.")));
    }
    if (!list) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("list is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextValid) {
      res["NextValid"] = boost::any(*nextValid);
    }
    if (nextPageToken) {
      res["nextPageToken"] = boost::any(*nextPageToken);
    }
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextValid") != m.end() && !m["NextValid"].empty()) {
      nextValid = make_shared<bool>(boost::any_cast<bool>(m["NextValid"]));
    }
    if (m.find("nextPageToken") != m.end() && !m["nextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["nextPageToken"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDeviceOriginalPropertyDataResponseDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDeviceOriginalPropertyDataResponseDataList>(model1);
      }
    }
  }


  virtual ~QueryDeviceOriginalPropertyDataResponseData() = default;
};
class QueryDeviceOriginalPropertyDataResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceOriginalPropertyDataResponseData> data{};

  QueryDeviceOriginalPropertyDataResponse() {}

  explicit QueryDeviceOriginalPropertyDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceOriginalPropertyDataResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceOriginalPropertyDataResponseData>(model1);
      }
    }
  }


  virtual ~QueryDeviceOriginalPropertyDataResponse() = default;
};
class QueryDeviceOriginalEventDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> startTime{};
  shared_ptr<string> identifier{};
  shared_ptr<int> asc{};
  shared_ptr<string> iotId{};
  shared_ptr<long> endTime{};

  QueryDeviceOriginalEventDataRequest() {}

  explicit QueryDeviceOriginalEventDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!startTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("startTime is required.")));
    }
    if (!identifier) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("identifier is required.")));
    }
    if (!asc) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("asc is required.")));
    }
    if (!endTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endTime is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<int>(boost::any_cast<int>(m["Asc"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
  }


  virtual ~QueryDeviceOriginalEventDataRequest() = default;
};
class QueryDeviceOriginalEventDataResponseDataListEventInfo : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> identifier{};
  shared_ptr<string> name{};
  shared_ptr<string> eventType{};
  shared_ptr<string> outputData{};

  QueryDeviceOriginalEventDataResponseDataListEventInfo() {}

  explicit QueryDeviceOriginalEventDataResponseDataListEventInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!time) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("time is required.")));
    }
    if (!identifier) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("identifier is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!eventType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("eventType is required.")));
    }
    if (!outputData) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("outputData is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (outputData) {
      res["OutputData"] = boost::any(*outputData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("OutputData") != m.end() && !m["OutputData"].empty()) {
      outputData = make_shared<string>(boost::any_cast<string>(m["OutputData"]));
    }
  }


  virtual ~QueryDeviceOriginalEventDataResponseDataListEventInfo() = default;
};
class QueryDeviceOriginalEventDataResponseDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceOriginalEventDataResponseDataListEventInfo>> eventInfo{};

  QueryDeviceOriginalEventDataResponseDataList() {}

  explicit QueryDeviceOriginalEventDataResponseDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!eventInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("eventInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventInfo) {
      vector<boost::any> temp1;
      for(auto item1:*eventInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventInfo") != m.end() && !m["EventInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["EventInfo"].type()) {
        vector<QueryDeviceOriginalEventDataResponseDataListEventInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceOriginalEventDataResponseDataListEventInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventInfo = make_shared<vector<QueryDeviceOriginalEventDataResponseDataListEventInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceOriginalEventDataResponseDataList() = default;
};
class QueryDeviceOriginalEventDataResponseData : public Darabonba::Model {
public:
  shared_ptr<string> nextPageToken{};
  shared_ptr<bool> nextValid{};
  shared_ptr<QueryDeviceOriginalEventDataResponseDataList> list{};

  QueryDeviceOriginalEventDataResponseData() {}

  explicit QueryDeviceOriginalEventDataResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nextPageToken) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nextPageToken is required.")));
    }
    if (!nextValid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nextValid is required.")));
    }
    if (!list) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("list is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (nextValid) {
      res["NextValid"] = boost::any(*nextValid);
    }
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("NextValid") != m.end() && !m["NextValid"].empty()) {
      nextValid = make_shared<bool>(boost::any_cast<bool>(m["NextValid"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDeviceOriginalEventDataResponseDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDeviceOriginalEventDataResponseDataList>(model1);
      }
    }
  }


  virtual ~QueryDeviceOriginalEventDataResponseData() = default;
};
class QueryDeviceOriginalEventDataResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceOriginalEventDataResponseData> data{};

  QueryDeviceOriginalEventDataResponse() {}

  explicit QueryDeviceOriginalEventDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceOriginalEventDataResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceOriginalEventDataResponseData>(model1);
      }
    }
  }


  virtual ~QueryDeviceOriginalEventDataResponse() = default;
};
class QueryDeviceOriginalPropertyStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> iotId{};
  shared_ptr<int> asc{};

  QueryDeviceOriginalPropertyStatusRequest() {}

  explicit QueryDeviceOriginalPropertyStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!asc) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("asc is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<int>(boost::any_cast<int>(m["Asc"]));
    }
  }


  virtual ~QueryDeviceOriginalPropertyStatusRequest() = default;
};
class QueryDeviceOriginalPropertyStatusResponseDataListPropertyStatusDataInfo : public Darabonba::Model {
public:
  shared_ptr<string> identifier{};
  shared_ptr<string> value{};
  shared_ptr<long> time{};

  QueryDeviceOriginalPropertyStatusResponseDataListPropertyStatusDataInfo() {}

  explicit QueryDeviceOriginalPropertyStatusResponseDataListPropertyStatusDataInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!identifier) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("identifier is required.")));
    }
    if (!value) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("value is required.")));
    }
    if (!time) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("time is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
  }


  virtual ~QueryDeviceOriginalPropertyStatusResponseDataListPropertyStatusDataInfo() = default;
};
class QueryDeviceOriginalPropertyStatusResponseDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceOriginalPropertyStatusResponseDataListPropertyStatusDataInfo>> propertyStatusDataInfo{};

  QueryDeviceOriginalPropertyStatusResponseDataList() {}

  explicit QueryDeviceOriginalPropertyStatusResponseDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!propertyStatusDataInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("propertyStatusDataInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertyStatusDataInfo) {
      vector<boost::any> temp1;
      for(auto item1:*propertyStatusDataInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyStatusDataInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertyStatusDataInfo") != m.end() && !m["PropertyStatusDataInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyStatusDataInfo"].type()) {
        vector<QueryDeviceOriginalPropertyStatusResponseDataListPropertyStatusDataInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyStatusDataInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceOriginalPropertyStatusResponseDataListPropertyStatusDataInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyStatusDataInfo = make_shared<vector<QueryDeviceOriginalPropertyStatusResponseDataListPropertyStatusDataInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceOriginalPropertyStatusResponseDataList() = default;
};
class QueryDeviceOriginalPropertyStatusResponseData : public Darabonba::Model {
public:
  shared_ptr<bool> nextValid{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<QueryDeviceOriginalPropertyStatusResponseDataList> list{};

  QueryDeviceOriginalPropertyStatusResponseData() {}

  explicit QueryDeviceOriginalPropertyStatusResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nextValid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nextValid is required.")));
    }
    if (!nextPageToken) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nextPageToken is required.")));
    }
    if (!list) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("list is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextValid) {
      res["NextValid"] = boost::any(*nextValid);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextValid") != m.end() && !m["NextValid"].empty()) {
      nextValid = make_shared<bool>(boost::any_cast<bool>(m["NextValid"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDeviceOriginalPropertyStatusResponseDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDeviceOriginalPropertyStatusResponseDataList>(model1);
      }
    }
  }


  virtual ~QueryDeviceOriginalPropertyStatusResponseData() = default;
};
class QueryDeviceOriginalPropertyStatusResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceOriginalPropertyStatusResponseData> data{};

  QueryDeviceOriginalPropertyStatusResponse() {}

  explicit QueryDeviceOriginalPropertyStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceOriginalPropertyStatusResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceOriginalPropertyStatusResponseData>(model1);
      }
    }
  }


  virtual ~QueryDeviceOriginalPropertyStatusResponse() = default;
};
class QueryDeviceOriginalServiceDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> startTime{};
  shared_ptr<string> identifier{};
  shared_ptr<int> asc{};
  shared_ptr<string> iotId{};
  shared_ptr<long> endTime{};

  QueryDeviceOriginalServiceDataRequest() {}

  explicit QueryDeviceOriginalServiceDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!startTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("startTime is required.")));
    }
    if (!identifier) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("identifier is required.")));
    }
    if (!asc) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("asc is required.")));
    }
    if (!endTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endTime is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<int>(boost::any_cast<int>(m["Asc"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
  }


  virtual ~QueryDeviceOriginalServiceDataRequest() = default;
};
class QueryDeviceOriginalServiceDataResponseDataListServiceInfo : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> identifier{};
  shared_ptr<string> name{};
  shared_ptr<string> inputData{};
  shared_ptr<string> outputData{};

  QueryDeviceOriginalServiceDataResponseDataListServiceInfo() {}

  explicit QueryDeviceOriginalServiceDataResponseDataListServiceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!time) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("time is required.")));
    }
    if (!identifier) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("identifier is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!inputData) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("inputData is required.")));
    }
    if (!outputData) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("outputData is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (inputData) {
      res["InputData"] = boost::any(*inputData);
    }
    if (outputData) {
      res["OutputData"] = boost::any(*outputData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("InputData") != m.end() && !m["InputData"].empty()) {
      inputData = make_shared<string>(boost::any_cast<string>(m["InputData"]));
    }
    if (m.find("OutputData") != m.end() && !m["OutputData"].empty()) {
      outputData = make_shared<string>(boost::any_cast<string>(m["OutputData"]));
    }
  }


  virtual ~QueryDeviceOriginalServiceDataResponseDataListServiceInfo() = default;
};
class QueryDeviceOriginalServiceDataResponseDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceOriginalServiceDataResponseDataListServiceInfo>> serviceInfo{};

  QueryDeviceOriginalServiceDataResponseDataList() {}

  explicit QueryDeviceOriginalServiceDataResponseDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!serviceInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("serviceInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*serviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceInfo") != m.end() && !m["ServiceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceInfo"].type()) {
        vector<QueryDeviceOriginalServiceDataResponseDataListServiceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceOriginalServiceDataResponseDataListServiceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceInfo = make_shared<vector<QueryDeviceOriginalServiceDataResponseDataListServiceInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceOriginalServiceDataResponseDataList() = default;
};
class QueryDeviceOriginalServiceDataResponseData : public Darabonba::Model {
public:
  shared_ptr<string> nextPageToken{};
  shared_ptr<bool> nextValid{};
  shared_ptr<QueryDeviceOriginalServiceDataResponseDataList> list{};

  QueryDeviceOriginalServiceDataResponseData() {}

  explicit QueryDeviceOriginalServiceDataResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nextPageToken) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nextPageToken is required.")));
    }
    if (!nextValid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nextValid is required.")));
    }
    if (!list) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("list is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (nextValid) {
      res["NextValid"] = boost::any(*nextValid);
    }
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("NextValid") != m.end() && !m["NextValid"].empty()) {
      nextValid = make_shared<bool>(boost::any_cast<bool>(m["NextValid"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDeviceOriginalServiceDataResponseDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDeviceOriginalServiceDataResponseDataList>(model1);
      }
    }
  }


  virtual ~QueryDeviceOriginalServiceDataResponseData() = default;
};
class QueryDeviceOriginalServiceDataResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceOriginalServiceDataResponseData> data{};

  QueryDeviceOriginalServiceDataResponse() {}

  explicit QueryDeviceOriginalServiceDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceOriginalServiceDataResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceOriginalServiceDataResponseData>(model1);
      }
    }
  }


  virtual ~QueryDeviceOriginalServiceDataResponse() = default;
};
class CreateThingScriptRequest : public Darabonba::Model {
public:
  shared_ptr<string> scriptContent{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> scriptType{};

  CreateThingScriptRequest() {}

  explicit CreateThingScriptRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!scriptContent) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("scriptContent is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!scriptType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("scriptType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scriptContent) {
      res["ScriptContent"] = boost::any(*scriptContent);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (scriptType) {
      res["ScriptType"] = boost::any(*scriptType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScriptContent") != m.end() && !m["ScriptContent"].empty()) {
      scriptContent = make_shared<string>(boost::any_cast<string>(m["ScriptContent"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ScriptType") != m.end() && !m["ScriptType"].empty()) {
      scriptType = make_shared<string>(boost::any_cast<string>(m["ScriptType"]));
    }
  }


  virtual ~CreateThingScriptRequest() = default;
};
class CreateThingScriptResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  CreateThingScriptResponse() {}

  explicit CreateThingScriptResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CreateThingScriptResponse() = default;
};
class UpdateThingScriptRequest : public Darabonba::Model {
public:
  shared_ptr<string> scriptContent{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> scriptType{};

  UpdateThingScriptRequest() {}

  explicit UpdateThingScriptRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!scriptContent) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("scriptContent is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!scriptType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("scriptType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scriptContent) {
      res["ScriptContent"] = boost::any(*scriptContent);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (scriptType) {
      res["ScriptType"] = boost::any(*scriptType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScriptContent") != m.end() && !m["ScriptContent"].empty()) {
      scriptContent = make_shared<string>(boost::any_cast<string>(m["ScriptContent"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ScriptType") != m.end() && !m["ScriptType"].empty()) {
      scriptType = make_shared<string>(boost::any_cast<string>(m["ScriptType"]));
    }
  }


  virtual ~UpdateThingScriptRequest() = default;
};
class UpdateThingScriptResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateThingScriptResponse() {}

  explicit UpdateThingScriptResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateThingScriptResponse() = default;
};
class GetThingScriptRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  GetThingScriptRequest() {}

  explicit GetThingScriptRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~GetThingScriptRequest() = default;
};
class GetThingScriptResponseData : public Darabonba::Model {
public:
  shared_ptr<string> scriptType{};
  shared_ptr<string> scriptUrl{};

  GetThingScriptResponseData() {}

  explicit GetThingScriptResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!scriptType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("scriptType is required.")));
    }
    if (!scriptUrl) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("scriptUrl is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scriptType) {
      res["ScriptType"] = boost::any(*scriptType);
    }
    if (scriptUrl) {
      res["ScriptUrl"] = boost::any(*scriptUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScriptType") != m.end() && !m["ScriptType"].empty()) {
      scriptType = make_shared<string>(boost::any_cast<string>(m["ScriptType"]));
    }
    if (m.find("ScriptUrl") != m.end() && !m["ScriptUrl"].empty()) {
      scriptUrl = make_shared<string>(boost::any_cast<string>(m["ScriptUrl"]));
    }
  }


  virtual ~GetThingScriptResponseData() = default;
};
class GetThingScriptResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetThingScriptResponseData> data{};

  GetThingScriptResponse() {}

  explicit GetThingScriptResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetThingScriptResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetThingScriptResponseData>(model1);
      }
    }
  }


  virtual ~GetThingScriptResponse() = default;
};
class ListOTAModuleVersionsByDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<int> currentPage{};

  ListOTAModuleVersionsByDeviceRequest() {}

  explicit ListOTAModuleVersionsByDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
  }


  virtual ~ListOTAModuleVersionsByDeviceRequest() = default;
};
class ListOTAModuleVersionsByDeviceResponseDataSimpleOTAModuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> moduleVersion{};
  shared_ptr<string> moduleName{};

  ListOTAModuleVersionsByDeviceResponseDataSimpleOTAModuleInfo() {}

  explicit ListOTAModuleVersionsByDeviceResponseDataSimpleOTAModuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!iotId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotId is required.")));
    }
    if (!moduleVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("moduleVersion is required.")));
    }
    if (!moduleName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("moduleName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (moduleVersion) {
      res["ModuleVersion"] = boost::any(*moduleVersion);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("ModuleVersion") != m.end() && !m["ModuleVersion"].empty()) {
      moduleVersion = make_shared<string>(boost::any_cast<string>(m["ModuleVersion"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
  }


  virtual ~ListOTAModuleVersionsByDeviceResponseDataSimpleOTAModuleInfo() = default;
};
class ListOTAModuleVersionsByDeviceResponseData : public Darabonba::Model {
public:
  shared_ptr<vector<ListOTAModuleVersionsByDeviceResponseDataSimpleOTAModuleInfo>> simpleOTAModuleInfo{};

  ListOTAModuleVersionsByDeviceResponseData() {}

  explicit ListOTAModuleVersionsByDeviceResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!simpleOTAModuleInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("simpleOTAModuleInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (simpleOTAModuleInfo) {
      vector<boost::any> temp1;
      for(auto item1:*simpleOTAModuleInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SimpleOTAModuleInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SimpleOTAModuleInfo") != m.end() && !m["SimpleOTAModuleInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SimpleOTAModuleInfo"].type()) {
        vector<ListOTAModuleVersionsByDeviceResponseDataSimpleOTAModuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SimpleOTAModuleInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOTAModuleVersionsByDeviceResponseDataSimpleOTAModuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        simpleOTAModuleInfo = make_shared<vector<ListOTAModuleVersionsByDeviceResponseDataSimpleOTAModuleInfo>>(expect1);
      }
    }
  }


  virtual ~ListOTAModuleVersionsByDeviceResponseData() = default;
};
class ListOTAModuleVersionsByDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> total{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> pageCount{};
  shared_ptr<int> currentPage{};
  shared_ptr<ListOTAModuleVersionsByDeviceResponseData> data{};

  ListOTAModuleVersionsByDeviceResponse() {}

  explicit ListOTAModuleVersionsByDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!pageCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageCount is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<int>(boost::any_cast<int>(m["PageCount"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListOTAModuleVersionsByDeviceResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListOTAModuleVersionsByDeviceResponseData>(model1);
      }
    }
  }


  virtual ~ListOTAModuleVersionsByDeviceResponse() = default;
};
class BatchPubRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<string>> deviceName{};
  shared_ptr<string> productKey{};
  shared_ptr<int> qos{};
  shared_ptr<string> topicShortName{};
  shared_ptr<string> messageContent{};

  BatchPubRequest() {}

  explicit BatchPubRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!topicShortName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topicShortName is required.")));
    }
    if (!messageContent) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("messageContent is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (qos) {
      res["Qos"] = boost::any(*qos);
    }
    if (topicShortName) {
      res["TopicShortName"] = boost::any(*topicShortName);
    }
    if (messageContent) {
      res["MessageContent"] = boost::any(*messageContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Qos") != m.end() && !m["Qos"].empty()) {
      qos = make_shared<int>(boost::any_cast<int>(m["Qos"]));
    }
    if (m.find("TopicShortName") != m.end() && !m["TopicShortName"].empty()) {
      topicShortName = make_shared<string>(boost::any_cast<string>(m["TopicShortName"]));
    }
    if (m.find("MessageContent") != m.end() && !m["MessageContent"].empty()) {
      messageContent = make_shared<string>(boost::any_cast<string>(m["MessageContent"]));
    }
  }


  virtual ~BatchPubRequest() = default;
};
class BatchPubResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  BatchPubResponse() {}

  explicit BatchPubResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~BatchPubResponse() = default;
};
class SpeechByCombinationRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> combinationList{};
  shared_ptr<string> iotId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotInstanceId{};

  SpeechByCombinationRequest() {}

  explicit SpeechByCombinationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!combinationList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("combinationList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (combinationList) {
      res["CombinationList"] = boost::any(*combinationList);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CombinationList") != m.end() && !m["CombinationList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CombinationList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CombinationList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      combinationList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~SpeechByCombinationRequest() = default;
};
class SpeechByCombinationResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  SpeechByCombinationResponse() {}

  explicit SpeechByCombinationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~SpeechByCombinationResponse() = default;
};
class UpdateThingModelValidationConfigRequest : public Darabonba::Model {
public:
  shared_ptr<int> validateType{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  UpdateThingModelValidationConfigRequest() {}

  explicit UpdateThingModelValidationConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!validateType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("validateType is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (validateType) {
      res["ValidateType"] = boost::any(*validateType);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ValidateType") != m.end() && !m["ValidateType"].empty()) {
      validateType = make_shared<int>(boost::any_cast<int>(m["ValidateType"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~UpdateThingModelValidationConfigRequest() = default;
};
class UpdateThingModelValidationConfigResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateThingModelValidationConfigResponse() {}

  explicit UpdateThingModelValidationConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateThingModelValidationConfigResponse() = default;
};
class QueryDeviceBySQLRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> SQL{};

  QueryDeviceBySQLRequest() {}

  explicit QueryDeviceBySQLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!iotInstanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotInstanceId is required.")));
    }
    if (!SQL) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("SQL is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (SQL) {
      res["SQL"] = boost::any(*SQL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("SQL") != m.end() && !m["SQL"].empty()) {
      SQL = make_shared<string>(boost::any_cast<string>(m["SQL"]));
    }
  }


  virtual ~QueryDeviceBySQLRequest() = default;
};
class QueryDeviceBySQLResponseDataGroups : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};

  QueryDeviceBySQLResponseDataGroups() {}

  explicit QueryDeviceBySQLResponseDataGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~QueryDeviceBySQLResponseDataGroups() = default;
};
class QueryDeviceBySQLResponseDataTags : public Darabonba::Model {
public:
  shared_ptr<string> tagName{};
  shared_ptr<string> tagValue{};

  QueryDeviceBySQLResponseDataTags() {}

  explicit QueryDeviceBySQLResponseDataTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tagName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tagName is required.")));
    }
    if (!tagValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tagValue is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~QueryDeviceBySQLResponseDataTags() = default;
};
class QueryDeviceBySQLResponseDataOTAModules : public Darabonba::Model {
public:
  shared_ptr<string> moduleName{};
  shared_ptr<string> firmwareVersion{};

  QueryDeviceBySQLResponseDataOTAModules() {}

  explicit QueryDeviceBySQLResponseDataOTAModules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!moduleName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("moduleName is required.")));
    }
    if (!firmwareVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareVersion is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    if (firmwareVersion) {
      res["FirmwareVersion"] = boost::any(*firmwareVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
    if (m.find("FirmwareVersion") != m.end() && !m["FirmwareVersion"].empty()) {
      firmwareVersion = make_shared<string>(boost::any_cast<string>(m["FirmwareVersion"]));
    }
  }


  virtual ~QueryDeviceBySQLResponseDataOTAModules() = default;
};
class QueryDeviceBySQLResponseData : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> nickname{};
  shared_ptr<string> status{};
  shared_ptr<string> activeTime{};
  shared_ptr<string> iotId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<vector<QueryDeviceBySQLResponseDataGroups>> groups{};
  shared_ptr<vector<QueryDeviceBySQLResponseDataTags>> tags{};
  shared_ptr<vector<QueryDeviceBySQLResponseDataOTAModules>> OTAModules{};

  QueryDeviceBySQLResponseData() {}

  explicit QueryDeviceBySQLResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!nickname) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nickname is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!activeTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("activeTime is required.")));
    }
    if (!iotId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotId is required.")));
    }
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!gmtModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModified is required.")));
    }
    if (!groups) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groups is required.")));
    }
    if (!tags) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tags is required.")));
    }
    if (!OTAModules) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("OTAModules is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (activeTime) {
      res["ActiveTime"] = boost::any(*activeTime);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (groups) {
      vector<boost::any> temp1;
      for(auto item1:*groups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Groups"] = boost::any(temp1);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (OTAModules) {
      vector<boost::any> temp1;
      for(auto item1:*OTAModules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OTAModules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ActiveTime") != m.end() && !m["ActiveTime"].empty()) {
      activeTime = make_shared<string>(boost::any_cast<string>(m["ActiveTime"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Groups") != m.end() && !m["Groups"].empty()) {
      if (typeid(vector<boost::any>) == m["Groups"].type()) {
        vector<QueryDeviceBySQLResponseDataGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Groups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceBySQLResponseDataGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groups = make_shared<vector<QueryDeviceBySQLResponseDataGroups>>(expect1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<QueryDeviceBySQLResponseDataTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceBySQLResponseDataTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<QueryDeviceBySQLResponseDataTags>>(expect1);
      }
    }
    if (m.find("OTAModules") != m.end() && !m["OTAModules"].empty()) {
      if (typeid(vector<boost::any>) == m["OTAModules"].type()) {
        vector<QueryDeviceBySQLResponseDataOTAModules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OTAModules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceBySQLResponseDataOTAModules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        OTAModules = make_shared<vector<QueryDeviceBySQLResponseDataOTAModules>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceBySQLResponseData() = default;
};
class QueryDeviceBySQLResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<QueryDeviceBySQLResponseData>> data{};

  QueryDeviceBySQLResponse() {}

  explicit QueryDeviceBySQLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<QueryDeviceBySQLResponseData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceBySQLResponseData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<QueryDeviceBySQLResponseData>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceBySQLResponse() = default;
};
class ListOTAModuleByProductRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  ListOTAModuleByProductRequest() {}

  explicit ListOTAModuleByProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~ListOTAModuleByProductRequest() = default;
};
class ListOTAModuleByProductResponseData : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> moduleName{};
  shared_ptr<string> aliasName{};
  shared_ptr<string> desc{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};

  ListOTAModuleByProductResponseData() {}

  explicit ListOTAModuleByProductResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!moduleName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("moduleName is required.")));
    }
    if (!aliasName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("aliasName is required.")));
    }
    if (!desc) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("desc is required.")));
    }
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!gmtModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModified is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
  }


  virtual ~ListOTAModuleByProductResponseData() = default;
};
class ListOTAModuleByProductResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<ListOTAModuleByProductResponseData>> data{};

  ListOTAModuleByProductResponse() {}

  explicit ListOTAModuleByProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListOTAModuleByProductResponseData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOTAModuleByProductResponseData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListOTAModuleByProductResponseData>>(expect1);
      }
    }
  }


  virtual ~ListOTAModuleByProductResponse() = default;
};
class DeleteOTAModuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> moduleName{};

  DeleteOTAModuleRequest() {}

  explicit DeleteOTAModuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!moduleName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("moduleName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
  }


  virtual ~DeleteOTAModuleRequest() = default;
};
class DeleteOTAModuleResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteOTAModuleResponse() {}

  explicit DeleteOTAModuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteOTAModuleResponse() = default;
};
class GenerateDeviceNameListURLRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};

  GenerateDeviceNameListURLRequest() {}

  explicit GenerateDeviceNameListURLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~GenerateDeviceNameListURLRequest() = default;
};
class GenerateDeviceNameListURLResponseData : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> host{};
  shared_ptr<string> policy{};
  shared_ptr<string> accessKeyId{};
  shared_ptr<string> signature{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> objectStorage{};

  GenerateDeviceNameListURLResponseData() {}

  explicit GenerateDeviceNameListURLResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!key) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("key is required.")));
    }
    if (!host) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("host is required.")));
    }
    if (!policy) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("policy is required.")));
    }
    if (!accessKeyId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("accessKeyId is required.")));
    }
    if (!signature) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("signature is required.")));
    }
    if (!fileUrl) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileUrl is required.")));
    }
    if (!utcCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcCreate is required.")));
    }
    if (!objectStorage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("objectStorage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (accessKeyId) {
      res["AccessKeyId"] = boost::any(*accessKeyId);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (objectStorage) {
      res["ObjectStorage"] = boost::any(*objectStorage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("AccessKeyId") != m.end() && !m["AccessKeyId"].empty()) {
      accessKeyId = make_shared<string>(boost::any_cast<string>(m["AccessKeyId"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("ObjectStorage") != m.end() && !m["ObjectStorage"].empty()) {
      objectStorage = make_shared<string>(boost::any_cast<string>(m["ObjectStorage"]));
    }
  }


  virtual ~GenerateDeviceNameListURLResponseData() = default;
};
class GenerateDeviceNameListURLResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GenerateDeviceNameListURLResponseData> data{};

  GenerateDeviceNameListURLResponse() {}

  explicit GenerateDeviceNameListURLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GenerateDeviceNameListURLResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GenerateDeviceNameListURLResponseData>(model1);
      }
    }
  }


  virtual ~GenerateDeviceNameListURLResponse() = default;
};
class UpdateOTAModuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> moduleName{};
  shared_ptr<string> desc{};
  shared_ptr<string> productKey{};

  UpdateOTAModuleRequest() {}

  explicit UpdateOTAModuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!moduleName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("moduleName is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~UpdateOTAModuleRequest() = default;
};
class UpdateOTAModuleResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateOTAModuleResponse() {}

  explicit UpdateOTAModuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateOTAModuleResponse() = default;
};
class CreateOTAModuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> moduleName{};
  shared_ptr<string> desc{};
  shared_ptr<string> productKey{};

  CreateOTAModuleRequest() {}

  explicit CreateOTAModuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!moduleName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("moduleName is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~CreateOTAModuleRequest() = default;
};
class CreateOTAModuleResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  CreateOTAModuleResponse() {}

  explicit CreateOTAModuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CreateOTAModuleResponse() = default;
};
class QueryThingModelExtendConfigPublishedRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> modelVersion{};
  shared_ptr<string> functionBlockId{};

  QueryThingModelExtendConfigPublishedRequest() {}

  explicit QueryThingModelExtendConfigPublishedRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (modelVersion) {
      res["ModelVersion"] = boost::any(*modelVersion);
    }
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ModelVersion") != m.end() && !m["ModelVersion"].empty()) {
      modelVersion = make_shared<string>(boost::any_cast<string>(m["ModelVersion"]));
    }
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
  }


  virtual ~QueryThingModelExtendConfigPublishedRequest() = default;
};
class QueryThingModelExtendConfigPublishedResponseData : public Darabonba::Model {
public:
  shared_ptr<string> configuration{};

  QueryThingModelExtendConfigPublishedResponseData() {}

  explicit QueryThingModelExtendConfigPublishedResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!configuration) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("configuration is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configuration) {
      res["Configuration"] = boost::any(*configuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configuration = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
  }


  virtual ~QueryThingModelExtendConfigPublishedResponseData() = default;
};
class QueryThingModelExtendConfigPublishedResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryThingModelExtendConfigPublishedResponseData> data{};

  QueryThingModelExtendConfigPublishedResponse() {}

  explicit QueryThingModelExtendConfigPublishedResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryThingModelExtendConfigPublishedResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryThingModelExtendConfigPublishedResponseData>(model1);
      }
    }
  }


  virtual ~QueryThingModelExtendConfigPublishedResponse() = default;
};
class GetThingModelTslPublishedRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> simple{};
  shared_ptr<string> modelVersion{};
  shared_ptr<string> functionBlockId{};

  GetThingModelTslPublishedRequest() {}

  explicit GetThingModelTslPublishedRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (simple) {
      res["Simple"] = boost::any(*simple);
    }
    if (modelVersion) {
      res["ModelVersion"] = boost::any(*modelVersion);
    }
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Simple") != m.end() && !m["Simple"].empty()) {
      simple = make_shared<bool>(boost::any_cast<bool>(m["Simple"]));
    }
    if (m.find("ModelVersion") != m.end() && !m["ModelVersion"].empty()) {
      modelVersion = make_shared<string>(boost::any_cast<string>(m["ModelVersion"]));
    }
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
  }


  virtual ~GetThingModelTslPublishedRequest() = default;
};
class GetThingModelTslPublishedResponseData : public Darabonba::Model {
public:
  shared_ptr<string> tslStr{};
  shared_ptr<string> tslUri{};

  GetThingModelTslPublishedResponseData() {}

  explicit GetThingModelTslPublishedResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tslStr) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tslStr is required.")));
    }
    if (!tslUri) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tslUri is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tslStr) {
      res["TslStr"] = boost::any(*tslStr);
    }
    if (tslUri) {
      res["TslUri"] = boost::any(*tslUri);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TslStr") != m.end() && !m["TslStr"].empty()) {
      tslStr = make_shared<string>(boost::any_cast<string>(m["TslStr"]));
    }
    if (m.find("TslUri") != m.end() && !m["TslUri"].empty()) {
      tslUri = make_shared<string>(boost::any_cast<string>(m["TslUri"]));
    }
  }


  virtual ~GetThingModelTslPublishedResponseData() = default;
};
class GetThingModelTslPublishedResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetThingModelTslPublishedResponseData> data{};

  GetThingModelTslPublishedResponse() {}

  explicit GetThingModelTslPublishedResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetThingModelTslPublishedResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetThingModelTslPublishedResponseData>(model1);
      }
    }
  }


  virtual ~GetThingModelTslPublishedResponse() = default;
};
class QueryThingModelPublishedRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> modelVersion{};
  shared_ptr<string> functionBlockId{};

  QueryThingModelPublishedRequest() {}

  explicit QueryThingModelPublishedRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (modelVersion) {
      res["ModelVersion"] = boost::any(*modelVersion);
    }
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ModelVersion") != m.end() && !m["ModelVersion"].empty()) {
      modelVersion = make_shared<string>(boost::any_cast<string>(m["ModelVersion"]));
    }
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
  }


  virtual ~QueryThingModelPublishedRequest() = default;
};
class QueryThingModelPublishedResponseData : public Darabonba::Model {
public:
  shared_ptr<string> thingModelJson{};

  QueryThingModelPublishedResponseData() {}

  explicit QueryThingModelPublishedResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!thingModelJson) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("thingModelJson is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (thingModelJson) {
      res["ThingModelJson"] = boost::any(*thingModelJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ThingModelJson") != m.end() && !m["ThingModelJson"].empty()) {
      thingModelJson = make_shared<string>(boost::any_cast<string>(m["ThingModelJson"]));
    }
  }


  virtual ~QueryThingModelPublishedResponseData() = default;
};
class QueryThingModelPublishedResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> productKey{};
  shared_ptr<QueryThingModelPublishedResponseData> data{};

  QueryThingModelPublishedResponse() {}

  explicit QueryThingModelPublishedResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryThingModelPublishedResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryThingModelPublishedResponseData>(model1);
      }
    }
  }


  virtual ~QueryThingModelPublishedResponse() = default;
};
class QueryThingModelExtendConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> modelVersion{};
  shared_ptr<string> functionBlockId{};

  QueryThingModelExtendConfigRequest() {}

  explicit QueryThingModelExtendConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (modelVersion) {
      res["ModelVersion"] = boost::any(*modelVersion);
    }
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ModelVersion") != m.end() && !m["ModelVersion"].empty()) {
      modelVersion = make_shared<string>(boost::any_cast<string>(m["ModelVersion"]));
    }
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
  }


  virtual ~QueryThingModelExtendConfigRequest() = default;
};
class QueryThingModelExtendConfigResponseData : public Darabonba::Model {
public:
  shared_ptr<string> configuration{};

  QueryThingModelExtendConfigResponseData() {}

  explicit QueryThingModelExtendConfigResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!configuration) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("configuration is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configuration) {
      res["Configuration"] = boost::any(*configuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configuration = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
  }


  virtual ~QueryThingModelExtendConfigResponseData() = default;
};
class QueryThingModelExtendConfigResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryThingModelExtendConfigResponseData> data{};

  QueryThingModelExtendConfigResponse() {}

  explicit QueryThingModelExtendConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryThingModelExtendConfigResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryThingModelExtendConfigResponseData>(model1);
      }
    }
  }


  virtual ~QueryThingModelExtendConfigResponse() = default;
};
class ListDistributedDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<int> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<int> currentPage{};
  shared_ptr<string> targetUid{};
  shared_ptr<string> sourceInstanceId{};

  ListDistributedDeviceRequest() {}

  explicit ListDistributedDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (targetUid) {
      res["TargetUid"] = boost::any(*targetUid);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("TargetUid") != m.end() && !m["TargetUid"].empty()) {
      targetUid = make_shared<string>(boost::any_cast<string>(m["TargetUid"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
  }


  virtual ~ListDistributedDeviceRequest() = default;
};
class ListDistributedDeviceResponseDataInfoItems : public Darabonba::Model {
public:
  shared_ptr<string> sourceUid{};
  shared_ptr<string> targetUid{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> targetInstanceId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> targetAliyunId{};
  shared_ptr<string> sourceRegion{};
  shared_ptr<string> targetRegion{};
  shared_ptr<string> sourceInstanceName{};
  shared_ptr<string> targetInstanceName{};
  shared_ptr<long> gmtModified{};

  ListDistributedDeviceResponseDataInfoItems() {}

  explicit ListDistributedDeviceResponseDataInfoItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!sourceUid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sourceUid is required.")));
    }
    if (!targetUid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetUid is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!sourceInstanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sourceInstanceId is required.")));
    }
    if (!targetInstanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetInstanceId is required.")));
    }
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!targetAliyunId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetAliyunId is required.")));
    }
    if (!sourceRegion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sourceRegion is required.")));
    }
    if (!targetRegion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetRegion is required.")));
    }
    if (!sourceInstanceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sourceInstanceName is required.")));
    }
    if (!targetInstanceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetInstanceName is required.")));
    }
    if (!gmtModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModified is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceUid) {
      res["SourceUid"] = boost::any(*sourceUid);
    }
    if (targetUid) {
      res["TargetUid"] = boost::any(*targetUid);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (targetAliyunId) {
      res["TargetAliyunId"] = boost::any(*targetAliyunId);
    }
    if (sourceRegion) {
      res["SourceRegion"] = boost::any(*sourceRegion);
    }
    if (targetRegion) {
      res["TargetRegion"] = boost::any(*targetRegion);
    }
    if (sourceInstanceName) {
      res["SourceInstanceName"] = boost::any(*sourceInstanceName);
    }
    if (targetInstanceName) {
      res["TargetInstanceName"] = boost::any(*targetInstanceName);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceUid") != m.end() && !m["SourceUid"].empty()) {
      sourceUid = make_shared<string>(boost::any_cast<string>(m["SourceUid"]));
    }
    if (m.find("TargetUid") != m.end() && !m["TargetUid"].empty()) {
      targetUid = make_shared<string>(boost::any_cast<string>(m["TargetUid"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("TargetAliyunId") != m.end() && !m["TargetAliyunId"].empty()) {
      targetAliyunId = make_shared<string>(boost::any_cast<string>(m["TargetAliyunId"]));
    }
    if (m.find("SourceRegion") != m.end() && !m["SourceRegion"].empty()) {
      sourceRegion = make_shared<string>(boost::any_cast<string>(m["SourceRegion"]));
    }
    if (m.find("TargetRegion") != m.end() && !m["TargetRegion"].empty()) {
      targetRegion = make_shared<string>(boost::any_cast<string>(m["TargetRegion"]));
    }
    if (m.find("SourceInstanceName") != m.end() && !m["SourceInstanceName"].empty()) {
      sourceInstanceName = make_shared<string>(boost::any_cast<string>(m["SourceInstanceName"]));
    }
    if (m.find("TargetInstanceName") != m.end() && !m["TargetInstanceName"].empty()) {
      targetInstanceName = make_shared<string>(boost::any_cast<string>(m["TargetInstanceName"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
  }


  virtual ~ListDistributedDeviceResponseDataInfoItems() = default;
};
class ListDistributedDeviceResponseDataInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDistributedDeviceResponseDataInfoItems>> items{};

  ListDistributedDeviceResponseDataInfo() {}

  explicit ListDistributedDeviceResponseDataInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!items) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("items is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<ListDistributedDeviceResponseDataInfoItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDistributedDeviceResponseDataInfoItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<ListDistributedDeviceResponseDataInfoItems>>(expect1);
      }
    }
  }


  virtual ~ListDistributedDeviceResponseDataInfo() = default;
};
class ListDistributedDeviceResponseData : public Darabonba::Model {
public:
  shared_ptr<int> total{};
  shared_ptr<ListDistributedDeviceResponseDataInfo> info{};

  ListDistributedDeviceResponseData() {}

  explicit ListDistributedDeviceResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!info) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("info is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (info) {
      res["Info"] = info ? boost::any(info->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      if (typeid(map<string, boost::any>) == m["Info"].type()) {
        ListDistributedDeviceResponseDataInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Info"]));
        info = make_shared<ListDistributedDeviceResponseDataInfo>(model1);
      }
    }
  }


  virtual ~ListDistributedDeviceResponseData() = default;
};
class ListDistributedDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<ListDistributedDeviceResponseData> data{};

  ListDistributedDeviceResponse() {}

  explicit ListDistributedDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListDistributedDeviceResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListDistributedDeviceResponseData>(model1);
      }
    }
  }


  virtual ~ListDistributedDeviceResponse() = default;
};
class ListDistributedProductRequest : public Darabonba::Model {
public:
  shared_ptr<int> pageSize{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> targetInstanceId{};
  shared_ptr<string> targetUid{};
  shared_ptr<int> currentPage{};

  ListDistributedProductRequest() {}

  explicit ListDistributedProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    if (targetUid) {
      res["TargetUid"] = boost::any(*targetUid);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
    if (m.find("TargetUid") != m.end() && !m["TargetUid"].empty()) {
      targetUid = make_shared<string>(boost::any_cast<string>(m["TargetUid"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
  }


  virtual ~ListDistributedProductRequest() = default;
};
class ListDistributedProductResponseDataInfoItems : public Darabonba::Model {
public:
  shared_ptr<string> sourceUid{};
  shared_ptr<string> targetUid{};
  shared_ptr<string> productKey{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> targetInstanceId{};
  shared_ptr<int> gmtCreate{};
  shared_ptr<string> targetAliyunId{};
  shared_ptr<string> sourceRegion{};
  shared_ptr<string> targetRegion{};
  shared_ptr<string> sourceInstanceName{};
  shared_ptr<string> targetInstanceName{};

  ListDistributedProductResponseDataInfoItems() {}

  explicit ListDistributedProductResponseDataInfoItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!sourceUid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sourceUid is required.")));
    }
    if (!targetUid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetUid is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!sourceInstanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sourceInstanceId is required.")));
    }
    if (!targetInstanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetInstanceId is required.")));
    }
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!targetAliyunId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetAliyunId is required.")));
    }
    if (!sourceRegion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sourceRegion is required.")));
    }
    if (!targetRegion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetRegion is required.")));
    }
    if (!sourceInstanceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sourceInstanceName is required.")));
    }
    if (!targetInstanceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetInstanceName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceUid) {
      res["SourceUid"] = boost::any(*sourceUid);
    }
    if (targetUid) {
      res["TargetUid"] = boost::any(*targetUid);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (targetAliyunId) {
      res["TargetAliyunId"] = boost::any(*targetAliyunId);
    }
    if (sourceRegion) {
      res["SourceRegion"] = boost::any(*sourceRegion);
    }
    if (targetRegion) {
      res["TargetRegion"] = boost::any(*targetRegion);
    }
    if (sourceInstanceName) {
      res["SourceInstanceName"] = boost::any(*sourceInstanceName);
    }
    if (targetInstanceName) {
      res["TargetInstanceName"] = boost::any(*targetInstanceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceUid") != m.end() && !m["SourceUid"].empty()) {
      sourceUid = make_shared<string>(boost::any_cast<string>(m["SourceUid"]));
    }
    if (m.find("TargetUid") != m.end() && !m["TargetUid"].empty()) {
      targetUid = make_shared<string>(boost::any_cast<string>(m["TargetUid"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<int>(boost::any_cast<int>(m["GmtCreate"]));
    }
    if (m.find("TargetAliyunId") != m.end() && !m["TargetAliyunId"].empty()) {
      targetAliyunId = make_shared<string>(boost::any_cast<string>(m["TargetAliyunId"]));
    }
    if (m.find("SourceRegion") != m.end() && !m["SourceRegion"].empty()) {
      sourceRegion = make_shared<string>(boost::any_cast<string>(m["SourceRegion"]));
    }
    if (m.find("TargetRegion") != m.end() && !m["TargetRegion"].empty()) {
      targetRegion = make_shared<string>(boost::any_cast<string>(m["TargetRegion"]));
    }
    if (m.find("SourceInstanceName") != m.end() && !m["SourceInstanceName"].empty()) {
      sourceInstanceName = make_shared<string>(boost::any_cast<string>(m["SourceInstanceName"]));
    }
    if (m.find("TargetInstanceName") != m.end() && !m["TargetInstanceName"].empty()) {
      targetInstanceName = make_shared<string>(boost::any_cast<string>(m["TargetInstanceName"]));
    }
  }


  virtual ~ListDistributedProductResponseDataInfoItems() = default;
};
class ListDistributedProductResponseDataInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDistributedProductResponseDataInfoItems>> items{};

  ListDistributedProductResponseDataInfo() {}

  explicit ListDistributedProductResponseDataInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!items) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("items is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<ListDistributedProductResponseDataInfoItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDistributedProductResponseDataInfoItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<ListDistributedProductResponseDataInfoItems>>(expect1);
      }
    }
  }


  virtual ~ListDistributedProductResponseDataInfo() = default;
};
class ListDistributedProductResponseData : public Darabonba::Model {
public:
  shared_ptr<int> total{};
  shared_ptr<ListDistributedProductResponseDataInfo> info{};

  ListDistributedProductResponseData() {}

  explicit ListDistributedProductResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!info) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("info is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (info) {
      res["Info"] = info ? boost::any(info->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      if (typeid(map<string, boost::any>) == m["Info"].type()) {
        ListDistributedProductResponseDataInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Info"]));
        info = make_shared<ListDistributedProductResponseDataInfo>(model1);
      }
    }
  }


  virtual ~ListDistributedProductResponseData() = default;
};
class ListDistributedProductResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<ListDistributedProductResponseData> data{};

  ListDistributedProductResponse() {}

  explicit ListDistributedProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListDistributedProductResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListDistributedProductResponseData>(model1);
      }
    }
  }


  virtual ~ListDistributedProductResponse() = default;
};
class QuerySubscribeRelationRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> type{};

  QuerySubscribeRelationRequest() {}

  explicit QuerySubscribeRelationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QuerySubscribeRelationRequest() = default;
};
class QuerySubscribeRelationResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> productKey{};
  shared_ptr<string> type{};
  shared_ptr<bool> deviceDataFlag{};
  shared_ptr<bool> deviceLifeCycleFlag{};
  shared_ptr<bool> deviceStatusChangeFlag{};
  shared_ptr<bool> deviceTopoLifeCycleFlag{};
  shared_ptr<bool> foundDeviceListFlag{};
  shared_ptr<bool> otaEventFlag{};
  shared_ptr<bool> thingHistoryFlag{};
  shared_ptr<string> mnsConfiguration{};
  shared_ptr<bool> deviceTagFlag{};
  shared_ptr<bool> otaVersionFlag{};
  shared_ptr<bool> otaJobFlag{};
  shared_ptr<vector<string>> consumerGroupIds{};

  QuerySubscribeRelationResponse() {}

  explicit QuerySubscribeRelationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
    if (!deviceDataFlag) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceDataFlag is required.")));
    }
    if (!deviceLifeCycleFlag) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceLifeCycleFlag is required.")));
    }
    if (!deviceStatusChangeFlag) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceStatusChangeFlag is required.")));
    }
    if (!deviceTopoLifeCycleFlag) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceTopoLifeCycleFlag is required.")));
    }
    if (!foundDeviceListFlag) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("foundDeviceListFlag is required.")));
    }
    if (!otaEventFlag) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("otaEventFlag is required.")));
    }
    if (!thingHistoryFlag) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("thingHistoryFlag is required.")));
    }
    if (!mnsConfiguration) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("mnsConfiguration is required.")));
    }
    if (!deviceTagFlag) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceTagFlag is required.")));
    }
    if (!otaVersionFlag) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("otaVersionFlag is required.")));
    }
    if (!otaJobFlag) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("otaJobFlag is required.")));
    }
    if (!consumerGroupIds) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("consumerGroupIds is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (deviceDataFlag) {
      res["DeviceDataFlag"] = boost::any(*deviceDataFlag);
    }
    if (deviceLifeCycleFlag) {
      res["DeviceLifeCycleFlag"] = boost::any(*deviceLifeCycleFlag);
    }
    if (deviceStatusChangeFlag) {
      res["DeviceStatusChangeFlag"] = boost::any(*deviceStatusChangeFlag);
    }
    if (deviceTopoLifeCycleFlag) {
      res["DeviceTopoLifeCycleFlag"] = boost::any(*deviceTopoLifeCycleFlag);
    }
    if (foundDeviceListFlag) {
      res["FoundDeviceListFlag"] = boost::any(*foundDeviceListFlag);
    }
    if (otaEventFlag) {
      res["OtaEventFlag"] = boost::any(*otaEventFlag);
    }
    if (thingHistoryFlag) {
      res["ThingHistoryFlag"] = boost::any(*thingHistoryFlag);
    }
    if (mnsConfiguration) {
      res["MnsConfiguration"] = boost::any(*mnsConfiguration);
    }
    if (deviceTagFlag) {
      res["DeviceTagFlag"] = boost::any(*deviceTagFlag);
    }
    if (otaVersionFlag) {
      res["OtaVersionFlag"] = boost::any(*otaVersionFlag);
    }
    if (otaJobFlag) {
      res["OtaJobFlag"] = boost::any(*otaJobFlag);
    }
    if (consumerGroupIds) {
      res["ConsumerGroupIds"] = boost::any(*consumerGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("DeviceDataFlag") != m.end() && !m["DeviceDataFlag"].empty()) {
      deviceDataFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceDataFlag"]));
    }
    if (m.find("DeviceLifeCycleFlag") != m.end() && !m["DeviceLifeCycleFlag"].empty()) {
      deviceLifeCycleFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceLifeCycleFlag"]));
    }
    if (m.find("DeviceStatusChangeFlag") != m.end() && !m["DeviceStatusChangeFlag"].empty()) {
      deviceStatusChangeFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceStatusChangeFlag"]));
    }
    if (m.find("DeviceTopoLifeCycleFlag") != m.end() && !m["DeviceTopoLifeCycleFlag"].empty()) {
      deviceTopoLifeCycleFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceTopoLifeCycleFlag"]));
    }
    if (m.find("FoundDeviceListFlag") != m.end() && !m["FoundDeviceListFlag"].empty()) {
      foundDeviceListFlag = make_shared<bool>(boost::any_cast<bool>(m["FoundDeviceListFlag"]));
    }
    if (m.find("OtaEventFlag") != m.end() && !m["OtaEventFlag"].empty()) {
      otaEventFlag = make_shared<bool>(boost::any_cast<bool>(m["OtaEventFlag"]));
    }
    if (m.find("ThingHistoryFlag") != m.end() && !m["ThingHistoryFlag"].empty()) {
      thingHistoryFlag = make_shared<bool>(boost::any_cast<bool>(m["ThingHistoryFlag"]));
    }
    if (m.find("MnsConfiguration") != m.end() && !m["MnsConfiguration"].empty()) {
      mnsConfiguration = make_shared<string>(boost::any_cast<string>(m["MnsConfiguration"]));
    }
    if (m.find("DeviceTagFlag") != m.end() && !m["DeviceTagFlag"].empty()) {
      deviceTagFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceTagFlag"]));
    }
    if (m.find("OtaVersionFlag") != m.end() && !m["OtaVersionFlag"].empty()) {
      otaVersionFlag = make_shared<bool>(boost::any_cast<bool>(m["OtaVersionFlag"]));
    }
    if (m.find("OtaJobFlag") != m.end() && !m["OtaJobFlag"].empty()) {
      otaJobFlag = make_shared<bool>(boost::any_cast<bool>(m["OtaJobFlag"]));
    }
    if (m.find("ConsumerGroupIds") != m.end() && !m["ConsumerGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ConsumerGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ConsumerGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      consumerGroupIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QuerySubscribeRelationResponse() = default;
};
class CreateConsumerGroupSubscribeRelationRequest : public Darabonba::Model {
public:
  shared_ptr<string> consumerGroupId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  CreateConsumerGroupSubscribeRelationRequest() {}

  explicit CreateConsumerGroupSubscribeRelationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!consumerGroupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("consumerGroupId is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consumerGroupId) {
      res["ConsumerGroupId"] = boost::any(*consumerGroupId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsumerGroupId") != m.end() && !m["ConsumerGroupId"].empty()) {
      consumerGroupId = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~CreateConsumerGroupSubscribeRelationRequest() = default;
};
class CreateConsumerGroupSubscribeRelationResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  CreateConsumerGroupSubscribeRelationResponse() {}

  explicit CreateConsumerGroupSubscribeRelationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CreateConsumerGroupSubscribeRelationResponse() = default;
};
class UpdateSubscribeRelationRequest : public Darabonba::Model {
public:
  shared_ptr<bool> deviceStatusChangeFlag{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<bool> thingHistoryFlag{};
  shared_ptr<string> productKey{};
  shared_ptr<string> type{};
  shared_ptr<bool> deviceDataFlag{};
  shared_ptr<vector<string>> consumerGroupIds{};
  shared_ptr<bool> deviceTopoLifeCycleFlag{};
  shared_ptr<bool> foundDeviceListFlag{};
  shared_ptr<bool> otaEventFlag{};
  shared_ptr<bool> deviceLifeCycleFlag{};
  shared_ptr<string> mnsConfiguration{};
  shared_ptr<bool> deviceTagFlag{};
  shared_ptr<bool> otaVersionFlag{};
  shared_ptr<bool> otaJobFlag{};

  UpdateSubscribeRelationRequest() {}

  explicit UpdateSubscribeRelationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceStatusChangeFlag) {
      res["DeviceStatusChangeFlag"] = boost::any(*deviceStatusChangeFlag);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (thingHistoryFlag) {
      res["ThingHistoryFlag"] = boost::any(*thingHistoryFlag);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (deviceDataFlag) {
      res["DeviceDataFlag"] = boost::any(*deviceDataFlag);
    }
    if (consumerGroupIds) {
      res["ConsumerGroupIds"] = boost::any(*consumerGroupIds);
    }
    if (deviceTopoLifeCycleFlag) {
      res["DeviceTopoLifeCycleFlag"] = boost::any(*deviceTopoLifeCycleFlag);
    }
    if (foundDeviceListFlag) {
      res["FoundDeviceListFlag"] = boost::any(*foundDeviceListFlag);
    }
    if (otaEventFlag) {
      res["OtaEventFlag"] = boost::any(*otaEventFlag);
    }
    if (deviceLifeCycleFlag) {
      res["DeviceLifeCycleFlag"] = boost::any(*deviceLifeCycleFlag);
    }
    if (mnsConfiguration) {
      res["MnsConfiguration"] = boost::any(*mnsConfiguration);
    }
    if (deviceTagFlag) {
      res["DeviceTagFlag"] = boost::any(*deviceTagFlag);
    }
    if (otaVersionFlag) {
      res["OtaVersionFlag"] = boost::any(*otaVersionFlag);
    }
    if (otaJobFlag) {
      res["OtaJobFlag"] = boost::any(*otaJobFlag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceStatusChangeFlag") != m.end() && !m["DeviceStatusChangeFlag"].empty()) {
      deviceStatusChangeFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceStatusChangeFlag"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ThingHistoryFlag") != m.end() && !m["ThingHistoryFlag"].empty()) {
      thingHistoryFlag = make_shared<bool>(boost::any_cast<bool>(m["ThingHistoryFlag"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("DeviceDataFlag") != m.end() && !m["DeviceDataFlag"].empty()) {
      deviceDataFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceDataFlag"]));
    }
    if (m.find("ConsumerGroupIds") != m.end() && !m["ConsumerGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ConsumerGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ConsumerGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      consumerGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DeviceTopoLifeCycleFlag") != m.end() && !m["DeviceTopoLifeCycleFlag"].empty()) {
      deviceTopoLifeCycleFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceTopoLifeCycleFlag"]));
    }
    if (m.find("FoundDeviceListFlag") != m.end() && !m["FoundDeviceListFlag"].empty()) {
      foundDeviceListFlag = make_shared<bool>(boost::any_cast<bool>(m["FoundDeviceListFlag"]));
    }
    if (m.find("OtaEventFlag") != m.end() && !m["OtaEventFlag"].empty()) {
      otaEventFlag = make_shared<bool>(boost::any_cast<bool>(m["OtaEventFlag"]));
    }
    if (m.find("DeviceLifeCycleFlag") != m.end() && !m["DeviceLifeCycleFlag"].empty()) {
      deviceLifeCycleFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceLifeCycleFlag"]));
    }
    if (m.find("MnsConfiguration") != m.end() && !m["MnsConfiguration"].empty()) {
      mnsConfiguration = make_shared<string>(boost::any_cast<string>(m["MnsConfiguration"]));
    }
    if (m.find("DeviceTagFlag") != m.end() && !m["DeviceTagFlag"].empty()) {
      deviceTagFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceTagFlag"]));
    }
    if (m.find("OtaVersionFlag") != m.end() && !m["OtaVersionFlag"].empty()) {
      otaVersionFlag = make_shared<bool>(boost::any_cast<bool>(m["OtaVersionFlag"]));
    }
    if (m.find("OtaJobFlag") != m.end() && !m["OtaJobFlag"].empty()) {
      otaJobFlag = make_shared<bool>(boost::any_cast<bool>(m["OtaJobFlag"]));
    }
  }


  virtual ~UpdateSubscribeRelationRequest() = default;
};
class UpdateSubscribeRelationResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateSubscribeRelationResponse() {}

  explicit UpdateSubscribeRelationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateSubscribeRelationResponse() = default;
};
class DeleteConsumerGroupSubscribeRelationRequest : public Darabonba::Model {
public:
  shared_ptr<string> consumerGroupId{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  DeleteConsumerGroupSubscribeRelationRequest() {}

  explicit DeleteConsumerGroupSubscribeRelationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!consumerGroupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("consumerGroupId is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consumerGroupId) {
      res["ConsumerGroupId"] = boost::any(*consumerGroupId);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsumerGroupId") != m.end() && !m["ConsumerGroupId"].empty()) {
      consumerGroupId = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupId"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~DeleteConsumerGroupSubscribeRelationRequest() = default;
};
class DeleteConsumerGroupSubscribeRelationResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteConsumerGroupSubscribeRelationResponse() {}

  explicit DeleteConsumerGroupSubscribeRelationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteConsumerGroupSubscribeRelationResponse() = default;
};
class ResetConsumerGroupPositionRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> groupId{};

  ResetConsumerGroupPositionRequest() {}

  explicit ResetConsumerGroupPositionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~ResetConsumerGroupPositionRequest() = default;
};
class ResetConsumerGroupPositionResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};

  ResetConsumerGroupPositionResponse() {}

  explicit ResetConsumerGroupPositionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~ResetConsumerGroupPositionResponse() = default;
};
class UpdateConsumerGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> newGroupName{};
  shared_ptr<string> groupId{};

  UpdateConsumerGroupRequest() {}

  explicit UpdateConsumerGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!newGroupName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("newGroupName is required.")));
    }
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (newGroupName) {
      res["NewGroupName"] = boost::any(*newGroupName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("NewGroupName") != m.end() && !m["NewGroupName"].empty()) {
      newGroupName = make_shared<string>(boost::any_cast<string>(m["NewGroupName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~UpdateConsumerGroupRequest() = default;
};
class UpdateConsumerGroupResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};

  UpdateConsumerGroupResponse() {}

  explicit UpdateConsumerGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~UpdateConsumerGroupResponse() = default;
};
class BatchDeleteEdgeInstanceChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<vector<string>> channelIds{};

  BatchDeleteEdgeInstanceChannelRequest() {}

  explicit BatchDeleteEdgeInstanceChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!driverId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverId is required.")));
    }
    if (!channelIds) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("channelIds is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (channelIds) {
      res["ChannelIds"] = boost::any(*channelIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("ChannelIds") != m.end() && !m["ChannelIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ChannelIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ChannelIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channelIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchDeleteEdgeInstanceChannelRequest() = default;
};
class BatchDeleteEdgeInstanceChannelResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  BatchDeleteEdgeInstanceChannelResponse() {}

  explicit BatchDeleteEdgeInstanceChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~BatchDeleteEdgeInstanceChannelResponse() = default;
};
class BatchSetEdgeInstanceDeviceChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<string> channelId{};
  shared_ptr<vector<string>> iotIds{};

  BatchSetEdgeInstanceDeviceChannelRequest() {}

  explicit BatchSetEdgeInstanceDeviceChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!driverId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverId is required.")));
    }
    if (!channelId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("channelId is required.")));
    }
    if (!iotIds) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotIds is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (iotIds) {
      res["IotIds"] = boost::any(*iotIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("IotIds") != m.end() && !m["IotIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchSetEdgeInstanceDeviceChannelRequest() = default;
};
class BatchSetEdgeInstanceDeviceChannelResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  BatchSetEdgeInstanceDeviceChannelResponse() {}

  explicit BatchSetEdgeInstanceDeviceChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~BatchSetEdgeInstanceDeviceChannelResponse() = default;
};
class BatchGetEdgeInstanceDeviceDriverRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> iotIds{};

  BatchGetEdgeInstanceDeviceDriverRequest() {}

  explicit BatchGetEdgeInstanceDeviceDriverRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!iotIds) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotIds is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotIds) {
      res["IotIds"] = boost::any(*iotIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotIds") != m.end() && !m["IotIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceDriverRequest() = default;
};
class BatchGetEdgeInstanceDeviceDriverResponseDeviceDriverList : public Darabonba::Model {
public:
  shared_ptr<string> driverId{};
  shared_ptr<string> iotId{};

  BatchGetEdgeInstanceDeviceDriverResponseDeviceDriverList() {}

  explicit BatchGetEdgeInstanceDeviceDriverResponseDeviceDriverList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!driverId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverId is required.")));
    }
    if (!iotId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceDriverResponseDeviceDriverList() = default;
};
class BatchGetEdgeInstanceDeviceDriverResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<BatchGetEdgeInstanceDeviceDriverResponseDeviceDriverList>> deviceDriverList{};

  BatchGetEdgeInstanceDeviceDriverResponse() {}

  explicit BatchGetEdgeInstanceDeviceDriverResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!deviceDriverList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceDriverList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (deviceDriverList) {
      vector<boost::any> temp1;
      for(auto item1:*deviceDriverList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceDriverList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("DeviceDriverList") != m.end() && !m["DeviceDriverList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceDriverList"].type()) {
        vector<BatchGetEdgeInstanceDeviceDriverResponseDeviceDriverList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceDriverList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetEdgeInstanceDeviceDriverResponseDeviceDriverList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceDriverList = make_shared<vector<BatchGetEdgeInstanceDeviceDriverResponseDeviceDriverList>>(expect1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceDriverResponse() = default;
};
class BatchGetEdgeInstanceDeviceChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<vector<string>> iotIds{};

  BatchGetEdgeInstanceDeviceChannelRequest() {}

  explicit BatchGetEdgeInstanceDeviceChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!driverId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverId is required.")));
    }
    if (!iotIds) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotIds is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (iotIds) {
      res["IotIds"] = boost::any(*iotIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("IotIds") != m.end() && !m["IotIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceChannelRequest() = default;
};
class BatchGetEdgeInstanceDeviceChannelResponseDeviceChannelList : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> channelName{};
  shared_ptr<string> iotId{};

  BatchGetEdgeInstanceDeviceChannelResponseDeviceChannelList() {}

  explicit BatchGetEdgeInstanceDeviceChannelResponseDeviceChannelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!channelId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("channelId is required.")));
    }
    if (!channelName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("channelName is required.")));
    }
    if (!iotId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceChannelResponseDeviceChannelList() = default;
};
class BatchGetEdgeInstanceDeviceChannelResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<BatchGetEdgeInstanceDeviceChannelResponseDeviceChannelList>> deviceChannelList{};

  BatchGetEdgeInstanceDeviceChannelResponse() {}

  explicit BatchGetEdgeInstanceDeviceChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!deviceChannelList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceChannelList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (deviceChannelList) {
      vector<boost::any> temp1;
      for(auto item1:*deviceChannelList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceChannelList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("DeviceChannelList") != m.end() && !m["DeviceChannelList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceChannelList"].type()) {
        vector<BatchGetEdgeInstanceDeviceChannelResponseDeviceChannelList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceChannelList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetEdgeInstanceDeviceChannelResponseDeviceChannelList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceChannelList = make_shared<vector<BatchGetEdgeInstanceDeviceChannelResponseDeviceChannelList>>(expect1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceChannelResponse() = default;
};
class ReleaseEdgeDriverVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};

  ReleaseEdgeDriverVersionRequest() {}

  explicit ReleaseEdgeDriverVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!driverId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverId is required.")));
    }
    if (!driverVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverVersion is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
  }


  virtual ~ReleaseEdgeDriverVersionRequest() = default;
};
class ReleaseEdgeDriverVersionResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  ReleaseEdgeDriverVersionResponse() {}

  explicit ReleaseEdgeDriverVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~ReleaseEdgeDriverVersionResponse() = default;
};
class QueryEdgeInstanceDeviceByDriverRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> driverId{};
  shared_ptr<int> currentPage{};

  QueryEdgeInstanceDeviceByDriverRequest() {}

  explicit QueryEdgeInstanceDeviceByDriverRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!driverId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverId is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
  }


  virtual ~QueryEdgeInstanceDeviceByDriverRequest() = default;
};
class QueryEdgeInstanceDeviceByDriverResponseDataDeviceList : public Darabonba::Model {
public:
  shared_ptr<string> iotId{};

  QueryEdgeInstanceDeviceByDriverResponseDataDeviceList() {}

  explicit QueryEdgeInstanceDeviceByDriverResponseDataDeviceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!iotId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~QueryEdgeInstanceDeviceByDriverResponseDataDeviceList() = default;
};
class QueryEdgeInstanceDeviceByDriverResponseData : public Darabonba::Model {
public:
  shared_ptr<int> total{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> currentPage{};
  shared_ptr<vector<QueryEdgeInstanceDeviceByDriverResponseDataDeviceList>> deviceList{};

  QueryEdgeInstanceDeviceByDriverResponseData() {}

  explicit QueryEdgeInstanceDeviceByDriverResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!deviceList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (deviceList) {
      vector<boost::any> temp1;
      for(auto item1:*deviceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("DeviceList") != m.end() && !m["DeviceList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceList"].type()) {
        vector<QueryEdgeInstanceDeviceByDriverResponseDataDeviceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeInstanceDeviceByDriverResponseDataDeviceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceList = make_shared<vector<QueryEdgeInstanceDeviceByDriverResponseDataDeviceList>>(expect1);
      }
    }
  }


  virtual ~QueryEdgeInstanceDeviceByDriverResponseData() = default;
};
class QueryEdgeInstanceDeviceByDriverResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryEdgeInstanceDeviceByDriverResponseData> data{};

  QueryEdgeInstanceDeviceByDriverResponse() {}

  explicit QueryEdgeInstanceDeviceByDriverResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEdgeInstanceDeviceByDriverResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEdgeInstanceDeviceByDriverResponseData>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceDeviceByDriverResponse() = default;
};
class DisableSceneRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> ruleId{};

  DisableSceneRuleRequest() {}

  explicit DisableSceneRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!ruleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~DisableSceneRuleRequest() = default;
};
class DisableSceneRuleResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};

  DisableSceneRuleResponse() {}

  explicit DisableSceneRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~DisableSceneRuleResponse() = default;
};
class TriggerSceneRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> instanceId{};

  TriggerSceneRuleRequest() {}

  explicit TriggerSceneRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!ruleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~TriggerSceneRuleRequest() = default;
};
class TriggerSceneRuleResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};

  TriggerSceneRuleResponse() {}

  explicit TriggerSceneRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~TriggerSceneRuleResponse() = default;
};
class UnbindSceneRuleFromEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ruleId{};

  UnbindSceneRuleFromEdgeInstanceRequest() {}

  explicit UnbindSceneRuleFromEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!ruleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~UnbindSceneRuleFromEdgeInstanceRequest() = default;
};
class UnbindSceneRuleFromEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UnbindSceneRuleFromEdgeInstanceResponse() {}

  explicit UnbindSceneRuleFromEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UnbindSceneRuleFromEdgeInstanceResponse() = default;
};
class QueryEdgeInstanceSceneRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<int> currentPage{};
  shared_ptr<int> pageSize{};

  QueryEdgeInstanceSceneRuleRequest() {}

  explicit QueryEdgeInstanceSceneRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
  }


  virtual ~QueryEdgeInstanceSceneRuleRequest() = default;
};
class QueryEdgeInstanceSceneRuleResponseDataRuleList : public Darabonba::Model {
public:
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<int> status{};
  shared_ptr<int> isExisted{};

  QueryEdgeInstanceSceneRuleResponseDataRuleList() {}

  explicit QueryEdgeInstanceSceneRuleResponseDataRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!ruleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleId is required.")));
    }
    if (!ruleName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleName is required.")));
    }
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!isExisted) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isExisted is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (isExisted) {
      res["IsExisted"] = boost::any(*isExisted);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<int>(boost::any_cast<int>(m["Status"]));
    }
    if (m.find("IsExisted") != m.end() && !m["IsExisted"].empty()) {
      isExisted = make_shared<int>(boost::any_cast<int>(m["IsExisted"]));
    }
  }


  virtual ~QueryEdgeInstanceSceneRuleResponseDataRuleList() = default;
};
class QueryEdgeInstanceSceneRuleResponseData : public Darabonba::Model {
public:
  shared_ptr<int> total{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> currentPage{};
  shared_ptr<vector<QueryEdgeInstanceSceneRuleResponseDataRuleList>> ruleList{};

  QueryEdgeInstanceSceneRuleResponseData() {}

  explicit QueryEdgeInstanceSceneRuleResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!ruleList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (ruleList) {
      vector<boost::any> temp1;
      for(auto item1:*ruleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("RuleList") != m.end() && !m["RuleList"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleList"].type()) {
        vector<QueryEdgeInstanceSceneRuleResponseDataRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeInstanceSceneRuleResponseDataRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleList = make_shared<vector<QueryEdgeInstanceSceneRuleResponseDataRuleList>>(expect1);
      }
    }
  }


  virtual ~QueryEdgeInstanceSceneRuleResponseData() = default;
};
class QueryEdgeInstanceSceneRuleResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryEdgeInstanceSceneRuleResponseData> data{};

  QueryEdgeInstanceSceneRuleResponse() {}

  explicit QueryEdgeInstanceSceneRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEdgeInstanceSceneRuleResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEdgeInstanceSceneRuleResponseData>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceSceneRuleResponse() = default;
};
class CreateSceneRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleContent{};
  shared_ptr<string> ruleDescription{};

  CreateSceneRuleRequest() {}

  explicit CreateSceneRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!ruleName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleContent) {
      res["RuleContent"] = boost::any(*ruleContent);
    }
    if (ruleDescription) {
      res["RuleDescription"] = boost::any(*ruleDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleContent") != m.end() && !m["RuleContent"].empty()) {
      ruleContent = make_shared<string>(boost::any_cast<string>(m["RuleContent"]));
    }
    if (m.find("RuleDescription") != m.end() && !m["RuleDescription"].empty()) {
      ruleDescription = make_shared<string>(boost::any_cast<string>(m["RuleDescription"]));
    }
  }


  virtual ~CreateSceneRuleRequest() = default;
};
class CreateSceneRuleResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> ruleId{};

  CreateSceneRuleResponse() {}

  explicit CreateSceneRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!ruleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~CreateSceneRuleResponse() = default;
};
class QueryDetailSceneRuleLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> ruleId{};
  shared_ptr<int> startTime{};
  shared_ptr<int> endTime{};
  shared_ptr<string> traceId{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> currentPage{};

  QueryDetailSceneRuleLogRequest() {}

  explicit QueryDetailSceneRuleLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!ruleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleId is required.")));
    }
    if (!startTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("startTime is required.")));
    }
    if (!endTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endTime is required.")));
    }
    if (!traceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("traceId is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<int>(boost::any_cast<int>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<int>(boost::any_cast<int>(m["EndTime"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
  }


  virtual ~QueryDetailSceneRuleLogRequest() = default;
};
class QueryDetailSceneRuleLogResponseDataLogList : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> pkDn{};

  QueryDetailSceneRuleLogResponseDataLogList() {}

  explicit QueryDetailSceneRuleLogResponseDataLogList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!message) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("message is required.")));
    }
    if (!pkDn) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pkDn is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pkDn) {
      res["PkDn"] = boost::any(*pkDn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PkDn") != m.end() && !m["PkDn"].empty()) {
      pkDn = make_shared<string>(boost::any_cast<string>(m["PkDn"]));
    }
  }


  virtual ~QueryDetailSceneRuleLogResponseDataLogList() = default;
};
class QueryDetailSceneRuleLogResponseData : public Darabonba::Model {
public:
  shared_ptr<int> total{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> currentPage{};
  shared_ptr<vector<QueryDetailSceneRuleLogResponseDataLogList>> logList{};

  QueryDetailSceneRuleLogResponseData() {}

  explicit QueryDetailSceneRuleLogResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!logList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("logList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (logList) {
      vector<boost::any> temp1;
      for(auto item1:*logList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("LogList") != m.end() && !m["LogList"].empty()) {
      if (typeid(vector<boost::any>) == m["LogList"].type()) {
        vector<QueryDetailSceneRuleLogResponseDataLogList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDetailSceneRuleLogResponseDataLogList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logList = make_shared<vector<QueryDetailSceneRuleLogResponseDataLogList>>(expect1);
      }
    }
  }


  virtual ~QueryDetailSceneRuleLogResponseData() = default;
};
class QueryDetailSceneRuleLogResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<QueryDetailSceneRuleLogResponseData> data{};

  QueryDetailSceneRuleLogResponse() {}

  explicit QueryDetailSceneRuleLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDetailSceneRuleLogResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDetailSceneRuleLogResponseData>(model1);
      }
    }
  }


  virtual ~QueryDetailSceneRuleLogResponse() = default;
};
class EnableSceneRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> ruleId{};

  EnableSceneRuleRequest() {}

  explicit EnableSceneRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!ruleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~EnableSceneRuleRequest() = default;
};
class EnableSceneRuleResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};

  EnableSceneRuleResponse() {}

  explicit EnableSceneRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~EnableSceneRuleResponse() = default;
};
class UpdateSceneRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleContent{};
  shared_ptr<string> ruleDescription{};

  UpdateSceneRuleRequest() {}

  explicit UpdateSceneRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!ruleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleContent) {
      res["RuleContent"] = boost::any(*ruleContent);
    }
    if (ruleDescription) {
      res["RuleDescription"] = boost::any(*ruleDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleContent") != m.end() && !m["RuleContent"].empty()) {
      ruleContent = make_shared<string>(boost::any_cast<string>(m["RuleContent"]));
    }
    if (m.find("RuleDescription") != m.end() && !m["RuleDescription"].empty()) {
      ruleDescription = make_shared<string>(boost::any_cast<string>(m["RuleDescription"]));
    }
  }


  virtual ~UpdateSceneRuleRequest() = default;
};
class UpdateSceneRuleResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateSceneRuleResponse() {}

  explicit UpdateSceneRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateSceneRuleResponse() = default;
};
class QuerySceneRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> ruleName{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> currentPage{};

  QuerySceneRuleRequest() {}

  explicit QuerySceneRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
  }


  virtual ~QuerySceneRuleRequest() = default;
};
class QuerySceneRuleResponseDataRuleList : public Darabonba::Model {
public:
  shared_ptr<string> ruleId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleDescription{};
  shared_ptr<int> ruleStatus{};

  QuerySceneRuleResponseDataRuleList() {}

  explicit QuerySceneRuleResponseDataRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!ruleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleId is required.")));
    }
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!gmtModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModified is required.")));
    }
    if (!ruleName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleName is required.")));
    }
    if (!ruleDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleDescription is required.")));
    }
    if (!ruleStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleStatus is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleDescription) {
      res["RuleDescription"] = boost::any(*ruleDescription);
    }
    if (ruleStatus) {
      res["RuleStatus"] = boost::any(*ruleStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleDescription") != m.end() && !m["RuleDescription"].empty()) {
      ruleDescription = make_shared<string>(boost::any_cast<string>(m["RuleDescription"]));
    }
    if (m.find("RuleStatus") != m.end() && !m["RuleStatus"].empty()) {
      ruleStatus = make_shared<int>(boost::any_cast<int>(m["RuleStatus"]));
    }
  }


  virtual ~QuerySceneRuleResponseDataRuleList() = default;
};
class QuerySceneRuleResponseData : public Darabonba::Model {
public:
  shared_ptr<int> total{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> currentPage{};
  shared_ptr<vector<QuerySceneRuleResponseDataRuleList>> ruleList{};

  QuerySceneRuleResponseData() {}

  explicit QuerySceneRuleResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!ruleList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (ruleList) {
      vector<boost::any> temp1;
      for(auto item1:*ruleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("RuleList") != m.end() && !m["RuleList"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleList"].type()) {
        vector<QuerySceneRuleResponseDataRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySceneRuleResponseDataRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleList = make_shared<vector<QuerySceneRuleResponseDataRuleList>>(expect1);
      }
    }
  }


  virtual ~QuerySceneRuleResponseData() = default;
};
class QuerySceneRuleResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QuerySceneRuleResponseData> data{};

  QuerySceneRuleResponse() {}

  explicit QuerySceneRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QuerySceneRuleResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QuerySceneRuleResponseData>(model1);
      }
    }
  }


  virtual ~QuerySceneRuleResponse() = default;
};
class QuerySummarySceneRuleLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> ruleId{};
  shared_ptr<int> startTime{};
  shared_ptr<int> endTime{};
  shared_ptr<string> status{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> currentPage{};

  QuerySummarySceneRuleLogRequest() {}

  explicit QuerySummarySceneRuleLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!ruleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleId is required.")));
    }
    if (!startTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("startTime is required.")));
    }
    if (!endTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endTime is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<int>(boost::any_cast<int>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<int>(boost::any_cast<int>(m["EndTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
  }


  virtual ~QuerySummarySceneRuleLogRequest() = default;
};
class QuerySummarySceneRuleLogResponseDataLogListLogInfo : public Darabonba::Model {
public:
  shared_ptr<int> logTime{};
  shared_ptr<string> result{};
  shared_ptr<string> traceId{};

  QuerySummarySceneRuleLogResponseDataLogListLogInfo() {}

  explicit QuerySummarySceneRuleLogResponseDataLogListLogInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!logTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("logTime is required.")));
    }
    if (!result) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("result is required.")));
    }
    if (!traceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("traceId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logTime) {
      res["LogTime"] = boost::any(*logTime);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogTime") != m.end() && !m["LogTime"].empty()) {
      logTime = make_shared<int>(boost::any_cast<int>(m["LogTime"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~QuerySummarySceneRuleLogResponseDataLogListLogInfo() = default;
};
class QuerySummarySceneRuleLogResponseDataLogList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySummarySceneRuleLogResponseDataLogListLogInfo>> logInfo{};

  QuerySummarySceneRuleLogResponseDataLogList() {}

  explicit QuerySummarySceneRuleLogResponseDataLogList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!logInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("logInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logInfo) {
      vector<boost::any> temp1;
      for(auto item1:*logInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogInfo") != m.end() && !m["LogInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["LogInfo"].type()) {
        vector<QuerySummarySceneRuleLogResponseDataLogListLogInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySummarySceneRuleLogResponseDataLogListLogInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logInfo = make_shared<vector<QuerySummarySceneRuleLogResponseDataLogListLogInfo>>(expect1);
      }
    }
  }


  virtual ~QuerySummarySceneRuleLogResponseDataLogList() = default;
};
class QuerySummarySceneRuleLogResponseData : public Darabonba::Model {
public:
  shared_ptr<int> total{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> currentPage{};
  shared_ptr<QuerySummarySceneRuleLogResponseDataLogList> logList{};

  QuerySummarySceneRuleLogResponseData() {}

  explicit QuerySummarySceneRuleLogResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!logList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("logList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (logList) {
      res["LogList"] = logList ? boost::any(logList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("LogList") != m.end() && !m["LogList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogList"].type()) {
        QuerySummarySceneRuleLogResponseDataLogList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogList"]));
        logList = make_shared<QuerySummarySceneRuleLogResponseDataLogList>(model1);
      }
    }
  }


  virtual ~QuerySummarySceneRuleLogResponseData() = default;
};
class QuerySummarySceneRuleLogResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<QuerySummarySceneRuleLogResponseData> data{};

  QuerySummarySceneRuleLogResponse() {}

  explicit QuerySummarySceneRuleLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QuerySummarySceneRuleLogResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QuerySummarySceneRuleLogResponseData>(model1);
      }
    }
  }


  virtual ~QuerySummarySceneRuleLogResponse() = default;
};
class GetSceneRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> ruleId{};

  GetSceneRuleRequest() {}

  explicit GetSceneRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!ruleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~GetSceneRuleRequest() = default;
};
class GetSceneRuleResponseData : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleContent{};
  shared_ptr<string> ruleDescription{};
  shared_ptr<int> ruleStatus{};

  GetSceneRuleResponseData() {}

  explicit GetSceneRuleResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!gmtModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModified is required.")));
    }
    if (!ruleName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleName is required.")));
    }
    if (!ruleContent) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleContent is required.")));
    }
    if (!ruleDescription) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleDescription is required.")));
    }
    if (!ruleStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleStatus is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleContent) {
      res["RuleContent"] = boost::any(*ruleContent);
    }
    if (ruleDescription) {
      res["RuleDescription"] = boost::any(*ruleDescription);
    }
    if (ruleStatus) {
      res["RuleStatus"] = boost::any(*ruleStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleContent") != m.end() && !m["RuleContent"].empty()) {
      ruleContent = make_shared<string>(boost::any_cast<string>(m["RuleContent"]));
    }
    if (m.find("RuleDescription") != m.end() && !m["RuleDescription"].empty()) {
      ruleDescription = make_shared<string>(boost::any_cast<string>(m["RuleDescription"]));
    }
    if (m.find("RuleStatus") != m.end() && !m["RuleStatus"].empty()) {
      ruleStatus = make_shared<int>(boost::any_cast<int>(m["RuleStatus"]));
    }
  }


  virtual ~GetSceneRuleResponseData() = default;
};
class GetSceneRuleResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<GetSceneRuleResponseData> data{};

  GetSceneRuleResponse() {}

  explicit GetSceneRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetSceneRuleResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetSceneRuleResponseData>(model1);
      }
    }
  }


  virtual ~GetSceneRuleResponse() = default;
};
class DeleteSceneRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> ruleId{};

  DeleteSceneRuleRequest() {}

  explicit DeleteSceneRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!ruleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~DeleteSceneRuleRequest() = default;
};
class DeleteSceneRuleResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};

  DeleteSceneRuleResponse() {}

  explicit DeleteSceneRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~DeleteSceneRuleResponse() = default;
};
class BindSceneRuleToEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ruleId{};

  BindSceneRuleToEdgeInstanceRequest() {}

  explicit BindSceneRuleToEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!ruleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~BindSceneRuleToEdgeInstanceRequest() = default;
};
class BindSceneRuleToEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};

  BindSceneRuleToEdgeInstanceResponse() {}

  explicit BindSceneRuleToEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~BindSceneRuleToEdgeInstanceResponse() = default;
};
class CreateEdgeOssPreSignedAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> fileName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> type{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> resourceVersion{};

  CreateEdgeOssPreSignedAddressRequest() {}

  explicit CreateEdgeOssPreSignedAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!resourceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("resourceId is required.")));
    }
    if (!fileName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileName is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
    if (!resourceVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("resourceVersion is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (resourceVersion) {
      res["ResourceVersion"] = boost::any(*resourceVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ResourceVersion") != m.end() && !m["ResourceVersion"].empty()) {
      resourceVersion = make_shared<string>(boost::any_cast<string>(m["ResourceVersion"]));
    }
  }


  virtual ~CreateEdgeOssPreSignedAddressRequest() = default;
};
class CreateEdgeOssPreSignedAddressResponseData : public Darabonba::Model {
public:
  shared_ptr<string> ossPreSignedAddress{};
  shared_ptr<string> ossAddress{};

  CreateEdgeOssPreSignedAddressResponseData() {}

  explicit CreateEdgeOssPreSignedAddressResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!ossPreSignedAddress) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ossPreSignedAddress is required.")));
    }
    if (!ossAddress) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ossAddress is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ossPreSignedAddress) {
      res["OssPreSignedAddress"] = boost::any(*ossPreSignedAddress);
    }
    if (ossAddress) {
      res["OssAddress"] = boost::any(*ossAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OssPreSignedAddress") != m.end() && !m["OssPreSignedAddress"].empty()) {
      ossPreSignedAddress = make_shared<string>(boost::any_cast<string>(m["OssPreSignedAddress"]));
    }
    if (m.find("OssAddress") != m.end() && !m["OssAddress"].empty()) {
      ossAddress = make_shared<string>(boost::any_cast<string>(m["OssAddress"]));
    }
  }


  virtual ~CreateEdgeOssPreSignedAddressResponseData() = default;
};
class CreateEdgeOssPreSignedAddressResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<CreateEdgeOssPreSignedAddressResponseData> data{};

  CreateEdgeOssPreSignedAddressResponse() {}

  explicit CreateEdgeOssPreSignedAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateEdgeOssPreSignedAddressResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateEdgeOssPreSignedAddressResponseData>(model1);
      }
    }
  }


  virtual ~CreateEdgeOssPreSignedAddressResponse() = default;
};
class UpdateEdgeDriverVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};
  shared_ptr<string> edgeVersion{};
  shared_ptr<string> description{};
  shared_ptr<string> sourceConfig{};
  shared_ptr<string> driverConfig{};
  shared_ptr<string> containerConfig{};
  shared_ptr<string> configCheckRule{};
  shared_ptr<string> argument{};

  UpdateEdgeDriverVersionRequest() {}

  explicit UpdateEdgeDriverVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!driverId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverId is required.")));
    }
    if (!driverVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverVersion is required.")));
    }
    if (!edgeVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("edgeVersion is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    if (edgeVersion) {
      res["EdgeVersion"] = boost::any(*edgeVersion);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (sourceConfig) {
      res["SourceConfig"] = boost::any(*sourceConfig);
    }
    if (driverConfig) {
      res["DriverConfig"] = boost::any(*driverConfig);
    }
    if (containerConfig) {
      res["ContainerConfig"] = boost::any(*containerConfig);
    }
    if (configCheckRule) {
      res["ConfigCheckRule"] = boost::any(*configCheckRule);
    }
    if (argument) {
      res["Argument"] = boost::any(*argument);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
    if (m.find("EdgeVersion") != m.end() && !m["EdgeVersion"].empty()) {
      edgeVersion = make_shared<string>(boost::any_cast<string>(m["EdgeVersion"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SourceConfig") != m.end() && !m["SourceConfig"].empty()) {
      sourceConfig = make_shared<string>(boost::any_cast<string>(m["SourceConfig"]));
    }
    if (m.find("DriverConfig") != m.end() && !m["DriverConfig"].empty()) {
      driverConfig = make_shared<string>(boost::any_cast<string>(m["DriverConfig"]));
    }
    if (m.find("ContainerConfig") != m.end() && !m["ContainerConfig"].empty()) {
      containerConfig = make_shared<string>(boost::any_cast<string>(m["ContainerConfig"]));
    }
    if (m.find("ConfigCheckRule") != m.end() && !m["ConfigCheckRule"].empty()) {
      configCheckRule = make_shared<string>(boost::any_cast<string>(m["ConfigCheckRule"]));
    }
    if (m.find("Argument") != m.end() && !m["Argument"].empty()) {
      argument = make_shared<string>(boost::any_cast<string>(m["Argument"]));
    }
  }


  virtual ~UpdateEdgeDriverVersionRequest() = default;
};
class UpdateEdgeDriverVersionResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateEdgeDriverVersionResponse() {}

  explicit UpdateEdgeDriverVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateEdgeDriverVersionResponse() = default;
};
class DeleteEdgeDriverVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};

  DeleteEdgeDriverVersionRequest() {}

  explicit DeleteEdgeDriverVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!driverId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverId is required.")));
    }
    if (!driverVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverVersion is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
  }


  virtual ~DeleteEdgeDriverVersionRequest() = default;
};
class DeleteEdgeDriverVersionResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteEdgeDriverVersionResponse() {}

  explicit DeleteEdgeDriverVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteEdgeDriverVersionResponse() = default;
};
class CreateEdgeDriverVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};
  shared_ptr<string> edgeVersion{};
  shared_ptr<string> description{};
  shared_ptr<string> sourceConfig{};
  shared_ptr<string> driverConfig{};
  shared_ptr<string> containerConfig{};
  shared_ptr<string> configCheckRule{};
  shared_ptr<string> argument{};

  CreateEdgeDriverVersionRequest() {}

  explicit CreateEdgeDriverVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!driverId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverId is required.")));
    }
    if (!driverVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverVersion is required.")));
    }
    if (!edgeVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("edgeVersion is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    if (edgeVersion) {
      res["EdgeVersion"] = boost::any(*edgeVersion);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (sourceConfig) {
      res["SourceConfig"] = boost::any(*sourceConfig);
    }
    if (driverConfig) {
      res["DriverConfig"] = boost::any(*driverConfig);
    }
    if (containerConfig) {
      res["ContainerConfig"] = boost::any(*containerConfig);
    }
    if (configCheckRule) {
      res["ConfigCheckRule"] = boost::any(*configCheckRule);
    }
    if (argument) {
      res["Argument"] = boost::any(*argument);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
    if (m.find("EdgeVersion") != m.end() && !m["EdgeVersion"].empty()) {
      edgeVersion = make_shared<string>(boost::any_cast<string>(m["EdgeVersion"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SourceConfig") != m.end() && !m["SourceConfig"].empty()) {
      sourceConfig = make_shared<string>(boost::any_cast<string>(m["SourceConfig"]));
    }
    if (m.find("DriverConfig") != m.end() && !m["DriverConfig"].empty()) {
      driverConfig = make_shared<string>(boost::any_cast<string>(m["DriverConfig"]));
    }
    if (m.find("ContainerConfig") != m.end() && !m["ContainerConfig"].empty()) {
      containerConfig = make_shared<string>(boost::any_cast<string>(m["ContainerConfig"]));
    }
    if (m.find("ConfigCheckRule") != m.end() && !m["ConfigCheckRule"].empty()) {
      configCheckRule = make_shared<string>(boost::any_cast<string>(m["ConfigCheckRule"]));
    }
    if (m.find("Argument") != m.end() && !m["Argument"].empty()) {
      argument = make_shared<string>(boost::any_cast<string>(m["Argument"]));
    }
  }


  virtual ~CreateEdgeDriverVersionRequest() = default;
};
class CreateEdgeDriverVersionResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  CreateEdgeDriverVersionResponse() {}

  explicit CreateEdgeDriverVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CreateEdgeDriverVersionResponse() = default;
};
class DeleteEdgeDriverRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> driverId{};

  DeleteEdgeDriverRequest() {}

  explicit DeleteEdgeDriverRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!driverId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
  }


  virtual ~DeleteEdgeDriverRequest() = default;
};
class DeleteEdgeDriverResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteEdgeDriverResponse() {}

  explicit DeleteEdgeDriverResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteEdgeDriverResponse() = default;
};
class QueryEdgeDriverRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> currentPage{};
  shared_ptr<int> type{};
  shared_ptr<string> driverName{};

  QueryEdgeDriverRequest() {}

  explicit QueryEdgeDriverRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (driverName) {
      res["DriverName"] = boost::any(*driverName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<int>(boost::any_cast<int>(m["Type"]));
    }
    if (m.find("DriverName") != m.end() && !m["DriverName"].empty()) {
      driverName = make_shared<string>(boost::any_cast<string>(m["DriverName"]));
    }
  }


  virtual ~QueryEdgeDriverRequest() = default;
};
class QueryEdgeDriverResponseDataDriverList : public Darabonba::Model {
public:
  shared_ptr<string> driverId{};
  shared_ptr<string> driverName{};
  shared_ptr<string> driverProtocol{};
  shared_ptr<string> runtime{};
  shared_ptr<string> cpuArch{};
  shared_ptr<int> type{};
  shared_ptr<bool> isBuiltIn{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<long> gmtModifiedTimestamp{};

  QueryEdgeDriverResponseDataDriverList() {}

  explicit QueryEdgeDriverResponseDataDriverList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!driverId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverId is required.")));
    }
    if (!driverName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverName is required.")));
    }
    if (!driverProtocol) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverProtocol is required.")));
    }
    if (!runtime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("runtime is required.")));
    }
    if (!cpuArch) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("cpuArch is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
    if (!isBuiltIn) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isBuiltIn is required.")));
    }
    if (!gmtCreateTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreateTimestamp is required.")));
    }
    if (!gmtModifiedTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModifiedTimestamp is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverName) {
      res["DriverName"] = boost::any(*driverName);
    }
    if (driverProtocol) {
      res["DriverProtocol"] = boost::any(*driverProtocol);
    }
    if (runtime) {
      res["Runtime"] = boost::any(*runtime);
    }
    if (cpuArch) {
      res["CpuArch"] = boost::any(*cpuArch);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (isBuiltIn) {
      res["IsBuiltIn"] = boost::any(*isBuiltIn);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverName") != m.end() && !m["DriverName"].empty()) {
      driverName = make_shared<string>(boost::any_cast<string>(m["DriverName"]));
    }
    if (m.find("DriverProtocol") != m.end() && !m["DriverProtocol"].empty()) {
      driverProtocol = make_shared<string>(boost::any_cast<string>(m["DriverProtocol"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      runtime = make_shared<string>(boost::any_cast<string>(m["Runtime"]));
    }
    if (m.find("CpuArch") != m.end() && !m["CpuArch"].empty()) {
      cpuArch = make_shared<string>(boost::any_cast<string>(m["CpuArch"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<int>(boost::any_cast<int>(m["Type"]));
    }
    if (m.find("IsBuiltIn") != m.end() && !m["IsBuiltIn"].empty()) {
      isBuiltIn = make_shared<bool>(boost::any_cast<bool>(m["IsBuiltIn"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
  }


  virtual ~QueryEdgeDriverResponseDataDriverList() = default;
};
class QueryEdgeDriverResponseData : public Darabonba::Model {
public:
  shared_ptr<int> total{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> currentPage{};
  shared_ptr<vector<QueryEdgeDriverResponseDataDriverList>> driverList{};

  QueryEdgeDriverResponseData() {}

  explicit QueryEdgeDriverResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!driverList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (driverList) {
      vector<boost::any> temp1;
      for(auto item1:*driverList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DriverList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("DriverList") != m.end() && !m["DriverList"].empty()) {
      if (typeid(vector<boost::any>) == m["DriverList"].type()) {
        vector<QueryEdgeDriverResponseDataDriverList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DriverList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeDriverResponseDataDriverList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        driverList = make_shared<vector<QueryEdgeDriverResponseDataDriverList>>(expect1);
      }
    }
  }


  virtual ~QueryEdgeDriverResponseData() = default;
};
class QueryEdgeDriverResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryEdgeDriverResponseData> data{};

  QueryEdgeDriverResponse() {}

  explicit QueryEdgeDriverResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEdgeDriverResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEdgeDriverResponseData>(model1);
      }
    }
  }


  virtual ~QueryEdgeDriverResponse() = default;
};
class BatchGetEdgeDriverRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<string>> driverIds{};

  BatchGetEdgeDriverRequest() {}

  explicit BatchGetEdgeDriverRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!driverIds) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverIds is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (driverIds) {
      res["DriverIds"] = boost::any(*driverIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("DriverIds") != m.end() && !m["DriverIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DriverIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DriverIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      driverIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchGetEdgeDriverRequest() = default;
};
class BatchGetEdgeDriverResponseDriverList : public Darabonba::Model {
public:
  shared_ptr<string> driverId{};
  shared_ptr<string> driverName{};
  shared_ptr<string> driverProtocol{};
  shared_ptr<string> runtime{};
  shared_ptr<string> cpuArch{};
  shared_ptr<int> type{};
  shared_ptr<bool> isBuiltIn{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<long> gmtModifiedTimestamp{};

  BatchGetEdgeDriverResponseDriverList() {}

  explicit BatchGetEdgeDriverResponseDriverList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!driverId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverId is required.")));
    }
    if (!driverName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverName is required.")));
    }
    if (!driverProtocol) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverProtocol is required.")));
    }
    if (!runtime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("runtime is required.")));
    }
    if (!cpuArch) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("cpuArch is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
    if (!isBuiltIn) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isBuiltIn is required.")));
    }
    if (!gmtCreateTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreateTimestamp is required.")));
    }
    if (!gmtModifiedTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModifiedTimestamp is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverName) {
      res["DriverName"] = boost::any(*driverName);
    }
    if (driverProtocol) {
      res["DriverProtocol"] = boost::any(*driverProtocol);
    }
    if (runtime) {
      res["Runtime"] = boost::any(*runtime);
    }
    if (cpuArch) {
      res["CpuArch"] = boost::any(*cpuArch);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (isBuiltIn) {
      res["IsBuiltIn"] = boost::any(*isBuiltIn);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverName") != m.end() && !m["DriverName"].empty()) {
      driverName = make_shared<string>(boost::any_cast<string>(m["DriverName"]));
    }
    if (m.find("DriverProtocol") != m.end() && !m["DriverProtocol"].empty()) {
      driverProtocol = make_shared<string>(boost::any_cast<string>(m["DriverProtocol"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      runtime = make_shared<string>(boost::any_cast<string>(m["Runtime"]));
    }
    if (m.find("CpuArch") != m.end() && !m["CpuArch"].empty()) {
      cpuArch = make_shared<string>(boost::any_cast<string>(m["CpuArch"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<int>(boost::any_cast<int>(m["Type"]));
    }
    if (m.find("IsBuiltIn") != m.end() && !m["IsBuiltIn"].empty()) {
      isBuiltIn = make_shared<bool>(boost::any_cast<bool>(m["IsBuiltIn"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
  }


  virtual ~BatchGetEdgeDriverResponseDriverList() = default;
};
class BatchGetEdgeDriverResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<BatchGetEdgeDriverResponseDriverList>> driverList{};

  BatchGetEdgeDriverResponse() {}

  explicit BatchGetEdgeDriverResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!driverList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (driverList) {
      vector<boost::any> temp1;
      for(auto item1:*driverList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DriverList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("DriverList") != m.end() && !m["DriverList"].empty()) {
      if (typeid(vector<boost::any>) == m["DriverList"].type()) {
        vector<BatchGetEdgeDriverResponseDriverList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DriverList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetEdgeDriverResponseDriverList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        driverList = make_shared<vector<BatchGetEdgeDriverResponseDriverList>>(expect1);
      }
    }
  }


  virtual ~BatchGetEdgeDriverResponse() = default;
};
class CreateEdgeDriverRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> driverName{};
  shared_ptr<string> driverProtocol{};
  shared_ptr<string> runtime{};
  shared_ptr<string> cpuArch{};
  shared_ptr<bool> isBuiltIn{};

  CreateEdgeDriverRequest() {}

  explicit CreateEdgeDriverRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!driverName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverName is required.")));
    }
    if (!driverProtocol) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverProtocol is required.")));
    }
    if (!runtime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("runtime is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (driverName) {
      res["DriverName"] = boost::any(*driverName);
    }
    if (driverProtocol) {
      res["DriverProtocol"] = boost::any(*driverProtocol);
    }
    if (runtime) {
      res["Runtime"] = boost::any(*runtime);
    }
    if (cpuArch) {
      res["CpuArch"] = boost::any(*cpuArch);
    }
    if (isBuiltIn) {
      res["IsBuiltIn"] = boost::any(*isBuiltIn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("DriverName") != m.end() && !m["DriverName"].empty()) {
      driverName = make_shared<string>(boost::any_cast<string>(m["DriverName"]));
    }
    if (m.find("DriverProtocol") != m.end() && !m["DriverProtocol"].empty()) {
      driverProtocol = make_shared<string>(boost::any_cast<string>(m["DriverProtocol"]));
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      runtime = make_shared<string>(boost::any_cast<string>(m["Runtime"]));
    }
    if (m.find("CpuArch") != m.end() && !m["CpuArch"].empty()) {
      cpuArch = make_shared<string>(boost::any_cast<string>(m["CpuArch"]));
    }
    if (m.find("IsBuiltIn") != m.end() && !m["IsBuiltIn"].empty()) {
      isBuiltIn = make_shared<bool>(boost::any_cast<bool>(m["IsBuiltIn"]));
    }
  }


  virtual ~CreateEdgeDriverRequest() = default;
};
class CreateEdgeDriverResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> driverId{};

  CreateEdgeDriverResponse() {}

  explicit CreateEdgeDriverResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!driverId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
  }


  virtual ~CreateEdgeDriverResponse() = default;
};
class GetEdgeDriverVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};

  GetEdgeDriverVersionRequest() {}

  explicit GetEdgeDriverVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!driverId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverId is required.")));
    }
    if (!driverVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverVersion is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
  }


  virtual ~GetEdgeDriverVersionRequest() = default;
};
class GetEdgeDriverVersionResponseData : public Darabonba::Model {
public:
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};
  shared_ptr<string> versionState{};
  shared_ptr<string> edgeVersion{};
  shared_ptr<string> description{};
  shared_ptr<string> sourceConfig{};
  shared_ptr<string> driverConfig{};
  shared_ptr<string> containerConfig{};
  shared_ptr<string> configCheckRule{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<string> argument{};

  GetEdgeDriverVersionResponseData() {}

  explicit GetEdgeDriverVersionResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!driverId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverId is required.")));
    }
    if (!driverVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverVersion is required.")));
    }
    if (!versionState) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("versionState is required.")));
    }
    if (!edgeVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("edgeVersion is required.")));
    }
    if (!description) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("description is required.")));
    }
    if (!sourceConfig) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sourceConfig is required.")));
    }
    if (!driverConfig) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverConfig is required.")));
    }
    if (!containerConfig) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("containerConfig is required.")));
    }
    if (!configCheckRule) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("configCheckRule is required.")));
    }
    if (!gmtCreateTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreateTimestamp is required.")));
    }
    if (!gmtModifiedTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModifiedTimestamp is required.")));
    }
    if (!argument) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("argument is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    if (versionState) {
      res["VersionState"] = boost::any(*versionState);
    }
    if (edgeVersion) {
      res["EdgeVersion"] = boost::any(*edgeVersion);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (sourceConfig) {
      res["SourceConfig"] = boost::any(*sourceConfig);
    }
    if (driverConfig) {
      res["DriverConfig"] = boost::any(*driverConfig);
    }
    if (containerConfig) {
      res["ContainerConfig"] = boost::any(*containerConfig);
    }
    if (configCheckRule) {
      res["ConfigCheckRule"] = boost::any(*configCheckRule);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (argument) {
      res["Argument"] = boost::any(*argument);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
    if (m.find("VersionState") != m.end() && !m["VersionState"].empty()) {
      versionState = make_shared<string>(boost::any_cast<string>(m["VersionState"]));
    }
    if (m.find("EdgeVersion") != m.end() && !m["EdgeVersion"].empty()) {
      edgeVersion = make_shared<string>(boost::any_cast<string>(m["EdgeVersion"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SourceConfig") != m.end() && !m["SourceConfig"].empty()) {
      sourceConfig = make_shared<string>(boost::any_cast<string>(m["SourceConfig"]));
    }
    if (m.find("DriverConfig") != m.end() && !m["DriverConfig"].empty()) {
      driverConfig = make_shared<string>(boost::any_cast<string>(m["DriverConfig"]));
    }
    if (m.find("ContainerConfig") != m.end() && !m["ContainerConfig"].empty()) {
      containerConfig = make_shared<string>(boost::any_cast<string>(m["ContainerConfig"]));
    }
    if (m.find("ConfigCheckRule") != m.end() && !m["ConfigCheckRule"].empty()) {
      configCheckRule = make_shared<string>(boost::any_cast<string>(m["ConfigCheckRule"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("Argument") != m.end() && !m["Argument"].empty()) {
      argument = make_shared<string>(boost::any_cast<string>(m["Argument"]));
    }
  }


  virtual ~GetEdgeDriverVersionResponseData() = default;
};
class GetEdgeDriverVersionResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetEdgeDriverVersionResponseData> data{};

  GetEdgeDriverVersionResponse() {}

  explicit GetEdgeDriverVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetEdgeDriverVersionResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetEdgeDriverVersionResponseData>(model1);
      }
    }
  }


  virtual ~GetEdgeDriverVersionResponse() = default;
};
class QueryEdgeDriverVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> currentPage{};
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};
  shared_ptr<int> versionState{};

  QueryEdgeDriverVersionRequest() {}

  explicit QueryEdgeDriverVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!driverId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    if (versionState) {
      res["VersionState"] = boost::any(*versionState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
    if (m.find("VersionState") != m.end() && !m["VersionState"].empty()) {
      versionState = make_shared<int>(boost::any_cast<int>(m["VersionState"]));
    }
  }


  virtual ~QueryEdgeDriverVersionRequest() = default;
};
class QueryEdgeDriverVersionResponseDataDriverVersionList : public Darabonba::Model {
public:
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};
  shared_ptr<string> versionState{};
  shared_ptr<string> edgeVersion{};
  shared_ptr<string> description{};
  shared_ptr<string> sourceConfig{};
  shared_ptr<string> driverConfig{};
  shared_ptr<string> containerConfig{};
  shared_ptr<string> configCheckRule{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<string> argument{};

  QueryEdgeDriverVersionResponseDataDriverVersionList() {}

  explicit QueryEdgeDriverVersionResponseDataDriverVersionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!driverId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverId is required.")));
    }
    if (!driverVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverVersion is required.")));
    }
    if (!versionState) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("versionState is required.")));
    }
    if (!edgeVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("edgeVersion is required.")));
    }
    if (!description) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("description is required.")));
    }
    if (!sourceConfig) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sourceConfig is required.")));
    }
    if (!driverConfig) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverConfig is required.")));
    }
    if (!containerConfig) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("containerConfig is required.")));
    }
    if (!configCheckRule) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("configCheckRule is required.")));
    }
    if (!gmtCreateTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreateTimestamp is required.")));
    }
    if (!gmtModifiedTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModifiedTimestamp is required.")));
    }
    if (!argument) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("argument is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    if (versionState) {
      res["VersionState"] = boost::any(*versionState);
    }
    if (edgeVersion) {
      res["EdgeVersion"] = boost::any(*edgeVersion);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (sourceConfig) {
      res["SourceConfig"] = boost::any(*sourceConfig);
    }
    if (driverConfig) {
      res["DriverConfig"] = boost::any(*driverConfig);
    }
    if (containerConfig) {
      res["ContainerConfig"] = boost::any(*containerConfig);
    }
    if (configCheckRule) {
      res["ConfigCheckRule"] = boost::any(*configCheckRule);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (argument) {
      res["Argument"] = boost::any(*argument);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
    if (m.find("VersionState") != m.end() && !m["VersionState"].empty()) {
      versionState = make_shared<string>(boost::any_cast<string>(m["VersionState"]));
    }
    if (m.find("EdgeVersion") != m.end() && !m["EdgeVersion"].empty()) {
      edgeVersion = make_shared<string>(boost::any_cast<string>(m["EdgeVersion"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SourceConfig") != m.end() && !m["SourceConfig"].empty()) {
      sourceConfig = make_shared<string>(boost::any_cast<string>(m["SourceConfig"]));
    }
    if (m.find("DriverConfig") != m.end() && !m["DriverConfig"].empty()) {
      driverConfig = make_shared<string>(boost::any_cast<string>(m["DriverConfig"]));
    }
    if (m.find("ContainerConfig") != m.end() && !m["ContainerConfig"].empty()) {
      containerConfig = make_shared<string>(boost::any_cast<string>(m["ContainerConfig"]));
    }
    if (m.find("ConfigCheckRule") != m.end() && !m["ConfigCheckRule"].empty()) {
      configCheckRule = make_shared<string>(boost::any_cast<string>(m["ConfigCheckRule"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("Argument") != m.end() && !m["Argument"].empty()) {
      argument = make_shared<string>(boost::any_cast<string>(m["Argument"]));
    }
  }


  virtual ~QueryEdgeDriverVersionResponseDataDriverVersionList() = default;
};
class QueryEdgeDriverVersionResponseData : public Darabonba::Model {
public:
  shared_ptr<int> total{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> currentPage{};
  shared_ptr<vector<QueryEdgeDriverVersionResponseDataDriverVersionList>> driverVersionList{};

  QueryEdgeDriverVersionResponseData() {}

  explicit QueryEdgeDriverVersionResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!driverVersionList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverVersionList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (driverVersionList) {
      vector<boost::any> temp1;
      for(auto item1:*driverVersionList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DriverVersionList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("DriverVersionList") != m.end() && !m["DriverVersionList"].empty()) {
      if (typeid(vector<boost::any>) == m["DriverVersionList"].type()) {
        vector<QueryEdgeDriverVersionResponseDataDriverVersionList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DriverVersionList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeDriverVersionResponseDataDriverVersionList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        driverVersionList = make_shared<vector<QueryEdgeDriverVersionResponseDataDriverVersionList>>(expect1);
      }
    }
  }


  virtual ~QueryEdgeDriverVersionResponseData() = default;
};
class QueryEdgeDriverVersionResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryEdgeDriverVersionResponseData> data{};

  QueryEdgeDriverVersionResponse() {}

  explicit QueryEdgeDriverVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEdgeDriverVersionResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEdgeDriverVersionResponseData>(model1);
      }
    }
  }


  virtual ~QueryEdgeDriverVersionResponse() = default;
};
class BatchGetDeviceBindStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<string>> iotIds{};

  BatchGetDeviceBindStatusRequest() {}

  explicit BatchGetDeviceBindStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!iotIds) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotIds is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (iotIds) {
      res["IotIds"] = boost::any(*iotIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("IotIds") != m.end() && !m["IotIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchGetDeviceBindStatusRequest() = default;
};
class BatchGetDeviceBindStatusResponseData : public Darabonba::Model {
public:
  shared_ptr<string> iotId{};
  shared_ptr<int> bindStatus{};

  BatchGetDeviceBindStatusResponseData() {}

  explicit BatchGetDeviceBindStatusResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!iotId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotId is required.")));
    }
    if (!bindStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bindStatus is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (bindStatus) {
      res["BindStatus"] = boost::any(*bindStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("BindStatus") != m.end() && !m["BindStatus"].empty()) {
      bindStatus = make_shared<int>(boost::any_cast<int>(m["BindStatus"]));
    }
  }


  virtual ~BatchGetDeviceBindStatusResponseData() = default;
};
class BatchGetDeviceBindStatusResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<BatchGetDeviceBindStatusResponseData>> data{};

  BatchGetDeviceBindStatusResponse() {}

  explicit BatchGetDeviceBindStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<BatchGetDeviceBindStatusResponseData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetDeviceBindStatusResponseData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<BatchGetDeviceBindStatusResponseData>>(expect1);
      }
    }
  }


  virtual ~BatchGetDeviceBindStatusResponse() = default;
};
class ListOTAJobByDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> firmwareId{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<int> currentPage{};

  ListOTAJobByDeviceRequest() {}

  explicit ListOTAJobByDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!firmwareId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareId is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
  }


  virtual ~ListOTAJobByDeviceRequest() = default;
};
class ListOTAJobByDeviceResponseDataSimpleOTAJobInfoTagsOtaTagDTO : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListOTAJobByDeviceResponseDataSimpleOTAJobInfoTagsOtaTagDTO() {}

  explicit ListOTAJobByDeviceResponseDataSimpleOTAJobInfoTagsOtaTagDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!key) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("key is required.")));
    }
    if (!value) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("value is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListOTAJobByDeviceResponseDataSimpleOTAJobInfoTagsOtaTagDTO() = default;
};
class ListOTAJobByDeviceResponseDataSimpleOTAJobInfoTags : public Darabonba::Model {
public:
  shared_ptr<vector<ListOTAJobByDeviceResponseDataSimpleOTAJobInfoTagsOtaTagDTO>> otaTagDTO{};

  ListOTAJobByDeviceResponseDataSimpleOTAJobInfoTags() {}

  explicit ListOTAJobByDeviceResponseDataSimpleOTAJobInfoTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!otaTagDTO) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("otaTagDTO is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (otaTagDTO) {
      vector<boost::any> temp1;
      for(auto item1:*otaTagDTO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OtaTagDTO"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OtaTagDTO") != m.end() && !m["OtaTagDTO"].empty()) {
      if (typeid(vector<boost::any>) == m["OtaTagDTO"].type()) {
        vector<ListOTAJobByDeviceResponseDataSimpleOTAJobInfoTagsOtaTagDTO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OtaTagDTO"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOTAJobByDeviceResponseDataSimpleOTAJobInfoTagsOtaTagDTO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        otaTagDTO = make_shared<vector<ListOTAJobByDeviceResponseDataSimpleOTAJobInfoTagsOtaTagDTO>>(expect1);
      }
    }
  }


  virtual ~ListOTAJobByDeviceResponseDataSimpleOTAJobInfoTags() = default;
};
class ListOTAJobByDeviceResponseDataSimpleOTAJobInfo : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> utcModified{};
  shared_ptr<string> productKey{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> utcStartTime{};
  shared_ptr<string> utcEndTime{};
  shared_ptr<string> jobStatus{};
  shared_ptr<string> jobType{};
  shared_ptr<string> targetSelection{};
  shared_ptr<string> selectionType{};
  shared_ptr<ListOTAJobByDeviceResponseDataSimpleOTAJobInfoTags> tags{};

  ListOTAJobByDeviceResponseDataSimpleOTAJobInfo() {}

  explicit ListOTAJobByDeviceResponseDataSimpleOTAJobInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
    if (!utcCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcCreate is required.")));
    }
    if (!utcModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcModified is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!firmwareId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareId is required.")));
    }
    if (!utcStartTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcStartTime is required.")));
    }
    if (!utcEndTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcEndTime is required.")));
    }
    if (!jobStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobStatus is required.")));
    }
    if (!jobType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobType is required.")));
    }
    if (!targetSelection) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetSelection is required.")));
    }
    if (!selectionType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("selectionType is required.")));
    }
    if (!tags) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tags is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (utcStartTime) {
      res["UtcStartTime"] = boost::any(*utcStartTime);
    }
    if (utcEndTime) {
      res["UtcEndTime"] = boost::any(*utcEndTime);
    }
    if (jobStatus) {
      res["JobStatus"] = boost::any(*jobStatus);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (targetSelection) {
      res["TargetSelection"] = boost::any(*targetSelection);
    }
    if (selectionType) {
      res["SelectionType"] = boost::any(*selectionType);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("UtcStartTime") != m.end() && !m["UtcStartTime"].empty()) {
      utcStartTime = make_shared<string>(boost::any_cast<string>(m["UtcStartTime"]));
    }
    if (m.find("UtcEndTime") != m.end() && !m["UtcEndTime"].empty()) {
      utcEndTime = make_shared<string>(boost::any_cast<string>(m["UtcEndTime"]));
    }
    if (m.find("JobStatus") != m.end() && !m["JobStatus"].empty()) {
      jobStatus = make_shared<string>(boost::any_cast<string>(m["JobStatus"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("TargetSelection") != m.end() && !m["TargetSelection"].empty()) {
      targetSelection = make_shared<string>(boost::any_cast<string>(m["TargetSelection"]));
    }
    if (m.find("SelectionType") != m.end() && !m["SelectionType"].empty()) {
      selectionType = make_shared<string>(boost::any_cast<string>(m["SelectionType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        ListOTAJobByDeviceResponseDataSimpleOTAJobInfoTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<ListOTAJobByDeviceResponseDataSimpleOTAJobInfoTags>(model1);
      }
    }
  }


  virtual ~ListOTAJobByDeviceResponseDataSimpleOTAJobInfo() = default;
};
class ListOTAJobByDeviceResponseData : public Darabonba::Model {
public:
  shared_ptr<vector<ListOTAJobByDeviceResponseDataSimpleOTAJobInfo>> simpleOTAJobInfo{};

  ListOTAJobByDeviceResponseData() {}

  explicit ListOTAJobByDeviceResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!simpleOTAJobInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("simpleOTAJobInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (simpleOTAJobInfo) {
      vector<boost::any> temp1;
      for(auto item1:*simpleOTAJobInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SimpleOTAJobInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SimpleOTAJobInfo") != m.end() && !m["SimpleOTAJobInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SimpleOTAJobInfo"].type()) {
        vector<ListOTAJobByDeviceResponseDataSimpleOTAJobInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SimpleOTAJobInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOTAJobByDeviceResponseDataSimpleOTAJobInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        simpleOTAJobInfo = make_shared<vector<ListOTAJobByDeviceResponseDataSimpleOTAJobInfo>>(expect1);
      }
    }
  }


  virtual ~ListOTAJobByDeviceResponseData() = default;
};
class ListOTAJobByDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> total{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> pageCount{};
  shared_ptr<int> currentPage{};
  shared_ptr<ListOTAJobByDeviceResponseData> data{};

  ListOTAJobByDeviceResponse() {}

  explicit ListOTAJobByDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!pageCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageCount is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<int>(boost::any_cast<int>(m["PageCount"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListOTAJobByDeviceResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListOTAJobByDeviceResponseData>(model1);
      }
    }
  }


  virtual ~ListOTAJobByDeviceResponse() = default;
};
class UpdateThingModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> identifier{};
  shared_ptr<string> thingModelJson{};
  shared_ptr<string> functionBlockId{};
  shared_ptr<string> functionBlockName{};

  UpdateThingModelRequest() {}

  explicit UpdateThingModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (thingModelJson) {
      res["ThingModelJson"] = boost::any(*thingModelJson);
    }
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    if (functionBlockName) {
      res["FunctionBlockName"] = boost::any(*functionBlockName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("ThingModelJson") != m.end() && !m["ThingModelJson"].empty()) {
      thingModelJson = make_shared<string>(boost::any_cast<string>(m["ThingModelJson"]));
    }
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
    if (m.find("FunctionBlockName") != m.end() && !m["FunctionBlockName"].empty()) {
      functionBlockName = make_shared<string>(boost::any_cast<string>(m["FunctionBlockName"]));
    }
  }


  virtual ~UpdateThingModelRequest() = default;
};
class UpdateThingModelResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateThingModelResponse() {}

  explicit UpdateThingModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateThingModelResponse() = default;
};
class CreateThingModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> thingModelJson{};
  shared_ptr<string> functionBlockId{};
  shared_ptr<string> functionBlockName{};

  CreateThingModelRequest() {}

  explicit CreateThingModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (thingModelJson) {
      res["ThingModelJson"] = boost::any(*thingModelJson);
    }
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    if (functionBlockName) {
      res["FunctionBlockName"] = boost::any(*functionBlockName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ThingModelJson") != m.end() && !m["ThingModelJson"].empty()) {
      thingModelJson = make_shared<string>(boost::any_cast<string>(m["ThingModelJson"]));
    }
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
    if (m.find("FunctionBlockName") != m.end() && !m["FunctionBlockName"].empty()) {
      functionBlockName = make_shared<string>(boost::any_cast<string>(m["FunctionBlockName"]));
    }
  }


  virtual ~CreateThingModelRequest() = default;
};
class CreateThingModelResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  CreateThingModelResponse() {}

  explicit CreateThingModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CreateThingModelResponse() = default;
};
class ListOTATaskByJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> taskStatus{};
  shared_ptr<string> jobId{};
  shared_ptr<int> currentPage{};
  shared_ptr<vector<string>> deviceNames{};

  ListOTATaskByJobRequest() {}

  explicit ListOTATaskByJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (deviceNames) {
      res["DeviceNames"] = boost::any(*deviceNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("DeviceNames") != m.end() && !m["DeviceNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListOTATaskByJobRequest() = default;
};
class ListOTATaskByJobResponseDataSimpleOTATaskInfo : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};
  shared_ptr<string> utcModified{};
  shared_ptr<string> productKey{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> taskStatus{};
  shared_ptr<string> jobId{};
  shared_ptr<string> productName{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> srcVersion{};
  shared_ptr<string> destVersion{};
  shared_ptr<string> taskDesc{};
  shared_ptr<string> progress{};
  shared_ptr<string> iotId{};
  shared_ptr<string> utcCreate{};

  ListOTATaskByJobResponseDataSimpleOTATaskInfo() {}

  explicit ListOTATaskByJobResponseDataSimpleOTATaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!taskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskId is required.")));
    }
    if (!utcModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcModified is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!firmwareId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareId is required.")));
    }
    if (!taskStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskStatus is required.")));
    }
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
    if (!productName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productName is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!srcVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("srcVersion is required.")));
    }
    if (!destVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("destVersion is required.")));
    }
    if (!taskDesc) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskDesc is required.")));
    }
    if (!progress) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("progress is required.")));
    }
    if (!iotId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotId is required.")));
    }
    if (!utcCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcCreate is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (srcVersion) {
      res["SrcVersion"] = boost::any(*srcVersion);
    }
    if (destVersion) {
      res["DestVersion"] = boost::any(*destVersion);
    }
    if (taskDesc) {
      res["TaskDesc"] = boost::any(*taskDesc);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("SrcVersion") != m.end() && !m["SrcVersion"].empty()) {
      srcVersion = make_shared<string>(boost::any_cast<string>(m["SrcVersion"]));
    }
    if (m.find("DestVersion") != m.end() && !m["DestVersion"].empty()) {
      destVersion = make_shared<string>(boost::any_cast<string>(m["DestVersion"]));
    }
    if (m.find("TaskDesc") != m.end() && !m["TaskDesc"].empty()) {
      taskDesc = make_shared<string>(boost::any_cast<string>(m["TaskDesc"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
  }


  virtual ~ListOTATaskByJobResponseDataSimpleOTATaskInfo() = default;
};
class ListOTATaskByJobResponseData : public Darabonba::Model {
public:
  shared_ptr<vector<ListOTATaskByJobResponseDataSimpleOTATaskInfo>> simpleOTATaskInfo{};

  ListOTATaskByJobResponseData() {}

  explicit ListOTATaskByJobResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!simpleOTATaskInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("simpleOTATaskInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (simpleOTATaskInfo) {
      vector<boost::any> temp1;
      for(auto item1:*simpleOTATaskInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SimpleOTATaskInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SimpleOTATaskInfo") != m.end() && !m["SimpleOTATaskInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SimpleOTATaskInfo"].type()) {
        vector<ListOTATaskByJobResponseDataSimpleOTATaskInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SimpleOTATaskInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOTATaskByJobResponseDataSimpleOTATaskInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        simpleOTATaskInfo = make_shared<vector<ListOTATaskByJobResponseDataSimpleOTATaskInfo>>(expect1);
      }
    }
  }


  virtual ~ListOTATaskByJobResponseData() = default;
};
class ListOTATaskByJobResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> total{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> pageCount{};
  shared_ptr<int> currentPage{};
  shared_ptr<ListOTATaskByJobResponseData> data{};

  ListOTATaskByJobResponse() {}

  explicit ListOTATaskByJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!pageCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageCount is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<int>(boost::any_cast<int>(m["PageCount"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListOTATaskByJobResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListOTATaskByJobResponseData>(model1);
      }
    }
  }


  virtual ~ListOTATaskByJobResponse() = default;
};
class ListThingTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> resourceGroupId{};

  ListThingTemplatesRequest() {}

  explicit ListThingTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListThingTemplatesRequest() = default;
};
class ListThingTemplatesResponseData : public Darabonba::Model {
public:
  shared_ptr<string> categoryKey{};
  shared_ptr<string> categoryName{};

  ListThingTemplatesResponseData() {}

  explicit ListThingTemplatesResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!categoryKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("categoryKey is required.")));
    }
    if (!categoryName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("categoryName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryKey) {
      res["CategoryKey"] = boost::any(*categoryKey);
    }
    if (categoryName) {
      res["CategoryName"] = boost::any(*categoryName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryKey") != m.end() && !m["CategoryKey"].empty()) {
      categoryKey = make_shared<string>(boost::any_cast<string>(m["CategoryKey"]));
    }
    if (m.find("CategoryName") != m.end() && !m["CategoryName"].empty()) {
      categoryName = make_shared<string>(boost::any_cast<string>(m["CategoryName"]));
    }
  }


  virtual ~ListThingTemplatesResponseData() = default;
};
class ListThingTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<ListThingTemplatesResponseData>> data{};

  ListThingTemplatesResponse() {}

  explicit ListThingTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListThingTemplatesResponseData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListThingTemplatesResponseData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListThingTemplatesResponseData>>(expect1);
      }
    }
  }


  virtual ~ListThingTemplatesResponse() = default;
};
class GetThingTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> categoryKey{};

  GetThingTemplateRequest() {}

  explicit GetThingTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (categoryKey) {
      res["CategoryKey"] = boost::any(*categoryKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("CategoryKey") != m.end() && !m["CategoryKey"].empty()) {
      categoryKey = make_shared<string>(boost::any_cast<string>(m["CategoryKey"]));
    }
  }


  virtual ~GetThingTemplateRequest() = default;
};
class GetThingTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> thingModelJSON{};

  GetThingTemplateResponse() {}

  explicit GetThingTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!thingModelJSON) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("thingModelJSON is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (thingModelJSON) {
      res["ThingModelJSON"] = boost::any(*thingModelJSON);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ThingModelJSON") != m.end() && !m["ThingModelJSON"].empty()) {
      thingModelJSON = make_shared<string>(boost::any_cast<string>(m["ThingModelJSON"]));
    }
  }


  virtual ~GetThingTemplateResponse() = default;
};
class ListThingModelVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> productKey{};

  ListThingModelVersionRequest() {}

  explicit ListThingModelVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~ListThingModelVersionRequest() = default;
};
class ListThingModelVersionResponseDataModelVersions : public Darabonba::Model {
public:
  shared_ptr<string> modelVersion{};
  shared_ptr<string> description{};
  shared_ptr<long> gmtCreate{};

  ListThingModelVersionResponseDataModelVersions() {}

  explicit ListThingModelVersionResponseDataModelVersions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!modelVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("modelVersion is required.")));
    }
    if (!description) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("description is required.")));
    }
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (modelVersion) {
      res["ModelVersion"] = boost::any(*modelVersion);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModelVersion") != m.end() && !m["ModelVersion"].empty()) {
      modelVersion = make_shared<string>(boost::any_cast<string>(m["ModelVersion"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
  }


  virtual ~ListThingModelVersionResponseDataModelVersions() = default;
};
class ListThingModelVersionResponseData : public Darabonba::Model {
public:
  shared_ptr<vector<ListThingModelVersionResponseDataModelVersions>> modelVersions{};

  ListThingModelVersionResponseData() {}

  explicit ListThingModelVersionResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!modelVersions) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("modelVersions is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (modelVersions) {
      vector<boost::any> temp1;
      for(auto item1:*modelVersions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ModelVersions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModelVersions") != m.end() && !m["ModelVersions"].empty()) {
      if (typeid(vector<boost::any>) == m["ModelVersions"].type()) {
        vector<ListThingModelVersionResponseDataModelVersions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ModelVersions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListThingModelVersionResponseDataModelVersions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        modelVersions = make_shared<vector<ListThingModelVersionResponseDataModelVersions>>(expect1);
      }
    }
  }


  virtual ~ListThingModelVersionResponseData() = default;
};
class ListThingModelVersionResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<ListThingModelVersionResponseData> data{};

  ListThingModelVersionResponse() {}

  explicit ListThingModelVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListThingModelVersionResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListThingModelVersionResponseData>(model1);
      }
    }
  }


  virtual ~ListThingModelVersionResponse() = default;
};
class ImportThingModelTslRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> tslStr{};
  shared_ptr<string> tslUrl{};
  shared_ptr<string> functionBlockId{};
  shared_ptr<string> functionBlockName{};

  ImportThingModelTslRequest() {}

  explicit ImportThingModelTslRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (tslStr) {
      res["TslStr"] = boost::any(*tslStr);
    }
    if (tslUrl) {
      res["TslUrl"] = boost::any(*tslUrl);
    }
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    if (functionBlockName) {
      res["FunctionBlockName"] = boost::any(*functionBlockName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("TslStr") != m.end() && !m["TslStr"].empty()) {
      tslStr = make_shared<string>(boost::any_cast<string>(m["TslStr"]));
    }
    if (m.find("TslUrl") != m.end() && !m["TslUrl"].empty()) {
      tslUrl = make_shared<string>(boost::any_cast<string>(m["TslUrl"]));
    }
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
    if (m.find("FunctionBlockName") != m.end() && !m["FunctionBlockName"].empty()) {
      functionBlockName = make_shared<string>(boost::any_cast<string>(m["FunctionBlockName"]));
    }
  }


  virtual ~ImportThingModelTslRequest() = default;
};
class ImportThingModelTslResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  ImportThingModelTslResponse() {}

  explicit ImportThingModelTslResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~ImportThingModelTslResponse() = default;
};
class PublishThingModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> modelVersion{};
  shared_ptr<string> description{};

  PublishThingModelRequest() {}

  explicit PublishThingModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (modelVersion) {
      res["ModelVersion"] = boost::any(*modelVersion);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ModelVersion") != m.end() && !m["ModelVersion"].empty()) {
      modelVersion = make_shared<string>(boost::any_cast<string>(m["ModelVersion"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~PublishThingModelRequest() = default;
};
class PublishThingModelResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  PublishThingModelResponse() {}

  explicit PublishThingModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~PublishThingModelResponse() = default;
};
class CopyThingModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> sourceProductKey{};
  shared_ptr<string> targetProductKey{};
  shared_ptr<string> sourceModelVersion{};

  CopyThingModelRequest() {}

  explicit CopyThingModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!sourceProductKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sourceProductKey is required.")));
    }
    if (!targetProductKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetProductKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (sourceProductKey) {
      res["SourceProductKey"] = boost::any(*sourceProductKey);
    }
    if (targetProductKey) {
      res["TargetProductKey"] = boost::any(*targetProductKey);
    }
    if (sourceModelVersion) {
      res["SourceModelVersion"] = boost::any(*sourceModelVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SourceProductKey") != m.end() && !m["SourceProductKey"].empty()) {
      sourceProductKey = make_shared<string>(boost::any_cast<string>(m["SourceProductKey"]));
    }
    if (m.find("TargetProductKey") != m.end() && !m["TargetProductKey"].empty()) {
      targetProductKey = make_shared<string>(boost::any_cast<string>(m["TargetProductKey"]));
    }
    if (m.find("SourceModelVersion") != m.end() && !m["SourceModelVersion"].empty()) {
      sourceModelVersion = make_shared<string>(boost::any_cast<string>(m["SourceModelVersion"]));
    }
  }


  virtual ~CopyThingModelRequest() = default;
};
class CopyThingModelResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  CopyThingModelResponse() {}

  explicit CopyThingModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CopyThingModelResponse() = default;
};
class GetThingModelTslRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> modelVersion{};
  shared_ptr<bool> simple{};
  shared_ptr<string> functionBlockId{};

  GetThingModelTslRequest() {}

  explicit GetThingModelTslRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (modelVersion) {
      res["ModelVersion"] = boost::any(*modelVersion);
    }
    if (simple) {
      res["Simple"] = boost::any(*simple);
    }
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ModelVersion") != m.end() && !m["ModelVersion"].empty()) {
      modelVersion = make_shared<string>(boost::any_cast<string>(m["ModelVersion"]));
    }
    if (m.find("Simple") != m.end() && !m["Simple"].empty()) {
      simple = make_shared<bool>(boost::any_cast<bool>(m["Simple"]));
    }
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
  }


  virtual ~GetThingModelTslRequest() = default;
};
class GetThingModelTslResponseData : public Darabonba::Model {
public:
  shared_ptr<string> tslStr{};
  shared_ptr<string> tslUri{};

  GetThingModelTslResponseData() {}

  explicit GetThingModelTslResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tslStr) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tslStr is required.")));
    }
    if (!tslUri) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tslUri is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tslStr) {
      res["TslStr"] = boost::any(*tslStr);
    }
    if (tslUri) {
      res["TslUri"] = boost::any(*tslUri);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TslStr") != m.end() && !m["TslStr"].empty()) {
      tslStr = make_shared<string>(boost::any_cast<string>(m["TslStr"]));
    }
    if (m.find("TslUri") != m.end() && !m["TslUri"].empty()) {
      tslUri = make_shared<string>(boost::any_cast<string>(m["TslUri"]));
    }
  }


  virtual ~GetThingModelTslResponseData() = default;
};
class GetThingModelTslResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetThingModelTslResponseData> data{};

  GetThingModelTslResponse() {}

  explicit GetThingModelTslResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetThingModelTslResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetThingModelTslResponseData>(model1);
      }
    }
  }


  virtual ~GetThingModelTslResponse() = default;
};
class QueryThingModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> modelVersion{};
  shared_ptr<string> functionBlockId{};

  QueryThingModelRequest() {}

  explicit QueryThingModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (modelVersion) {
      res["ModelVersion"] = boost::any(*modelVersion);
    }
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ModelVersion") != m.end() && !m["ModelVersion"].empty()) {
      modelVersion = make_shared<string>(boost::any_cast<string>(m["ModelVersion"]));
    }
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
  }


  virtual ~QueryThingModelRequest() = default;
};
class QueryThingModelResponseData : public Darabonba::Model {
public:
  shared_ptr<string> thingModelJson{};

  QueryThingModelResponseData() {}

  explicit QueryThingModelResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!thingModelJson) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("thingModelJson is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (thingModelJson) {
      res["ThingModelJson"] = boost::any(*thingModelJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ThingModelJson") != m.end() && !m["ThingModelJson"].empty()) {
      thingModelJson = make_shared<string>(boost::any_cast<string>(m["ThingModelJson"]));
    }
  }


  virtual ~QueryThingModelResponseData() = default;
};
class QueryThingModelResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> productKey{};
  shared_ptr<QueryThingModelResponseData> data{};

  QueryThingModelResponse() {}

  explicit QueryThingModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryThingModelResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryThingModelResponseData>(model1);
      }
    }
  }


  virtual ~QueryThingModelResponse() = default;
};
class DeleteThingModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> productKey{};
  shared_ptr<vector<string>> propertyIdentifier{};
  shared_ptr<vector<string>> serviceIdentifier{};
  shared_ptr<vector<string>> eventIdentifier{};
  shared_ptr<string> functionBlockId{};

  DeleteThingModelRequest() {}

  explicit DeleteThingModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (propertyIdentifier) {
      res["PropertyIdentifier"] = boost::any(*propertyIdentifier);
    }
    if (serviceIdentifier) {
      res["ServiceIdentifier"] = boost::any(*serviceIdentifier);
    }
    if (eventIdentifier) {
      res["EventIdentifier"] = boost::any(*eventIdentifier);
    }
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("PropertyIdentifier") != m.end() && !m["PropertyIdentifier"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PropertyIdentifier"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PropertyIdentifier"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      propertyIdentifier = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ServiceIdentifier") != m.end() && !m["ServiceIdentifier"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ServiceIdentifier"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ServiceIdentifier"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      serviceIdentifier = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EventIdentifier") != m.end() && !m["EventIdentifier"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EventIdentifier"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EventIdentifier"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      eventIdentifier = make_shared<vector<string>>(toVec1);
    }
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
  }


  virtual ~DeleteThingModelRequest() = default;
};
class DeleteThingModelResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteThingModelResponse() {}

  explicit DeleteThingModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteThingModelResponse() = default;
};
class UpdateProductFilterConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<bool> propertyTimestampFilter{};
  shared_ptr<bool> propertyValueFilter{};

  UpdateProductFilterConfigRequest() {}

  explicit UpdateProductFilterConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!propertyTimestampFilter) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("propertyTimestampFilter is required.")));
    }
    if (!propertyValueFilter) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("propertyValueFilter is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (propertyTimestampFilter) {
      res["PropertyTimestampFilter"] = boost::any(*propertyTimestampFilter);
    }
    if (propertyValueFilter) {
      res["PropertyValueFilter"] = boost::any(*propertyValueFilter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("PropertyTimestampFilter") != m.end() && !m["PropertyTimestampFilter"].empty()) {
      propertyTimestampFilter = make_shared<bool>(boost::any_cast<bool>(m["PropertyTimestampFilter"]));
    }
    if (m.find("PropertyValueFilter") != m.end() && !m["PropertyValueFilter"].empty()) {
      propertyValueFilter = make_shared<bool>(boost::any_cast<bool>(m["PropertyValueFilter"]));
    }
  }


  virtual ~UpdateProductFilterConfigRequest() = default;
};
class UpdateProductFilterConfigResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateProductFilterConfigResponse() {}

  explicit UpdateProductFilterConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateProductFilterConfigResponse() = default;
};
class CancelOTAStrategyByJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobId{};

  CancelOTAStrategyByJobRequest() {}

  explicit CancelOTAStrategyByJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~CancelOTAStrategyByJobRequest() = default;
};
class CancelOTAStrategyByJobResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  CancelOTAStrategyByJobResponse() {}

  explicit CancelOTAStrategyByJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CancelOTAStrategyByJobResponse() = default;
};
class ListOTAJobByFirmwareRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> firmwareId{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> currentPage{};

  ListOTAJobByFirmwareRequest() {}

  explicit ListOTAJobByFirmwareRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!firmwareId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareId is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
  }


  virtual ~ListOTAJobByFirmwareRequest() = default;
};
class ListOTAJobByFirmwareResponseDataSimpleOTAJobInfoTagsOtaTagDTO : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListOTAJobByFirmwareResponseDataSimpleOTAJobInfoTagsOtaTagDTO() {}

  explicit ListOTAJobByFirmwareResponseDataSimpleOTAJobInfoTagsOtaTagDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!key) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("key is required.")));
    }
    if (!value) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("value is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListOTAJobByFirmwareResponseDataSimpleOTAJobInfoTagsOtaTagDTO() = default;
};
class ListOTAJobByFirmwareResponseDataSimpleOTAJobInfoTags : public Darabonba::Model {
public:
  shared_ptr<vector<ListOTAJobByFirmwareResponseDataSimpleOTAJobInfoTagsOtaTagDTO>> otaTagDTO{};

  ListOTAJobByFirmwareResponseDataSimpleOTAJobInfoTags() {}

  explicit ListOTAJobByFirmwareResponseDataSimpleOTAJobInfoTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!otaTagDTO) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("otaTagDTO is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (otaTagDTO) {
      vector<boost::any> temp1;
      for(auto item1:*otaTagDTO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OtaTagDTO"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OtaTagDTO") != m.end() && !m["OtaTagDTO"].empty()) {
      if (typeid(vector<boost::any>) == m["OtaTagDTO"].type()) {
        vector<ListOTAJobByFirmwareResponseDataSimpleOTAJobInfoTagsOtaTagDTO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OtaTagDTO"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOTAJobByFirmwareResponseDataSimpleOTAJobInfoTagsOtaTagDTO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        otaTagDTO = make_shared<vector<ListOTAJobByFirmwareResponseDataSimpleOTAJobInfoTagsOtaTagDTO>>(expect1);
      }
    }
  }


  virtual ~ListOTAJobByFirmwareResponseDataSimpleOTAJobInfoTags() = default;
};
class ListOTAJobByFirmwareResponseDataSimpleOTAJobInfo : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> utcModified{};
  shared_ptr<string> productKey{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> utcStartTime{};
  shared_ptr<string> utcEndTime{};
  shared_ptr<string> jobStatus{};
  shared_ptr<string> jobType{};
  shared_ptr<string> targetSelection{};
  shared_ptr<string> selectionType{};
  shared_ptr<ListOTAJobByFirmwareResponseDataSimpleOTAJobInfoTags> tags{};

  ListOTAJobByFirmwareResponseDataSimpleOTAJobInfo() {}

  explicit ListOTAJobByFirmwareResponseDataSimpleOTAJobInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
    if (!utcCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcCreate is required.")));
    }
    if (!utcModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcModified is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!firmwareId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareId is required.")));
    }
    if (!utcStartTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcStartTime is required.")));
    }
    if (!utcEndTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcEndTime is required.")));
    }
    if (!jobStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobStatus is required.")));
    }
    if (!jobType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobType is required.")));
    }
    if (!targetSelection) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetSelection is required.")));
    }
    if (!selectionType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("selectionType is required.")));
    }
    if (!tags) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tags is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (utcStartTime) {
      res["UtcStartTime"] = boost::any(*utcStartTime);
    }
    if (utcEndTime) {
      res["UtcEndTime"] = boost::any(*utcEndTime);
    }
    if (jobStatus) {
      res["JobStatus"] = boost::any(*jobStatus);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (targetSelection) {
      res["TargetSelection"] = boost::any(*targetSelection);
    }
    if (selectionType) {
      res["SelectionType"] = boost::any(*selectionType);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("UtcStartTime") != m.end() && !m["UtcStartTime"].empty()) {
      utcStartTime = make_shared<string>(boost::any_cast<string>(m["UtcStartTime"]));
    }
    if (m.find("UtcEndTime") != m.end() && !m["UtcEndTime"].empty()) {
      utcEndTime = make_shared<string>(boost::any_cast<string>(m["UtcEndTime"]));
    }
    if (m.find("JobStatus") != m.end() && !m["JobStatus"].empty()) {
      jobStatus = make_shared<string>(boost::any_cast<string>(m["JobStatus"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("TargetSelection") != m.end() && !m["TargetSelection"].empty()) {
      targetSelection = make_shared<string>(boost::any_cast<string>(m["TargetSelection"]));
    }
    if (m.find("SelectionType") != m.end() && !m["SelectionType"].empty()) {
      selectionType = make_shared<string>(boost::any_cast<string>(m["SelectionType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        ListOTAJobByFirmwareResponseDataSimpleOTAJobInfoTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<ListOTAJobByFirmwareResponseDataSimpleOTAJobInfoTags>(model1);
      }
    }
  }


  virtual ~ListOTAJobByFirmwareResponseDataSimpleOTAJobInfo() = default;
};
class ListOTAJobByFirmwareResponseData : public Darabonba::Model {
public:
  shared_ptr<vector<ListOTAJobByFirmwareResponseDataSimpleOTAJobInfo>> simpleOTAJobInfo{};

  ListOTAJobByFirmwareResponseData() {}

  explicit ListOTAJobByFirmwareResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!simpleOTAJobInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("simpleOTAJobInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (simpleOTAJobInfo) {
      vector<boost::any> temp1;
      for(auto item1:*simpleOTAJobInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SimpleOTAJobInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SimpleOTAJobInfo") != m.end() && !m["SimpleOTAJobInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SimpleOTAJobInfo"].type()) {
        vector<ListOTAJobByFirmwareResponseDataSimpleOTAJobInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SimpleOTAJobInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOTAJobByFirmwareResponseDataSimpleOTAJobInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        simpleOTAJobInfo = make_shared<vector<ListOTAJobByFirmwareResponseDataSimpleOTAJobInfo>>(expect1);
      }
    }
  }


  virtual ~ListOTAJobByFirmwareResponseData() = default;
};
class ListOTAJobByFirmwareResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> total{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> pageCount{};
  shared_ptr<int> currentPage{};
  shared_ptr<ListOTAJobByFirmwareResponseData> data{};

  ListOTAJobByFirmwareResponse() {}

  explicit ListOTAJobByFirmwareResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!pageCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageCount is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<int>(boost::any_cast<int>(m["PageCount"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListOTAJobByFirmwareResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListOTAJobByFirmwareResponseData>(model1);
      }
    }
  }


  virtual ~ListOTAJobByFirmwareResponse() = default;
};
class ListOTAFirmwareRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> currentPage{};
  shared_ptr<string> destVersion{};

  ListOTAFirmwareRequest() {}

  explicit ListOTAFirmwareRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (destVersion) {
      res["DestVersion"] = boost::any(*destVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("DestVersion") != m.end() && !m["DestVersion"].empty()) {
      destVersion = make_shared<string>(boost::any_cast<string>(m["DestVersion"]));
    }
  }


  virtual ~ListOTAFirmwareRequest() = default;
};
class ListOTAFirmwareResponseFirmwareInfoSimpleFirmwareInfo : public Darabonba::Model {
public:
  shared_ptr<string> firmwareName{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> srcVersion{};
  shared_ptr<string> destVersion{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> utcModified{};
  shared_ptr<int> status{};
  shared_ptr<string> firmwareDesc{};
  shared_ptr<string> firmwareSign{};
  shared_ptr<int> firmwareSize{};
  shared_ptr<string> firmwareUrl{};
  shared_ptr<string> productKey{};
  shared_ptr<string> signMethod{};
  shared_ptr<string> productName{};
  shared_ptr<int> type{};
  shared_ptr<string> moduleName{};

  ListOTAFirmwareResponseFirmwareInfoSimpleFirmwareInfo() {}

  explicit ListOTAFirmwareResponseFirmwareInfoSimpleFirmwareInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!firmwareName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareName is required.")));
    }
    if (!firmwareId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareId is required.")));
    }
    if (!srcVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("srcVersion is required.")));
    }
    if (!destVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("destVersion is required.")));
    }
    if (!utcCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcCreate is required.")));
    }
    if (!utcModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcModified is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!firmwareDesc) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareDesc is required.")));
    }
    if (!firmwareSign) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareSign is required.")));
    }
    if (!firmwareSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareSize is required.")));
    }
    if (!firmwareUrl) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareUrl is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!signMethod) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("signMethod is required.")));
    }
    if (!productName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productName is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
    if (!moduleName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("moduleName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (firmwareName) {
      res["FirmwareName"] = boost::any(*firmwareName);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (srcVersion) {
      res["SrcVersion"] = boost::any(*srcVersion);
    }
    if (destVersion) {
      res["DestVersion"] = boost::any(*destVersion);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (firmwareDesc) {
      res["FirmwareDesc"] = boost::any(*firmwareDesc);
    }
    if (firmwareSign) {
      res["FirmwareSign"] = boost::any(*firmwareSign);
    }
    if (firmwareSize) {
      res["FirmwareSize"] = boost::any(*firmwareSize);
    }
    if (firmwareUrl) {
      res["FirmwareUrl"] = boost::any(*firmwareUrl);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (signMethod) {
      res["SignMethod"] = boost::any(*signMethod);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FirmwareName") != m.end() && !m["FirmwareName"].empty()) {
      firmwareName = make_shared<string>(boost::any_cast<string>(m["FirmwareName"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("SrcVersion") != m.end() && !m["SrcVersion"].empty()) {
      srcVersion = make_shared<string>(boost::any_cast<string>(m["SrcVersion"]));
    }
    if (m.find("DestVersion") != m.end() && !m["DestVersion"].empty()) {
      destVersion = make_shared<string>(boost::any_cast<string>(m["DestVersion"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<int>(boost::any_cast<int>(m["Status"]));
    }
    if (m.find("FirmwareDesc") != m.end() && !m["FirmwareDesc"].empty()) {
      firmwareDesc = make_shared<string>(boost::any_cast<string>(m["FirmwareDesc"]));
    }
    if (m.find("FirmwareSign") != m.end() && !m["FirmwareSign"].empty()) {
      firmwareSign = make_shared<string>(boost::any_cast<string>(m["FirmwareSign"]));
    }
    if (m.find("FirmwareSize") != m.end() && !m["FirmwareSize"].empty()) {
      firmwareSize = make_shared<int>(boost::any_cast<int>(m["FirmwareSize"]));
    }
    if (m.find("FirmwareUrl") != m.end() && !m["FirmwareUrl"].empty()) {
      firmwareUrl = make_shared<string>(boost::any_cast<string>(m["FirmwareUrl"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("SignMethod") != m.end() && !m["SignMethod"].empty()) {
      signMethod = make_shared<string>(boost::any_cast<string>(m["SignMethod"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<int>(boost::any_cast<int>(m["Type"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
  }


  virtual ~ListOTAFirmwareResponseFirmwareInfoSimpleFirmwareInfo() = default;
};
class ListOTAFirmwareResponseFirmwareInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListOTAFirmwareResponseFirmwareInfoSimpleFirmwareInfo>> simpleFirmwareInfo{};

  ListOTAFirmwareResponseFirmwareInfo() {}

  explicit ListOTAFirmwareResponseFirmwareInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!simpleFirmwareInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("simpleFirmwareInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (simpleFirmwareInfo) {
      vector<boost::any> temp1;
      for(auto item1:*simpleFirmwareInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SimpleFirmwareInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SimpleFirmwareInfo") != m.end() && !m["SimpleFirmwareInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SimpleFirmwareInfo"].type()) {
        vector<ListOTAFirmwareResponseFirmwareInfoSimpleFirmwareInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SimpleFirmwareInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOTAFirmwareResponseFirmwareInfoSimpleFirmwareInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        simpleFirmwareInfo = make_shared<vector<ListOTAFirmwareResponseFirmwareInfoSimpleFirmwareInfo>>(expect1);
      }
    }
  }


  virtual ~ListOTAFirmwareResponseFirmwareInfo() = default;
};
class ListOTAFirmwareResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> total{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> pageCount{};
  shared_ptr<int> currentPage{};
  shared_ptr<ListOTAFirmwareResponseFirmwareInfo> firmwareInfo{};

  ListOTAFirmwareResponse() {}

  explicit ListOTAFirmwareResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!pageCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageCount is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!firmwareInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (firmwareInfo) {
      res["FirmwareInfo"] = firmwareInfo ? boost::any(firmwareInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<int>(boost::any_cast<int>(m["PageCount"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("FirmwareInfo") != m.end() && !m["FirmwareInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FirmwareInfo"].type()) {
        ListOTAFirmwareResponseFirmwareInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FirmwareInfo"]));
        firmwareInfo = make_shared<ListOTAFirmwareResponseFirmwareInfo>(model1);
      }
    }
  }


  virtual ~ListOTAFirmwareResponse() = default;
};
class CancelOTATaskByJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<bool> cancelScheduledTask{};
  shared_ptr<bool> cancelQueuedTask{};
  shared_ptr<bool> cancelInProgressTask{};
  shared_ptr<bool> cancelNotifiedTask{};

  CancelOTATaskByJobRequest() {}

  explicit CancelOTATaskByJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (cancelScheduledTask) {
      res["CancelScheduledTask"] = boost::any(*cancelScheduledTask);
    }
    if (cancelQueuedTask) {
      res["CancelQueuedTask"] = boost::any(*cancelQueuedTask);
    }
    if (cancelInProgressTask) {
      res["CancelInProgressTask"] = boost::any(*cancelInProgressTask);
    }
    if (cancelNotifiedTask) {
      res["CancelNotifiedTask"] = boost::any(*cancelNotifiedTask);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("CancelScheduledTask") != m.end() && !m["CancelScheduledTask"].empty()) {
      cancelScheduledTask = make_shared<bool>(boost::any_cast<bool>(m["CancelScheduledTask"]));
    }
    if (m.find("CancelQueuedTask") != m.end() && !m["CancelQueuedTask"].empty()) {
      cancelQueuedTask = make_shared<bool>(boost::any_cast<bool>(m["CancelQueuedTask"]));
    }
    if (m.find("CancelInProgressTask") != m.end() && !m["CancelInProgressTask"].empty()) {
      cancelInProgressTask = make_shared<bool>(boost::any_cast<bool>(m["CancelInProgressTask"]));
    }
    if (m.find("CancelNotifiedTask") != m.end() && !m["CancelNotifiedTask"].empty()) {
      cancelNotifiedTask = make_shared<bool>(boost::any_cast<bool>(m["CancelNotifiedTask"]));
    }
  }


  virtual ~CancelOTATaskByJobRequest() = default;
};
class CancelOTATaskByJobResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  CancelOTATaskByJobResponse() {}

  explicit CancelOTATaskByJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CancelOTATaskByJobResponse() = default;
};
class CreateDeviceDistributeJobRequestTargetInstanceConfig : public Darabonba::Model {
public:
  shared_ptr<string> targetInstanceId{};

  CreateDeviceDistributeJobRequestTargetInstanceConfig() {}

  explicit CreateDeviceDistributeJobRequestTargetInstanceConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!targetInstanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetInstanceId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
  }


  virtual ~CreateDeviceDistributeJobRequestTargetInstanceConfig() = default;
};
class CreateDeviceDistributeJobRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> deviceName{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> targetUid{};
  shared_ptr<string> targetAliyunId{};
  shared_ptr<vector<CreateDeviceDistributeJobRequestTargetInstanceConfig>> targetInstanceConfig{};
  shared_ptr<int> strategy{};

  CreateDeviceDistributeJobRequest() {}

  explicit CreateDeviceDistributeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!sourceInstanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sourceInstanceId is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!targetInstanceConfig) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetInstanceConfig is required.")));
    }
    if (!strategy) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("strategy is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (targetUid) {
      res["TargetUid"] = boost::any(*targetUid);
    }
    if (targetAliyunId) {
      res["TargetAliyunId"] = boost::any(*targetAliyunId);
    }
    if (targetInstanceConfig) {
      vector<boost::any> temp1;
      for(auto item1:*targetInstanceConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TargetInstanceConfig"] = boost::any(temp1);
    }
    if (strategy) {
      res["Strategy"] = boost::any(*strategy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("TargetUid") != m.end() && !m["TargetUid"].empty()) {
      targetUid = make_shared<string>(boost::any_cast<string>(m["TargetUid"]));
    }
    if (m.find("TargetAliyunId") != m.end() && !m["TargetAliyunId"].empty()) {
      targetAliyunId = make_shared<string>(boost::any_cast<string>(m["TargetAliyunId"]));
    }
    if (m.find("TargetInstanceConfig") != m.end() && !m["TargetInstanceConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["TargetInstanceConfig"].type()) {
        vector<CreateDeviceDistributeJobRequestTargetInstanceConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TargetInstanceConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDeviceDistributeJobRequestTargetInstanceConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targetInstanceConfig = make_shared<vector<CreateDeviceDistributeJobRequestTargetInstanceConfig>>(expect1);
      }
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      strategy = make_shared<int>(boost::any_cast<int>(m["Strategy"]));
    }
  }


  virtual ~CreateDeviceDistributeJobRequest() = default;
};
class CreateDeviceDistributeJobResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> jobId{};

  CreateDeviceDistributeJobResponse() {}

  explicit CreateDeviceDistributeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~CreateDeviceDistributeJobResponse() = default;
};
class QueryDeviceDistributeDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  QueryDeviceDistributeDetailRequest() {}

  explicit QueryDeviceDistributeDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~QueryDeviceDistributeDetailRequest() = default;
};
class QueryDeviceDistributeDetailResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> file{};

  QueryDeviceDistributeDetailResponse() {}

  explicit QueryDeviceDistributeDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!file) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("file is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (file) {
      res["File"] = boost::any(*file);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      file = make_shared<string>(boost::any_cast<string>(m["File"]));
    }
  }


  virtual ~QueryDeviceDistributeDetailResponse() = default;
};
class ListDeviceDistributeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> targetUid{};
  shared_ptr<int> currentPage{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> status{};

  ListDeviceDistributeJobRequest() {}

  explicit ListDeviceDistributeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetUid) {
      res["TargetUid"] = boost::any(*targetUid);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetUid") != m.end() && !m["TargetUid"].empty()) {
      targetUid = make_shared<string>(boost::any_cast<string>(m["TargetUid"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<int>(boost::any_cast<int>(m["Status"]));
    }
  }


  virtual ~ListDeviceDistributeJobRequest() = default;
};
class ListDeviceDistributeJobResponseDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs : public Darabonba::Model {
public:
  shared_ptr<string> targetInstanceId{};

  ListDeviceDistributeJobResponseDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs() {}

  explicit ListDeviceDistributeJobResponseDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!targetInstanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetInstanceId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
  }


  virtual ~ListDeviceDistributeJobResponseDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs() = default;
};
class ListDeviceDistributeJobResponseDataJobInfoItemsTargetInstanceConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<ListDeviceDistributeJobResponseDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs>> targetInstanceConfigs{};

  ListDeviceDistributeJobResponseDataJobInfoItemsTargetInstanceConfigs() {}

  explicit ListDeviceDistributeJobResponseDataJobInfoItemsTargetInstanceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!targetInstanceConfigs) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetInstanceConfigs is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetInstanceConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*targetInstanceConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["targetInstanceConfigs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("targetInstanceConfigs") != m.end() && !m["targetInstanceConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["targetInstanceConfigs"].type()) {
        vector<ListDeviceDistributeJobResponseDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["targetInstanceConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDeviceDistributeJobResponseDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targetInstanceConfigs = make_shared<vector<ListDeviceDistributeJobResponseDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs>>(expect1);
      }
    }
  }


  virtual ~ListDeviceDistributeJobResponseDataJobInfoItemsTargetInstanceConfigs() = default;
};
class ListDeviceDistributeJobResponseDataJobInfoItems : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> sourceUid{};
  shared_ptr<string> targetUid{};
  shared_ptr<string> jobId{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<int> total{};
  shared_ptr<int> status{};
  shared_ptr<int> strategy{};
  shared_ptr<ListDeviceDistributeJobResponseDataJobInfoItemsTargetInstanceConfigs> targetInstanceConfigs{};

  ListDeviceDistributeJobResponseDataJobInfoItems() {}

  explicit ListDeviceDistributeJobResponseDataJobInfoItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!sourceUid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sourceUid is required.")));
    }
    if (!targetUid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetUid is required.")));
    }
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
    if (!sourceInstanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sourceInstanceId is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!strategy) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("strategy is required.")));
    }
    if (!targetInstanceConfigs) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetInstanceConfigs is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (sourceUid) {
      res["SourceUid"] = boost::any(*sourceUid);
    }
    if (targetUid) {
      res["TargetUid"] = boost::any(*targetUid);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (strategy) {
      res["Strategy"] = boost::any(*strategy);
    }
    if (targetInstanceConfigs) {
      res["TargetInstanceConfigs"] = targetInstanceConfigs ? boost::any(targetInstanceConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("SourceUid") != m.end() && !m["SourceUid"].empty()) {
      sourceUid = make_shared<string>(boost::any_cast<string>(m["SourceUid"]));
    }
    if (m.find("TargetUid") != m.end() && !m["TargetUid"].empty()) {
      targetUid = make_shared<string>(boost::any_cast<string>(m["TargetUid"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<int>(boost::any_cast<int>(m["Status"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      strategy = make_shared<int>(boost::any_cast<int>(m["Strategy"]));
    }
    if (m.find("TargetInstanceConfigs") != m.end() && !m["TargetInstanceConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["TargetInstanceConfigs"].type()) {
        ListDeviceDistributeJobResponseDataJobInfoItemsTargetInstanceConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TargetInstanceConfigs"]));
        targetInstanceConfigs = make_shared<ListDeviceDistributeJobResponseDataJobInfoItemsTargetInstanceConfigs>(model1);
      }
    }
  }


  virtual ~ListDeviceDistributeJobResponseDataJobInfoItems() = default;
};
class ListDeviceDistributeJobResponseDataJobInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDeviceDistributeJobResponseDataJobInfoItems>> items{};

  ListDeviceDistributeJobResponseDataJobInfo() {}

  explicit ListDeviceDistributeJobResponseDataJobInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!items) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("items is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<ListDeviceDistributeJobResponseDataJobInfoItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDeviceDistributeJobResponseDataJobInfoItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<ListDeviceDistributeJobResponseDataJobInfoItems>>(expect1);
      }
    }
  }


  virtual ~ListDeviceDistributeJobResponseDataJobInfo() = default;
};
class ListDeviceDistributeJobResponseData : public Darabonba::Model {
public:
  shared_ptr<int> total{};
  shared_ptr<ListDeviceDistributeJobResponseDataJobInfo> jobInfo{};

  ListDeviceDistributeJobResponseData() {}

  explicit ListDeviceDistributeJobResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!jobInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (jobInfo) {
      res["JobInfo"] = jobInfo ? boost::any(jobInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("JobInfo") != m.end() && !m["JobInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobInfo"].type()) {
        ListDeviceDistributeJobResponseDataJobInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobInfo"]));
        jobInfo = make_shared<ListDeviceDistributeJobResponseDataJobInfo>(model1);
      }
    }
  }


  virtual ~ListDeviceDistributeJobResponseData() = default;
};
class ListDeviceDistributeJobResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<ListDeviceDistributeJobResponseData> data{};

  ListDeviceDistributeJobResponse() {}

  explicit ListDeviceDistributeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListDeviceDistributeJobResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListDeviceDistributeJobResponseData>(model1);
      }
    }
  }


  virtual ~ListDeviceDistributeJobResponse() = default;
};
class QueryDeviceDistributeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  QueryDeviceDistributeJobRequest() {}

  explicit QueryDeviceDistributeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~QueryDeviceDistributeJobRequest() = default;
};
class QueryDeviceDistributeJobResponseDataTargetInstanceConfigsTargetInstanceConfigs : public Darabonba::Model {
public:
  shared_ptr<string> targetInstanceId{};

  QueryDeviceDistributeJobResponseDataTargetInstanceConfigsTargetInstanceConfigs() {}

  explicit QueryDeviceDistributeJobResponseDataTargetInstanceConfigsTargetInstanceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!targetInstanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetInstanceId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
  }


  virtual ~QueryDeviceDistributeJobResponseDataTargetInstanceConfigsTargetInstanceConfigs() = default;
};
class QueryDeviceDistributeJobResponseDataTargetInstanceConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceDistributeJobResponseDataTargetInstanceConfigsTargetInstanceConfigs>> targetInstanceConfigs{};

  QueryDeviceDistributeJobResponseDataTargetInstanceConfigs() {}

  explicit QueryDeviceDistributeJobResponseDataTargetInstanceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!targetInstanceConfigs) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetInstanceConfigs is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetInstanceConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*targetInstanceConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["targetInstanceConfigs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("targetInstanceConfigs") != m.end() && !m["targetInstanceConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["targetInstanceConfigs"].type()) {
        vector<QueryDeviceDistributeJobResponseDataTargetInstanceConfigsTargetInstanceConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["targetInstanceConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceDistributeJobResponseDataTargetInstanceConfigsTargetInstanceConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targetInstanceConfigs = make_shared<vector<QueryDeviceDistributeJobResponseDataTargetInstanceConfigsTargetInstanceConfigs>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceDistributeJobResponseDataTargetInstanceConfigs() = default;
};
class QueryDeviceDistributeJobResponseData : public Darabonba::Model {
public:
  shared_ptr<string> sourceUid{};
  shared_ptr<string> targetUid{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> productKey{};
  shared_ptr<int> total{};
  shared_ptr<int> status{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<int> strategy{};
  shared_ptr<QueryDeviceDistributeJobResponseDataTargetInstanceConfigs> targetInstanceConfigs{};

  QueryDeviceDistributeJobResponseData() {}

  explicit QueryDeviceDistributeJobResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!sourceUid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sourceUid is required.")));
    }
    if (!targetUid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetUid is required.")));
    }
    if (!sourceInstanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sourceInstanceId is required.")));
    }
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!strategy) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("strategy is required.")));
    }
    if (!targetInstanceConfigs) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetInstanceConfigs is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceUid) {
      res["SourceUid"] = boost::any(*sourceUid);
    }
    if (targetUid) {
      res["TargetUid"] = boost::any(*targetUid);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (strategy) {
      res["Strategy"] = boost::any(*strategy);
    }
    if (targetInstanceConfigs) {
      res["TargetInstanceConfigs"] = targetInstanceConfigs ? boost::any(targetInstanceConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceUid") != m.end() && !m["SourceUid"].empty()) {
      sourceUid = make_shared<string>(boost::any_cast<string>(m["SourceUid"]));
    }
    if (m.find("TargetUid") != m.end() && !m["TargetUid"].empty()) {
      targetUid = make_shared<string>(boost::any_cast<string>(m["TargetUid"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<int>(boost::any_cast<int>(m["Status"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      strategy = make_shared<int>(boost::any_cast<int>(m["Strategy"]));
    }
    if (m.find("TargetInstanceConfigs") != m.end() && !m["TargetInstanceConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["TargetInstanceConfigs"].type()) {
        QueryDeviceDistributeJobResponseDataTargetInstanceConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TargetInstanceConfigs"]));
        targetInstanceConfigs = make_shared<QueryDeviceDistributeJobResponseDataTargetInstanceConfigs>(model1);
      }
    }
  }


  virtual ~QueryDeviceDistributeJobResponseData() = default;
};
class QueryDeviceDistributeJobResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceDistributeJobResponseData> data{};

  QueryDeviceDistributeJobResponse() {}

  explicit QueryDeviceDistributeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceDistributeJobResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceDistributeJobResponseData>(model1);
      }
    }
  }


  virtual ~QueryDeviceDistributeJobResponse() = default;
};
class DeleteDeviceDistributeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  DeleteDeviceDistributeJobRequest() {}

  explicit DeleteDeviceDistributeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~DeleteDeviceDistributeJobRequest() = default;
};
class DeleteDeviceDistributeJobResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteDeviceDistributeJobResponse() {}

  explicit DeleteDeviceDistributeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteDeviceDistributeJobResponse() = default;
};
class QueryDeviceByStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<int> status{};
  shared_ptr<int> currentPage{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> resourceGroupId{};

  QueryDeviceByStatusRequest() {}

  explicit QueryDeviceByStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<int>(boost::any_cast<int>(m["Status"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~QueryDeviceByStatusRequest() = default;
};
class QueryDeviceByStatusResponseDataSimpleDeviceInfo : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> status{};
  shared_ptr<string> iotId{};
  shared_ptr<string> nickname{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> utcModified{};
  shared_ptr<string> deviceSecret{};

  QueryDeviceByStatusResponseDataSimpleDeviceInfo() {}

  explicit QueryDeviceByStatusResponseDataSimpleDeviceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!iotId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotId is required.")));
    }
    if (!nickname) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nickname is required.")));
    }
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!gmtModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModified is required.")));
    }
    if (!utcCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcCreate is required.")));
    }
    if (!utcModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcModified is required.")));
    }
    if (!deviceSecret) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceSecret is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (deviceSecret) {
      res["DeviceSecret"] = boost::any(*deviceSecret);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("DeviceSecret") != m.end() && !m["DeviceSecret"].empty()) {
      deviceSecret = make_shared<string>(boost::any_cast<string>(m["DeviceSecret"]));
    }
  }


  virtual ~QueryDeviceByStatusResponseDataSimpleDeviceInfo() = default;
};
class QueryDeviceByStatusResponseData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceByStatusResponseDataSimpleDeviceInfo>> simpleDeviceInfo{};

  QueryDeviceByStatusResponseData() {}

  explicit QueryDeviceByStatusResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!simpleDeviceInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("simpleDeviceInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (simpleDeviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*simpleDeviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SimpleDeviceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SimpleDeviceInfo") != m.end() && !m["SimpleDeviceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SimpleDeviceInfo"].type()) {
        vector<QueryDeviceByStatusResponseDataSimpleDeviceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SimpleDeviceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceByStatusResponseDataSimpleDeviceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        simpleDeviceInfo = make_shared<vector<QueryDeviceByStatusResponseDataSimpleDeviceInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceByStatusResponseData() = default;
};
class QueryDeviceByStatusResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> page{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> pageCount{};
  shared_ptr<int> total{};
  shared_ptr<QueryDeviceByStatusResponseData> data{};

  QueryDeviceByStatusResponse() {}

  explicit QueryDeviceByStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!page) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("page is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!pageCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageCount is required.")));
    }
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<int>(boost::any_cast<int>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<int>(boost::any_cast<int>(m["PageCount"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceByStatusResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceByStatusResponseData>(model1);
      }
    }
  }


  virtual ~QueryDeviceByStatusResponse() = default;
};
class GenerateOTAUploadURLRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> fileSuffix{};

  GenerateOTAUploadURLRequest() {}

  explicit GenerateOTAUploadURLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (fileSuffix) {
      res["FileSuffix"] = boost::any(*fileSuffix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("FileSuffix") != m.end() && !m["FileSuffix"].empty()) {
      fileSuffix = make_shared<string>(boost::any_cast<string>(m["FileSuffix"]));
    }
  }


  virtual ~GenerateOTAUploadURLRequest() = default;
};
class GenerateOTAUploadURLResponseData : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> host{};
  shared_ptr<string> policy{};
  shared_ptr<string> OSSAccessKeyId{};
  shared_ptr<string> signature{};
  shared_ptr<string> firmwareUrl{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> objectStorage{};

  GenerateOTAUploadURLResponseData() {}

  explicit GenerateOTAUploadURLResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!key) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("key is required.")));
    }
    if (!host) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("host is required.")));
    }
    if (!policy) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("policy is required.")));
    }
    if (!OSSAccessKeyId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("OSSAccessKeyId is required.")));
    }
    if (!signature) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("signature is required.")));
    }
    if (!firmwareUrl) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareUrl is required.")));
    }
    if (!utcCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcCreate is required.")));
    }
    if (!objectStorage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("objectStorage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (OSSAccessKeyId) {
      res["OSSAccessKeyId"] = boost::any(*OSSAccessKeyId);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    if (firmwareUrl) {
      res["FirmwareUrl"] = boost::any(*firmwareUrl);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (objectStorage) {
      res["ObjectStorage"] = boost::any(*objectStorage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("OSSAccessKeyId") != m.end() && !m["OSSAccessKeyId"].empty()) {
      OSSAccessKeyId = make_shared<string>(boost::any_cast<string>(m["OSSAccessKeyId"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
    if (m.find("FirmwareUrl") != m.end() && !m["FirmwareUrl"].empty()) {
      firmwareUrl = make_shared<string>(boost::any_cast<string>(m["FirmwareUrl"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("ObjectStorage") != m.end() && !m["ObjectStorage"].empty()) {
      objectStorage = make_shared<string>(boost::any_cast<string>(m["ObjectStorage"]));
    }
  }


  virtual ~GenerateOTAUploadURLResponseData() = default;
};
class GenerateOTAUploadURLResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GenerateOTAUploadURLResponseData> data{};

  GenerateOTAUploadURLResponse() {}

  explicit GenerateOTAUploadURLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GenerateOTAUploadURLResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GenerateOTAUploadURLResponseData>(model1);
      }
    }
  }


  virtual ~GenerateOTAUploadURLResponse() = default;
};
class QueryProductCertInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  QueryProductCertInfoRequest() {}

  explicit QueryProductCertInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryProductCertInfoRequest() = default;
};
class QueryProductCertInfoResponseProductCertInfo : public Darabonba::Model {
public:
  shared_ptr<int> issueModel{};

  QueryProductCertInfoResponseProductCertInfo() {}

  explicit QueryProductCertInfoResponseProductCertInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!issueModel) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("issueModel is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (issueModel) {
      res["IssueModel"] = boost::any(*issueModel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IssueModel") != m.end() && !m["IssueModel"].empty()) {
      issueModel = make_shared<int>(boost::any_cast<int>(m["IssueModel"]));
    }
  }


  virtual ~QueryProductCertInfoResponseProductCertInfo() = default;
};
class QueryProductCertInfoResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryProductCertInfoResponseProductCertInfo> productCertInfo{};

  QueryProductCertInfoResponse() {}

  explicit QueryProductCertInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!productCertInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productCertInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (productCertInfo) {
      res["ProductCertInfo"] = productCertInfo ? boost::any(productCertInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ProductCertInfo") != m.end() && !m["ProductCertInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProductCertInfo"].type()) {
        QueryProductCertInfoResponseProductCertInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProductCertInfo"]));
        productCertInfo = make_shared<QueryProductCertInfoResponseProductCertInfo>(model1);
      }
    }
  }


  virtual ~QueryProductCertInfoResponse() = default;
};
class SetProductCertInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<int> issueModel{};

  SetProductCertInfoRequest() {}

  explicit SetProductCertInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!issueModel) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("issueModel is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (issueModel) {
      res["IssueModel"] = boost::any(*issueModel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("IssueModel") != m.end() && !m["IssueModel"].empty()) {
      issueModel = make_shared<int>(boost::any_cast<int>(m["IssueModel"]));
    }
  }


  virtual ~SetProductCertInfoRequest() = default;
};
class SetProductCertInfoResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  SetProductCertInfoResponse() {}

  explicit SetProductCertInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~SetProductCertInfoResponse() = default;
};
class CreateSubscribeRelationRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<bool> deviceDataFlag{};
  shared_ptr<bool> deviceLifeCycleFlag{};
  shared_ptr<bool> deviceStatusChangeFlag{};
  shared_ptr<bool> deviceTopoLifeCycleFlag{};
  shared_ptr<bool> foundDeviceListFlag{};
  shared_ptr<string> mnsConfiguration{};
  shared_ptr<string> type{};
  shared_ptr<vector<string>> consumerGroupIds{};
  shared_ptr<bool> otaEventFlag{};
  shared_ptr<bool> thingHistoryFlag{};
  shared_ptr<bool> deviceTagFlag{};
  shared_ptr<bool> otaVersionFlag{};
  shared_ptr<bool> otaJobFlag{};

  CreateSubscribeRelationRequest() {}

  explicit CreateSubscribeRelationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceDataFlag) {
      res["DeviceDataFlag"] = boost::any(*deviceDataFlag);
    }
    if (deviceLifeCycleFlag) {
      res["DeviceLifeCycleFlag"] = boost::any(*deviceLifeCycleFlag);
    }
    if (deviceStatusChangeFlag) {
      res["DeviceStatusChangeFlag"] = boost::any(*deviceStatusChangeFlag);
    }
    if (deviceTopoLifeCycleFlag) {
      res["DeviceTopoLifeCycleFlag"] = boost::any(*deviceTopoLifeCycleFlag);
    }
    if (foundDeviceListFlag) {
      res["FoundDeviceListFlag"] = boost::any(*foundDeviceListFlag);
    }
    if (mnsConfiguration) {
      res["MnsConfiguration"] = boost::any(*mnsConfiguration);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (consumerGroupIds) {
      res["ConsumerGroupIds"] = boost::any(*consumerGroupIds);
    }
    if (otaEventFlag) {
      res["OtaEventFlag"] = boost::any(*otaEventFlag);
    }
    if (thingHistoryFlag) {
      res["ThingHistoryFlag"] = boost::any(*thingHistoryFlag);
    }
    if (deviceTagFlag) {
      res["DeviceTagFlag"] = boost::any(*deviceTagFlag);
    }
    if (otaVersionFlag) {
      res["OtaVersionFlag"] = boost::any(*otaVersionFlag);
    }
    if (otaJobFlag) {
      res["OtaJobFlag"] = boost::any(*otaJobFlag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceDataFlag") != m.end() && !m["DeviceDataFlag"].empty()) {
      deviceDataFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceDataFlag"]));
    }
    if (m.find("DeviceLifeCycleFlag") != m.end() && !m["DeviceLifeCycleFlag"].empty()) {
      deviceLifeCycleFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceLifeCycleFlag"]));
    }
    if (m.find("DeviceStatusChangeFlag") != m.end() && !m["DeviceStatusChangeFlag"].empty()) {
      deviceStatusChangeFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceStatusChangeFlag"]));
    }
    if (m.find("DeviceTopoLifeCycleFlag") != m.end() && !m["DeviceTopoLifeCycleFlag"].empty()) {
      deviceTopoLifeCycleFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceTopoLifeCycleFlag"]));
    }
    if (m.find("FoundDeviceListFlag") != m.end() && !m["FoundDeviceListFlag"].empty()) {
      foundDeviceListFlag = make_shared<bool>(boost::any_cast<bool>(m["FoundDeviceListFlag"]));
    }
    if (m.find("MnsConfiguration") != m.end() && !m["MnsConfiguration"].empty()) {
      mnsConfiguration = make_shared<string>(boost::any_cast<string>(m["MnsConfiguration"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ConsumerGroupIds") != m.end() && !m["ConsumerGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ConsumerGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ConsumerGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      consumerGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OtaEventFlag") != m.end() && !m["OtaEventFlag"].empty()) {
      otaEventFlag = make_shared<bool>(boost::any_cast<bool>(m["OtaEventFlag"]));
    }
    if (m.find("ThingHistoryFlag") != m.end() && !m["ThingHistoryFlag"].empty()) {
      thingHistoryFlag = make_shared<bool>(boost::any_cast<bool>(m["ThingHistoryFlag"]));
    }
    if (m.find("DeviceTagFlag") != m.end() && !m["DeviceTagFlag"].empty()) {
      deviceTagFlag = make_shared<bool>(boost::any_cast<bool>(m["DeviceTagFlag"]));
    }
    if (m.find("OtaVersionFlag") != m.end() && !m["OtaVersionFlag"].empty()) {
      otaVersionFlag = make_shared<bool>(boost::any_cast<bool>(m["OtaVersionFlag"]));
    }
    if (m.find("OtaJobFlag") != m.end() && !m["OtaJobFlag"].empty()) {
      otaJobFlag = make_shared<bool>(boost::any_cast<bool>(m["OtaJobFlag"]));
    }
  }


  virtual ~CreateSubscribeRelationRequest() = default;
};
class CreateSubscribeRelationResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  CreateSubscribeRelationResponse() {}

  explicit CreateSubscribeRelationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CreateSubscribeRelationResponse() = default;
};
class DeleteSubscribeRelationRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> type{};

  DeleteSubscribeRelationRequest() {}

  explicit DeleteSubscribeRelationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DeleteSubscribeRelationRequest() = default;
};
class DeleteSubscribeRelationResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteSubscribeRelationResponse() {}

  explicit DeleteSubscribeRelationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteSubscribeRelationResponse() = default;
};
class QueryConsumerGroupStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> groupId{};

  QueryConsumerGroupStatusRequest() {}

  explicit QueryConsumerGroupStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~QueryConsumerGroupStatusRequest() = default;
};
class QueryConsumerGroupStatusResponseClientConnectionStatusListConsumerGroupClientConnectionInfo : public Darabonba::Model {
public:
  shared_ptr<string> clientId{};
  shared_ptr<string> clientIpPort{};
  shared_ptr<long> onlineTime{};

  QueryConsumerGroupStatusResponseClientConnectionStatusListConsumerGroupClientConnectionInfo() {}

  explicit QueryConsumerGroupStatusResponseClientConnectionStatusListConsumerGroupClientConnectionInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!clientId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("clientId is required.")));
    }
    if (!clientIpPort) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("clientIpPort is required.")));
    }
    if (!onlineTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("onlineTime is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (clientIpPort) {
      res["ClientIpPort"] = boost::any(*clientIpPort);
    }
    if (onlineTime) {
      res["OnlineTime"] = boost::any(*onlineTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
    if (m.find("ClientIpPort") != m.end() && !m["ClientIpPort"].empty()) {
      clientIpPort = make_shared<string>(boost::any_cast<string>(m["ClientIpPort"]));
    }
    if (m.find("OnlineTime") != m.end() && !m["OnlineTime"].empty()) {
      onlineTime = make_shared<long>(boost::any_cast<long>(m["OnlineTime"]));
    }
  }


  virtual ~QueryConsumerGroupStatusResponseClientConnectionStatusListConsumerGroupClientConnectionInfo() = default;
};
class QueryConsumerGroupStatusResponseClientConnectionStatusList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryConsumerGroupStatusResponseClientConnectionStatusListConsumerGroupClientConnectionInfo>> consumerGroupClientConnectionInfo{};

  QueryConsumerGroupStatusResponseClientConnectionStatusList() {}

  explicit QueryConsumerGroupStatusResponseClientConnectionStatusList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!consumerGroupClientConnectionInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("consumerGroupClientConnectionInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consumerGroupClientConnectionInfo) {
      vector<boost::any> temp1;
      for(auto item1:*consumerGroupClientConnectionInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConsumerGroupClientConnectionInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsumerGroupClientConnectionInfo") != m.end() && !m["ConsumerGroupClientConnectionInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ConsumerGroupClientConnectionInfo"].type()) {
        vector<QueryConsumerGroupStatusResponseClientConnectionStatusListConsumerGroupClientConnectionInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConsumerGroupClientConnectionInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryConsumerGroupStatusResponseClientConnectionStatusListConsumerGroupClientConnectionInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        consumerGroupClientConnectionInfo = make_shared<vector<QueryConsumerGroupStatusResponseClientConnectionStatusListConsumerGroupClientConnectionInfo>>(expect1);
      }
    }
  }


  virtual ~QueryConsumerGroupStatusResponseClientConnectionStatusList() = default;
};
class QueryConsumerGroupStatusResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> accumulationCount{};
  shared_ptr<int> consumerSpeed{};
  shared_ptr<string> lastConsumerTime{};
  shared_ptr<string> code{};
  shared_ptr<QueryConsumerGroupStatusResponseClientConnectionStatusList> clientConnectionStatusList{};

  QueryConsumerGroupStatusResponse() {}

  explicit QueryConsumerGroupStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!accumulationCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("accumulationCount is required.")));
    }
    if (!consumerSpeed) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("consumerSpeed is required.")));
    }
    if (!lastConsumerTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("lastConsumerTime is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!clientConnectionStatusList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("clientConnectionStatusList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (accumulationCount) {
      res["AccumulationCount"] = boost::any(*accumulationCount);
    }
    if (consumerSpeed) {
      res["ConsumerSpeed"] = boost::any(*consumerSpeed);
    }
    if (lastConsumerTime) {
      res["LastConsumerTime"] = boost::any(*lastConsumerTime);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (clientConnectionStatusList) {
      res["ClientConnectionStatusList"] = clientConnectionStatusList ? boost::any(clientConnectionStatusList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("AccumulationCount") != m.end() && !m["AccumulationCount"].empty()) {
      accumulationCount = make_shared<int>(boost::any_cast<int>(m["AccumulationCount"]));
    }
    if (m.find("ConsumerSpeed") != m.end() && !m["ConsumerSpeed"].empty()) {
      consumerSpeed = make_shared<int>(boost::any_cast<int>(m["ConsumerSpeed"]));
    }
    if (m.find("LastConsumerTime") != m.end() && !m["LastConsumerTime"].empty()) {
      lastConsumerTime = make_shared<string>(boost::any_cast<string>(m["LastConsumerTime"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ClientConnectionStatusList") != m.end() && !m["ClientConnectionStatusList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClientConnectionStatusList"].type()) {
        QueryConsumerGroupStatusResponseClientConnectionStatusList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClientConnectionStatusList"]));
        clientConnectionStatusList = make_shared<QueryConsumerGroupStatusResponseClientConnectionStatusList>(model1);
      }
    }
  }


  virtual ~QueryConsumerGroupStatusResponse() = default;
};
class DeleteConsumerGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> groupId{};

  DeleteConsumerGroupRequest() {}

  explicit DeleteConsumerGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~DeleteConsumerGroupRequest() = default;
};
class DeleteConsumerGroupResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};

  DeleteConsumerGroupResponse() {}

  explicit DeleteConsumerGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~DeleteConsumerGroupResponse() = default;
};
class QueryConsumerGroupListRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> currentPage{};
  shared_ptr<bool> fuzzy{};
  shared_ptr<string> groupName{};

  QueryConsumerGroupListRequest() {}

  explicit QueryConsumerGroupListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (fuzzy) {
      res["Fuzzy"] = boost::any(*fuzzy);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("Fuzzy") != m.end() && !m["Fuzzy"].empty()) {
      fuzzy = make_shared<bool>(boost::any_cast<bool>(m["Fuzzy"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~QueryConsumerGroupListRequest() = default;
};
class QueryConsumerGroupListResponseDataConsumerGroupDTO : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> createTime{};

  QueryConsumerGroupListResponseDataConsumerGroupDTO() {}

  explicit QueryConsumerGroupListResponseDataConsumerGroupDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
    if (!groupName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupName is required.")));
    }
    if (!createTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createTime is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
  }


  virtual ~QueryConsumerGroupListResponseDataConsumerGroupDTO() = default;
};
class QueryConsumerGroupListResponseData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryConsumerGroupListResponseDataConsumerGroupDTO>> consumerGroupDTO{};

  QueryConsumerGroupListResponseData() {}

  explicit QueryConsumerGroupListResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!consumerGroupDTO) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("consumerGroupDTO is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consumerGroupDTO) {
      vector<boost::any> temp1;
      for(auto item1:*consumerGroupDTO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConsumerGroupDTO"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsumerGroupDTO") != m.end() && !m["ConsumerGroupDTO"].empty()) {
      if (typeid(vector<boost::any>) == m["ConsumerGroupDTO"].type()) {
        vector<QueryConsumerGroupListResponseDataConsumerGroupDTO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConsumerGroupDTO"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryConsumerGroupListResponseDataConsumerGroupDTO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        consumerGroupDTO = make_shared<vector<QueryConsumerGroupListResponseDataConsumerGroupDTO>>(expect1);
      }
    }
  }


  virtual ~QueryConsumerGroupListResponseData() = default;
};
class QueryConsumerGroupListResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> pageCount{};
  shared_ptr<int> total{};
  shared_ptr<int> currentPage{};
  shared_ptr<string> code{};
  shared_ptr<QueryConsumerGroupListResponseData> data{};

  QueryConsumerGroupListResponse() {}

  explicit QueryConsumerGroupListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!pageCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageCount is required.")));
    }
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<int>(boost::any_cast<int>(m["PageCount"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryConsumerGroupListResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryConsumerGroupListResponseData>(model1);
      }
    }
  }


  virtual ~QueryConsumerGroupListResponse() = default;
};
class QueryConsumerGroupByGroupIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> groupId{};

  QueryConsumerGroupByGroupIdRequest() {}

  explicit QueryConsumerGroupByGroupIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~QueryConsumerGroupByGroupIdRequest() = default;
};
class QueryConsumerGroupByGroupIdResponseData : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> createTime{};

  QueryConsumerGroupByGroupIdResponseData() {}

  explicit QueryConsumerGroupByGroupIdResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
    if (!groupName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupName is required.")));
    }
    if (!createTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createTime is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
  }


  virtual ~QueryConsumerGroupByGroupIdResponseData() = default;
};
class QueryConsumerGroupByGroupIdResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<QueryConsumerGroupByGroupIdResponseData> data{};

  QueryConsumerGroupByGroupIdResponse() {}

  explicit QueryConsumerGroupByGroupIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryConsumerGroupByGroupIdResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryConsumerGroupByGroupIdResponseData>(model1);
      }
    }
  }


  virtual ~QueryConsumerGroupByGroupIdResponse() = default;
};
class CreateConsumerGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> groupName{};

  CreateConsumerGroupRequest() {}

  explicit CreateConsumerGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!groupName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~CreateConsumerGroupRequest() = default;
};
class CreateConsumerGroupResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> groupId{};
  shared_ptr<string> code{};

  CreateConsumerGroupResponse() {}

  explicit CreateConsumerGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~CreateConsumerGroupResponse() = default;
};
class CreateOTADynamicUpgradeJobRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateOTADynamicUpgradeJobRequestTag() {}

  explicit CreateOTADynamicUpgradeJobRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!key) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("key is required.")));
    }
    if (!value) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("value is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateOTADynamicUpgradeJobRequestTag() = default;
};
class CreateOTADynamicUpgradeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> productKey{};
  shared_ptr<vector<string>> srcVersion{};
  shared_ptr<int> retryInterval{};
  shared_ptr<int> retryCount{};
  shared_ptr<int> timeoutInMinutes{};
  shared_ptr<int> maximumPerMinute{};
  shared_ptr<int> overwriteMode{};
  shared_ptr<int> dynamicMode{};
  shared_ptr<vector<CreateOTADynamicUpgradeJobRequestTag>> tag{};

  CreateOTADynamicUpgradeJobRequest() {}

  explicit CreateOTADynamicUpgradeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!firmwareId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareId is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (srcVersion) {
      res["SrcVersion"] = boost::any(*srcVersion);
    }
    if (retryInterval) {
      res["RetryInterval"] = boost::any(*retryInterval);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (timeoutInMinutes) {
      res["TimeoutInMinutes"] = boost::any(*timeoutInMinutes);
    }
    if (maximumPerMinute) {
      res["MaximumPerMinute"] = boost::any(*maximumPerMinute);
    }
    if (overwriteMode) {
      res["OverwriteMode"] = boost::any(*overwriteMode);
    }
    if (dynamicMode) {
      res["DynamicMode"] = boost::any(*dynamicMode);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("SrcVersion") != m.end() && !m["SrcVersion"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SrcVersion"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SrcVersion"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      srcVersion = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RetryInterval") != m.end() && !m["RetryInterval"].empty()) {
      retryInterval = make_shared<int>(boost::any_cast<int>(m["RetryInterval"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<int>(boost::any_cast<int>(m["RetryCount"]));
    }
    if (m.find("TimeoutInMinutes") != m.end() && !m["TimeoutInMinutes"].empty()) {
      timeoutInMinutes = make_shared<int>(boost::any_cast<int>(m["TimeoutInMinutes"]));
    }
    if (m.find("MaximumPerMinute") != m.end() && !m["MaximumPerMinute"].empty()) {
      maximumPerMinute = make_shared<int>(boost::any_cast<int>(m["MaximumPerMinute"]));
    }
    if (m.find("OverwriteMode") != m.end() && !m["OverwriteMode"].empty()) {
      overwriteMode = make_shared<int>(boost::any_cast<int>(m["OverwriteMode"]));
    }
    if (m.find("DynamicMode") != m.end() && !m["DynamicMode"].empty()) {
      dynamicMode = make_shared<int>(boost::any_cast<int>(m["DynamicMode"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateOTADynamicUpgradeJobRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOTADynamicUpgradeJobRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateOTADynamicUpgradeJobRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateOTADynamicUpgradeJobRequest() = default;
};
class CreateOTADynamicUpgradeJobResponseData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> utcCreate{};

  CreateOTADynamicUpgradeJobResponseData() {}

  explicit CreateOTADynamicUpgradeJobResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
    if (!utcCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcCreate is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
  }


  virtual ~CreateOTADynamicUpgradeJobResponseData() = default;
};
class CreateOTADynamicUpgradeJobResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<CreateOTADynamicUpgradeJobResponseData> data{};

  CreateOTADynamicUpgradeJobResponse() {}

  explicit CreateOTADynamicUpgradeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateOTADynamicUpgradeJobResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateOTADynamicUpgradeJobResponseData>(model1);
      }
    }
  }


  virtual ~CreateOTADynamicUpgradeJobResponse() = default;
};
class CreateOTAStaticUpgradeJobRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateOTAStaticUpgradeJobRequestTag() {}

  explicit CreateOTAStaticUpgradeJobRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!key) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("key is required.")));
    }
    if (!value) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("value is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateOTAStaticUpgradeJobRequestTag() = default;
};
class CreateOTAStaticUpgradeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> targetSelection{};
  shared_ptr<vector<string>> srcVersion{};
  shared_ptr<long> scheduleTime{};
  shared_ptr<int> retryInterval{};
  shared_ptr<int> retryCount{};
  shared_ptr<int> timeoutInMinutes{};
  shared_ptr<int> maximumPerMinute{};
  shared_ptr<string> grayPercent{};
  shared_ptr<vector<string>> targetDeviceName{};
  shared_ptr<long> scheduleFinishTime{};
  shared_ptr<int> overwriteMode{};
  shared_ptr<vector<CreateOTAStaticUpgradeJobRequestTag>> tag{};
  shared_ptr<string> dnListFileUrl{};

  CreateOTAStaticUpgradeJobRequest() {}

  explicit CreateOTAStaticUpgradeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!firmwareId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareId is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!targetSelection) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetSelection is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (targetSelection) {
      res["TargetSelection"] = boost::any(*targetSelection);
    }
    if (srcVersion) {
      res["SrcVersion"] = boost::any(*srcVersion);
    }
    if (scheduleTime) {
      res["ScheduleTime"] = boost::any(*scheduleTime);
    }
    if (retryInterval) {
      res["RetryInterval"] = boost::any(*retryInterval);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (timeoutInMinutes) {
      res["TimeoutInMinutes"] = boost::any(*timeoutInMinutes);
    }
    if (maximumPerMinute) {
      res["MaximumPerMinute"] = boost::any(*maximumPerMinute);
    }
    if (grayPercent) {
      res["GrayPercent"] = boost::any(*grayPercent);
    }
    if (targetDeviceName) {
      res["TargetDeviceName"] = boost::any(*targetDeviceName);
    }
    if (scheduleFinishTime) {
      res["ScheduleFinishTime"] = boost::any(*scheduleFinishTime);
    }
    if (overwriteMode) {
      res["OverwriteMode"] = boost::any(*overwriteMode);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (dnListFileUrl) {
      res["DnListFileUrl"] = boost::any(*dnListFileUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("TargetSelection") != m.end() && !m["TargetSelection"].empty()) {
      targetSelection = make_shared<string>(boost::any_cast<string>(m["TargetSelection"]));
    }
    if (m.find("SrcVersion") != m.end() && !m["SrcVersion"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SrcVersion"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SrcVersion"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      srcVersion = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScheduleTime") != m.end() && !m["ScheduleTime"].empty()) {
      scheduleTime = make_shared<long>(boost::any_cast<long>(m["ScheduleTime"]));
    }
    if (m.find("RetryInterval") != m.end() && !m["RetryInterval"].empty()) {
      retryInterval = make_shared<int>(boost::any_cast<int>(m["RetryInterval"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<int>(boost::any_cast<int>(m["RetryCount"]));
    }
    if (m.find("TimeoutInMinutes") != m.end() && !m["TimeoutInMinutes"].empty()) {
      timeoutInMinutes = make_shared<int>(boost::any_cast<int>(m["TimeoutInMinutes"]));
    }
    if (m.find("MaximumPerMinute") != m.end() && !m["MaximumPerMinute"].empty()) {
      maximumPerMinute = make_shared<int>(boost::any_cast<int>(m["MaximumPerMinute"]));
    }
    if (m.find("GrayPercent") != m.end() && !m["GrayPercent"].empty()) {
      grayPercent = make_shared<string>(boost::any_cast<string>(m["GrayPercent"]));
    }
    if (m.find("TargetDeviceName") != m.end() && !m["TargetDeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TargetDeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TargetDeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      targetDeviceName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScheduleFinishTime") != m.end() && !m["ScheduleFinishTime"].empty()) {
      scheduleFinishTime = make_shared<long>(boost::any_cast<long>(m["ScheduleFinishTime"]));
    }
    if (m.find("OverwriteMode") != m.end() && !m["OverwriteMode"].empty()) {
      overwriteMode = make_shared<int>(boost::any_cast<int>(m["OverwriteMode"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateOTAStaticUpgradeJobRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOTAStaticUpgradeJobRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateOTAStaticUpgradeJobRequestTag>>(expect1);
      }
    }
    if (m.find("DnListFileUrl") != m.end() && !m["DnListFileUrl"].empty()) {
      dnListFileUrl = make_shared<string>(boost::any_cast<string>(m["DnListFileUrl"]));
    }
  }


  virtual ~CreateOTAStaticUpgradeJobRequest() = default;
};
class CreateOTAStaticUpgradeJobResponseData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> utcCreate{};

  CreateOTAStaticUpgradeJobResponseData() {}

  explicit CreateOTAStaticUpgradeJobResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
    if (!utcCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcCreate is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
  }


  virtual ~CreateOTAStaticUpgradeJobResponseData() = default;
};
class CreateOTAStaticUpgradeJobResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<CreateOTAStaticUpgradeJobResponseData> data{};

  CreateOTAStaticUpgradeJobResponse() {}

  explicit CreateOTAStaticUpgradeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateOTAStaticUpgradeJobResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateOTAStaticUpgradeJobResponseData>(model1);
      }
    }
  }


  virtual ~CreateOTAStaticUpgradeJobResponse() = default;
};
class CreateOTAFirmwareRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> firmwareName{};
  shared_ptr<string> destVersion{};
  shared_ptr<string> firmwareUrl{};
  shared_ptr<string> firmwareSign{};
  shared_ptr<string> signMethod{};
  shared_ptr<int> firmwareSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> firmwareDesc{};
  shared_ptr<int> type{};
  shared_ptr<string> srcVersion{};
  shared_ptr<string> moduleName{};
  shared_ptr<bool> needToVerify{};

  CreateOTAFirmwareRequest() {}

  explicit CreateOTAFirmwareRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!firmwareName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareName is required.")));
    }
    if (!destVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("destVersion is required.")));
    }
    if (!firmwareUrl) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareUrl is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (firmwareName) {
      res["FirmwareName"] = boost::any(*firmwareName);
    }
    if (destVersion) {
      res["DestVersion"] = boost::any(*destVersion);
    }
    if (firmwareUrl) {
      res["FirmwareUrl"] = boost::any(*firmwareUrl);
    }
    if (firmwareSign) {
      res["FirmwareSign"] = boost::any(*firmwareSign);
    }
    if (signMethod) {
      res["SignMethod"] = boost::any(*signMethod);
    }
    if (firmwareSize) {
      res["FirmwareSize"] = boost::any(*firmwareSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (firmwareDesc) {
      res["FirmwareDesc"] = boost::any(*firmwareDesc);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (srcVersion) {
      res["SrcVersion"] = boost::any(*srcVersion);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    if (needToVerify) {
      res["NeedToVerify"] = boost::any(*needToVerify);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("FirmwareName") != m.end() && !m["FirmwareName"].empty()) {
      firmwareName = make_shared<string>(boost::any_cast<string>(m["FirmwareName"]));
    }
    if (m.find("DestVersion") != m.end() && !m["DestVersion"].empty()) {
      destVersion = make_shared<string>(boost::any_cast<string>(m["DestVersion"]));
    }
    if (m.find("FirmwareUrl") != m.end() && !m["FirmwareUrl"].empty()) {
      firmwareUrl = make_shared<string>(boost::any_cast<string>(m["FirmwareUrl"]));
    }
    if (m.find("FirmwareSign") != m.end() && !m["FirmwareSign"].empty()) {
      firmwareSign = make_shared<string>(boost::any_cast<string>(m["FirmwareSign"]));
    }
    if (m.find("SignMethod") != m.end() && !m["SignMethod"].empty()) {
      signMethod = make_shared<string>(boost::any_cast<string>(m["SignMethod"]));
    }
    if (m.find("FirmwareSize") != m.end() && !m["FirmwareSize"].empty()) {
      firmwareSize = make_shared<int>(boost::any_cast<int>(m["FirmwareSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("FirmwareDesc") != m.end() && !m["FirmwareDesc"].empty()) {
      firmwareDesc = make_shared<string>(boost::any_cast<string>(m["FirmwareDesc"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<int>(boost::any_cast<int>(m["Type"]));
    }
    if (m.find("SrcVersion") != m.end() && !m["SrcVersion"].empty()) {
      srcVersion = make_shared<string>(boost::any_cast<string>(m["SrcVersion"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
    if (m.find("NeedToVerify") != m.end() && !m["NeedToVerify"].empty()) {
      needToVerify = make_shared<bool>(boost::any_cast<bool>(m["NeedToVerify"]));
    }
  }


  virtual ~CreateOTAFirmwareRequest() = default;
};
class CreateOTAFirmwareResponseData : public Darabonba::Model {
public:
  shared_ptr<string> firmwareId{};
  shared_ptr<string> utcCreate{};

  CreateOTAFirmwareResponseData() {}

  explicit CreateOTAFirmwareResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!firmwareId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareId is required.")));
    }
    if (!utcCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcCreate is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
  }


  virtual ~CreateOTAFirmwareResponseData() = default;
};
class CreateOTAFirmwareResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<CreateOTAFirmwareResponseData> data{};

  CreateOTAFirmwareResponse() {}

  explicit CreateOTAFirmwareResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateOTAFirmwareResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateOTAFirmwareResponseData>(model1);
      }
    }
  }


  virtual ~CreateOTAFirmwareResponse() = default;
};
class CreateOTAVerifyJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> firmwareId{};
  shared_ptr<int> timeoutInMinutes{};
  shared_ptr<string> productKey{};
  shared_ptr<vector<string>> targetDeviceName{};

  CreateOTAVerifyJobRequest() {}

  explicit CreateOTAVerifyJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!firmwareId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareId is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!targetDeviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetDeviceName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (timeoutInMinutes) {
      res["TimeoutInMinutes"] = boost::any(*timeoutInMinutes);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (targetDeviceName) {
      res["TargetDeviceName"] = boost::any(*targetDeviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("TimeoutInMinutes") != m.end() && !m["TimeoutInMinutes"].empty()) {
      timeoutInMinutes = make_shared<int>(boost::any_cast<int>(m["TimeoutInMinutes"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("TargetDeviceName") != m.end() && !m["TargetDeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TargetDeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TargetDeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      targetDeviceName = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateOTAVerifyJobRequest() = default;
};
class CreateOTAVerifyJobResponseData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> utcCreate{};

  CreateOTAVerifyJobResponseData() {}

  explicit CreateOTAVerifyJobResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
    if (!utcCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcCreate is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
  }


  virtual ~CreateOTAVerifyJobResponseData() = default;
};
class CreateOTAVerifyJobResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<CreateOTAVerifyJobResponseData> data{};

  CreateOTAVerifyJobResponse() {}

  explicit CreateOTAVerifyJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateOTAVerifyJobResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateOTAVerifyJobResponseData>(model1);
      }
    }
  }


  virtual ~CreateOTAVerifyJobResponse() = default;
};
class QueryOTAJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> jobId{};

  QueryOTAJobRequest() {}

  explicit QueryOTAJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~QueryOTAJobRequest() = default;
};
class QueryOTAJobResponseDataTagsOtaTagDTO : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  QueryOTAJobResponseDataTagsOtaTagDTO() {}

  explicit QueryOTAJobResponseDataTagsOtaTagDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!key) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("key is required.")));
    }
    if (!value) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("value is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryOTAJobResponseDataTagsOtaTagDTO() = default;
};
class QueryOTAJobResponseDataTags : public Darabonba::Model {
public:
  shared_ptr<vector<QueryOTAJobResponseDataTagsOtaTagDTO>> otaTagDTO{};

  QueryOTAJobResponseDataTags() {}

  explicit QueryOTAJobResponseDataTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!otaTagDTO) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("otaTagDTO is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (otaTagDTO) {
      vector<boost::any> temp1;
      for(auto item1:*otaTagDTO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OtaTagDTO"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OtaTagDTO") != m.end() && !m["OtaTagDTO"].empty()) {
      if (typeid(vector<boost::any>) == m["OtaTagDTO"].type()) {
        vector<QueryOTAJobResponseDataTagsOtaTagDTO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OtaTagDTO"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOTAJobResponseDataTagsOtaTagDTO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        otaTagDTO = make_shared<vector<QueryOTAJobResponseDataTagsOtaTagDTO>>(expect1);
      }
    }
  }


  virtual ~QueryOTAJobResponseDataTags() = default;
};
class QueryOTAJobResponseDataSrcVersions : public Darabonba::Model {
public:
  shared_ptr<vector<string>> srcVersion{};

  QueryOTAJobResponseDataSrcVersions() {}

  explicit QueryOTAJobResponseDataSrcVersions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!srcVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("srcVersion is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (srcVersion) {
      res["SrcVersion"] = boost::any(*srcVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SrcVersion") != m.end() && !m["SrcVersion"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SrcVersion"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SrcVersion"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      srcVersion = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryOTAJobResponseDataSrcVersions() = default;
};
class QueryOTAJobResponseData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> utcModified{};
  shared_ptr<string> productKey{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> utcStartTime{};
  shared_ptr<string> utcEndTime{};
  shared_ptr<string> jobStatus{};
  shared_ptr<string> jobType{};
  shared_ptr<string> jobDesc{};
  shared_ptr<string> name{};
  shared_ptr<string> utcScheduleTime{};
  shared_ptr<int> retryInterval{};
  shared_ptr<int> retryCount{};
  shared_ptr<int> timeoutInMinutes{};
  shared_ptr<string> targetSelection{};
  shared_ptr<string> selectionType{};
  shared_ptr<string> grayPercent{};
  shared_ptr<int> maximumPerMinute{};
  shared_ptr<string> destVersion{};
  shared_ptr<string> utcScheduleFinishTime{};
  shared_ptr<int> overwriteMode{};
  shared_ptr<int> dynamicMode{};
  shared_ptr<QueryOTAJobResponseDataTags> tags{};
  shared_ptr<QueryOTAJobResponseDataSrcVersions> srcVersions{};

  QueryOTAJobResponseData() {}

  explicit QueryOTAJobResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
    if (!utcCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcCreate is required.")));
    }
    if (!utcModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcModified is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!firmwareId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareId is required.")));
    }
    if (!utcStartTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcStartTime is required.")));
    }
    if (!utcEndTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcEndTime is required.")));
    }
    if (!jobStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobStatus is required.")));
    }
    if (!jobType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobType is required.")));
    }
    if (!jobDesc) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobDesc is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!utcScheduleTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcScheduleTime is required.")));
    }
    if (!retryInterval) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("retryInterval is required.")));
    }
    if (!retryCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("retryCount is required.")));
    }
    if (!timeoutInMinutes) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("timeoutInMinutes is required.")));
    }
    if (!targetSelection) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("targetSelection is required.")));
    }
    if (!selectionType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("selectionType is required.")));
    }
    if (!grayPercent) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("grayPercent is required.")));
    }
    if (!maximumPerMinute) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("maximumPerMinute is required.")));
    }
    if (!destVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("destVersion is required.")));
    }
    if (!utcScheduleFinishTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcScheduleFinishTime is required.")));
    }
    if (!overwriteMode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("overwriteMode is required.")));
    }
    if (!dynamicMode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dynamicMode is required.")));
    }
    if (!tags) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tags is required.")));
    }
    if (!srcVersions) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("srcVersions is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (utcStartTime) {
      res["UtcStartTime"] = boost::any(*utcStartTime);
    }
    if (utcEndTime) {
      res["UtcEndTime"] = boost::any(*utcEndTime);
    }
    if (jobStatus) {
      res["JobStatus"] = boost::any(*jobStatus);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (jobDesc) {
      res["JobDesc"] = boost::any(*jobDesc);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (utcScheduleTime) {
      res["UtcScheduleTime"] = boost::any(*utcScheduleTime);
    }
    if (retryInterval) {
      res["RetryInterval"] = boost::any(*retryInterval);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (timeoutInMinutes) {
      res["TimeoutInMinutes"] = boost::any(*timeoutInMinutes);
    }
    if (targetSelection) {
      res["TargetSelection"] = boost::any(*targetSelection);
    }
    if (selectionType) {
      res["SelectionType"] = boost::any(*selectionType);
    }
    if (grayPercent) {
      res["GrayPercent"] = boost::any(*grayPercent);
    }
    if (maximumPerMinute) {
      res["MaximumPerMinute"] = boost::any(*maximumPerMinute);
    }
    if (destVersion) {
      res["DestVersion"] = boost::any(*destVersion);
    }
    if (utcScheduleFinishTime) {
      res["UtcScheduleFinishTime"] = boost::any(*utcScheduleFinishTime);
    }
    if (overwriteMode) {
      res["OverwriteMode"] = boost::any(*overwriteMode);
    }
    if (dynamicMode) {
      res["DynamicMode"] = boost::any(*dynamicMode);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (srcVersions) {
      res["SrcVersions"] = srcVersions ? boost::any(srcVersions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("UtcStartTime") != m.end() && !m["UtcStartTime"].empty()) {
      utcStartTime = make_shared<string>(boost::any_cast<string>(m["UtcStartTime"]));
    }
    if (m.find("UtcEndTime") != m.end() && !m["UtcEndTime"].empty()) {
      utcEndTime = make_shared<string>(boost::any_cast<string>(m["UtcEndTime"]));
    }
    if (m.find("JobStatus") != m.end() && !m["JobStatus"].empty()) {
      jobStatus = make_shared<string>(boost::any_cast<string>(m["JobStatus"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("JobDesc") != m.end() && !m["JobDesc"].empty()) {
      jobDesc = make_shared<string>(boost::any_cast<string>(m["JobDesc"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UtcScheduleTime") != m.end() && !m["UtcScheduleTime"].empty()) {
      utcScheduleTime = make_shared<string>(boost::any_cast<string>(m["UtcScheduleTime"]));
    }
    if (m.find("RetryInterval") != m.end() && !m["RetryInterval"].empty()) {
      retryInterval = make_shared<int>(boost::any_cast<int>(m["RetryInterval"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<int>(boost::any_cast<int>(m["RetryCount"]));
    }
    if (m.find("TimeoutInMinutes") != m.end() && !m["TimeoutInMinutes"].empty()) {
      timeoutInMinutes = make_shared<int>(boost::any_cast<int>(m["TimeoutInMinutes"]));
    }
    if (m.find("TargetSelection") != m.end() && !m["TargetSelection"].empty()) {
      targetSelection = make_shared<string>(boost::any_cast<string>(m["TargetSelection"]));
    }
    if (m.find("SelectionType") != m.end() && !m["SelectionType"].empty()) {
      selectionType = make_shared<string>(boost::any_cast<string>(m["SelectionType"]));
    }
    if (m.find("GrayPercent") != m.end() && !m["GrayPercent"].empty()) {
      grayPercent = make_shared<string>(boost::any_cast<string>(m["GrayPercent"]));
    }
    if (m.find("MaximumPerMinute") != m.end() && !m["MaximumPerMinute"].empty()) {
      maximumPerMinute = make_shared<int>(boost::any_cast<int>(m["MaximumPerMinute"]));
    }
    if (m.find("DestVersion") != m.end() && !m["DestVersion"].empty()) {
      destVersion = make_shared<string>(boost::any_cast<string>(m["DestVersion"]));
    }
    if (m.find("UtcScheduleFinishTime") != m.end() && !m["UtcScheduleFinishTime"].empty()) {
      utcScheduleFinishTime = make_shared<string>(boost::any_cast<string>(m["UtcScheduleFinishTime"]));
    }
    if (m.find("OverwriteMode") != m.end() && !m["OverwriteMode"].empty()) {
      overwriteMode = make_shared<int>(boost::any_cast<int>(m["OverwriteMode"]));
    }
    if (m.find("DynamicMode") != m.end() && !m["DynamicMode"].empty()) {
      dynamicMode = make_shared<int>(boost::any_cast<int>(m["DynamicMode"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        QueryOTAJobResponseDataTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<QueryOTAJobResponseDataTags>(model1);
      }
    }
    if (m.find("SrcVersions") != m.end() && !m["SrcVersions"].empty()) {
      if (typeid(map<string, boost::any>) == m["SrcVersions"].type()) {
        QueryOTAJobResponseDataSrcVersions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SrcVersions"]));
        srcVersions = make_shared<QueryOTAJobResponseDataSrcVersions>(model1);
      }
    }
  }


  virtual ~QueryOTAJobResponseData() = default;
};
class QueryOTAJobResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryOTAJobResponseData> data{};

  QueryOTAJobResponse() {}

  explicit QueryOTAJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryOTAJobResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryOTAJobResponseData>(model1);
      }
    }
  }


  virtual ~QueryOTAJobResponse() = default;
};
class CancelOTATaskByDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> productKey{};
  shared_ptr<vector<string>> deviceName{};
  shared_ptr<string> jobId{};

  CancelOTATaskByDeviceRequest() {}

  explicit CancelOTATaskByDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!firmwareId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareId is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~CancelOTATaskByDeviceRequest() = default;
};
class CancelOTATaskByDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  CancelOTATaskByDeviceResponse() {}

  explicit CancelOTATaskByDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CancelOTATaskByDeviceResponse() = default;
};
class DeleteOTAFirmwareRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> firmwareId{};

  DeleteOTAFirmwareRequest() {}

  explicit DeleteOTAFirmwareRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!firmwareId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
  }


  virtual ~DeleteOTAFirmwareRequest() = default;
};
class DeleteOTAFirmwareResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteOTAFirmwareResponse() {}

  explicit DeleteOTAFirmwareResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteOTAFirmwareResponse() = default;
};
class QueryOTAFirmwareRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> firmwareId{};

  QueryOTAFirmwareRequest() {}

  explicit QueryOTAFirmwareRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!firmwareId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
  }


  virtual ~QueryOTAFirmwareRequest() = default;
};
class QueryOTAFirmwareResponseFirmwareInfo : public Darabonba::Model {
public:
  shared_ptr<string> firmwareName{};
  shared_ptr<string> firmwareId{};
  shared_ptr<string> srcVersion{};
  shared_ptr<string> destVersion{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> utcModified{};
  shared_ptr<int> status{};
  shared_ptr<string> firmwareDesc{};
  shared_ptr<string> firmwareSign{};
  shared_ptr<int> firmwareSize{};
  shared_ptr<string> firmwareUrl{};
  shared_ptr<string> productKey{};
  shared_ptr<string> signMethod{};
  shared_ptr<string> productName{};
  shared_ptr<int> type{};
  shared_ptr<int> verifyProgress{};
  shared_ptr<string> moduleName{};

  QueryOTAFirmwareResponseFirmwareInfo() {}

  explicit QueryOTAFirmwareResponseFirmwareInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!firmwareName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareName is required.")));
    }
    if (!firmwareId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareId is required.")));
    }
    if (!srcVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("srcVersion is required.")));
    }
    if (!destVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("destVersion is required.")));
    }
    if (!utcCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcCreate is required.")));
    }
    if (!utcModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcModified is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!firmwareDesc) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareDesc is required.")));
    }
    if (!firmwareSign) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareSign is required.")));
    }
    if (!firmwareSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareSize is required.")));
    }
    if (!firmwareUrl) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareUrl is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!signMethod) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("signMethod is required.")));
    }
    if (!productName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productName is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
    if (!verifyProgress) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("verifyProgress is required.")));
    }
    if (!moduleName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("moduleName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (firmwareName) {
      res["FirmwareName"] = boost::any(*firmwareName);
    }
    if (firmwareId) {
      res["FirmwareId"] = boost::any(*firmwareId);
    }
    if (srcVersion) {
      res["SrcVersion"] = boost::any(*srcVersion);
    }
    if (destVersion) {
      res["DestVersion"] = boost::any(*destVersion);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (firmwareDesc) {
      res["FirmwareDesc"] = boost::any(*firmwareDesc);
    }
    if (firmwareSign) {
      res["FirmwareSign"] = boost::any(*firmwareSign);
    }
    if (firmwareSize) {
      res["FirmwareSize"] = boost::any(*firmwareSize);
    }
    if (firmwareUrl) {
      res["FirmwareUrl"] = boost::any(*firmwareUrl);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (signMethod) {
      res["SignMethod"] = boost::any(*signMethod);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (verifyProgress) {
      res["VerifyProgress"] = boost::any(*verifyProgress);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FirmwareName") != m.end() && !m["FirmwareName"].empty()) {
      firmwareName = make_shared<string>(boost::any_cast<string>(m["FirmwareName"]));
    }
    if (m.find("FirmwareId") != m.end() && !m["FirmwareId"].empty()) {
      firmwareId = make_shared<string>(boost::any_cast<string>(m["FirmwareId"]));
    }
    if (m.find("SrcVersion") != m.end() && !m["SrcVersion"].empty()) {
      srcVersion = make_shared<string>(boost::any_cast<string>(m["SrcVersion"]));
    }
    if (m.find("DestVersion") != m.end() && !m["DestVersion"].empty()) {
      destVersion = make_shared<string>(boost::any_cast<string>(m["DestVersion"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<int>(boost::any_cast<int>(m["Status"]));
    }
    if (m.find("FirmwareDesc") != m.end() && !m["FirmwareDesc"].empty()) {
      firmwareDesc = make_shared<string>(boost::any_cast<string>(m["FirmwareDesc"]));
    }
    if (m.find("FirmwareSign") != m.end() && !m["FirmwareSign"].empty()) {
      firmwareSign = make_shared<string>(boost::any_cast<string>(m["FirmwareSign"]));
    }
    if (m.find("FirmwareSize") != m.end() && !m["FirmwareSize"].empty()) {
      firmwareSize = make_shared<int>(boost::any_cast<int>(m["FirmwareSize"]));
    }
    if (m.find("FirmwareUrl") != m.end() && !m["FirmwareUrl"].empty()) {
      firmwareUrl = make_shared<string>(boost::any_cast<string>(m["FirmwareUrl"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("SignMethod") != m.end() && !m["SignMethod"].empty()) {
      signMethod = make_shared<string>(boost::any_cast<string>(m["SignMethod"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<int>(boost::any_cast<int>(m["Type"]));
    }
    if (m.find("VerifyProgress") != m.end() && !m["VerifyProgress"].empty()) {
      verifyProgress = make_shared<int>(boost::any_cast<int>(m["VerifyProgress"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
  }


  virtual ~QueryOTAFirmwareResponseFirmwareInfo() = default;
};
class QueryOTAFirmwareResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryOTAFirmwareResponseFirmwareInfo> firmwareInfo{};

  QueryOTAFirmwareResponse() {}

  explicit QueryOTAFirmwareResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!firmwareInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (firmwareInfo) {
      res["FirmwareInfo"] = firmwareInfo ? boost::any(firmwareInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("FirmwareInfo") != m.end() && !m["FirmwareInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FirmwareInfo"].type()) {
        QueryOTAFirmwareResponseFirmwareInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FirmwareInfo"]));
        firmwareInfo = make_shared<QueryOTAFirmwareResponseFirmwareInfo>(model1);
      }
    }
  }


  virtual ~QueryOTAFirmwareResponse() = default;
};
class UnbindApplicationFromEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> applicationId{};

  UnbindApplicationFromEdgeInstanceRequest() {}

  explicit UnbindApplicationFromEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!applicationId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applicationId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
  }


  virtual ~UnbindApplicationFromEdgeInstanceRequest() = default;
};
class UnbindApplicationFromEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UnbindApplicationFromEdgeInstanceResponse() {}

  explicit UnbindApplicationFromEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UnbindApplicationFromEdgeInstanceResponse() = default;
};
class BindApplicationToEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> applicationId{};
  shared_ptr<string> applicationVersion{};

  BindApplicationToEdgeInstanceRequest() {}

  explicit BindApplicationToEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!applicationId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applicationId is required.")));
    }
    if (!applicationVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applicationVersion is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (applicationVersion) {
      res["ApplicationVersion"] = boost::any(*applicationVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("ApplicationVersion") != m.end() && !m["ApplicationVersion"].empty()) {
      applicationVersion = make_shared<string>(boost::any_cast<string>(m["ApplicationVersion"]));
    }
  }


  virtual ~BindApplicationToEdgeInstanceRequest() = default;
};
class BindApplicationToEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  BindApplicationToEdgeInstanceResponse() {}

  explicit BindApplicationToEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~BindApplicationToEdgeInstanceResponse() = default;
};
class QueryCertUrlByApplyIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> applyId{};

  QueryCertUrlByApplyIdRequest() {}

  explicit QueryCertUrlByApplyIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!applyId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applyId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (applyId) {
      res["ApplyId"] = boost::any(*applyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ApplyId") != m.end() && !m["ApplyId"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["ApplyId"]));
    }
  }


  virtual ~QueryCertUrlByApplyIdRequest() = default;
};
class QueryCertUrlByApplyIdResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> certUrl{};

  QueryCertUrlByApplyIdResponse() {}

  explicit QueryCertUrlByApplyIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!certUrl) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("certUrl is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (certUrl) {
      res["CertUrl"] = boost::any(*certUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("CertUrl") != m.end() && !m["CertUrl"].empty()) {
      certUrl = make_shared<string>(boost::any_cast<string>(m["CertUrl"]));
    }
  }


  virtual ~QueryCertUrlByApplyIdResponse() = default;
};
class QueryDeviceCertRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};

  QueryDeviceCertRequest() {}

  explicit QueryDeviceCertRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
  }


  virtual ~QueryDeviceCertRequest() = default;
};
class QueryDeviceCertResponseDeviceCertInfo : public Darabonba::Model {
public:
  shared_ptr<int> status{};
  shared_ptr<string> certificate{};
  shared_ptr<string> privateKey{};
  shared_ptr<string> certSN{};

  QueryDeviceCertResponseDeviceCertInfo() {}

  explicit QueryDeviceCertResponseDeviceCertInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!certificate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("certificate is required.")));
    }
    if (!privateKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("privateKey is required.")));
    }
    if (!certSN) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("certSN is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (certificate) {
      res["Certificate"] = boost::any(*certificate);
    }
    if (privateKey) {
      res["PrivateKey"] = boost::any(*privateKey);
    }
    if (certSN) {
      res["CertSN"] = boost::any(*certSN);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<int>(boost::any_cast<int>(m["Status"]));
    }
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["Certificate"]));
    }
    if (m.find("PrivateKey") != m.end() && !m["PrivateKey"].empty()) {
      privateKey = make_shared<string>(boost::any_cast<string>(m["PrivateKey"]));
    }
    if (m.find("CertSN") != m.end() && !m["CertSN"].empty()) {
      certSN = make_shared<string>(boost::any_cast<string>(m["CertSN"]));
    }
  }


  virtual ~QueryDeviceCertResponseDeviceCertInfo() = default;
};
class QueryDeviceCertResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceCertResponseDeviceCertInfo> deviceCertInfo{};

  QueryDeviceCertResponse() {}

  explicit QueryDeviceCertResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!deviceCertInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceCertInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (deviceCertInfo) {
      res["DeviceCertInfo"] = deviceCertInfo ? boost::any(deviceCertInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("DeviceCertInfo") != m.end() && !m["DeviceCertInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeviceCertInfo"].type()) {
        QueryDeviceCertResponseDeviceCertInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeviceCertInfo"]));
        deviceCertInfo = make_shared<QueryDeviceCertResponseDeviceCertInfo>(model1);
      }
    }
  }


  virtual ~QueryDeviceCertResponse() = default;
};
class CloseEdgeInstanceDeploymentRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};

  CloseEdgeInstanceDeploymentRequest() {}

  explicit CloseEdgeInstanceDeploymentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~CloseEdgeInstanceDeploymentRequest() = default;
};
class CloseEdgeInstanceDeploymentResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  CloseEdgeInstanceDeploymentResponse() {}

  explicit CloseEdgeInstanceDeploymentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CloseEdgeInstanceDeploymentResponse() = default;
};
class UnbindDriverFromEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> driverId{};

  UnbindDriverFromEdgeInstanceRequest() {}

  explicit UnbindDriverFromEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!driverId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
  }


  virtual ~UnbindDriverFromEdgeInstanceRequest() = default;
};
class UnbindDriverFromEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UnbindDriverFromEdgeInstanceResponse() {}

  explicit UnbindDriverFromEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UnbindDriverFromEdgeInstanceResponse() = default;
};
class ReplaceEdgeInstanceGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> currentGatewayId{};
  shared_ptr<string> newGatewayId{};

  ReplaceEdgeInstanceGatewayRequest() {}

  explicit ReplaceEdgeInstanceGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!currentGatewayId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentGatewayId is required.")));
    }
    if (!newGatewayId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("newGatewayId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (currentGatewayId) {
      res["CurrentGatewayId"] = boost::any(*currentGatewayId);
    }
    if (newGatewayId) {
      res["NewGatewayId"] = boost::any(*newGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("CurrentGatewayId") != m.end() && !m["CurrentGatewayId"].empty()) {
      currentGatewayId = make_shared<string>(boost::any_cast<string>(m["CurrentGatewayId"]));
    }
    if (m.find("NewGatewayId") != m.end() && !m["NewGatewayId"].empty()) {
      newGatewayId = make_shared<string>(boost::any_cast<string>(m["NewGatewayId"]));
    }
  }


  virtual ~ReplaceEdgeInstanceGatewayRequest() = default;
};
class ReplaceEdgeInstanceGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  ReplaceEdgeInstanceGatewayResponse() {}

  explicit ReplaceEdgeInstanceGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~ReplaceEdgeInstanceGatewayResponse() = default;
};
class BindDriverToEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};
  shared_ptr<string> orderId{};

  BindDriverToEdgeInstanceRequest() {}

  explicit BindDriverToEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!driverId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
  }


  virtual ~BindDriverToEdgeInstanceRequest() = default;
};
class BindDriverToEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  BindDriverToEdgeInstanceResponse() {}

  explicit BindDriverToEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~BindDriverToEdgeInstanceResponse() = default;
};
class BatchQueryDeviceDetailRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> deviceName{};
  shared_ptr<string> productKey{};
  shared_ptr<string> iotInstanceId{};

  BatchQueryDeviceDetailRequest() {}

  explicit BatchQueryDeviceDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~BatchQueryDeviceDetailRequest() = default;
};
class BatchQueryDeviceDetailResponseDataData : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> nickname{};
  shared_ptr<string> deviceSecret{};
  shared_ptr<string> iotId{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> utcActive{};
  shared_ptr<string> gmtActive{};
  shared_ptr<string> status{};
  shared_ptr<string> firmwareVersion{};
  shared_ptr<int> nodeType{};
  shared_ptr<string> region{};

  BatchQueryDeviceDetailResponseDataData() {}

  explicit BatchQueryDeviceDetailResponseDataData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!productName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productName is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!nickname) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nickname is required.")));
    }
    if (!deviceSecret) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceSecret is required.")));
    }
    if (!iotId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotId is required.")));
    }
    if (!utcCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcCreate is required.")));
    }
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!utcActive) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcActive is required.")));
    }
    if (!gmtActive) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtActive is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!firmwareVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareVersion is required.")));
    }
    if (!nodeType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeType is required.")));
    }
    if (!region) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("region is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    if (deviceSecret) {
      res["DeviceSecret"] = boost::any(*deviceSecret);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (utcActive) {
      res["UtcActive"] = boost::any(*utcActive);
    }
    if (gmtActive) {
      res["GmtActive"] = boost::any(*gmtActive);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (firmwareVersion) {
      res["FirmwareVersion"] = boost::any(*firmwareVersion);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
    if (m.find("DeviceSecret") != m.end() && !m["DeviceSecret"].empty()) {
      deviceSecret = make_shared<string>(boost::any_cast<string>(m["DeviceSecret"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("UtcActive") != m.end() && !m["UtcActive"].empty()) {
      utcActive = make_shared<string>(boost::any_cast<string>(m["UtcActive"]));
    }
    if (m.find("GmtActive") != m.end() && !m["GmtActive"].empty()) {
      gmtActive = make_shared<string>(boost::any_cast<string>(m["GmtActive"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("FirmwareVersion") != m.end() && !m["FirmwareVersion"].empty()) {
      firmwareVersion = make_shared<string>(boost::any_cast<string>(m["FirmwareVersion"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<int>(boost::any_cast<int>(m["NodeType"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~BatchQueryDeviceDetailResponseDataData() = default;
};
class BatchQueryDeviceDetailResponseData : public Darabonba::Model {
public:
  shared_ptr<vector<BatchQueryDeviceDetailResponseDataData>> data{};

  BatchQueryDeviceDetailResponseData() {}

  explicit BatchQueryDeviceDetailResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<BatchQueryDeviceDetailResponseDataData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchQueryDeviceDetailResponseDataData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<BatchQueryDeviceDetailResponseDataData>>(expect1);
      }
    }
  }


  virtual ~BatchQueryDeviceDetailResponseData() = default;
};
class BatchQueryDeviceDetailResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<BatchQueryDeviceDetailResponseData> data{};

  BatchQueryDeviceDetailResponse() {}

  explicit BatchQueryDeviceDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BatchQueryDeviceDetailResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BatchQueryDeviceDetailResponseData>(model1);
      }
    }
  }


  virtual ~BatchQueryDeviceDetailResponse() = default;
};
class GetEdgeInstanceDeploymentRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> deploymentId{};

  GetEdgeInstanceDeploymentRequest() {}

  explicit GetEdgeInstanceDeploymentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!deploymentId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deploymentId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (deploymentId) {
      res["DeploymentId"] = boost::any(*deploymentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DeploymentId") != m.end() && !m["DeploymentId"].empty()) {
      deploymentId = make_shared<string>(boost::any_cast<string>(m["DeploymentId"]));
    }
  }


  virtual ~GetEdgeInstanceDeploymentRequest() = default;
};
class GetEdgeInstanceDeploymentResponseDataTaskListResourceSnapshotList : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> gmtCompleted{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceName{};
  shared_ptr<int> operateType{};
  shared_ptr<int> stage{};
  shared_ptr<int> status{};
  shared_ptr<string> log{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<long> gmtCompletedTimestamp{};

  GetEdgeInstanceDeploymentResponseDataTaskListResourceSnapshotList() {}

  explicit GetEdgeInstanceDeploymentResponseDataTaskListResourceSnapshotList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!gmtModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModified is required.")));
    }
    if (!gmtCompleted) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCompleted is required.")));
    }
    if (!snapshotId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("snapshotId is required.")));
    }
    if (!resourceType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("resourceType is required.")));
    }
    if (!resourceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("resourceId is required.")));
    }
    if (!resourceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("resourceName is required.")));
    }
    if (!operateType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("operateType is required.")));
    }
    if (!stage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("stage is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!log) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("log is required.")));
    }
    if (!gmtCreateTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreateTimestamp is required.")));
    }
    if (!gmtModifiedTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModifiedTimestamp is required.")));
    }
    if (!gmtCompletedTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCompletedTimestamp is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtCompleted) {
      res["GmtCompleted"] = boost::any(*gmtCompleted);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (operateType) {
      res["OperateType"] = boost::any(*operateType);
    }
    if (stage) {
      res["Stage"] = boost::any(*stage);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (log) {
      res["Log"] = boost::any(*log);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (gmtCompletedTimestamp) {
      res["GmtCompletedTimestamp"] = boost::any(*gmtCompletedTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtCompleted") != m.end() && !m["GmtCompleted"].empty()) {
      gmtCompleted = make_shared<string>(boost::any_cast<string>(m["GmtCompleted"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("OperateType") != m.end() && !m["OperateType"].empty()) {
      operateType = make_shared<int>(boost::any_cast<int>(m["OperateType"]));
    }
    if (m.find("Stage") != m.end() && !m["Stage"].empty()) {
      stage = make_shared<int>(boost::any_cast<int>(m["Stage"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<int>(boost::any_cast<int>(m["Status"]));
    }
    if (m.find("Log") != m.end() && !m["Log"].empty()) {
      log = make_shared<string>(boost::any_cast<string>(m["Log"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("GmtCompletedTimestamp") != m.end() && !m["GmtCompletedTimestamp"].empty()) {
      gmtCompletedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCompletedTimestamp"]));
    }
  }


  virtual ~GetEdgeInstanceDeploymentResponseDataTaskListResourceSnapshotList() = default;
};
class GetEdgeInstanceDeploymentResponseDataTaskList : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> gmtCompleted{};
  shared_ptr<string> gatewayId{};
  shared_ptr<string> taskId{};
  shared_ptr<int> stage{};
  shared_ptr<int> status{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<long> gmtCompletedTimestamp{};
  shared_ptr<vector<GetEdgeInstanceDeploymentResponseDataTaskListResourceSnapshotList>> resourceSnapshotList{};

  GetEdgeInstanceDeploymentResponseDataTaskList() {}

  explicit GetEdgeInstanceDeploymentResponseDataTaskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!gmtModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModified is required.")));
    }
    if (!gmtCompleted) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCompleted is required.")));
    }
    if (!gatewayId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gatewayId is required.")));
    }
    if (!taskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskId is required.")));
    }
    if (!stage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("stage is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!gmtCreateTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreateTimestamp is required.")));
    }
    if (!gmtModifiedTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModifiedTimestamp is required.")));
    }
    if (!gmtCompletedTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCompletedTimestamp is required.")));
    }
    if (!resourceSnapshotList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("resourceSnapshotList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtCompleted) {
      res["GmtCompleted"] = boost::any(*gmtCompleted);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (stage) {
      res["Stage"] = boost::any(*stage);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (gmtCompletedTimestamp) {
      res["GmtCompletedTimestamp"] = boost::any(*gmtCompletedTimestamp);
    }
    if (resourceSnapshotList) {
      vector<boost::any> temp1;
      for(auto item1:*resourceSnapshotList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceSnapshotList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtCompleted") != m.end() && !m["GmtCompleted"].empty()) {
      gmtCompleted = make_shared<string>(boost::any_cast<string>(m["GmtCompleted"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<string>(boost::any_cast<string>(m["GatewayId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Stage") != m.end() && !m["Stage"].empty()) {
      stage = make_shared<int>(boost::any_cast<int>(m["Stage"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<int>(boost::any_cast<int>(m["Status"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("GmtCompletedTimestamp") != m.end() && !m["GmtCompletedTimestamp"].empty()) {
      gmtCompletedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCompletedTimestamp"]));
    }
    if (m.find("ResourceSnapshotList") != m.end() && !m["ResourceSnapshotList"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceSnapshotList"].type()) {
        vector<GetEdgeInstanceDeploymentResponseDataTaskListResourceSnapshotList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceSnapshotList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEdgeInstanceDeploymentResponseDataTaskListResourceSnapshotList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceSnapshotList = make_shared<vector<GetEdgeInstanceDeploymentResponseDataTaskListResourceSnapshotList>>(expect1);
      }
    }
  }


  virtual ~GetEdgeInstanceDeploymentResponseDataTaskList() = default;
};
class GetEdgeInstanceDeploymentResponseData : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> gmtCompleted{};
  shared_ptr<string> deploymentId{};
  shared_ptr<string> description{};
  shared_ptr<int> status{};
  shared_ptr<string> type{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<long> gmtCompletedTimestamp{};
  shared_ptr<vector<GetEdgeInstanceDeploymentResponseDataTaskList>> taskList{};

  GetEdgeInstanceDeploymentResponseData() {}

  explicit GetEdgeInstanceDeploymentResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!gmtModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModified is required.")));
    }
    if (!gmtCompleted) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCompleted is required.")));
    }
    if (!deploymentId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deploymentId is required.")));
    }
    if (!description) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("description is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
    if (!gmtCreateTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreateTimestamp is required.")));
    }
    if (!gmtModifiedTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModifiedTimestamp is required.")));
    }
    if (!gmtCompletedTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCompletedTimestamp is required.")));
    }
    if (!taskList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtCompleted) {
      res["GmtCompleted"] = boost::any(*gmtCompleted);
    }
    if (deploymentId) {
      res["DeploymentId"] = boost::any(*deploymentId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (gmtCompletedTimestamp) {
      res["GmtCompletedTimestamp"] = boost::any(*gmtCompletedTimestamp);
    }
    if (taskList) {
      vector<boost::any> temp1;
      for(auto item1:*taskList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtCompleted") != m.end() && !m["GmtCompleted"].empty()) {
      gmtCompleted = make_shared<string>(boost::any_cast<string>(m["GmtCompleted"]));
    }
    if (m.find("DeploymentId") != m.end() && !m["DeploymentId"].empty()) {
      deploymentId = make_shared<string>(boost::any_cast<string>(m["DeploymentId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<int>(boost::any_cast<int>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("GmtCompletedTimestamp") != m.end() && !m["GmtCompletedTimestamp"].empty()) {
      gmtCompletedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCompletedTimestamp"]));
    }
    if (m.find("TaskList") != m.end() && !m["TaskList"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskList"].type()) {
        vector<GetEdgeInstanceDeploymentResponseDataTaskList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEdgeInstanceDeploymentResponseDataTaskList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskList = make_shared<vector<GetEdgeInstanceDeploymentResponseDataTaskList>>(expect1);
      }
    }
  }


  virtual ~GetEdgeInstanceDeploymentResponseData() = default;
};
class GetEdgeInstanceDeploymentResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetEdgeInstanceDeploymentResponseData> data{};

  GetEdgeInstanceDeploymentResponse() {}

  explicit GetEdgeInstanceDeploymentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetEdgeInstanceDeploymentResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetEdgeInstanceDeploymentResponseData>(model1);
      }
    }
  }


  virtual ~GetEdgeInstanceDeploymentResponse() = default;
};
class QueryTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> taskId{};

  QueryTaskRequest() {}

  explicit QueryTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!taskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~QueryTaskRequest() = default;
};
class QueryTaskResponseData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> jobName{};
  shared_ptr<string> taskId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> progress{};
  shared_ptr<string> utcQueueTime{};
  shared_ptr<string> utcModified{};
  shared_ptr<string> statusDetail{};
  shared_ptr<string> status{};
  shared_ptr<string> message{};

  QueryTaskResponseData() {}

  explicit QueryTaskResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!jobId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobId is required.")));
    }
    if (!jobName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("jobName is required.")));
    }
    if (!taskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskId is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!iotId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotId is required.")));
    }
    if (!progress) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("progress is required.")));
    }
    if (!utcQueueTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcQueueTime is required.")));
    }
    if (!utcModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcModified is required.")));
    }
    if (!statusDetail) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusDetail is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!message) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("message is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (utcQueueTime) {
      res["UtcQueueTime"] = boost::any(*utcQueueTime);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (statusDetail) {
      res["StatusDetail"] = boost::any(*statusDetail);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("UtcQueueTime") != m.end() && !m["UtcQueueTime"].empty()) {
      utcQueueTime = make_shared<string>(boost::any_cast<string>(m["UtcQueueTime"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("StatusDetail") != m.end() && !m["StatusDetail"].empty()) {
      statusDetail = make_shared<string>(boost::any_cast<string>(m["StatusDetail"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~QueryTaskResponseData() = default;
};
class QueryTaskResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryTaskResponseData> data{};

  QueryTaskResponse() {}

  explicit QueryTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryTaskResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryTaskResponseData>(model1);
      }
    }
  }


  virtual ~QueryTaskResponse() = default;
};
class CreateDataAPIServiceRequestRequestParam : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> desc{};
  shared_ptr<string> example{};
  shared_ptr<bool> required{};

  CreateDataAPIServiceRequestRequestParam() {}

  explicit CreateDataAPIServiceRequestRequestParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (example) {
      res["Example"] = boost::any(*example);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Example") != m.end() && !m["Example"].empty()) {
      example = make_shared<string>(boost::any_cast<string>(m["Example"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<bool>(boost::any_cast<bool>(m["Required"]));
    }
  }


  virtual ~CreateDataAPIServiceRequestRequestParam() = default;
};
class CreateDataAPIServiceRequestResponseParam : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> desc{};
  shared_ptr<string> example{};
  shared_ptr<bool> required{};

  CreateDataAPIServiceRequestResponseParam() {}

  explicit CreateDataAPIServiceRequestResponseParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (example) {
      res["Example"] = boost::any(*example);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Example") != m.end() && !m["Example"].empty()) {
      example = make_shared<string>(boost::any_cast<string>(m["Example"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<bool>(boost::any_cast<bool>(m["Required"]));
    }
  }


  virtual ~CreateDataAPIServiceRequestResponseParam() = default;
};
class CreateDataAPIServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> originSql{};
  shared_ptr<vector<CreateDataAPIServiceRequestRequestParam>> requestParam{};
  shared_ptr<string> desc{};
  shared_ptr<vector<CreateDataAPIServiceRequestResponseParam>> responseParam{};
  shared_ptr<string> templateSql{};
  shared_ptr<string> apiPath{};
  shared_ptr<string> iotInstanceId{};

  CreateDataAPIServiceRequest() {}

  explicit CreateDataAPIServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!displayName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("displayName is required.")));
    }
    if (!originSql) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("originSql is required.")));
    }
    if (!templateSql) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("templateSql is required.")));
    }
    if (!apiPath) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiPath is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (originSql) {
      res["OriginSql"] = boost::any(*originSql);
    }
    if (requestParam) {
      vector<boost::any> temp1;
      for(auto item1:*requestParam){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParam"] = boost::any(temp1);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (responseParam) {
      vector<boost::any> temp1;
      for(auto item1:*responseParam){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResponseParam"] = boost::any(temp1);
    }
    if (templateSql) {
      res["TemplateSql"] = boost::any(*templateSql);
    }
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("OriginSql") != m.end() && !m["OriginSql"].empty()) {
      originSql = make_shared<string>(boost::any_cast<string>(m["OriginSql"]));
    }
    if (m.find("RequestParam") != m.end() && !m["RequestParam"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParam"].type()) {
        vector<CreateDataAPIServiceRequestRequestParam> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParam"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataAPIServiceRequestRequestParam model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParam = make_shared<vector<CreateDataAPIServiceRequestRequestParam>>(expect1);
      }
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("ResponseParam") != m.end() && !m["ResponseParam"].empty()) {
      if (typeid(vector<boost::any>) == m["ResponseParam"].type()) {
        vector<CreateDataAPIServiceRequestResponseParam> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResponseParam"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataAPIServiceRequestResponseParam model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        responseParam = make_shared<vector<CreateDataAPIServiceRequestResponseParam>>(expect1);
      }
    }
    if (m.find("TemplateSql") != m.end() && !m["TemplateSql"].empty()) {
      templateSql = make_shared<string>(boost::any_cast<string>(m["TemplateSql"]));
    }
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~CreateDataAPIServiceRequest() = default;
};
class CreateDataAPIServiceResponseData : public Darabonba::Model {
public:
  shared_ptr<string> apiSrn{};
  shared_ptr<long> createTime{};
  shared_ptr<long> lastUpdateTime{};

  CreateDataAPIServiceResponseData() {}

  explicit CreateDataAPIServiceResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!apiSrn) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiSrn is required.")));
    }
    if (!createTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createTime is required.")));
    }
    if (!lastUpdateTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("lastUpdateTime is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiSrn) {
      res["ApiSrn"] = boost::any(*apiSrn);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (lastUpdateTime) {
      res["LastUpdateTime"] = boost::any(*lastUpdateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiSrn") != m.end() && !m["ApiSrn"].empty()) {
      apiSrn = make_shared<string>(boost::any_cast<string>(m["ApiSrn"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("LastUpdateTime") != m.end() && !m["LastUpdateTime"].empty()) {
      lastUpdateTime = make_shared<long>(boost::any_cast<long>(m["LastUpdateTime"]));
    }
  }


  virtual ~CreateDataAPIServiceResponseData() = default;
};
class CreateDataAPIServiceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<CreateDataAPIServiceResponseData> data{};

  CreateDataAPIServiceResponse() {}

  explicit CreateDataAPIServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateDataAPIServiceResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateDataAPIServiceResponseData>(model1);
      }
    }
  }


  virtual ~CreateDataAPIServiceResponse() = default;
};
class GetDataAPIServiceDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiSrn{};
  shared_ptr<string> iotInstanceId{};

  GetDataAPIServiceDetailRequest() {}

  explicit GetDataAPIServiceDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!apiSrn) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiSrn is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiSrn) {
      res["ApiSrn"] = boost::any(*apiSrn);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiSrn") != m.end() && !m["ApiSrn"].empty()) {
      apiSrn = make_shared<string>(boost::any_cast<string>(m["ApiSrn"]));
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~GetDataAPIServiceDetailRequest() = default;
};
class GetDataAPIServiceDetailResponseDataSqlTemplateDTORequestParamsRequestParams : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> desc{};
  shared_ptr<string> example{};
  shared_ptr<bool> required{};

  GetDataAPIServiceDetailResponseDataSqlTemplateDTORequestParamsRequestParams() {}

  explicit GetDataAPIServiceDetailResponseDataSqlTemplateDTORequestParamsRequestParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
    if (!desc) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("desc is required.")));
    }
    if (!example) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("example is required.")));
    }
    if (!required) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("required is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (example) {
      res["Example"] = boost::any(*example);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Example") != m.end() && !m["Example"].empty()) {
      example = make_shared<string>(boost::any_cast<string>(m["Example"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<bool>(boost::any_cast<bool>(m["Required"]));
    }
  }


  virtual ~GetDataAPIServiceDetailResponseDataSqlTemplateDTORequestParamsRequestParams() = default;
};
class GetDataAPIServiceDetailResponseDataSqlTemplateDTORequestParams : public Darabonba::Model {
public:
  shared_ptr<vector<GetDataAPIServiceDetailResponseDataSqlTemplateDTORequestParamsRequestParams>> requestParams{};

  GetDataAPIServiceDetailResponseDataSqlTemplateDTORequestParams() {}

  explicit GetDataAPIServiceDetailResponseDataSqlTemplateDTORequestParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestParams) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestParams is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParams) {
      vector<boost::any> temp1;
      for(auto item1:*requestParams){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParams"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParams") != m.end() && !m["RequestParams"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParams"].type()) {
        vector<GetDataAPIServiceDetailResponseDataSqlTemplateDTORequestParamsRequestParams> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParams"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataAPIServiceDetailResponseDataSqlTemplateDTORequestParamsRequestParams model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParams = make_shared<vector<GetDataAPIServiceDetailResponseDataSqlTemplateDTORequestParamsRequestParams>>(expect1);
      }
    }
  }


  virtual ~GetDataAPIServiceDetailResponseDataSqlTemplateDTORequestParams() = default;
};
class GetDataAPIServiceDetailResponseDataSqlTemplateDTOResponseParamsResponseParams : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> desc{};
  shared_ptr<string> example{};
  shared_ptr<bool> required{};

  GetDataAPIServiceDetailResponseDataSqlTemplateDTOResponseParamsResponseParams() {}

  explicit GetDataAPIServiceDetailResponseDataSqlTemplateDTOResponseParamsResponseParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
    if (!desc) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("desc is required.")));
    }
    if (!example) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("example is required.")));
    }
    if (!required) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("required is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (example) {
      res["Example"] = boost::any(*example);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Example") != m.end() && !m["Example"].empty()) {
      example = make_shared<string>(boost::any_cast<string>(m["Example"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<bool>(boost::any_cast<bool>(m["Required"]));
    }
  }


  virtual ~GetDataAPIServiceDetailResponseDataSqlTemplateDTOResponseParamsResponseParams() = default;
};
class GetDataAPIServiceDetailResponseDataSqlTemplateDTOResponseParams : public Darabonba::Model {
public:
  shared_ptr<vector<GetDataAPIServiceDetailResponseDataSqlTemplateDTOResponseParamsResponseParams>> responseParams{};

  GetDataAPIServiceDetailResponseDataSqlTemplateDTOResponseParams() {}

  explicit GetDataAPIServiceDetailResponseDataSqlTemplateDTOResponseParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!responseParams) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("responseParams is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (responseParams) {
      vector<boost::any> temp1;
      for(auto item1:*responseParams){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResponseParams"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResponseParams") != m.end() && !m["ResponseParams"].empty()) {
      if (typeid(vector<boost::any>) == m["ResponseParams"].type()) {
        vector<GetDataAPIServiceDetailResponseDataSqlTemplateDTOResponseParamsResponseParams> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResponseParams"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataAPIServiceDetailResponseDataSqlTemplateDTOResponseParamsResponseParams model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        responseParams = make_shared<vector<GetDataAPIServiceDetailResponseDataSqlTemplateDTOResponseParamsResponseParams>>(expect1);
      }
    }
  }


  virtual ~GetDataAPIServiceDetailResponseDataSqlTemplateDTOResponseParams() = default;
};
class GetDataAPIServiceDetailResponseDataSqlTemplateDTO : public Darabonba::Model {
public:
  shared_ptr<string> originSql{};
  shared_ptr<string> templateSql{};
  shared_ptr<GetDataAPIServiceDetailResponseDataSqlTemplateDTORequestParams> requestParams{};
  shared_ptr<GetDataAPIServiceDetailResponseDataSqlTemplateDTOResponseParams> responseParams{};

  GetDataAPIServiceDetailResponseDataSqlTemplateDTO() {}

  explicit GetDataAPIServiceDetailResponseDataSqlTemplateDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!originSql) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("originSql is required.")));
    }
    if (!templateSql) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("templateSql is required.")));
    }
    if (!requestParams) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestParams is required.")));
    }
    if (!responseParams) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("responseParams is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (originSql) {
      res["OriginSql"] = boost::any(*originSql);
    }
    if (templateSql) {
      res["TemplateSql"] = boost::any(*templateSql);
    }
    if (requestParams) {
      res["RequestParams"] = requestParams ? boost::any(requestParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (responseParams) {
      res["ResponseParams"] = responseParams ? boost::any(responseParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OriginSql") != m.end() && !m["OriginSql"].empty()) {
      originSql = make_shared<string>(boost::any_cast<string>(m["OriginSql"]));
    }
    if (m.find("TemplateSql") != m.end() && !m["TemplateSql"].empty()) {
      templateSql = make_shared<string>(boost::any_cast<string>(m["TemplateSql"]));
    }
    if (m.find("RequestParams") != m.end() && !m["RequestParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestParams"].type()) {
        GetDataAPIServiceDetailResponseDataSqlTemplateDTORequestParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestParams"]));
        requestParams = make_shared<GetDataAPIServiceDetailResponseDataSqlTemplateDTORequestParams>(model1);
      }
    }
    if (m.find("ResponseParams") != m.end() && !m["ResponseParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResponseParams"].type()) {
        GetDataAPIServiceDetailResponseDataSqlTemplateDTOResponseParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResponseParams"]));
        responseParams = make_shared<GetDataAPIServiceDetailResponseDataSqlTemplateDTOResponseParams>(model1);
      }
    }
  }


  virtual ~GetDataAPIServiceDetailResponseDataSqlTemplateDTO() = default;
};
class GetDataAPIServiceDetailResponseData : public Darabonba::Model {
public:
  shared_ptr<string> apiSrn{};
  shared_ptr<int> status{};
  shared_ptr<string> displayName{};
  shared_ptr<string> apiPath{};
  shared_ptr<long> createTime{};
  shared_ptr<long> lastUpdateTime{};
  shared_ptr<string> dateFormat{};
  shared_ptr<string> requestMethod{};
  shared_ptr<string> requestProtocol{};
  shared_ptr<string> description{};
  shared_ptr<GetDataAPIServiceDetailResponseDataSqlTemplateDTO> sqlTemplateDTO{};

  GetDataAPIServiceDetailResponseData() {}

  explicit GetDataAPIServiceDetailResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!apiSrn) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiSrn is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!displayName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("displayName is required.")));
    }
    if (!apiPath) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiPath is required.")));
    }
    if (!createTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createTime is required.")));
    }
    if (!lastUpdateTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("lastUpdateTime is required.")));
    }
    if (!dateFormat) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dateFormat is required.")));
    }
    if (!requestMethod) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestMethod is required.")));
    }
    if (!requestProtocol) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestProtocol is required.")));
    }
    if (!description) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("description is required.")));
    }
    if (!sqlTemplateDTO) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sqlTemplateDTO is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiSrn) {
      res["ApiSrn"] = boost::any(*apiSrn);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (lastUpdateTime) {
      res["LastUpdateTime"] = boost::any(*lastUpdateTime);
    }
    if (dateFormat) {
      res["DateFormat"] = boost::any(*dateFormat);
    }
    if (requestMethod) {
      res["RequestMethod"] = boost::any(*requestMethod);
    }
    if (requestProtocol) {
      res["RequestProtocol"] = boost::any(*requestProtocol);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (sqlTemplateDTO) {
      res["SqlTemplateDTO"] = sqlTemplateDTO ? boost::any(sqlTemplateDTO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiSrn") != m.end() && !m["ApiSrn"].empty()) {
      apiSrn = make_shared<string>(boost::any_cast<string>(m["ApiSrn"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<int>(boost::any_cast<int>(m["Status"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("LastUpdateTime") != m.end() && !m["LastUpdateTime"].empty()) {
      lastUpdateTime = make_shared<long>(boost::any_cast<long>(m["LastUpdateTime"]));
    }
    if (m.find("DateFormat") != m.end() && !m["DateFormat"].empty()) {
      dateFormat = make_shared<string>(boost::any_cast<string>(m["DateFormat"]));
    }
    if (m.find("RequestMethod") != m.end() && !m["RequestMethod"].empty()) {
      requestMethod = make_shared<string>(boost::any_cast<string>(m["RequestMethod"]));
    }
    if (m.find("RequestProtocol") != m.end() && !m["RequestProtocol"].empty()) {
      requestProtocol = make_shared<string>(boost::any_cast<string>(m["RequestProtocol"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SqlTemplateDTO") != m.end() && !m["SqlTemplateDTO"].empty()) {
      if (typeid(map<string, boost::any>) == m["SqlTemplateDTO"].type()) {
        GetDataAPIServiceDetailResponseDataSqlTemplateDTO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SqlTemplateDTO"]));
        sqlTemplateDTO = make_shared<GetDataAPIServiceDetailResponseDataSqlTemplateDTO>(model1);
      }
    }
  }


  virtual ~GetDataAPIServiceDetailResponseData() = default;
};
class GetDataAPIServiceDetailResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetDataAPIServiceDetailResponseData> data{};

  GetDataAPIServiceDetailResponse() {}

  explicit GetDataAPIServiceDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDataAPIServiceDetailResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDataAPIServiceDetailResponseData>(model1);
      }
    }
  }


  virtual ~GetDataAPIServiceDetailResponse() = default;
};
class InvokeDataAPIServiceRequestParam : public Darabonba::Model {
public:
  shared_ptr<string> paramType{};
  shared_ptr<vector<string>> listParamValue{};
  shared_ptr<string> listParamType{};
  shared_ptr<string> paramName{};
  shared_ptr<string> paramValue{};

  InvokeDataAPIServiceRequestParam() {}

  explicit InvokeDataAPIServiceRequestParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (paramType) {
      res["ParamType"] = boost::any(*paramType);
    }
    if (listParamValue) {
      res["ListParamValue"] = boost::any(*listParamValue);
    }
    if (listParamType) {
      res["ListParamType"] = boost::any(*listParamType);
    }
    if (paramName) {
      res["ParamName"] = boost::any(*paramName);
    }
    if (paramValue) {
      res["ParamValue"] = boost::any(*paramValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParamType") != m.end() && !m["ParamType"].empty()) {
      paramType = make_shared<string>(boost::any_cast<string>(m["ParamType"]));
    }
    if (m.find("ListParamValue") != m.end() && !m["ListParamValue"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ListParamValue"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ListParamValue"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      listParamValue = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ListParamType") != m.end() && !m["ListParamType"].empty()) {
      listParamType = make_shared<string>(boost::any_cast<string>(m["ListParamType"]));
    }
    if (m.find("ParamName") != m.end() && !m["ParamName"].empty()) {
      paramName = make_shared<string>(boost::any_cast<string>(m["ParamName"]));
    }
    if (m.find("ParamValue") != m.end() && !m["ParamValue"].empty()) {
      paramValue = make_shared<string>(boost::any_cast<string>(m["ParamValue"]));
    }
  }


  virtual ~InvokeDataAPIServiceRequestParam() = default;
};
class InvokeDataAPIServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiSrn{};
  shared_ptr<vector<InvokeDataAPIServiceRequestParam>> param{};
  shared_ptr<string> iotInstanceId{};

  InvokeDataAPIServiceRequest() {}

  explicit InvokeDataAPIServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!apiSrn) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiSrn is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiSrn) {
      res["ApiSrn"] = boost::any(*apiSrn);
    }
    if (param) {
      vector<boost::any> temp1;
      for(auto item1:*param){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Param"] = boost::any(temp1);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiSrn") != m.end() && !m["ApiSrn"].empty()) {
      apiSrn = make_shared<string>(boost::any_cast<string>(m["ApiSrn"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      if (typeid(vector<boost::any>) == m["Param"].type()) {
        vector<InvokeDataAPIServiceRequestParam> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Param"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InvokeDataAPIServiceRequestParam model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        param = make_shared<vector<InvokeDataAPIServiceRequestParam>>(expect1);
      }
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~InvokeDataAPIServiceRequest() = default;
};
class InvokeDataAPIServiceResponseDataFieldNameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fieldNameList{};

  InvokeDataAPIServiceResponseDataFieldNameList() {}

  explicit InvokeDataAPIServiceResponseDataFieldNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!fieldNameList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fieldNameList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldNameList) {
      res["FieldNameList"] = boost::any(*fieldNameList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldNameList") != m.end() && !m["FieldNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FieldNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FieldNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fieldNameList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~InvokeDataAPIServiceResponseDataFieldNameList() = default;
};
class InvokeDataAPIServiceResponseDataResultList : public Darabonba::Model {
public:
  shared_ptr<vector<map<string, boost::any>>> resultList{};

  InvokeDataAPIServiceResponseDataResultList() {}

  explicit InvokeDataAPIServiceResponseDataResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!resultList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("resultList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resultList) {
      res["ResultList"] = boost::any(*resultList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResultList") != m.end() && !m["ResultList"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["ResultList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResultList"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      resultList = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
  }


  virtual ~InvokeDataAPIServiceResponseDataResultList() = default;
};
class InvokeDataAPIServiceResponseData : public Darabonba::Model {
public:
  shared_ptr<int> pageNo{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> apiSrn{};
  shared_ptr<InvokeDataAPIServiceResponseDataFieldNameList> fieldNameList{};
  shared_ptr<InvokeDataAPIServiceResponseDataResultList> resultList{};

  InvokeDataAPIServiceResponseData() {}

  explicit InvokeDataAPIServiceResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageNo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNo is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!apiSrn) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("apiSrn is required.")));
    }
    if (!fieldNameList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fieldNameList is required.")));
    }
    if (!resultList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("resultList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (apiSrn) {
      res["ApiSrn"] = boost::any(*apiSrn);
    }
    if (fieldNameList) {
      res["FieldNameList"] = fieldNameList ? boost::any(fieldNameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultList) {
      res["ResultList"] = resultList ? boost::any(resultList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<int>(boost::any_cast<int>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ApiSrn") != m.end() && !m["ApiSrn"].empty()) {
      apiSrn = make_shared<string>(boost::any_cast<string>(m["ApiSrn"]));
    }
    if (m.find("FieldNameList") != m.end() && !m["FieldNameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["FieldNameList"].type()) {
        InvokeDataAPIServiceResponseDataFieldNameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FieldNameList"]));
        fieldNameList = make_shared<InvokeDataAPIServiceResponseDataFieldNameList>(model1);
      }
    }
    if (m.find("ResultList") != m.end() && !m["ResultList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultList"].type()) {
        InvokeDataAPIServiceResponseDataResultList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultList"]));
        resultList = make_shared<InvokeDataAPIServiceResponseDataResultList>(model1);
      }
    }
  }


  virtual ~InvokeDataAPIServiceResponseData() = default;
};
class InvokeDataAPIServiceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<InvokeDataAPIServiceResponseData> data{};

  InvokeDataAPIServiceResponse() {}

  explicit InvokeDataAPIServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        InvokeDataAPIServiceResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<InvokeDataAPIServiceResponseData>(model1);
      }
    }
  }


  virtual ~InvokeDataAPIServiceResponse() = default;
};
class UpdateEdgeInstanceChannelRequestConfigs : public Darabonba::Model {
public:
  shared_ptr<string> format{};
  shared_ptr<string> content{};
  shared_ptr<string> key{};

  UpdateEdgeInstanceChannelRequestConfigs() {}

  explicit UpdateEdgeInstanceChannelRequestConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!format) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("format is required.")));
    }
    if (!content) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("content is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~UpdateEdgeInstanceChannelRequestConfigs() = default;
};
class UpdateEdgeInstanceChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelName{};
  shared_ptr<vector<UpdateEdgeInstanceChannelRequestConfigs>> configs{};

  UpdateEdgeInstanceChannelRequest() {}

  explicit UpdateEdgeInstanceChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!driverId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverId is required.")));
    }
    if (!channelId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("channelId is required.")));
    }
    if (!channelName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("channelName is required.")));
    }
    if (!configs) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("configs is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (configs) {
      vector<boost::any> temp1;
      for(auto item1:*configs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Configs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("Configs") != m.end() && !m["Configs"].empty()) {
      if (typeid(vector<boost::any>) == m["Configs"].type()) {
        vector<UpdateEdgeInstanceChannelRequestConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Configs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateEdgeInstanceChannelRequestConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configs = make_shared<vector<UpdateEdgeInstanceChannelRequestConfigs>>(expect1);
      }
    }
  }


  virtual ~UpdateEdgeInstanceChannelRequest() = default;
};
class UpdateEdgeInstanceChannelResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateEdgeInstanceChannelResponse() {}

  explicit UpdateEdgeInstanceChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateEdgeInstanceChannelResponse() = default;
};
class QueryEdgeInstanceChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<string> channelName{};
  shared_ptr<int> currentPage{};
  shared_ptr<int> pageSize{};

  QueryEdgeInstanceChannelRequest() {}

  explicit QueryEdgeInstanceChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!driverId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverId is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
  }


  virtual ~QueryEdgeInstanceChannelRequest() = default;
};
class QueryEdgeInstanceChannelResponseDataChannelListChannelConfigListConfig : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<string> format{};
  shared_ptr<string> content{};
  shared_ptr<string> key{};

  QueryEdgeInstanceChannelResponseDataChannelListChannelConfigListConfig() {}

  explicit QueryEdgeInstanceChannelResponseDataChannelListChannelConfigListConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!configId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("configId is required.")));
    }
    if (!format) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("format is required.")));
    }
    if (!content) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("content is required.")));
    }
    if (!key) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("key is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~QueryEdgeInstanceChannelResponseDataChannelListChannelConfigListConfig() = default;
};
class QueryEdgeInstanceChannelResponseDataChannelListChannelConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEdgeInstanceChannelResponseDataChannelListChannelConfigListConfig>> config{};

  QueryEdgeInstanceChannelResponseDataChannelListChannelConfigList() {}

  explicit QueryEdgeInstanceChannelResponseDataChannelListChannelConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!config) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("config is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      vector<boost::any> temp1;
      for(auto item1:*config){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Config"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(vector<boost::any>) == m["Config"].type()) {
        vector<QueryEdgeInstanceChannelResponseDataChannelListChannelConfigListConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Config"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeInstanceChannelResponseDataChannelListChannelConfigListConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        config = make_shared<vector<QueryEdgeInstanceChannelResponseDataChannelListChannelConfigListConfig>>(expect1);
      }
    }
  }


  virtual ~QueryEdgeInstanceChannelResponseDataChannelListChannelConfigList() = default;
};
class QueryEdgeInstanceChannelResponseDataChannelListChannel : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> channelName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<QueryEdgeInstanceChannelResponseDataChannelListChannelConfigList> configList{};

  QueryEdgeInstanceChannelResponseDataChannelListChannel() {}

  explicit QueryEdgeInstanceChannelResponseDataChannelListChannel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!channelId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("channelId is required.")));
    }
    if (!channelName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("channelName is required.")));
    }
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!gmtModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModified is required.")));
    }
    if (!gmtCreateTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreateTimestamp is required.")));
    }
    if (!gmtModifiedTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModifiedTimestamp is required.")));
    }
    if (!configList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("configList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (configList) {
      res["ConfigList"] = configList ? boost::any(configList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("ConfigList") != m.end() && !m["ConfigList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigList"].type()) {
        QueryEdgeInstanceChannelResponseDataChannelListChannelConfigList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigList"]));
        configList = make_shared<QueryEdgeInstanceChannelResponseDataChannelListChannelConfigList>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceChannelResponseDataChannelListChannel() = default;
};
class QueryEdgeInstanceChannelResponseDataChannelList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEdgeInstanceChannelResponseDataChannelListChannel>> channel{};

  QueryEdgeInstanceChannelResponseDataChannelList() {}

  explicit QueryEdgeInstanceChannelResponseDataChannelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!channel) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("channel is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channel) {
      vector<boost::any> temp1;
      for(auto item1:*channel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Channel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      if (typeid(vector<boost::any>) == m["Channel"].type()) {
        vector<QueryEdgeInstanceChannelResponseDataChannelListChannel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Channel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeInstanceChannelResponseDataChannelListChannel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channel = make_shared<vector<QueryEdgeInstanceChannelResponseDataChannelListChannel>>(expect1);
      }
    }
  }


  virtual ~QueryEdgeInstanceChannelResponseDataChannelList() = default;
};
class QueryEdgeInstanceChannelResponseData : public Darabonba::Model {
public:
  shared_ptr<int> total{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> currentPage{};
  shared_ptr<QueryEdgeInstanceChannelResponseDataChannelList> channelList{};

  QueryEdgeInstanceChannelResponseData() {}

  explicit QueryEdgeInstanceChannelResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!channelList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("channelList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (channelList) {
      res["ChannelList"] = channelList ? boost::any(channelList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("ChannelList") != m.end() && !m["ChannelList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ChannelList"].type()) {
        QueryEdgeInstanceChannelResponseDataChannelList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ChannelList"]));
        channelList = make_shared<QueryEdgeInstanceChannelResponseDataChannelList>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceChannelResponseData() = default;
};
class QueryEdgeInstanceChannelResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryEdgeInstanceChannelResponseData> data{};

  QueryEdgeInstanceChannelResponse() {}

  explicit QueryEdgeInstanceChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEdgeInstanceChannelResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEdgeInstanceChannelResponseData>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceChannelResponse() = default;
};
class BatchUnbindDeviceFromEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> iotIds{};

  BatchUnbindDeviceFromEdgeInstanceRequest() {}

  explicit BatchUnbindDeviceFromEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!iotIds) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotIds is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotIds) {
      res["IotIds"] = boost::any(*iotIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotIds") != m.end() && !m["IotIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchUnbindDeviceFromEdgeInstanceRequest() = default;
};
class BatchUnbindDeviceFromEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  BatchUnbindDeviceFromEdgeInstanceResponse() {}

  explicit BatchUnbindDeviceFromEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~BatchUnbindDeviceFromEdgeInstanceResponse() = default;
};
class SetEdgeInstanceDriverConfigsRequestConfigs : public Darabonba::Model {
public:
  shared_ptr<string> format{};
  shared_ptr<string> content{};
  shared_ptr<string> key{};

  SetEdgeInstanceDriverConfigsRequestConfigs() {}

  explicit SetEdgeInstanceDriverConfigsRequestConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!format) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("format is required.")));
    }
    if (!content) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("content is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~SetEdgeInstanceDriverConfigsRequestConfigs() = default;
};
class SetEdgeInstanceDriverConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<vector<SetEdgeInstanceDriverConfigsRequestConfigs>> configs{};

  SetEdgeInstanceDriverConfigsRequest() {}

  explicit SetEdgeInstanceDriverConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!driverId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverId is required.")));
    }
    if (!configs) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("configs is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (configs) {
      vector<boost::any> temp1;
      for(auto item1:*configs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Configs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("Configs") != m.end() && !m["Configs"].empty()) {
      if (typeid(vector<boost::any>) == m["Configs"].type()) {
        vector<SetEdgeInstanceDriverConfigsRequestConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Configs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SetEdgeInstanceDriverConfigsRequestConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configs = make_shared<vector<SetEdgeInstanceDriverConfigsRequestConfigs>>(expect1);
      }
    }
  }


  virtual ~SetEdgeInstanceDriverConfigsRequest() = default;
};
class SetEdgeInstanceDriverConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  SetEdgeInstanceDriverConfigsResponse() {}

  explicit SetEdgeInstanceDriverConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~SetEdgeInstanceDriverConfigsResponse() = default;
};
class CreateEdgeInstanceChannelRequestConfigs : public Darabonba::Model {
public:
  shared_ptr<string> format{};
  shared_ptr<string> content{};
  shared_ptr<string> key{};

  CreateEdgeInstanceChannelRequestConfigs() {}

  explicit CreateEdgeInstanceChannelRequestConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!format) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("format is required.")));
    }
    if (!content) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("content is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~CreateEdgeInstanceChannelRequestConfigs() = default;
};
class CreateEdgeInstanceChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<string> channelName{};
  shared_ptr<vector<CreateEdgeInstanceChannelRequestConfigs>> configs{};

  CreateEdgeInstanceChannelRequest() {}

  explicit CreateEdgeInstanceChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!driverId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverId is required.")));
    }
    if (!channelName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("channelName is required.")));
    }
    if (!configs) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("configs is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (configs) {
      vector<boost::any> temp1;
      for(auto item1:*configs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Configs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("Configs") != m.end() && !m["Configs"].empty()) {
      if (typeid(vector<boost::any>) == m["Configs"].type()) {
        vector<CreateEdgeInstanceChannelRequestConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Configs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEdgeInstanceChannelRequestConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configs = make_shared<vector<CreateEdgeInstanceChannelRequestConfigs>>(expect1);
      }
    }
  }


  virtual ~CreateEdgeInstanceChannelRequest() = default;
};
class CreateEdgeInstanceChannelResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> data{};

  CreateEdgeInstanceChannelResponse() {}

  explicit CreateEdgeInstanceChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
  }


  virtual ~CreateEdgeInstanceChannelResponse() = default;
};
class BatchBindDeviceToEdgeInstanceWithDriverRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<vector<string>> iotIds{};

  BatchBindDeviceToEdgeInstanceWithDriverRequest() {}

  explicit BatchBindDeviceToEdgeInstanceWithDriverRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!driverId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverId is required.")));
    }
    if (!iotIds) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotIds is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (iotIds) {
      res["IotIds"] = boost::any(*iotIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("IotIds") != m.end() && !m["IotIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchBindDeviceToEdgeInstanceWithDriverRequest() = default;
};
class BatchBindDeviceToEdgeInstanceWithDriverResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  BatchBindDeviceToEdgeInstanceWithDriverResponse() {}

  explicit BatchBindDeviceToEdgeInstanceWithDriverResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~BatchBindDeviceToEdgeInstanceWithDriverResponse() = default;
};
class BatchGetEdgeInstanceChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> driverId{};
  shared_ptr<vector<string>> channelIds{};

  BatchGetEdgeInstanceChannelRequest() {}

  explicit BatchGetEdgeInstanceChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!driverId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverId is required.")));
    }
    if (!channelIds) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("channelIds is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (channelIds) {
      res["ChannelIds"] = boost::any(*channelIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("ChannelIds") != m.end() && !m["ChannelIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ChannelIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ChannelIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channelIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchGetEdgeInstanceChannelRequest() = default;
};
class BatchGetEdgeInstanceChannelResponseDataChannelConfigListConfig : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<string> format{};
  shared_ptr<string> content{};
  shared_ptr<string> key{};

  BatchGetEdgeInstanceChannelResponseDataChannelConfigListConfig() {}

  explicit BatchGetEdgeInstanceChannelResponseDataChannelConfigListConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!configId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("configId is required.")));
    }
    if (!format) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("format is required.")));
    }
    if (!content) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("content is required.")));
    }
    if (!key) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("key is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~BatchGetEdgeInstanceChannelResponseDataChannelConfigListConfig() = default;
};
class BatchGetEdgeInstanceChannelResponseDataChannelConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<BatchGetEdgeInstanceChannelResponseDataChannelConfigListConfig>> config{};

  BatchGetEdgeInstanceChannelResponseDataChannelConfigList() {}

  explicit BatchGetEdgeInstanceChannelResponseDataChannelConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!config) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("config is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      vector<boost::any> temp1;
      for(auto item1:*config){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Config"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(vector<boost::any>) == m["Config"].type()) {
        vector<BatchGetEdgeInstanceChannelResponseDataChannelConfigListConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Config"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetEdgeInstanceChannelResponseDataChannelConfigListConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        config = make_shared<vector<BatchGetEdgeInstanceChannelResponseDataChannelConfigListConfig>>(expect1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceChannelResponseDataChannelConfigList() = default;
};
class BatchGetEdgeInstanceChannelResponseDataChannel : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> channelName{};
  shared_ptr<BatchGetEdgeInstanceChannelResponseDataChannelConfigList> configList{};

  BatchGetEdgeInstanceChannelResponseDataChannel() {}

  explicit BatchGetEdgeInstanceChannelResponseDataChannel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!channelId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("channelId is required.")));
    }
    if (!channelName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("channelName is required.")));
    }
    if (!configList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("configList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (configList) {
      res["ConfigList"] = configList ? boost::any(configList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ConfigList") != m.end() && !m["ConfigList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigList"].type()) {
        BatchGetEdgeInstanceChannelResponseDataChannelConfigList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigList"]));
        configList = make_shared<BatchGetEdgeInstanceChannelResponseDataChannelConfigList>(model1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceChannelResponseDataChannel() = default;
};
class BatchGetEdgeInstanceChannelResponseData : public Darabonba::Model {
public:
  shared_ptr<vector<BatchGetEdgeInstanceChannelResponseDataChannel>> channel{};

  BatchGetEdgeInstanceChannelResponseData() {}

  explicit BatchGetEdgeInstanceChannelResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!channel) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("channel is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channel) {
      vector<boost::any> temp1;
      for(auto item1:*channel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Channel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      if (typeid(vector<boost::any>) == m["Channel"].type()) {
        vector<BatchGetEdgeInstanceChannelResponseDataChannel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Channel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetEdgeInstanceChannelResponseDataChannel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channel = make_shared<vector<BatchGetEdgeInstanceChannelResponseDataChannel>>(expect1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceChannelResponseData() = default;
};
class BatchGetEdgeInstanceChannelResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<BatchGetEdgeInstanceChannelResponseData> data{};

  BatchGetEdgeInstanceChannelResponse() {}

  explicit BatchGetEdgeInstanceChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BatchGetEdgeInstanceChannelResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BatchGetEdgeInstanceChannelResponseData>(model1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceChannelResponse() = default;
};
class BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs : public Darabonba::Model {
public:
  shared_ptr<string> iotId{};
  shared_ptr<string> content{};

  BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs() {}

  explicit BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!iotId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotId is required.")));
    }
    if (!content) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("content is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs() = default;
};
class BatchSetEdgeInstanceDeviceConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs>> deviceConfigs{};

  BatchSetEdgeInstanceDeviceConfigRequest() {}

  explicit BatchSetEdgeInstanceDeviceConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!deviceConfigs) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceConfigs is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (deviceConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*deviceConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceConfigs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DeviceConfigs") != m.end() && !m["DeviceConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceConfigs"].type()) {
        vector<BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceConfigs = make_shared<vector<BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs>>(expect1);
      }
    }
  }


  virtual ~BatchSetEdgeInstanceDeviceConfigRequest() = default;
};
class BatchSetEdgeInstanceDeviceConfigResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  BatchSetEdgeInstanceDeviceConfigResponse() {}

  explicit BatchSetEdgeInstanceDeviceConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~BatchSetEdgeInstanceDeviceConfigResponse() = default;
};
class BatchClearEdgeInstanceDeviceConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> iotIds{};

  BatchClearEdgeInstanceDeviceConfigRequest() {}

  explicit BatchClearEdgeInstanceDeviceConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!iotIds) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotIds is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotIds) {
      res["IotIds"] = boost::any(*iotIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotIds") != m.end() && !m["IotIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchClearEdgeInstanceDeviceConfigRequest() = default;
};
class BatchClearEdgeInstanceDeviceConfigResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  BatchClearEdgeInstanceDeviceConfigResponse() {}

  explicit BatchClearEdgeInstanceDeviceConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~BatchClearEdgeInstanceDeviceConfigResponse() = default;
};
class BatchGetEdgeInstanceDeviceConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> iotIds{};

  BatchGetEdgeInstanceDeviceConfigRequest() {}

  explicit BatchGetEdgeInstanceDeviceConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!iotIds) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotIds is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (iotIds) {
      res["IotIds"] = boost::any(*iotIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IotIds") != m.end() && !m["IotIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceConfigRequest() = default;
};
class BatchGetEdgeInstanceDeviceConfigResponseDeviceConfigListConfig : public Darabonba::Model {
public:
  shared_ptr<string> format{};
  shared_ptr<string> content{};

  BatchGetEdgeInstanceDeviceConfigResponseDeviceConfigListConfig() {}

  explicit BatchGetEdgeInstanceDeviceConfigResponseDeviceConfigListConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!format) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("format is required.")));
    }
    if (!content) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("content is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceConfigResponseDeviceConfigListConfig() = default;
};
class BatchGetEdgeInstanceDeviceConfigResponseDeviceConfigList : public Darabonba::Model {
public:
  shared_ptr<string> iotId{};
  shared_ptr<BatchGetEdgeInstanceDeviceConfigResponseDeviceConfigListConfig> config{};

  BatchGetEdgeInstanceDeviceConfigResponseDeviceConfigList() {}

  explicit BatchGetEdgeInstanceDeviceConfigResponseDeviceConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!iotId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotId is required.")));
    }
    if (!config) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("config is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (config) {
      res["Config"] = config ? boost::any(config->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(map<string, boost::any>) == m["Config"].type()) {
        BatchGetEdgeInstanceDeviceConfigResponseDeviceConfigListConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Config"]));
        config = make_shared<BatchGetEdgeInstanceDeviceConfigResponseDeviceConfigListConfig>(model1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceConfigResponseDeviceConfigList() = default;
};
class BatchGetEdgeInstanceDeviceConfigResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<BatchGetEdgeInstanceDeviceConfigResponseDeviceConfigList>> deviceConfigList{};

  BatchGetEdgeInstanceDeviceConfigResponse() {}

  explicit BatchGetEdgeInstanceDeviceConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!deviceConfigList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceConfigList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (deviceConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*deviceConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceConfigList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("DeviceConfigList") != m.end() && !m["DeviceConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceConfigList"].type()) {
        vector<BatchGetEdgeInstanceDeviceConfigResponseDeviceConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetEdgeInstanceDeviceConfigResponseDeviceConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceConfigList = make_shared<vector<BatchGetEdgeInstanceDeviceConfigResponseDeviceConfigList>>(expect1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceDeviceConfigResponse() = default;
};
class BatchGetEdgeInstanceDriverConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> driverIds{};

  BatchGetEdgeInstanceDriverConfigsRequest() {}

  explicit BatchGetEdgeInstanceDriverConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!driverIds) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverIds is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (driverIds) {
      res["DriverIds"] = boost::any(*driverIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DriverIds") != m.end() && !m["DriverIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DriverIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DriverIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      driverIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchGetEdgeInstanceDriverConfigsRequest() = default;
};
class BatchGetEdgeInstanceDriverConfigsResponseDriverConfigListConfigList : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<string> format{};
  shared_ptr<string> content{};
  shared_ptr<string> key{};

  BatchGetEdgeInstanceDriverConfigsResponseDriverConfigListConfigList() {}

  explicit BatchGetEdgeInstanceDriverConfigsResponseDriverConfigListConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!configId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("configId is required.")));
    }
    if (!format) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("format is required.")));
    }
    if (!content) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("content is required.")));
    }
    if (!key) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("key is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~BatchGetEdgeInstanceDriverConfigsResponseDriverConfigListConfigList() = default;
};
class BatchGetEdgeInstanceDriverConfigsResponseDriverConfigList : public Darabonba::Model {
public:
  shared_ptr<string> driverId{};
  shared_ptr<vector<BatchGetEdgeInstanceDriverConfigsResponseDriverConfigListConfigList>> configList{};

  BatchGetEdgeInstanceDriverConfigsResponseDriverConfigList() {}

  explicit BatchGetEdgeInstanceDriverConfigsResponseDriverConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!driverId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverId is required.")));
    }
    if (!configList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("configList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (configList) {
      vector<boost::any> temp1;
      for(auto item1:*configList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("ConfigList") != m.end() && !m["ConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigList"].type()) {
        vector<BatchGetEdgeInstanceDriverConfigsResponseDriverConfigListConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetEdgeInstanceDriverConfigsResponseDriverConfigListConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configList = make_shared<vector<BatchGetEdgeInstanceDriverConfigsResponseDriverConfigListConfigList>>(expect1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceDriverConfigsResponseDriverConfigList() = default;
};
class BatchGetEdgeInstanceDriverConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<BatchGetEdgeInstanceDriverConfigsResponseDriverConfigList>> driverConfigList{};

  BatchGetEdgeInstanceDriverConfigsResponse() {}

  explicit BatchGetEdgeInstanceDriverConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!driverConfigList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverConfigList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (driverConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*driverConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DriverConfigList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("DriverConfigList") != m.end() && !m["DriverConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["DriverConfigList"].type()) {
        vector<BatchGetEdgeInstanceDriverConfigsResponseDriverConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DriverConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetEdgeInstanceDriverConfigsResponseDriverConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        driverConfigList = make_shared<vector<BatchGetEdgeInstanceDriverConfigsResponseDriverConfigList>>(expect1);
      }
    }
  }


  virtual ~BatchGetEdgeInstanceDriverConfigsResponse() = default;
};
class ClearEdgeInstanceDriverConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> driverId{};

  ClearEdgeInstanceDriverConfigsRequest() {}

  explicit ClearEdgeInstanceDriverConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!driverId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
  }


  virtual ~ClearEdgeInstanceDriverConfigsRequest() = default;
};
class ClearEdgeInstanceDriverConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  ClearEdgeInstanceDriverConfigsResponse() {}

  explicit ClearEdgeInstanceDriverConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~ClearEdgeInstanceDriverConfigsResponse() = default;
};
class CreateLoRaNodesTaskRequestDeviceInfo : public Darabonba::Model {
public:
  shared_ptr<string> devEui{};
  shared_ptr<string> pinCode{};

  CreateLoRaNodesTaskRequestDeviceInfo() {}

  explicit CreateLoRaNodesTaskRequestDeviceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (devEui) {
      res["DevEui"] = boost::any(*devEui);
    }
    if (pinCode) {
      res["PinCode"] = boost::any(*pinCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DevEui") != m.end() && !m["DevEui"].empty()) {
      devEui = make_shared<string>(boost::any_cast<string>(m["DevEui"]));
    }
    if (m.find("PinCode") != m.end() && !m["PinCode"].empty()) {
      pinCode = make_shared<string>(boost::any_cast<string>(m["PinCode"]));
    }
  }


  virtual ~CreateLoRaNodesTaskRequestDeviceInfo() = default;
};
class CreateLoRaNodesTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<vector<CreateLoRaNodesTaskRequestDeviceInfo>> deviceInfo{};

  CreateLoRaNodesTaskRequest() {}

  explicit CreateLoRaNodesTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*deviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceInfo") != m.end() && !m["DeviceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceInfo"].type()) {
        vector<CreateLoRaNodesTaskRequestDeviceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateLoRaNodesTaskRequestDeviceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceInfo = make_shared<vector<CreateLoRaNodesTaskRequestDeviceInfo>>(expect1);
      }
    }
  }


  virtual ~CreateLoRaNodesTaskRequest() = default;
};
class CreateLoRaNodesTaskResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> taskId{};

  CreateLoRaNodesTaskResponse() {}

  explicit CreateLoRaNodesTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!taskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateLoRaNodesTaskResponse() = default;
};
class GetLoraNodesTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> taskId{};

  GetLoraNodesTaskRequest() {}

  explicit GetLoraNodesTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!taskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetLoraNodesTaskRequest() = default;
};
class GetLoraNodesTaskResponseSuccessDevEuis : public Darabonba::Model {
public:
  shared_ptr<vector<string>> successDevEui{};

  GetLoraNodesTaskResponseSuccessDevEuis() {}

  explicit GetLoraNodesTaskResponseSuccessDevEuis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!successDevEui) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("successDevEui is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (successDevEui) {
      res["SuccessDevEui"] = boost::any(*successDevEui);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SuccessDevEui") != m.end() && !m["SuccessDevEui"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SuccessDevEui"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SuccessDevEui"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      successDevEui = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetLoraNodesTaskResponseSuccessDevEuis() = default;
};
class GetLoraNodesTaskResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskState{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> successCount{};
  shared_ptr<GetLoraNodesTaskResponseSuccessDevEuis> successDevEuis{};

  GetLoraNodesTaskResponse() {}

  explicit GetLoraNodesTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!taskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskId is required.")));
    }
    if (!taskState) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskState is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!successCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("successCount is required.")));
    }
    if (!successDevEuis) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("successDevEuis is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskState) {
      res["TaskState"] = boost::any(*taskState);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    if (successDevEuis) {
      res["SuccessDevEuis"] = successDevEuis ? boost::any(successDevEuis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskState") != m.end() && !m["TaskState"].empty()) {
      taskState = make_shared<string>(boost::any_cast<string>(m["TaskState"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
    if (m.find("SuccessDevEuis") != m.end() && !m["SuccessDevEuis"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuccessDevEuis"].type()) {
        GetLoraNodesTaskResponseSuccessDevEuis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SuccessDevEuis"]));
        successDevEuis = make_shared<GetLoraNodesTaskResponseSuccessDevEuis>(model1);
      }
    }
  }


  virtual ~GetLoraNodesTaskResponse() = default;
};
class QueryLoRaJoinPermissionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};

  QueryLoRaJoinPermissionsRequest() {}

  explicit QueryLoRaJoinPermissionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
  }


  virtual ~QueryLoRaJoinPermissionsRequest() = default;
};
class QueryLoRaJoinPermissionsResponseJoinPermissionsJoinPermission : public Darabonba::Model {
public:
  shared_ptr<string> joinPermissionId{};
  shared_ptr<string> joinPermissionName{};
  shared_ptr<string> joinPermissionType{};
  shared_ptr<string> ownerAliyunPk{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> classMode{};

  QueryLoRaJoinPermissionsResponseJoinPermissionsJoinPermission() {}

  explicit QueryLoRaJoinPermissionsResponseJoinPermissionsJoinPermission(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!joinPermissionId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("joinPermissionId is required.")));
    }
    if (!joinPermissionName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("joinPermissionName is required.")));
    }
    if (!joinPermissionType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("joinPermissionType is required.")));
    }
    if (!ownerAliyunPk) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ownerAliyunPk is required.")));
    }
    if (!enabled) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("enabled is required.")));
    }
    if (!classMode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("classMode is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (joinPermissionId) {
      res["JoinPermissionId"] = boost::any(*joinPermissionId);
    }
    if (joinPermissionName) {
      res["JoinPermissionName"] = boost::any(*joinPermissionName);
    }
    if (joinPermissionType) {
      res["JoinPermissionType"] = boost::any(*joinPermissionType);
    }
    if (ownerAliyunPk) {
      res["OwnerAliyunPk"] = boost::any(*ownerAliyunPk);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (classMode) {
      res["ClassMode"] = boost::any(*classMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JoinPermissionId") != m.end() && !m["JoinPermissionId"].empty()) {
      joinPermissionId = make_shared<string>(boost::any_cast<string>(m["JoinPermissionId"]));
    }
    if (m.find("JoinPermissionName") != m.end() && !m["JoinPermissionName"].empty()) {
      joinPermissionName = make_shared<string>(boost::any_cast<string>(m["JoinPermissionName"]));
    }
    if (m.find("JoinPermissionType") != m.end() && !m["JoinPermissionType"].empty()) {
      joinPermissionType = make_shared<string>(boost::any_cast<string>(m["JoinPermissionType"]));
    }
    if (m.find("OwnerAliyunPk") != m.end() && !m["OwnerAliyunPk"].empty()) {
      ownerAliyunPk = make_shared<string>(boost::any_cast<string>(m["OwnerAliyunPk"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("ClassMode") != m.end() && !m["ClassMode"].empty()) {
      classMode = make_shared<string>(boost::any_cast<string>(m["ClassMode"]));
    }
  }


  virtual ~QueryLoRaJoinPermissionsResponseJoinPermissionsJoinPermission() = default;
};
class QueryLoRaJoinPermissionsResponseJoinPermissions : public Darabonba::Model {
public:
  shared_ptr<vector<QueryLoRaJoinPermissionsResponseJoinPermissionsJoinPermission>> joinPermission{};

  QueryLoRaJoinPermissionsResponseJoinPermissions() {}

  explicit QueryLoRaJoinPermissionsResponseJoinPermissions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!joinPermission) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("joinPermission is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (joinPermission) {
      vector<boost::any> temp1;
      for(auto item1:*joinPermission){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JoinPermission"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JoinPermission") != m.end() && !m["JoinPermission"].empty()) {
      if (typeid(vector<boost::any>) == m["JoinPermission"].type()) {
        vector<QueryLoRaJoinPermissionsResponseJoinPermissionsJoinPermission> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JoinPermission"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryLoRaJoinPermissionsResponseJoinPermissionsJoinPermission model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        joinPermission = make_shared<vector<QueryLoRaJoinPermissionsResponseJoinPermissionsJoinPermission>>(expect1);
      }
    }
  }


  virtual ~QueryLoRaJoinPermissionsResponseJoinPermissions() = default;
};
class QueryLoRaJoinPermissionsResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> productKey{};
  shared_ptr<QueryLoRaJoinPermissionsResponseJoinPermissions> joinPermissions{};

  QueryLoRaJoinPermissionsResponse() {}

  explicit QueryLoRaJoinPermissionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!joinPermissions) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("joinPermissions is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (joinPermissions) {
      res["JoinPermissions"] = joinPermissions ? boost::any(joinPermissions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("JoinPermissions") != m.end() && !m["JoinPermissions"].empty()) {
      if (typeid(map<string, boost::any>) == m["JoinPermissions"].type()) {
        QueryLoRaJoinPermissionsResponseJoinPermissions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JoinPermissions"]));
        joinPermissions = make_shared<QueryLoRaJoinPermissionsResponseJoinPermissions>(model1);
      }
    }
  }


  virtual ~QueryLoRaJoinPermissionsResponse() = default;
};
class QueryEdgeInstanceDriverRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<int> currentPage{};
  shared_ptr<int> pageSize{};

  QueryEdgeInstanceDriverRequest() {}

  explicit QueryEdgeInstanceDriverRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
  }


  virtual ~QueryEdgeInstanceDriverRequest() = default;
};
class QueryEdgeInstanceDriverResponseDataDriverList : public Darabonba::Model {
public:
  shared_ptr<string> driverId{};
  shared_ptr<string> driverVersion{};
  shared_ptr<string> orderId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};

  QueryEdgeInstanceDriverResponseDataDriverList() {}

  explicit QueryEdgeInstanceDriverResponseDataDriverList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!driverId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverId is required.")));
    }
    if (!driverVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverVersion is required.")));
    }
    if (!orderId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("orderId is required.")));
    }
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!gmtModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModified is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    if (driverVersion) {
      res["DriverVersion"] = boost::any(*driverVersion);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
    if (m.find("DriverVersion") != m.end() && !m["DriverVersion"].empty()) {
      driverVersion = make_shared<string>(boost::any_cast<string>(m["DriverVersion"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
  }


  virtual ~QueryEdgeInstanceDriverResponseDataDriverList() = default;
};
class QueryEdgeInstanceDriverResponseData : public Darabonba::Model {
public:
  shared_ptr<int> total{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> currentPage{};
  shared_ptr<vector<QueryEdgeInstanceDriverResponseDataDriverList>> driverList{};

  QueryEdgeInstanceDriverResponseData() {}

  explicit QueryEdgeInstanceDriverResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!driverList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (driverList) {
      vector<boost::any> temp1;
      for(auto item1:*driverList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DriverList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("DriverList") != m.end() && !m["DriverList"].empty()) {
      if (typeid(vector<boost::any>) == m["DriverList"].type()) {
        vector<QueryEdgeInstanceDriverResponseDataDriverList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DriverList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeInstanceDriverResponseDataDriverList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        driverList = make_shared<vector<QueryEdgeInstanceDriverResponseDataDriverList>>(expect1);
      }
    }
  }


  virtual ~QueryEdgeInstanceDriverResponseData() = default;
};
class QueryEdgeInstanceDriverResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryEdgeInstanceDriverResponseData> data{};

  QueryEdgeInstanceDriverResponse() {}

  explicit QueryEdgeInstanceDriverResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEdgeInstanceDriverResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEdgeInstanceDriverResponseData>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceDriverResponse() = default;
};
class BatchUpdateDeviceNicknameRequestDeviceNicknameInfo : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> nickname{};
  shared_ptr<string> iotId{};

  BatchUpdateDeviceNicknameRequestDeviceNicknameInfo() {}

  explicit BatchUpdateDeviceNicknameRequestDeviceNicknameInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~BatchUpdateDeviceNicknameRequestDeviceNicknameInfo() = default;
};
class BatchUpdateDeviceNicknameRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<BatchUpdateDeviceNicknameRequestDeviceNicknameInfo>> deviceNicknameInfo{};

  BatchUpdateDeviceNicknameRequest() {}

  explicit BatchUpdateDeviceNicknameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!deviceNicknameInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceNicknameInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (deviceNicknameInfo) {
      vector<boost::any> temp1;
      for(auto item1:*deviceNicknameInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceNicknameInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("DeviceNicknameInfo") != m.end() && !m["DeviceNicknameInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceNicknameInfo"].type()) {
        vector<BatchUpdateDeviceNicknameRequestDeviceNicknameInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceNicknameInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchUpdateDeviceNicknameRequestDeviceNicknameInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceNicknameInfo = make_shared<vector<BatchUpdateDeviceNicknameRequestDeviceNicknameInfo>>(expect1);
      }
    }
  }


  virtual ~BatchUpdateDeviceNicknameRequest() = default;
};
class BatchUpdateDeviceNicknameResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  BatchUpdateDeviceNicknameResponse() {}

  explicit BatchUpdateDeviceNicknameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~BatchUpdateDeviceNicknameResponse() = default;
};
class QueryDeviceFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> fileId{};

  QueryDeviceFileRequest() {}

  explicit QueryDeviceFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!fileId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
  }


  virtual ~QueryDeviceFileRequest() = default;
};
class QueryDeviceFileResponseData : public Darabonba::Model {
public:
  shared_ptr<string> fileId{};
  shared_ptr<string> name{};
  shared_ptr<string> size{};
  shared_ptr<string> utcCreatedOn{};
  shared_ptr<string> downloadUrl{};

  QueryDeviceFileResponseData() {}

  explicit QueryDeviceFileResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!fileId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileId is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!size) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("size is required.")));
    }
    if (!utcCreatedOn) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcCreatedOn is required.")));
    }
    if (!downloadUrl) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("downloadUrl is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (utcCreatedOn) {
      res["UtcCreatedOn"] = boost::any(*utcCreatedOn);
    }
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("UtcCreatedOn") != m.end() && !m["UtcCreatedOn"].empty()) {
      utcCreatedOn = make_shared<string>(boost::any_cast<string>(m["UtcCreatedOn"]));
    }
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
  }


  virtual ~QueryDeviceFileResponseData() = default;
};
class QueryDeviceFileResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceFileResponseData> data{};

  QueryDeviceFileResponse() {}

  explicit QueryDeviceFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceFileResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceFileResponseData>(model1);
      }
    }
  }


  virtual ~QueryDeviceFileResponse() = default;
};
class QueryDeviceFileListRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<int> currentPage{};

  QueryDeviceFileListRequest() {}

  explicit QueryDeviceFileListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
  }


  virtual ~QueryDeviceFileListRequest() = default;
};
class QueryDeviceFileListResponseDataFileSummary : public Darabonba::Model {
public:
  shared_ptr<string> fileId{};
  shared_ptr<string> name{};
  shared_ptr<string> size{};
  shared_ptr<string> utcCreatedOn{};

  QueryDeviceFileListResponseDataFileSummary() {}

  explicit QueryDeviceFileListResponseDataFileSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!fileId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileId is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!size) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("size is required.")));
    }
    if (!utcCreatedOn) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcCreatedOn is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (utcCreatedOn) {
      res["UtcCreatedOn"] = boost::any(*utcCreatedOn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("UtcCreatedOn") != m.end() && !m["UtcCreatedOn"].empty()) {
      utcCreatedOn = make_shared<string>(boost::any_cast<string>(m["UtcCreatedOn"]));
    }
  }


  virtual ~QueryDeviceFileListResponseDataFileSummary() = default;
};
class QueryDeviceFileListResponseData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceFileListResponseDataFileSummary>> fileSummary{};

  QueryDeviceFileListResponseData() {}

  explicit QueryDeviceFileListResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!fileSummary) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileSummary is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileSummary) {
      vector<boost::any> temp1;
      for(auto item1:*fileSummary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileSummary"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileSummary") != m.end() && !m["FileSummary"].empty()) {
      if (typeid(vector<boost::any>) == m["FileSummary"].type()) {
        vector<QueryDeviceFileListResponseDataFileSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileSummary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceFileListResponseDataFileSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileSummary = make_shared<vector<QueryDeviceFileListResponseDataFileSummary>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceFileListResponseData() = default;
};
class QueryDeviceFileListResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> currentPage{};
  shared_ptr<int> pageCount{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> total{};
  shared_ptr<QueryDeviceFileListResponseData> data{};

  QueryDeviceFileListResponse() {}

  explicit QueryDeviceFileListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!pageCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageCount is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<int>(boost::any_cast<int>(m["PageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceFileListResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceFileListResponseData>(model1);
      }
    }
  }


  virtual ~QueryDeviceFileListResponse() = default;
};
class DeleteDeviceFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> fileId{};

  DeleteDeviceFileRequest() {}

  explicit DeleteDeviceFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!fileId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("fileId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
  }


  virtual ~DeleteDeviceFileRequest() = default;
};
class DeleteDeviceFileResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteDeviceFileResponse() {}

  explicit DeleteDeviceFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteDeviceFileResponse() = default;
};
class GetNodesAddingTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> taskId{};

  GetNodesAddingTaskRequest() {}

  explicit GetNodesAddingTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!taskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetNodesAddingTaskRequest() = default;
};
class GetNodesAddingTaskResponseSuccessDevEuis : public Darabonba::Model {
public:
  shared_ptr<vector<string>> successDevEui{};

  GetNodesAddingTaskResponseSuccessDevEuis() {}

  explicit GetNodesAddingTaskResponseSuccessDevEuis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!successDevEui) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("successDevEui is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (successDevEui) {
      res["SuccessDevEui"] = boost::any(*successDevEui);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SuccessDevEui") != m.end() && !m["SuccessDevEui"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SuccessDevEui"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SuccessDevEui"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      successDevEui = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetNodesAddingTaskResponseSuccessDevEuis() = default;
};
class GetNodesAddingTaskResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskState{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> successCount{};
  shared_ptr<GetNodesAddingTaskResponseSuccessDevEuis> successDevEuis{};

  GetNodesAddingTaskResponse() {}

  explicit GetNodesAddingTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!taskId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskId is required.")));
    }
    if (!taskState) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("taskState is required.")));
    }
    if (!totalCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("totalCount is required.")));
    }
    if (!successCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("successCount is required.")));
    }
    if (!successDevEuis) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("successDevEuis is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskState) {
      res["TaskState"] = boost::any(*taskState);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    if (successDevEuis) {
      res["SuccessDevEuis"] = successDevEuis ? boost::any(successDevEuis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskState") != m.end() && !m["TaskState"].empty()) {
      taskState = make_shared<string>(boost::any_cast<string>(m["TaskState"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
    if (m.find("SuccessDevEuis") != m.end() && !m["SuccessDevEuis"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuccessDevEuis"].type()) {
        GetNodesAddingTaskResponseSuccessDevEuis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SuccessDevEuis"]));
        successDevEuis = make_shared<GetNodesAddingTaskResponseSuccessDevEuis>(model1);
      }
    }
  }


  virtual ~GetNodesAddingTaskResponse() = default;
};
class SetDeviceDesiredPropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> iotId{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> productKey{};
  shared_ptr<string> items{};
  shared_ptr<string> versions{};

  SetDeviceDesiredPropertyRequest() {}

  explicit SetDeviceDesiredPropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!items) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("items is required.")));
    }
    if (!versions) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("versions is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (items) {
      res["Items"] = boost::any(*items);
    }
    if (versions) {
      res["Versions"] = boost::any(*versions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      items = make_shared<string>(boost::any_cast<string>(m["Items"]));
    }
    if (m.find("Versions") != m.end() && !m["Versions"].empty()) {
      versions = make_shared<string>(boost::any_cast<string>(m["Versions"]));
    }
  }


  virtual ~SetDeviceDesiredPropertyRequest() = default;
};
class SetDeviceDesiredPropertyResponseData : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};
  shared_ptr<string> versions{};

  SetDeviceDesiredPropertyResponseData() {}

  explicit SetDeviceDesiredPropertyResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!messageId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("messageId is required.")));
    }
    if (!versions) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("versions is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (versions) {
      res["Versions"] = boost::any(*versions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("Versions") != m.end() && !m["Versions"].empty()) {
      versions = make_shared<string>(boost::any_cast<string>(m["Versions"]));
    }
  }


  virtual ~SetDeviceDesiredPropertyResponseData() = default;
};
class SetDeviceDesiredPropertyResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<SetDeviceDesiredPropertyResponseData> data{};

  SetDeviceDesiredPropertyResponse() {}

  explicit SetDeviceDesiredPropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SetDeviceDesiredPropertyResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SetDeviceDesiredPropertyResponseData>(model1);
      }
    }
  }


  virtual ~SetDeviceDesiredPropertyResponse() = default;
};
class QueryDeviceDesiredPropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<vector<string>> identifier{};
  shared_ptr<string> iotId{};
  shared_ptr<string> functionBlockId{};

  QueryDeviceDesiredPropertyRequest() {}

  explicit QueryDeviceDesiredPropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Identifier"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Identifier"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      identifier = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
  }


  virtual ~QueryDeviceDesiredPropertyRequest() = default;
};
class QueryDeviceDesiredPropertyResponseDataListDesiredPropertyInfo : public Darabonba::Model {
public:
  shared_ptr<string> unit{};
  shared_ptr<string> identifier{};
  shared_ptr<string> dataType{};
  shared_ptr<string> time{};
  shared_ptr<string> value{};
  shared_ptr<string> name{};
  shared_ptr<long> version{};

  QueryDeviceDesiredPropertyResponseDataListDesiredPropertyInfo() {}

  explicit QueryDeviceDesiredPropertyResponseDataListDesiredPropertyInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!unit) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("unit is required.")));
    }
    if (!identifier) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("identifier is required.")));
    }
    if (!dataType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataType is required.")));
    }
    if (!time) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("time is required.")));
    }
    if (!value) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("value is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!version) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("version is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~QueryDeviceDesiredPropertyResponseDataListDesiredPropertyInfo() = default;
};
class QueryDeviceDesiredPropertyResponseDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceDesiredPropertyResponseDataListDesiredPropertyInfo>> desiredPropertyInfo{};

  QueryDeviceDesiredPropertyResponseDataList() {}

  explicit QueryDeviceDesiredPropertyResponseDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!desiredPropertyInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("desiredPropertyInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desiredPropertyInfo) {
      vector<boost::any> temp1;
      for(auto item1:*desiredPropertyInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DesiredPropertyInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesiredPropertyInfo") != m.end() && !m["DesiredPropertyInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["DesiredPropertyInfo"].type()) {
        vector<QueryDeviceDesiredPropertyResponseDataListDesiredPropertyInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DesiredPropertyInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceDesiredPropertyResponseDataListDesiredPropertyInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        desiredPropertyInfo = make_shared<vector<QueryDeviceDesiredPropertyResponseDataListDesiredPropertyInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceDesiredPropertyResponseDataList() = default;
};
class QueryDeviceDesiredPropertyResponseData : public Darabonba::Model {
public:
  shared_ptr<QueryDeviceDesiredPropertyResponseDataList> list{};

  QueryDeviceDesiredPropertyResponseData() {}

  explicit QueryDeviceDesiredPropertyResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!list) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("list is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDeviceDesiredPropertyResponseDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDeviceDesiredPropertyResponseDataList>(model1);
      }
    }
  }


  virtual ~QueryDeviceDesiredPropertyResponseData() = default;
};
class QueryDeviceDesiredPropertyResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceDesiredPropertyResponseData> data{};

  QueryDeviceDesiredPropertyResponse() {}

  explicit QueryDeviceDesiredPropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceDesiredPropertyResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceDesiredPropertyResponseData>(model1);
      }
    }
  }


  virtual ~QueryDeviceDesiredPropertyResponse() = default;
};
class QueryEdgeInstanceHistoricDeploymentRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<int> currentPage{};
  shared_ptr<int> pageSize{};
  shared_ptr<long> startTime{};
  shared_ptr<long> endTime{};

  QueryEdgeInstanceHistoricDeploymentRequest() {}

  explicit QueryEdgeInstanceHistoricDeploymentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
  }


  virtual ~QueryEdgeInstanceHistoricDeploymentRequest() = default;
};
class QueryEdgeInstanceHistoricDeploymentResponseDataDeploymentList : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> gmtCompleted{};
  shared_ptr<string> deploymentId{};
  shared_ptr<string> description{};
  shared_ptr<int> status{};
  shared_ptr<string> type{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<long> gmtCompletedTimestamp{};

  QueryEdgeInstanceHistoricDeploymentResponseDataDeploymentList() {}

  explicit QueryEdgeInstanceHistoricDeploymentResponseDataDeploymentList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!gmtModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModified is required.")));
    }
    if (!gmtCompleted) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCompleted is required.")));
    }
    if (!deploymentId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deploymentId is required.")));
    }
    if (!description) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("description is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
    if (!gmtCreateTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreateTimestamp is required.")));
    }
    if (!gmtModifiedTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModifiedTimestamp is required.")));
    }
    if (!gmtCompletedTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCompletedTimestamp is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtCompleted) {
      res["GmtCompleted"] = boost::any(*gmtCompleted);
    }
    if (deploymentId) {
      res["DeploymentId"] = boost::any(*deploymentId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (gmtCompletedTimestamp) {
      res["GmtCompletedTimestamp"] = boost::any(*gmtCompletedTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtCompleted") != m.end() && !m["GmtCompleted"].empty()) {
      gmtCompleted = make_shared<string>(boost::any_cast<string>(m["GmtCompleted"]));
    }
    if (m.find("DeploymentId") != m.end() && !m["DeploymentId"].empty()) {
      deploymentId = make_shared<string>(boost::any_cast<string>(m["DeploymentId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<int>(boost::any_cast<int>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("GmtCompletedTimestamp") != m.end() && !m["GmtCompletedTimestamp"].empty()) {
      gmtCompletedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCompletedTimestamp"]));
    }
  }


  virtual ~QueryEdgeInstanceHistoricDeploymentResponseDataDeploymentList() = default;
};
class QueryEdgeInstanceHistoricDeploymentResponseData : public Darabonba::Model {
public:
  shared_ptr<int> total{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> currentPage{};
  shared_ptr<vector<QueryEdgeInstanceHistoricDeploymentResponseDataDeploymentList>> deploymentList{};

  QueryEdgeInstanceHistoricDeploymentResponseData() {}

  explicit QueryEdgeInstanceHistoricDeploymentResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!deploymentList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deploymentList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (deploymentList) {
      vector<boost::any> temp1;
      for(auto item1:*deploymentList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeploymentList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("DeploymentList") != m.end() && !m["DeploymentList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeploymentList"].type()) {
        vector<QueryEdgeInstanceHistoricDeploymentResponseDataDeploymentList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeploymentList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeInstanceHistoricDeploymentResponseDataDeploymentList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deploymentList = make_shared<vector<QueryEdgeInstanceHistoricDeploymentResponseDataDeploymentList>>(expect1);
      }
    }
  }


  virtual ~QueryEdgeInstanceHistoricDeploymentResponseData() = default;
};
class QueryEdgeInstanceHistoricDeploymentResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryEdgeInstanceHistoricDeploymentResponseData> data{};

  QueryEdgeInstanceHistoricDeploymentResponse() {}

  explicit QueryEdgeInstanceHistoricDeploymentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEdgeInstanceHistoricDeploymentResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEdgeInstanceHistoricDeploymentResponseData>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceHistoricDeploymentResponse() = default;
};
class CreateProductTagsRequestProductTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  CreateProductTagsRequestProductTag() {}

  explicit CreateProductTagsRequestProductTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~CreateProductTagsRequestProductTag() = default;
};
class CreateProductTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<vector<CreateProductTagsRequestProductTag>> productTag{};

  CreateProductTagsRequest() {}

  explicit CreateProductTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!productTag) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productTag is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productTag) {
      vector<boost::any> temp1;
      for(auto item1:*productTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProductTag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductTag") != m.end() && !m["ProductTag"].empty()) {
      if (typeid(vector<boost::any>) == m["ProductTag"].type()) {
        vector<CreateProductTagsRequestProductTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProductTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateProductTagsRequestProductTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        productTag = make_shared<vector<CreateProductTagsRequestProductTag>>(expect1);
      }
    }
  }


  virtual ~CreateProductTagsRequest() = default;
};
class CreateProductTagsResponseInvalidProductTagsProductTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  CreateProductTagsResponseInvalidProductTagsProductTag() {}

  explicit CreateProductTagsResponseInvalidProductTagsProductTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tagKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tagKey is required.")));
    }
    if (!tagValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tagValue is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~CreateProductTagsResponseInvalidProductTagsProductTag() = default;
};
class CreateProductTagsResponseInvalidProductTags : public Darabonba::Model {
public:
  shared_ptr<vector<CreateProductTagsResponseInvalidProductTagsProductTag>> productTag{};

  CreateProductTagsResponseInvalidProductTags() {}

  explicit CreateProductTagsResponseInvalidProductTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productTag) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productTag is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productTag) {
      vector<boost::any> temp1;
      for(auto item1:*productTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProductTag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductTag") != m.end() && !m["ProductTag"].empty()) {
      if (typeid(vector<boost::any>) == m["ProductTag"].type()) {
        vector<CreateProductTagsResponseInvalidProductTagsProductTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProductTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateProductTagsResponseInvalidProductTagsProductTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        productTag = make_shared<vector<CreateProductTagsResponseInvalidProductTagsProductTag>>(expect1);
      }
    }
  }


  virtual ~CreateProductTagsResponseInvalidProductTags() = default;
};
class CreateProductTagsResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<CreateProductTagsResponseInvalidProductTags> invalidProductTags{};

  CreateProductTagsResponse() {}

  explicit CreateProductTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!invalidProductTags) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("invalidProductTags is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (invalidProductTags) {
      res["InvalidProductTags"] = invalidProductTags ? boost::any(invalidProductTags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("InvalidProductTags") != m.end() && !m["InvalidProductTags"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvalidProductTags"].type()) {
        CreateProductTagsResponseInvalidProductTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvalidProductTags"]));
        invalidProductTags = make_shared<CreateProductTagsResponseInvalidProductTags>(model1);
      }
    }
  }


  virtual ~CreateProductTagsResponse() = default;
};
class UpdateProductTagsRequestProductTag : public Darabonba::Model {
public:
  shared_ptr<string> tagValue{};
  shared_ptr<string> tagKey{};

  UpdateProductTagsRequestProductTag() {}

  explicit UpdateProductTagsRequestProductTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~UpdateProductTagsRequestProductTag() = default;
};
class UpdateProductTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<vector<UpdateProductTagsRequestProductTag>> productTag{};

  UpdateProductTagsRequest() {}

  explicit UpdateProductTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!productTag) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productTag is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productTag) {
      vector<boost::any> temp1;
      for(auto item1:*productTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProductTag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductTag") != m.end() && !m["ProductTag"].empty()) {
      if (typeid(vector<boost::any>) == m["ProductTag"].type()) {
        vector<UpdateProductTagsRequestProductTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProductTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateProductTagsRequestProductTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        productTag = make_shared<vector<UpdateProductTagsRequestProductTag>>(expect1);
      }
    }
  }


  virtual ~UpdateProductTagsRequest() = default;
};
class UpdateProductTagsResponseInvalidProductTagsProductTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  UpdateProductTagsResponseInvalidProductTagsProductTag() {}

  explicit UpdateProductTagsResponseInvalidProductTagsProductTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tagKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tagKey is required.")));
    }
    if (!tagValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tagValue is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~UpdateProductTagsResponseInvalidProductTagsProductTag() = default;
};
class UpdateProductTagsResponseInvalidProductTags : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateProductTagsResponseInvalidProductTagsProductTag>> productTag{};

  UpdateProductTagsResponseInvalidProductTags() {}

  explicit UpdateProductTagsResponseInvalidProductTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productTag) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productTag is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productTag) {
      vector<boost::any> temp1;
      for(auto item1:*productTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProductTag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductTag") != m.end() && !m["ProductTag"].empty()) {
      if (typeid(vector<boost::any>) == m["ProductTag"].type()) {
        vector<UpdateProductTagsResponseInvalidProductTagsProductTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProductTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateProductTagsResponseInvalidProductTagsProductTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        productTag = make_shared<vector<UpdateProductTagsResponseInvalidProductTagsProductTag>>(expect1);
      }
    }
  }


  virtual ~UpdateProductTagsResponseInvalidProductTags() = default;
};
class UpdateProductTagsResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<UpdateProductTagsResponseInvalidProductTags> invalidProductTags{};

  UpdateProductTagsResponse() {}

  explicit UpdateProductTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!invalidProductTags) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("invalidProductTags is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (invalidProductTags) {
      res["InvalidProductTags"] = invalidProductTags ? boost::any(invalidProductTags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("InvalidProductTags") != m.end() && !m["InvalidProductTags"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvalidProductTags"].type()) {
        UpdateProductTagsResponseInvalidProductTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvalidProductTags"]));
        invalidProductTags = make_shared<UpdateProductTagsResponseInvalidProductTags>(model1);
      }
    }
  }


  virtual ~UpdateProductTagsResponse() = default;
};
class DeleteProductTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<string>> productTagKey{};
  shared_ptr<string> productKey{};

  DeleteProductTagsRequest() {}

  explicit DeleteProductTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productTagKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productTagKey is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productTagKey) {
      res["ProductTagKey"] = boost::any(*productTagKey);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductTagKey") != m.end() && !m["ProductTagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProductTagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProductTagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      productTagKey = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~DeleteProductTagsRequest() = default;
};
class DeleteProductTagsResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};

  DeleteProductTagsResponse() {}

  explicit DeleteProductTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~DeleteProductTagsResponse() = default;
};
class ListProductTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  ListProductTagsRequest() {}

  explicit ListProductTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~ListProductTagsRequest() = default;
};
class ListProductTagsResponseDataProductTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListProductTagsResponseDataProductTag() {}

  explicit ListProductTagsResponseDataProductTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tagKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tagKey is required.")));
    }
    if (!tagValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tagValue is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListProductTagsResponseDataProductTag() = default;
};
class ListProductTagsResponseData : public Darabonba::Model {
public:
  shared_ptr<vector<ListProductTagsResponseDataProductTag>> productTag{};

  ListProductTagsResponseData() {}

  explicit ListProductTagsResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productTag) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productTag is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productTag) {
      vector<boost::any> temp1;
      for(auto item1:*productTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProductTag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductTag") != m.end() && !m["ProductTag"].empty()) {
      if (typeid(vector<boost::any>) == m["ProductTag"].type()) {
        vector<ListProductTagsResponseDataProductTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProductTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProductTagsResponseDataProductTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        productTag = make_shared<vector<ListProductTagsResponseDataProductTag>>(expect1);
      }
    }
  }


  virtual ~ListProductTagsResponseData() = default;
};
class ListProductTagsResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<ListProductTagsResponseData> data{};

  ListProductTagsResponse() {}

  explicit ListProductTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListProductTagsResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListProductTagsResponseData>(model1);
      }
    }
  }


  virtual ~ListProductTagsResponse() = default;
};
class ListProductByTagsRequestProductTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListProductByTagsRequestProductTag() {}

  explicit ListProductByTagsRequestProductTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tagKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tagKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListProductByTagsRequestProductTag() = default;
};
class ListProductByTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<int> currentPage{};
  shared_ptr<int> pageSize{};
  shared_ptr<vector<ListProductByTagsRequestProductTag>> productTag{};

  ListProductByTagsRequest() {}

  explicit ListProductByTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productTag) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productTag is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productTag) {
      vector<boost::any> temp1;
      for(auto item1:*productTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProductTag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ProductTag") != m.end() && !m["ProductTag"].empty()) {
      if (typeid(vector<boost::any>) == m["ProductTag"].type()) {
        vector<ListProductByTagsRequestProductTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProductTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProductByTagsRequestProductTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        productTag = make_shared<vector<ListProductByTagsRequestProductTag>>(expect1);
      }
    }
  }


  virtual ~ListProductByTagsRequest() = default;
};
class ListProductByTagsResponseProductInfosProductInfo : public Darabonba::Model {
public:
  shared_ptr<string> productName{};
  shared_ptr<string> productKey{};
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<int> nodeType{};

  ListProductByTagsResponseProductInfosProductInfo() {}

  explicit ListProductByTagsResponseProductInfosProductInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productName is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!createTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createTime is required.")));
    }
    if (!description) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("description is required.")));
    }
    if (!nodeType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<int>(boost::any_cast<int>(m["NodeType"]));
    }
  }


  virtual ~ListProductByTagsResponseProductInfosProductInfo() = default;
};
class ListProductByTagsResponseProductInfos : public Darabonba::Model {
public:
  shared_ptr<vector<ListProductByTagsResponseProductInfosProductInfo>> productInfo{};

  ListProductByTagsResponseProductInfos() {}

  explicit ListProductByTagsResponseProductInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productInfo) {
      vector<boost::any> temp1;
      for(auto item1:*productInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProductInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductInfo") != m.end() && !m["ProductInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ProductInfo"].type()) {
        vector<ListProductByTagsResponseProductInfosProductInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProductInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProductByTagsResponseProductInfosProductInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        productInfo = make_shared<vector<ListProductByTagsResponseProductInfosProductInfo>>(expect1);
      }
    }
  }


  virtual ~ListProductByTagsResponseProductInfos() = default;
};
class ListProductByTagsResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<ListProductByTagsResponseProductInfos> productInfos{};

  ListProductByTagsResponse() {}

  explicit ListProductByTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!productInfos) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productInfos is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (productInfos) {
      res["ProductInfos"] = productInfos ? boost::any(productInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ProductInfos") != m.end() && !m["ProductInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProductInfos"].type()) {
        ListProductByTagsResponseProductInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProductInfos"]));
        productInfos = make_shared<ListProductByTagsResponseProductInfos>(model1);
      }
    }
  }


  virtual ~ListProductByTagsResponse() = default;
};
class QueryDeviceGroupByTagsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  QueryDeviceGroupByTagsRequestTag() {}

  explicit QueryDeviceGroupByTagsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tagKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tagKey is required.")));
    }
    if (!tagValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tagValue is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~QueryDeviceGroupByTagsRequestTag() = default;
};
class QueryDeviceGroupByTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<QueryDeviceGroupByTagsRequestTag>> tag{};
  shared_ptr<int> currentPage{};
  shared_ptr<int> pageSize{};

  QueryDeviceGroupByTagsRequest() {}

  explicit QueryDeviceGroupByTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<QueryDeviceGroupByTagsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceGroupByTagsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<QueryDeviceGroupByTagsRequestTag>>(expect1);
      }
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
  }


  virtual ~QueryDeviceGroupByTagsRequest() = default;
};
class QueryDeviceGroupByTagsResponseDataDeviceGroup : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};

  QueryDeviceGroupByTagsResponseDataDeviceGroup() {}

  explicit QueryDeviceGroupByTagsResponseDataDeviceGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
    if (!groupName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~QueryDeviceGroupByTagsResponseDataDeviceGroup() = default;
};
class QueryDeviceGroupByTagsResponseData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceGroupByTagsResponseDataDeviceGroup>> deviceGroup{};

  QueryDeviceGroupByTagsResponseData() {}

  explicit QueryDeviceGroupByTagsResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!deviceGroup) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceGroup is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceGroup) {
      vector<boost::any> temp1;
      for(auto item1:*deviceGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceGroup") != m.end() && !m["DeviceGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceGroup"].type()) {
        vector<QueryDeviceGroupByTagsResponseDataDeviceGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceGroupByTagsResponseDataDeviceGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceGroup = make_shared<vector<QueryDeviceGroupByTagsResponseDataDeviceGroup>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceGroupByTagsResponseData() = default;
};
class QueryDeviceGroupByTagsResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> page{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> pageCount{};
  shared_ptr<int> total{};
  shared_ptr<QueryDeviceGroupByTagsResponseData> data{};

  QueryDeviceGroupByTagsResponse() {}

  explicit QueryDeviceGroupByTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!page) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("page is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!pageCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageCount is required.")));
    }
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<int>(boost::any_cast<int>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<int>(boost::any_cast<int>(m["PageCount"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceGroupByTagsResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceGroupByTagsResponseData>(model1);
      }
    }
  }


  virtual ~QueryDeviceGroupByTagsResponse() = default;
};
class BatchAddThingTopoRequestTopoAddItem : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> sign{};
  shared_ptr<string> signMethod{};
  shared_ptr<string> timestamp{};
  shared_ptr<string> clientId{};

  BatchAddThingTopoRequestTopoAddItem() {}

  explicit BatchAddThingTopoRequestTopoAddItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!sign) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("sign is required.")));
    }
    if (!signMethod) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("signMethod is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (sign) {
      res["Sign"] = boost::any(*sign);
    }
    if (signMethod) {
      res["SignMethod"] = boost::any(*signMethod);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Sign") != m.end() && !m["Sign"].empty()) {
      sign = make_shared<string>(boost::any_cast<string>(m["Sign"]));
    }
    if (m.find("SignMethod") != m.end() && !m["SignMethod"].empty()) {
      signMethod = make_shared<string>(boost::any_cast<string>(m["SignMethod"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
  }


  virtual ~BatchAddThingTopoRequestTopoAddItem() = default;
};
class BatchAddThingTopoRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<BatchAddThingTopoRequestTopoAddItem>> topoAddItem{};
  shared_ptr<string> gwProductKey{};
  shared_ptr<string> gwDeviceName{};

  BatchAddThingTopoRequest() {}

  explicit BatchAddThingTopoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!topoAddItem) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topoAddItem is required.")));
    }
    if (!gwProductKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gwProductKey is required.")));
    }
    if (!gwDeviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gwDeviceName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (topoAddItem) {
      vector<boost::any> temp1;
      for(auto item1:*topoAddItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TopoAddItem"] = boost::any(temp1);
    }
    if (gwProductKey) {
      res["GwProductKey"] = boost::any(*gwProductKey);
    }
    if (gwDeviceName) {
      res["GwDeviceName"] = boost::any(*gwDeviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("TopoAddItem") != m.end() && !m["TopoAddItem"].empty()) {
      if (typeid(vector<boost::any>) == m["TopoAddItem"].type()) {
        vector<BatchAddThingTopoRequestTopoAddItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TopoAddItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchAddThingTopoRequestTopoAddItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topoAddItem = make_shared<vector<BatchAddThingTopoRequestTopoAddItem>>(expect1);
      }
    }
    if (m.find("GwProductKey") != m.end() && !m["GwProductKey"].empty()) {
      gwProductKey = make_shared<string>(boost::any_cast<string>(m["GwProductKey"]));
    }
    if (m.find("GwDeviceName") != m.end() && !m["GwDeviceName"].empty()) {
      gwDeviceName = make_shared<string>(boost::any_cast<string>(m["GwDeviceName"]));
    }
  }


  virtual ~BatchAddThingTopoRequest() = default;
};
class BatchAddThingTopoResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  BatchAddThingTopoResponse() {}

  explicit BatchAddThingTopoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~BatchAddThingTopoResponse() = default;
};
class QueryDeviceListByDeviceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> groupId{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> currentPage{};

  QueryDeviceListByDeviceGroupRequest() {}

  explicit QueryDeviceListByDeviceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
  }


  virtual ~QueryDeviceListByDeviceGroupRequest() = default;
};
class QueryDeviceListByDeviceGroupResponseDataSimpleDeviceInfo : public Darabonba::Model {
public:
  shared_ptr<string> productName{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};

  QueryDeviceListByDeviceGroupResponseDataSimpleDeviceInfo() {}

  explicit QueryDeviceListByDeviceGroupResponseDataSimpleDeviceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productName is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!iotId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~QueryDeviceListByDeviceGroupResponseDataSimpleDeviceInfo() = default;
};
class QueryDeviceListByDeviceGroupResponseData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceListByDeviceGroupResponseDataSimpleDeviceInfo>> simpleDeviceInfo{};

  QueryDeviceListByDeviceGroupResponseData() {}

  explicit QueryDeviceListByDeviceGroupResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!simpleDeviceInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("simpleDeviceInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (simpleDeviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*simpleDeviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SimpleDeviceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SimpleDeviceInfo") != m.end() && !m["SimpleDeviceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SimpleDeviceInfo"].type()) {
        vector<QueryDeviceListByDeviceGroupResponseDataSimpleDeviceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SimpleDeviceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceListByDeviceGroupResponseDataSimpleDeviceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        simpleDeviceInfo = make_shared<vector<QueryDeviceListByDeviceGroupResponseDataSimpleDeviceInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceListByDeviceGroupResponseData() = default;
};
class QueryDeviceListByDeviceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> page{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> pageCount{};
  shared_ptr<int> total{};
  shared_ptr<QueryDeviceListByDeviceGroupResponseData> data{};

  QueryDeviceListByDeviceGroupResponse() {}

  explicit QueryDeviceListByDeviceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!page) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("page is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!pageCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageCount is required.")));
    }
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<int>(boost::any_cast<int>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<int>(boost::any_cast<int>(m["PageCount"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceListByDeviceGroupResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceListByDeviceGroupResponseData>(model1);
      }
    }
  }


  virtual ~QueryDeviceListByDeviceGroupResponse() = default;
};
class QueryDevicePropertiesDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<long> startTime{};
  shared_ptr<vector<string>> identifier{};
  shared_ptr<int> asc{};
  shared_ptr<string> iotId{};
  shared_ptr<long> endTime{};

  QueryDevicePropertiesDataRequest() {}

  explicit QueryDevicePropertiesDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!startTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("startTime is required.")));
    }
    if (!identifier) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("identifier is required.")));
    }
    if (!asc) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("asc is required.")));
    }
    if (!endTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endTime is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Identifier"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Identifier"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      identifier = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<int>(boost::any_cast<int>(m["Asc"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
  }


  virtual ~QueryDevicePropertiesDataRequest() = default;
};
class QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfoListPropertyInfo : public Darabonba::Model {
public:
  shared_ptr<long> time{};
  shared_ptr<string> value{};

  QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfoListPropertyInfo() {}

  explicit QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfoListPropertyInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!time) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("time is required.")));
    }
    if (!value) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("value is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfoListPropertyInfo() = default;
};
class QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfoListPropertyInfo>> propertyInfo{};

  QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfoList() {}

  explicit QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!propertyInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("propertyInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertyInfo) {
      vector<boost::any> temp1;
      for(auto item1:*propertyInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertyInfo") != m.end() && !m["PropertyInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyInfo"].type()) {
        vector<QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfoListPropertyInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfoListPropertyInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyInfo = make_shared<vector<QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfoListPropertyInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfoList() = default;
};
class QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfo : public Darabonba::Model {
public:
  shared_ptr<string> identifier{};
  shared_ptr<QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfoList> list{};

  QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfo() {}

  explicit QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!identifier) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("identifier is required.")));
    }
    if (!list) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("list is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfoList>(model1);
      }
    }
  }


  virtual ~QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfo() = default;
};
class QueryDevicePropertiesDataResponsePropertyDataInfos : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfo>> propertyDataInfo{};

  QueryDevicePropertiesDataResponsePropertyDataInfos() {}

  explicit QueryDevicePropertiesDataResponsePropertyDataInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!propertyDataInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("propertyDataInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertyDataInfo) {
      vector<boost::any> temp1;
      for(auto item1:*propertyDataInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyDataInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertyDataInfo") != m.end() && !m["PropertyDataInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyDataInfo"].type()) {
        vector<QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyDataInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyDataInfo = make_shared<vector<QueryDevicePropertiesDataResponsePropertyDataInfosPropertyDataInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDevicePropertiesDataResponsePropertyDataInfos() = default;
};
class QueryDevicePropertiesDataResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> nextValid{};
  shared_ptr<long> nextTime{};
  shared_ptr<QueryDevicePropertiesDataResponsePropertyDataInfos> propertyDataInfos{};

  QueryDevicePropertiesDataResponse() {}

  explicit QueryDevicePropertiesDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!nextValid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nextValid is required.")));
    }
    if (!nextTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nextTime is required.")));
    }
    if (!propertyDataInfos) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("propertyDataInfos is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (nextValid) {
      res["NextValid"] = boost::any(*nextValid);
    }
    if (nextTime) {
      res["NextTime"] = boost::any(*nextTime);
    }
    if (propertyDataInfos) {
      res["PropertyDataInfos"] = propertyDataInfos ? boost::any(propertyDataInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NextValid") != m.end() && !m["NextValid"].empty()) {
      nextValid = make_shared<bool>(boost::any_cast<bool>(m["NextValid"]));
    }
    if (m.find("NextTime") != m.end() && !m["NextTime"].empty()) {
      nextTime = make_shared<long>(boost::any_cast<long>(m["NextTime"]));
    }
    if (m.find("PropertyDataInfos") != m.end() && !m["PropertyDataInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["PropertyDataInfos"].type()) {
        QueryDevicePropertiesDataResponsePropertyDataInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PropertyDataInfos"]));
        propertyDataInfos = make_shared<QueryDevicePropertiesDataResponsePropertyDataInfos>(model1);
      }
    }
  }


  virtual ~QueryDevicePropertiesDataResponse() = default;
};
class UnbindRoleFromEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};

  UnbindRoleFromEdgeInstanceRequest() {}

  explicit UnbindRoleFromEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~UnbindRoleFromEdgeInstanceRequest() = default;
};
class UnbindRoleFromEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UnbindRoleFromEdgeInstanceResponse() {}

  explicit UnbindRoleFromEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UnbindRoleFromEdgeInstanceResponse() = default;
};
class UpdateEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> tags{};
  shared_ptr<int> spec{};
  shared_ptr<bool> bizEnable{};

  UpdateEdgeInstanceRequest() {}

  explicit UpdateEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (bizEnable) {
      res["BizEnable"] = boost::any(*bizEnable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<int>(boost::any_cast<int>(m["Spec"]));
    }
    if (m.find("BizEnable") != m.end() && !m["BizEnable"].empty()) {
      bizEnable = make_shared<bool>(boost::any_cast<bool>(m["BizEnable"]));
    }
  }


  virtual ~UpdateEdgeInstanceRequest() = default;
};
class UpdateEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateEdgeInstanceResponse() {}

  explicit UpdateEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateEdgeInstanceResponse() = default;
};
class GetEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};

  GetEdgeInstanceRequest() {}

  explicit GetEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetEdgeInstanceRequest() = default;
};
class GetEdgeInstanceResponseData : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> tags{};
  shared_ptr<string> type{};
  shared_ptr<int> spec{};
  shared_ptr<bool> bizEnable{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> roleName{};
  shared_ptr<string> roleAttachTime{};
  shared_ptr<int> latestDeploymentStatus{};
  shared_ptr<string> latestDeploymentType{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<long> roleAttachTimestamp{};

  GetEdgeInstanceResponseData() {}

  explicit GetEdgeInstanceResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!tags) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tags is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
    if (!spec) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("spec is required.")));
    }
    if (!bizEnable) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizEnable is required.")));
    }
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!gmtModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModified is required.")));
    }
    if (!roleArn) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("roleArn is required.")));
    }
    if (!roleName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("roleName is required.")));
    }
    if (!roleAttachTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("roleAttachTime is required.")));
    }
    if (!latestDeploymentStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("latestDeploymentStatus is required.")));
    }
    if (!latestDeploymentType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("latestDeploymentType is required.")));
    }
    if (!gmtCreateTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreateTimestamp is required.")));
    }
    if (!gmtModifiedTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModifiedTimestamp is required.")));
    }
    if (!roleAttachTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("roleAttachTimestamp is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (bizEnable) {
      res["BizEnable"] = boost::any(*bizEnable);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (roleAttachTime) {
      res["RoleAttachTime"] = boost::any(*roleAttachTime);
    }
    if (latestDeploymentStatus) {
      res["LatestDeploymentStatus"] = boost::any(*latestDeploymentStatus);
    }
    if (latestDeploymentType) {
      res["LatestDeploymentType"] = boost::any(*latestDeploymentType);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (roleAttachTimestamp) {
      res["RoleAttachTimestamp"] = boost::any(*roleAttachTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<int>(boost::any_cast<int>(m["Spec"]));
    }
    if (m.find("BizEnable") != m.end() && !m["BizEnable"].empty()) {
      bizEnable = make_shared<bool>(boost::any_cast<bool>(m["BizEnable"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("RoleAttachTime") != m.end() && !m["RoleAttachTime"].empty()) {
      roleAttachTime = make_shared<string>(boost::any_cast<string>(m["RoleAttachTime"]));
    }
    if (m.find("LatestDeploymentStatus") != m.end() && !m["LatestDeploymentStatus"].empty()) {
      latestDeploymentStatus = make_shared<int>(boost::any_cast<int>(m["LatestDeploymentStatus"]));
    }
    if (m.find("LatestDeploymentType") != m.end() && !m["LatestDeploymentType"].empty()) {
      latestDeploymentType = make_shared<string>(boost::any_cast<string>(m["LatestDeploymentType"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("RoleAttachTimestamp") != m.end() && !m["RoleAttachTimestamp"].empty()) {
      roleAttachTimestamp = make_shared<long>(boost::any_cast<long>(m["RoleAttachTimestamp"]));
    }
  }


  virtual ~GetEdgeInstanceResponseData() = default;
};
class GetEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetEdgeInstanceResponseData> data{};

  GetEdgeInstanceResponse() {}

  explicit GetEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetEdgeInstanceResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetEdgeInstanceResponseData>(model1);
      }
    }
  }


  virtual ~GetEdgeInstanceResponse() = default;
};
class DeleteEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};

  DeleteEdgeInstanceRequest() {}

  explicit DeleteEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteEdgeInstanceRequest() = default;
};
class DeleteEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteEdgeInstanceResponse() {}

  explicit DeleteEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteEdgeInstanceResponse() = default;
};
class CreateEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> tags{};
  shared_ptr<int> spec{};

  CreateEdgeInstanceRequest() {}

  explicit CreateEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<int>(boost::any_cast<int>(m["Spec"]));
    }
  }


  virtual ~CreateEdgeInstanceRequest() = default;
};
class CreateEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<string> instanceId{};

  CreateEdgeInstanceResponse() {}

  explicit CreateEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~CreateEdgeInstanceResponse() = default;
};
class QueryEdgeInstanceGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};

  QueryEdgeInstanceGatewayRequest() {}

  explicit QueryEdgeInstanceGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~QueryEdgeInstanceGatewayRequest() = default;
};
class QueryEdgeInstanceGatewayResponseGatewayList : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> edgeVersion{};

  QueryEdgeInstanceGatewayResponseGatewayList() {}

  explicit QueryEdgeInstanceGatewayResponseGatewayList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!iotId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotId is required.")));
    }
    if (!edgeVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("edgeVersion is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (edgeVersion) {
      res["EdgeVersion"] = boost::any(*edgeVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("EdgeVersion") != m.end() && !m["EdgeVersion"].empty()) {
      edgeVersion = make_shared<string>(boost::any_cast<string>(m["EdgeVersion"]));
    }
  }


  virtual ~QueryEdgeInstanceGatewayResponseGatewayList() = default;
};
class QueryEdgeInstanceGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<QueryEdgeInstanceGatewayResponseGatewayList>> gatewayList{};

  QueryEdgeInstanceGatewayResponse() {}

  explicit QueryEdgeInstanceGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!gatewayList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gatewayList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (gatewayList) {
      vector<boost::any> temp1;
      for(auto item1:*gatewayList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GatewayList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("GatewayList") != m.end() && !m["GatewayList"].empty()) {
      if (typeid(vector<boost::any>) == m["GatewayList"].type()) {
        vector<QueryEdgeInstanceGatewayResponseGatewayList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GatewayList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeInstanceGatewayResponseGatewayList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        gatewayList = make_shared<vector<QueryEdgeInstanceGatewayResponseGatewayList>>(expect1);
      }
    }
  }


  virtual ~QueryEdgeInstanceGatewayResponse() = default;
};
class QueryEdgeInstanceDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<int> currentPage{};
  shared_ptr<int> pageSize{};

  QueryEdgeInstanceDeviceRequest() {}

  explicit QueryEdgeInstanceDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
  }


  virtual ~QueryEdgeInstanceDeviceRequest() = default;
};
class QueryEdgeInstanceDeviceResponseDataDeviceList : public Darabonba::Model {
public:
  shared_ptr<string> iotId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> driverId{};

  QueryEdgeInstanceDeviceResponseDataDeviceList() {}

  explicit QueryEdgeInstanceDeviceResponseDataDeviceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!iotId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotId is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!driverId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("driverId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (driverId) {
      res["DriverId"] = boost::any(*driverId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DriverId") != m.end() && !m["DriverId"].empty()) {
      driverId = make_shared<string>(boost::any_cast<string>(m["DriverId"]));
    }
  }


  virtual ~QueryEdgeInstanceDeviceResponseDataDeviceList() = default;
};
class QueryEdgeInstanceDeviceResponseData : public Darabonba::Model {
public:
  shared_ptr<int> total{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> currentPage{};
  shared_ptr<vector<QueryEdgeInstanceDeviceResponseDataDeviceList>> deviceList{};

  QueryEdgeInstanceDeviceResponseData() {}

  explicit QueryEdgeInstanceDeviceResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!deviceList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (deviceList) {
      vector<boost::any> temp1;
      for(auto item1:*deviceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("DeviceList") != m.end() && !m["DeviceList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceList"].type()) {
        vector<QueryEdgeInstanceDeviceResponseDataDeviceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeInstanceDeviceResponseDataDeviceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceList = make_shared<vector<QueryEdgeInstanceDeviceResponseDataDeviceList>>(expect1);
      }
    }
  }


  virtual ~QueryEdgeInstanceDeviceResponseData() = default;
};
class QueryEdgeInstanceDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryEdgeInstanceDeviceResponseData> data{};

  QueryEdgeInstanceDeviceResponse() {}

  explicit QueryEdgeInstanceDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEdgeInstanceDeviceResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEdgeInstanceDeviceResponseData>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceDeviceResponse() = default;
};
class BindGatewayToEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};

  BindGatewayToEdgeInstanceRequest() {}

  explicit BindGatewayToEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~BindGatewayToEdgeInstanceRequest() = default;
};
class BindGatewayToEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  BindGatewayToEdgeInstanceResponse() {}

  explicit BindGatewayToEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~BindGatewayToEdgeInstanceResponse() = default;
};
class QueryEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> currentPage{};
  shared_ptr<string> name{};

  QueryEdgeInstanceRequest() {}

  explicit QueryEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~QueryEdgeInstanceRequest() = default;
};
class QueryEdgeInstanceResponseDataInstanceList : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> tags{};
  shared_ptr<int> type{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> roleName{};
  shared_ptr<string> roleAttachTime{};
  shared_ptr<int> spec{};
  shared_ptr<bool> bizEnable{};
  shared_ptr<int> latestDeploymentStatus{};
  shared_ptr<string> latestDeploymentType{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<long> gmtModifiedTimestamp{};
  shared_ptr<long> roleAttachTimestamp{};

  QueryEdgeInstanceResponseDataInstanceList() {}

  explicit QueryEdgeInstanceResponseDataInstanceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!tags) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tags is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!gmtModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModified is required.")));
    }
    if (!roleArn) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("roleArn is required.")));
    }
    if (!roleName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("roleName is required.")));
    }
    if (!roleAttachTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("roleAttachTime is required.")));
    }
    if (!spec) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("spec is required.")));
    }
    if (!bizEnable) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("bizEnable is required.")));
    }
    if (!latestDeploymentStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("latestDeploymentStatus is required.")));
    }
    if (!latestDeploymentType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("latestDeploymentType is required.")));
    }
    if (!gmtCreateTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreateTimestamp is required.")));
    }
    if (!gmtModifiedTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModifiedTimestamp is required.")));
    }
    if (!roleAttachTimestamp) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("roleAttachTimestamp is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (roleAttachTime) {
      res["RoleAttachTime"] = boost::any(*roleAttachTime);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (bizEnable) {
      res["BizEnable"] = boost::any(*bizEnable);
    }
    if (latestDeploymentStatus) {
      res["LatestDeploymentStatus"] = boost::any(*latestDeploymentStatus);
    }
    if (latestDeploymentType) {
      res["LatestDeploymentType"] = boost::any(*latestDeploymentType);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModifiedTimestamp) {
      res["GmtModifiedTimestamp"] = boost::any(*gmtModifiedTimestamp);
    }
    if (roleAttachTimestamp) {
      res["RoleAttachTimestamp"] = boost::any(*roleAttachTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<int>(boost::any_cast<int>(m["Type"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("RoleAttachTime") != m.end() && !m["RoleAttachTime"].empty()) {
      roleAttachTime = make_shared<string>(boost::any_cast<string>(m["RoleAttachTime"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<int>(boost::any_cast<int>(m["Spec"]));
    }
    if (m.find("BizEnable") != m.end() && !m["BizEnable"].empty()) {
      bizEnable = make_shared<bool>(boost::any_cast<bool>(m["BizEnable"]));
    }
    if (m.find("LatestDeploymentStatus") != m.end() && !m["LatestDeploymentStatus"].empty()) {
      latestDeploymentStatus = make_shared<int>(boost::any_cast<int>(m["LatestDeploymentStatus"]));
    }
    if (m.find("LatestDeploymentType") != m.end() && !m["LatestDeploymentType"].empty()) {
      latestDeploymentType = make_shared<string>(boost::any_cast<string>(m["LatestDeploymentType"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModifiedTimestamp") != m.end() && !m["GmtModifiedTimestamp"].empty()) {
      gmtModifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifiedTimestamp"]));
    }
    if (m.find("RoleAttachTimestamp") != m.end() && !m["RoleAttachTimestamp"].empty()) {
      roleAttachTimestamp = make_shared<long>(boost::any_cast<long>(m["RoleAttachTimestamp"]));
    }
  }


  virtual ~QueryEdgeInstanceResponseDataInstanceList() = default;
};
class QueryEdgeInstanceResponseData : public Darabonba::Model {
public:
  shared_ptr<int> total{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> currentPage{};
  shared_ptr<vector<QueryEdgeInstanceResponseDataInstanceList>> instanceList{};

  QueryEdgeInstanceResponseData() {}

  explicit QueryEdgeInstanceResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!instanceList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (instanceList) {
      vector<boost::any> temp1;
      for(auto item1:*instanceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("InstanceList") != m.end() && !m["InstanceList"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceList"].type()) {
        vector<QueryEdgeInstanceResponseDataInstanceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEdgeInstanceResponseDataInstanceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceList = make_shared<vector<QueryEdgeInstanceResponseDataInstanceList>>(expect1);
      }
    }
  }


  virtual ~QueryEdgeInstanceResponseData() = default;
};
class QueryEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryEdgeInstanceResponseData> data{};

  QueryEdgeInstanceResponse() {}

  explicit QueryEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryEdgeInstanceResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryEdgeInstanceResponseData>(model1);
      }
    }
  }


  virtual ~QueryEdgeInstanceResponse() = default;
};
class CreateEdgeInstanceDeploymentRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> type{};

  CreateEdgeInstanceDeploymentRequest() {}

  explicit CreateEdgeInstanceDeploymentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateEdgeInstanceDeploymentRequest() = default;
};
class CreateEdgeInstanceDeploymentResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> deploymentId{};

  CreateEdgeInstanceDeploymentResponse() {}

  explicit CreateEdgeInstanceDeploymentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!deploymentId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deploymentId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (deploymentId) {
      res["DeploymentId"] = boost::any(*deploymentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("DeploymentId") != m.end() && !m["DeploymentId"].empty()) {
      deploymentId = make_shared<string>(boost::any_cast<string>(m["DeploymentId"]));
    }
  }


  virtual ~CreateEdgeInstanceDeploymentResponse() = default;
};
class BindRoleToEdgeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> roleName{};

  BindRoleToEdgeInstanceRequest() {}

  explicit BindRoleToEdgeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!instanceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("instanceId is required.")));
    }
    if (!roleArn) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("roleArn is required.")));
    }
    if (!roleName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("roleName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
  }


  virtual ~BindRoleToEdgeInstanceRequest() = default;
};
class BindRoleToEdgeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  BindRoleToEdgeInstanceResponse() {}

  explicit BindRoleToEdgeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~BindRoleToEdgeInstanceResponse() = default;
};
class QuerySuperDeviceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> groupId{};

  QuerySuperDeviceGroupRequest() {}

  explicit QuerySuperDeviceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~QuerySuperDeviceGroupRequest() = default;
};
class QuerySuperDeviceGroupResponseDataGroupInfo : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> groupDesc{};

  QuerySuperDeviceGroupResponseDataGroupInfo() {}

  explicit QuerySuperDeviceGroupResponseDataGroupInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
    if (!groupName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupName is required.")));
    }
    if (!groupDesc) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupDesc is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupDesc) {
      res["GroupDesc"] = boost::any(*groupDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupDesc") != m.end() && !m["GroupDesc"].empty()) {
      groupDesc = make_shared<string>(boost::any_cast<string>(m["GroupDesc"]));
    }
  }


  virtual ~QuerySuperDeviceGroupResponseDataGroupInfo() = default;
};
class QuerySuperDeviceGroupResponseData : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySuperDeviceGroupResponseDataGroupInfo>> groupInfo{};

  QuerySuperDeviceGroupResponseData() {}

  explicit QuerySuperDeviceGroupResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!groupInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupInfo) {
      vector<boost::any> temp1;
      for(auto item1:*groupInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupInfo") != m.end() && !m["GroupInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupInfo"].type()) {
        vector<QuerySuperDeviceGroupResponseDataGroupInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySuperDeviceGroupResponseDataGroupInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupInfo = make_shared<vector<QuerySuperDeviceGroupResponseDataGroupInfo>>(expect1);
      }
    }
  }


  virtual ~QuerySuperDeviceGroupResponseData() = default;
};
class QuerySuperDeviceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QuerySuperDeviceGroupResponseData> data{};

  QuerySuperDeviceGroupResponse() {}

  explicit QuerySuperDeviceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QuerySuperDeviceGroupResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QuerySuperDeviceGroupResponseData>(model1);
      }
    }
  }


  virtual ~QuerySuperDeviceGroupResponse() = default;
};
class QueryDeviceByTagsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  QueryDeviceByTagsRequestTag() {}

  explicit QueryDeviceByTagsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tagKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tagKey is required.")));
    }
    if (!tagValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tagValue is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~QueryDeviceByTagsRequestTag() = default;
};
class QueryDeviceByTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<QueryDeviceByTagsRequestTag>> tag{};
  shared_ptr<int> currentPage{};
  shared_ptr<int> pageSize{};

  QueryDeviceByTagsRequest() {}

  explicit QueryDeviceByTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<QueryDeviceByTagsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceByTagsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<QueryDeviceByTagsRequestTag>>(expect1);
      }
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
  }


  virtual ~QueryDeviceByTagsRequest() = default;
};
class QueryDeviceByTagsResponseDataSimpleDeviceInfo : public Darabonba::Model {
public:
  shared_ptr<string> productName{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};

  QueryDeviceByTagsResponseDataSimpleDeviceInfo() {}

  explicit QueryDeviceByTagsResponseDataSimpleDeviceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productName is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!iotId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~QueryDeviceByTagsResponseDataSimpleDeviceInfo() = default;
};
class QueryDeviceByTagsResponseData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceByTagsResponseDataSimpleDeviceInfo>> simpleDeviceInfo{};

  QueryDeviceByTagsResponseData() {}

  explicit QueryDeviceByTagsResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!simpleDeviceInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("simpleDeviceInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (simpleDeviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*simpleDeviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SimpleDeviceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SimpleDeviceInfo") != m.end() && !m["SimpleDeviceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SimpleDeviceInfo"].type()) {
        vector<QueryDeviceByTagsResponseDataSimpleDeviceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SimpleDeviceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceByTagsResponseDataSimpleDeviceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        simpleDeviceInfo = make_shared<vector<QueryDeviceByTagsResponseDataSimpleDeviceInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceByTagsResponseData() = default;
};
class QueryDeviceByTagsResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> page{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> pageCount{};
  shared_ptr<int> total{};
  shared_ptr<QueryDeviceByTagsResponseData> data{};

  QueryDeviceByTagsResponse() {}

  explicit QueryDeviceByTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!page) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("page is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!pageCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageCount is required.")));
    }
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<int>(boost::any_cast<int>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<int>(boost::any_cast<int>(m["PageCount"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceByTagsResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceByTagsResponseData>(model1);
      }
    }
  }


  virtual ~QueryDeviceByTagsResponse() = default;
};
class SetDevicesPropertyRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> items{};

  SetDevicesPropertyRequest() {}

  explicit SetDevicesPropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!items) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("items is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (items) {
      res["Items"] = boost::any(*items);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      items = make_shared<string>(boost::any_cast<string>(m["Items"]));
    }
  }


  virtual ~SetDevicesPropertyRequest() = default;
};
class SetDevicesPropertyResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};

  SetDevicesPropertyResponse() {}

  explicit SetDevicesPropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~SetDevicesPropertyResponse() = default;
};
class InvokeThingsServiceRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> identifier{};
  shared_ptr<string> args{};

  InvokeThingsServiceRequest() {}

  explicit InvokeThingsServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!identifier) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("identifier is required.")));
    }
    if (!args) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("args is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (args) {
      res["Args"] = boost::any(*args);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Args") != m.end() && !m["Args"].empty()) {
      args = make_shared<string>(boost::any_cast<string>(m["Args"]));
    }
  }


  virtual ~InvokeThingsServiceRequest() = default;
};
class InvokeThingsServiceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};

  InvokeThingsServiceResponse() {}

  explicit InvokeThingsServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~InvokeThingsServiceResponse() = default;
};
class SetDeviceGroupTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> tagString{};

  SetDeviceGroupTagsRequest() {}

  explicit SetDeviceGroupTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (tagString) {
      res["TagString"] = boost::any(*tagString);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("TagString") != m.end() && !m["TagString"].empty()) {
      tagString = make_shared<string>(boost::any_cast<string>(m["TagString"]));
    }
  }


  virtual ~SetDeviceGroupTagsRequest() = default;
};
class SetDeviceGroupTagsResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  SetDeviceGroupTagsResponse() {}

  explicit SetDeviceGroupTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~SetDeviceGroupTagsResponse() = default;
};
class QueryAppDeviceListRequestTagList : public Darabonba::Model {
public:
  shared_ptr<string> tagName{};
  shared_ptr<string> tagValue{};

  QueryAppDeviceListRequestTagList() {}

  explicit QueryAppDeviceListRequestTagList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~QueryAppDeviceListRequestTagList() = default;
};
class QueryAppDeviceListRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<int> pageSize{};
  shared_ptr<vector<string>> productKeyList{};
  shared_ptr<vector<string>> categoryKeyList{};
  shared_ptr<string> appKey{};
  shared_ptr<vector<QueryAppDeviceListRequestTagList>> tagList{};
  shared_ptr<int> currentPage{};

  QueryAppDeviceListRequest() {}

  explicit QueryAppDeviceListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKeyList) {
      res["ProductKeyList"] = boost::any(*productKeyList);
    }
    if (categoryKeyList) {
      res["CategoryKeyList"] = boost::any(*categoryKeyList);
    }
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (tagList) {
      vector<boost::any> temp1;
      for(auto item1:*tagList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagList"] = boost::any(temp1);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ProductKeyList") != m.end() && !m["ProductKeyList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProductKeyList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProductKeyList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      productKeyList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CategoryKeyList") != m.end() && !m["CategoryKeyList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CategoryKeyList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CategoryKeyList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      categoryKeyList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("TagList") != m.end() && !m["TagList"].empty()) {
      if (typeid(vector<boost::any>) == m["TagList"].type()) {
        vector<QueryAppDeviceListRequestTagList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryAppDeviceListRequestTagList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagList = make_shared<vector<QueryAppDeviceListRequestTagList>>(expect1);
      }
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
  }


  virtual ~QueryAppDeviceListRequest() = default;
};
class QueryAppDeviceListResponseDataData : public Darabonba::Model {
public:
  shared_ptr<string> productName{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<int> nodeType{};
  shared_ptr<string> status{};
  shared_ptr<string> activeTime{};
  shared_ptr<string> lastOnlineTime{};
  shared_ptr<string> createTime{};
  shared_ptr<long> childDeviceCount{};
  shared_ptr<string> utcActiveTime{};
  shared_ptr<string> utcLastOnlineTime{};
  shared_ptr<string> utcCreateTime{};

  QueryAppDeviceListResponseDataData() {}

  explicit QueryAppDeviceListResponseDataData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productName is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!nodeType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeType is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!activeTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("activeTime is required.")));
    }
    if (!lastOnlineTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("lastOnlineTime is required.")));
    }
    if (!createTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createTime is required.")));
    }
    if (!childDeviceCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("childDeviceCount is required.")));
    }
    if (!utcActiveTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcActiveTime is required.")));
    }
    if (!utcLastOnlineTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcLastOnlineTime is required.")));
    }
    if (!utcCreateTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcCreateTime is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (activeTime) {
      res["ActiveTime"] = boost::any(*activeTime);
    }
    if (lastOnlineTime) {
      res["LastOnlineTime"] = boost::any(*lastOnlineTime);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (childDeviceCount) {
      res["ChildDeviceCount"] = boost::any(*childDeviceCount);
    }
    if (utcActiveTime) {
      res["UtcActiveTime"] = boost::any(*utcActiveTime);
    }
    if (utcLastOnlineTime) {
      res["UtcLastOnlineTime"] = boost::any(*utcLastOnlineTime);
    }
    if (utcCreateTime) {
      res["UtcCreateTime"] = boost::any(*utcCreateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<int>(boost::any_cast<int>(m["NodeType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ActiveTime") != m.end() && !m["ActiveTime"].empty()) {
      activeTime = make_shared<string>(boost::any_cast<string>(m["ActiveTime"]));
    }
    if (m.find("LastOnlineTime") != m.end() && !m["LastOnlineTime"].empty()) {
      lastOnlineTime = make_shared<string>(boost::any_cast<string>(m["LastOnlineTime"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ChildDeviceCount") != m.end() && !m["ChildDeviceCount"].empty()) {
      childDeviceCount = make_shared<long>(boost::any_cast<long>(m["ChildDeviceCount"]));
    }
    if (m.find("UtcActiveTime") != m.end() && !m["UtcActiveTime"].empty()) {
      utcActiveTime = make_shared<string>(boost::any_cast<string>(m["UtcActiveTime"]));
    }
    if (m.find("UtcLastOnlineTime") != m.end() && !m["UtcLastOnlineTime"].empty()) {
      utcLastOnlineTime = make_shared<string>(boost::any_cast<string>(m["UtcLastOnlineTime"]));
    }
    if (m.find("UtcCreateTime") != m.end() && !m["UtcCreateTime"].empty()) {
      utcCreateTime = make_shared<string>(boost::any_cast<string>(m["UtcCreateTime"]));
    }
  }


  virtual ~QueryAppDeviceListResponseDataData() = default;
};
class QueryAppDeviceListResponseData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryAppDeviceListResponseDataData>> data{};

  QueryAppDeviceListResponseData() {}

  explicit QueryAppDeviceListResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<QueryAppDeviceListResponseDataData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryAppDeviceListResponseDataData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<QueryAppDeviceListResponseDataData>>(expect1);
      }
    }
  }


  virtual ~QueryAppDeviceListResponseData() = default;
};
class QueryAppDeviceListResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<int> page{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> pageCount{};
  shared_ptr<int> total{};
  shared_ptr<QueryAppDeviceListResponseData> data{};

  QueryAppDeviceListResponse() {}

  explicit QueryAppDeviceListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!page) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("page is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!pageCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageCount is required.")));
    }
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<int>(boost::any_cast<int>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<int>(boost::any_cast<int>(m["PageCount"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryAppDeviceListResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryAppDeviceListResponseData>(model1);
      }
    }
  }


  virtual ~QueryAppDeviceListResponse() = default;
};
class UpdateDeviceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupDesc{};

  UpdateDeviceGroupRequest() {}

  explicit UpdateDeviceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupDesc) {
      res["GroupDesc"] = boost::any(*groupDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupDesc") != m.end() && !m["GroupDesc"].empty()) {
      groupDesc = make_shared<string>(boost::any_cast<string>(m["GroupDesc"]));
    }
  }


  virtual ~UpdateDeviceGroupRequest() = default;
};
class UpdateDeviceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateDeviceGroupResponse() {}

  explicit UpdateDeviceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateDeviceGroupResponse() = default;
};
class QueryDeviceGroupTagListRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> groupId{};

  QueryDeviceGroupTagListRequest() {}

  explicit QueryDeviceGroupTagListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~QueryDeviceGroupTagListRequest() = default;
};
class QueryDeviceGroupTagListResponseDataGroupTagInfo : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  QueryDeviceGroupTagListResponseDataGroupTagInfo() {}

  explicit QueryDeviceGroupTagListResponseDataGroupTagInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!tagKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tagKey is required.")));
    }
    if (!tagValue) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("tagValue is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~QueryDeviceGroupTagListResponseDataGroupTagInfo() = default;
};
class QueryDeviceGroupTagListResponseData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceGroupTagListResponseDataGroupTagInfo>> groupTagInfo{};

  QueryDeviceGroupTagListResponseData() {}

  explicit QueryDeviceGroupTagListResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!groupTagInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupTagInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupTagInfo) {
      vector<boost::any> temp1;
      for(auto item1:*groupTagInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupTagInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupTagInfo") != m.end() && !m["GroupTagInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupTagInfo"].type()) {
        vector<QueryDeviceGroupTagListResponseDataGroupTagInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupTagInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceGroupTagListResponseDataGroupTagInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupTagInfo = make_shared<vector<QueryDeviceGroupTagListResponseDataGroupTagInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceGroupTagListResponseData() = default;
};
class QueryDeviceGroupTagListResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceGroupTagListResponseData> data{};

  QueryDeviceGroupTagListResponse() {}

  explicit QueryDeviceGroupTagListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceGroupTagListResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceGroupTagListResponseData>(model1);
      }
    }
  }


  virtual ~QueryDeviceGroupTagListResponse() = default;
};
class QueryDeviceGroupListRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> superGroupId{};
  shared_ptr<string> groupName{};
  shared_ptr<int> currentPage{};

  QueryDeviceGroupListRequest() {}

  explicit QueryDeviceGroupListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (superGroupId) {
      res["SuperGroupId"] = boost::any(*superGroupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("SuperGroupId") != m.end() && !m["SuperGroupId"].empty()) {
      superGroupId = make_shared<string>(boost::any_cast<string>(m["SuperGroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
  }


  virtual ~QueryDeviceGroupListRequest() = default;
};
class QueryDeviceGroupListResponseDataGroupInfo : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> groupName{};
  shared_ptr<string> groupDesc{};

  QueryDeviceGroupListResponseDataGroupInfo() {}

  explicit QueryDeviceGroupListResponseDataGroupInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
    if (!utcCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcCreate is required.")));
    }
    if (!groupName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupName is required.")));
    }
    if (!groupDesc) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupDesc is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupDesc) {
      res["GroupDesc"] = boost::any(*groupDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupDesc") != m.end() && !m["GroupDesc"].empty()) {
      groupDesc = make_shared<string>(boost::any_cast<string>(m["GroupDesc"]));
    }
  }


  virtual ~QueryDeviceGroupListResponseDataGroupInfo() = default;
};
class QueryDeviceGroupListResponseData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceGroupListResponseDataGroupInfo>> groupInfo{};

  QueryDeviceGroupListResponseData() {}

  explicit QueryDeviceGroupListResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!groupInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupInfo) {
      vector<boost::any> temp1;
      for(auto item1:*groupInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupInfo") != m.end() && !m["GroupInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupInfo"].type()) {
        vector<QueryDeviceGroupListResponseDataGroupInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceGroupListResponseDataGroupInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupInfo = make_shared<vector<QueryDeviceGroupListResponseDataGroupInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceGroupListResponseData() = default;
};
class QueryDeviceGroupListResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> currentPage{};
  shared_ptr<int> pageCount{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> total{};
  shared_ptr<QueryDeviceGroupListResponseData> data{};

  QueryDeviceGroupListResponse() {}

  explicit QueryDeviceGroupListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!pageCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageCount is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<int>(boost::any_cast<int>(m["PageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceGroupListResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceGroupListResponseData>(model1);
      }
    }
  }


  virtual ~QueryDeviceGroupListResponse() = default;
};
class QueryDeviceGroupInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> groupId{};

  QueryDeviceGroupInfoRequest() {}

  explicit QueryDeviceGroupInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~QueryDeviceGroupInfoRequest() = default;
};
class QueryDeviceGroupInfoResponseData : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> groupName{};
  shared_ptr<string> groupDesc{};
  shared_ptr<int> deviceCount{};
  shared_ptr<int> deviceActive{};
  shared_ptr<int> deviceOnline{};

  QueryDeviceGroupInfoResponseData() {}

  explicit QueryDeviceGroupInfoResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
    if (!utcCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcCreate is required.")));
    }
    if (!groupName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupName is required.")));
    }
    if (!groupDesc) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupDesc is required.")));
    }
    if (!deviceCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceCount is required.")));
    }
    if (!deviceActive) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceActive is required.")));
    }
    if (!deviceOnline) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceOnline is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupDesc) {
      res["GroupDesc"] = boost::any(*groupDesc);
    }
    if (deviceCount) {
      res["DeviceCount"] = boost::any(*deviceCount);
    }
    if (deviceActive) {
      res["DeviceActive"] = boost::any(*deviceActive);
    }
    if (deviceOnline) {
      res["DeviceOnline"] = boost::any(*deviceOnline);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupDesc") != m.end() && !m["GroupDesc"].empty()) {
      groupDesc = make_shared<string>(boost::any_cast<string>(m["GroupDesc"]));
    }
    if (m.find("DeviceCount") != m.end() && !m["DeviceCount"].empty()) {
      deviceCount = make_shared<int>(boost::any_cast<int>(m["DeviceCount"]));
    }
    if (m.find("DeviceActive") != m.end() && !m["DeviceActive"].empty()) {
      deviceActive = make_shared<int>(boost::any_cast<int>(m["DeviceActive"]));
    }
    if (m.find("DeviceOnline") != m.end() && !m["DeviceOnline"].empty()) {
      deviceOnline = make_shared<int>(boost::any_cast<int>(m["DeviceOnline"]));
    }
  }


  virtual ~QueryDeviceGroupInfoResponseData() = default;
};
class QueryDeviceGroupInfoResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceGroupInfoResponseData> data{};

  QueryDeviceGroupInfoResponse() {}

  explicit QueryDeviceGroupInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceGroupInfoResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceGroupInfoResponseData>(model1);
      }
    }
  }


  virtual ~QueryDeviceGroupInfoResponse() = default;
};
class QueryDeviceGroupByDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};

  QueryDeviceGroupByDeviceRequest() {}

  explicit QueryDeviceGroupByDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
  }


  virtual ~QueryDeviceGroupByDeviceRequest() = default;
};
class QueryDeviceGroupByDeviceResponseGroupInfosGroupInfo : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> groupDesc{};

  QueryDeviceGroupByDeviceResponseGroupInfosGroupInfo() {}

  explicit QueryDeviceGroupByDeviceResponseGroupInfosGroupInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
    if (!groupName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupName is required.")));
    }
    if (!utcCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcCreate is required.")));
    }
    if (!groupDesc) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupDesc is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (groupDesc) {
      res["GroupDesc"] = boost::any(*groupDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("GroupDesc") != m.end() && !m["GroupDesc"].empty()) {
      groupDesc = make_shared<string>(boost::any_cast<string>(m["GroupDesc"]));
    }
  }


  virtual ~QueryDeviceGroupByDeviceResponseGroupInfosGroupInfo() = default;
};
class QueryDeviceGroupByDeviceResponseGroupInfos : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceGroupByDeviceResponseGroupInfosGroupInfo>> groupInfo{};

  QueryDeviceGroupByDeviceResponseGroupInfos() {}

  explicit QueryDeviceGroupByDeviceResponseGroupInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!groupInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupInfo) {
      vector<boost::any> temp1;
      for(auto item1:*groupInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupInfo") != m.end() && !m["GroupInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupInfo"].type()) {
        vector<QueryDeviceGroupByDeviceResponseGroupInfosGroupInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceGroupByDeviceResponseGroupInfosGroupInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupInfo = make_shared<vector<QueryDeviceGroupByDeviceResponseGroupInfosGroupInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceGroupByDeviceResponseGroupInfos() = default;
};
class QueryDeviceGroupByDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceGroupByDeviceResponseGroupInfos> groupInfos{};

  QueryDeviceGroupByDeviceResponse() {}

  explicit QueryDeviceGroupByDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!groupInfos) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupInfos is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (groupInfos) {
      res["GroupInfos"] = groupInfos ? boost::any(groupInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("GroupInfos") != m.end() && !m["GroupInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["GroupInfos"].type()) {
        QueryDeviceGroupByDeviceResponseGroupInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GroupInfos"]));
        groupInfos = make_shared<QueryDeviceGroupByDeviceResponseGroupInfos>(model1);
      }
    }
  }


  virtual ~QueryDeviceGroupByDeviceResponse() = default;
};
class DeleteDeviceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> groupId{};

  DeleteDeviceGroupRequest() {}

  explicit DeleteDeviceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~DeleteDeviceGroupRequest() = default;
};
class DeleteDeviceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteDeviceGroupResponse() {}

  explicit DeleteDeviceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteDeviceGroupResponse() = default;
};
class CreateDeviceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> superGroupId{};
  shared_ptr<string> groupDesc{};
  shared_ptr<string> groupName{};

  CreateDeviceGroupRequest() {}

  explicit CreateDeviceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!groupName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (superGroupId) {
      res["SuperGroupId"] = boost::any(*superGroupId);
    }
    if (groupDesc) {
      res["GroupDesc"] = boost::any(*groupDesc);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("SuperGroupId") != m.end() && !m["SuperGroupId"].empty()) {
      superGroupId = make_shared<string>(boost::any_cast<string>(m["SuperGroupId"]));
    }
    if (m.find("GroupDesc") != m.end() && !m["GroupDesc"].empty()) {
      groupDesc = make_shared<string>(boost::any_cast<string>(m["GroupDesc"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~CreateDeviceGroupRequest() = default;
};
class CreateDeviceGroupResponseData : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> groupName{};
  shared_ptr<string> groupDesc{};

  CreateDeviceGroupResponseData() {}

  explicit CreateDeviceGroupResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
    if (!utcCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcCreate is required.")));
    }
    if (!groupName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupName is required.")));
    }
    if (!groupDesc) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupDesc is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupDesc) {
      res["GroupDesc"] = boost::any(*groupDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupDesc") != m.end() && !m["GroupDesc"].empty()) {
      groupDesc = make_shared<string>(boost::any_cast<string>(m["GroupDesc"]));
    }
  }


  virtual ~CreateDeviceGroupResponseData() = default;
};
class CreateDeviceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<CreateDeviceGroupResponseData> data{};

  CreateDeviceGroupResponse() {}

  explicit CreateDeviceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateDeviceGroupResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateDeviceGroupResponseData>(model1);
      }
    }
  }


  virtual ~CreateDeviceGroupResponse() = default;
};
class BatchDeleteDeviceGroupRelationsRequestDevice : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};

  BatchDeleteDeviceGroupRelationsRequestDevice() {}

  explicit BatchDeleteDeviceGroupRelationsRequestDevice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
  }


  virtual ~BatchDeleteDeviceGroupRelationsRequestDevice() = default;
};
class BatchDeleteDeviceGroupRelationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> groupId{};
  shared_ptr<vector<BatchDeleteDeviceGroupRelationsRequestDevice>> device{};

  BatchDeleteDeviceGroupRelationsRequest() {}

  explicit BatchDeleteDeviceGroupRelationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (device) {
      vector<boost::any> temp1;
      for(auto item1:*device){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Device"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      if (typeid(vector<boost::any>) == m["Device"].type()) {
        vector<BatchDeleteDeviceGroupRelationsRequestDevice> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Device"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchDeleteDeviceGroupRelationsRequestDevice model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        device = make_shared<vector<BatchDeleteDeviceGroupRelationsRequestDevice>>(expect1);
      }
    }
  }


  virtual ~BatchDeleteDeviceGroupRelationsRequest() = default;
};
class BatchDeleteDeviceGroupRelationsResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> validDeviceCount{};
  shared_ptr<int> alreadyRelatedGroupDeviceCount{};
  shared_ptr<int> successDeviceCount{};

  BatchDeleteDeviceGroupRelationsResponse() {}

  explicit BatchDeleteDeviceGroupRelationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!validDeviceCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("validDeviceCount is required.")));
    }
    if (!alreadyRelatedGroupDeviceCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("alreadyRelatedGroupDeviceCount is required.")));
    }
    if (!successDeviceCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("successDeviceCount is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (validDeviceCount) {
      res["ValidDeviceCount"] = boost::any(*validDeviceCount);
    }
    if (alreadyRelatedGroupDeviceCount) {
      res["AlreadyRelatedGroupDeviceCount"] = boost::any(*alreadyRelatedGroupDeviceCount);
    }
    if (successDeviceCount) {
      res["SuccessDeviceCount"] = boost::any(*successDeviceCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ValidDeviceCount") != m.end() && !m["ValidDeviceCount"].empty()) {
      validDeviceCount = make_shared<int>(boost::any_cast<int>(m["ValidDeviceCount"]));
    }
    if (m.find("AlreadyRelatedGroupDeviceCount") != m.end() && !m["AlreadyRelatedGroupDeviceCount"].empty()) {
      alreadyRelatedGroupDeviceCount = make_shared<int>(boost::any_cast<int>(m["AlreadyRelatedGroupDeviceCount"]));
    }
    if (m.find("SuccessDeviceCount") != m.end() && !m["SuccessDeviceCount"].empty()) {
      successDeviceCount = make_shared<int>(boost::any_cast<int>(m["SuccessDeviceCount"]));
    }
  }


  virtual ~BatchDeleteDeviceGroupRelationsResponse() = default;
};
class BatchAddDeviceGroupRelationsRequestDevice : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};

  BatchAddDeviceGroupRelationsRequestDevice() {}

  explicit BatchAddDeviceGroupRelationsRequestDevice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
  }


  virtual ~BatchAddDeviceGroupRelationsRequestDevice() = default;
};
class BatchAddDeviceGroupRelationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> groupId{};
  shared_ptr<vector<BatchAddDeviceGroupRelationsRequestDevice>> device{};

  BatchAddDeviceGroupRelationsRequest() {}

  explicit BatchAddDeviceGroupRelationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!groupId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("groupId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (device) {
      vector<boost::any> temp1;
      for(auto item1:*device){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Device"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      if (typeid(vector<boost::any>) == m["Device"].type()) {
        vector<BatchAddDeviceGroupRelationsRequestDevice> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Device"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchAddDeviceGroupRelationsRequestDevice model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        device = make_shared<vector<BatchAddDeviceGroupRelationsRequestDevice>>(expect1);
      }
    }
  }


  virtual ~BatchAddDeviceGroupRelationsRequest() = default;
};
class BatchAddDeviceGroupRelationsResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<int> validDeviceCount{};
  shared_ptr<int> exceedTenGroupDeviceCount{};
  shared_ptr<int> alreadyRelatedGroupDeviceCount{};
  shared_ptr<int> successAddedDeviceCount{};
  shared_ptr<string> errorMessage{};

  BatchAddDeviceGroupRelationsResponse() {}

  explicit BatchAddDeviceGroupRelationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!validDeviceCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("validDeviceCount is required.")));
    }
    if (!exceedTenGroupDeviceCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("exceedTenGroupDeviceCount is required.")));
    }
    if (!alreadyRelatedGroupDeviceCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("alreadyRelatedGroupDeviceCount is required.")));
    }
    if (!successAddedDeviceCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("successAddedDeviceCount is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (validDeviceCount) {
      res["ValidDeviceCount"] = boost::any(*validDeviceCount);
    }
    if (exceedTenGroupDeviceCount) {
      res["ExceedTenGroupDeviceCount"] = boost::any(*exceedTenGroupDeviceCount);
    }
    if (alreadyRelatedGroupDeviceCount) {
      res["AlreadyRelatedGroupDeviceCount"] = boost::any(*alreadyRelatedGroupDeviceCount);
    }
    if (successAddedDeviceCount) {
      res["SuccessAddedDeviceCount"] = boost::any(*successAddedDeviceCount);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ValidDeviceCount") != m.end() && !m["ValidDeviceCount"].empty()) {
      validDeviceCount = make_shared<int>(boost::any_cast<int>(m["ValidDeviceCount"]));
    }
    if (m.find("ExceedTenGroupDeviceCount") != m.end() && !m["ExceedTenGroupDeviceCount"].empty()) {
      exceedTenGroupDeviceCount = make_shared<int>(boost::any_cast<int>(m["ExceedTenGroupDeviceCount"]));
    }
    if (m.find("AlreadyRelatedGroupDeviceCount") != m.end() && !m["AlreadyRelatedGroupDeviceCount"].empty()) {
      alreadyRelatedGroupDeviceCount = make_shared<int>(boost::any_cast<int>(m["AlreadyRelatedGroupDeviceCount"]));
    }
    if (m.find("SuccessAddedDeviceCount") != m.end() && !m["SuccessAddedDeviceCount"].empty()) {
      successAddedDeviceCount = make_shared<int>(boost::any_cast<int>(m["SuccessAddedDeviceCount"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~BatchAddDeviceGroupRelationsResponse() = default;
};
class RRpcRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<int> timeout{};
  shared_ptr<string> requestBase64Byte{};
  shared_ptr<string> topic{};

  RRpcRequest() {}

  explicit RRpcRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!timeout) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("timeout is required.")));
    }
    if (!requestBase64Byte) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestBase64Byte is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (requestBase64Byte) {
      res["RequestBase64Byte"] = boost::any(*requestBase64Byte);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<int>(boost::any_cast<int>(m["Timeout"]));
    }
    if (m.find("RequestBase64Byte") != m.end() && !m["RequestBase64Byte"].empty()) {
      requestBase64Byte = make_shared<string>(boost::any_cast<string>(m["RequestBase64Byte"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~RRpcRequest() = default;
};
class RRpcResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> rrpcCode{};
  shared_ptr<string> payloadBase64Byte{};
  shared_ptr<long> messageId{};

  RRpcResponse() {}

  explicit RRpcResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!rrpcCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("rrpcCode is required.")));
    }
    if (!payloadBase64Byte) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("payloadBase64Byte is required.")));
    }
    if (!messageId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("messageId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (rrpcCode) {
      res["RrpcCode"] = boost::any(*rrpcCode);
    }
    if (payloadBase64Byte) {
      res["PayloadBase64Byte"] = boost::any(*payloadBase64Byte);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RrpcCode") != m.end() && !m["RrpcCode"].empty()) {
      rrpcCode = make_shared<string>(boost::any_cast<string>(m["RrpcCode"]));
    }
    if (m.find("PayloadBase64Byte") != m.end() && !m["PayloadBase64Byte"].empty()) {
      payloadBase64Byte = make_shared<string>(boost::any_cast<string>(m["PayloadBase64Byte"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<long>(boost::any_cast<long>(m["MessageId"]));
    }
  }


  virtual ~RRpcResponse() = default;
};
class QueryPageByApplyIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<int> pageSize{};
  shared_ptr<long> applyId{};
  shared_ptr<int> currentPage{};

  QueryPageByApplyIdRequest() {}

  explicit QueryPageByApplyIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!applyId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applyId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (applyId) {
      res["ApplyId"] = boost::any(*applyId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ApplyId") != m.end() && !m["ApplyId"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["ApplyId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
  }


  virtual ~QueryPageByApplyIdRequest() = default;
};
class QueryPageByApplyIdResponseApplyDeviceListApplyDeviceInfo : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceSecret{};
  shared_ptr<string> iotId{};

  QueryPageByApplyIdResponseApplyDeviceListApplyDeviceInfo() {}

  explicit QueryPageByApplyIdResponseApplyDeviceListApplyDeviceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!deviceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceId is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!deviceSecret) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceSecret is required.")));
    }
    if (!iotId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceSecret) {
      res["DeviceSecret"] = boost::any(*deviceSecret);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceSecret") != m.end() && !m["DeviceSecret"].empty()) {
      deviceSecret = make_shared<string>(boost::any_cast<string>(m["DeviceSecret"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~QueryPageByApplyIdResponseApplyDeviceListApplyDeviceInfo() = default;
};
class QueryPageByApplyIdResponseApplyDeviceList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryPageByApplyIdResponseApplyDeviceListApplyDeviceInfo>> applyDeviceInfo{};

  QueryPageByApplyIdResponseApplyDeviceList() {}

  explicit QueryPageByApplyIdResponseApplyDeviceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!applyDeviceInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applyDeviceInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyDeviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*applyDeviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApplyDeviceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyDeviceInfo") != m.end() && !m["ApplyDeviceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ApplyDeviceInfo"].type()) {
        vector<QueryPageByApplyIdResponseApplyDeviceListApplyDeviceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApplyDeviceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryPageByApplyIdResponseApplyDeviceListApplyDeviceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applyDeviceInfo = make_shared<vector<QueryPageByApplyIdResponseApplyDeviceListApplyDeviceInfo>>(expect1);
      }
    }
  }


  virtual ~QueryPageByApplyIdResponseApplyDeviceList() = default;
};
class QueryPageByApplyIdResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> page{};
  shared_ptr<int> pageCount{};
  shared_ptr<int> total{};
  shared_ptr<QueryPageByApplyIdResponseApplyDeviceList> applyDeviceList{};

  QueryPageByApplyIdResponse() {}

  explicit QueryPageByApplyIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!page) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("page is required.")));
    }
    if (!pageCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageCount is required.")));
    }
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!applyDeviceList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applyDeviceList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (applyDeviceList) {
      res["ApplyDeviceList"] = applyDeviceList ? boost::any(applyDeviceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<int>(boost::any_cast<int>(m["Page"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<int>(boost::any_cast<int>(m["PageCount"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("ApplyDeviceList") != m.end() && !m["ApplyDeviceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApplyDeviceList"].type()) {
        QueryPageByApplyIdResponseApplyDeviceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApplyDeviceList"]));
        applyDeviceList = make_shared<QueryPageByApplyIdResponseApplyDeviceList>(model1);
      }
    }
  }


  virtual ~QueryPageByApplyIdResponse() = default;
};
class QueryDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<int> currentPage{};

  QueryDeviceRequest() {}

  explicit QueryDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
  }


  virtual ~QueryDeviceRequest() = default;
};
class QueryDeviceResponseDataDeviceInfo : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceSecret{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceStatus{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceType{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> utcModified{};
  shared_ptr<string> iotId{};
  shared_ptr<string> nickname{};

  QueryDeviceResponseDataDeviceInfo() {}

  explicit QueryDeviceResponseDataDeviceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!deviceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceId is required.")));
    }
    if (!deviceSecret) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceSecret is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceStatus is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!deviceType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceType is required.")));
    }
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!gmtModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtModified is required.")));
    }
    if (!utcCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcCreate is required.")));
    }
    if (!utcModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcModified is required.")));
    }
    if (!iotId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotId is required.")));
    }
    if (!nickname) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nickname is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceSecret) {
      res["DeviceSecret"] = boost::any(*deviceSecret);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceStatus) {
      res["DeviceStatus"] = boost::any(*deviceStatus);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceSecret") != m.end() && !m["DeviceSecret"].empty()) {
      deviceSecret = make_shared<string>(boost::any_cast<string>(m["DeviceSecret"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceStatus") != m.end() && !m["DeviceStatus"].empty()) {
      deviceStatus = make_shared<string>(boost::any_cast<string>(m["DeviceStatus"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
  }


  virtual ~QueryDeviceResponseDataDeviceInfo() = default;
};
class QueryDeviceResponseData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceResponseDataDeviceInfo>> deviceInfo{};

  QueryDeviceResponseData() {}

  explicit QueryDeviceResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!deviceInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*deviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceInfo") != m.end() && !m["DeviceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceInfo"].type()) {
        vector<QueryDeviceResponseDataDeviceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceResponseDataDeviceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceInfo = make_shared<vector<QueryDeviceResponseDataDeviceInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceResponseData() = default;
};
class QueryDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> total{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> pageCount{};
  shared_ptr<int> page{};
  shared_ptr<QueryDeviceResponseData> data{};

  QueryDeviceResponse() {}

  explicit QueryDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!pageCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageCount is required.")));
    }
    if (!page) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("page is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<int>(boost::any_cast<int>(m["PageCount"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<int>(boost::any_cast<int>(m["Page"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceResponseData>(model1);
      }
    }
  }


  virtual ~QueryDeviceResponse() = default;
};
class SaveDevicePropRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> props{};
  shared_ptr<string> iotId{};

  SaveDevicePropRequest() {}

  explicit SaveDevicePropRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!props) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("props is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (props) {
      res["Props"] = boost::any(*props);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Props") != m.end() && !m["Props"].empty()) {
      props = make_shared<string>(boost::any_cast<string>(m["Props"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~SaveDevicePropRequest() = default;
};
class SaveDevicePropResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  SaveDevicePropResponse() {}

  explicit SaveDevicePropResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~SaveDevicePropResponse() = default;
};
class QueryTopicRouteTableRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> topic{};

  QueryTopicRouteTableRequest() {}

  explicit QueryTopicRouteTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!topic) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topic is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~QueryTopicRouteTableRequest() = default;
};
class QueryTopicRouteTableResponseDstTopics : public Darabonba::Model {
public:
  shared_ptr<vector<map<string, boost::any>>> topic{};

  QueryTopicRouteTableResponseDstTopics() {}

  explicit QueryTopicRouteTableResponseDstTopics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!topic) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topic is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Topic"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Topic"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      topic = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
  }


  virtual ~QueryTopicRouteTableResponseDstTopics() = default;
};
class QueryTopicRouteTableResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryTopicRouteTableResponseDstTopics> dstTopics{};

  QueryTopicRouteTableResponse() {}

  explicit QueryTopicRouteTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!dstTopics) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dstTopics is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (dstTopics) {
      res["DstTopics"] = dstTopics ? boost::any(dstTopics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("DstTopics") != m.end() && !m["DstTopics"].empty()) {
      if (typeid(map<string, boost::any>) == m["DstTopics"].type()) {
        QueryTopicRouteTableResponseDstTopics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DstTopics"]));
        dstTopics = make_shared<QueryTopicRouteTableResponseDstTopics>(model1);
      }
    }
  }


  virtual ~QueryTopicRouteTableResponse() = default;
};
class QueryTopicReverseRouteTableRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> topic{};

  QueryTopicReverseRouteTableRequest() {}

  explicit QueryTopicReverseRouteTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!topic) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topic is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~QueryTopicReverseRouteTableRequest() = default;
};
class QueryTopicReverseRouteTableResponseSrcTopics : public Darabonba::Model {
public:
  shared_ptr<vector<map<string, boost::any>>> topic{};

  QueryTopicReverseRouteTableResponseSrcTopics() {}

  explicit QueryTopicReverseRouteTableResponseSrcTopics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!topic) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topic is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Topic"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Topic"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      topic = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
  }


  virtual ~QueryTopicReverseRouteTableResponseSrcTopics() = default;
};
class QueryTopicReverseRouteTableResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryTopicReverseRouteTableResponseSrcTopics> srcTopics{};

  QueryTopicReverseRouteTableResponse() {}

  explicit QueryTopicReverseRouteTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!srcTopics) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("srcTopics is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (srcTopics) {
      res["SrcTopics"] = srcTopics ? boost::any(srcTopics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("SrcTopics") != m.end() && !m["SrcTopics"].empty()) {
      if (typeid(map<string, boost::any>) == m["SrcTopics"].type()) {
        QueryTopicReverseRouteTableResponseSrcTopics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SrcTopics"]));
        srcTopics = make_shared<QueryTopicReverseRouteTableResponseSrcTopics>(model1);
      }
    }
  }


  virtual ~QueryTopicReverseRouteTableResponse() = default;
};
class PubBroadcastRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> topicFullName{};
  shared_ptr<string> messageContent{};

  PubBroadcastRequest() {}

  explicit PubBroadcastRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!messageContent) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("messageContent is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (topicFullName) {
      res["TopicFullName"] = boost::any(*topicFullName);
    }
    if (messageContent) {
      res["MessageContent"] = boost::any(*messageContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("TopicFullName") != m.end() && !m["TopicFullName"].empty()) {
      topicFullName = make_shared<string>(boost::any_cast<string>(m["TopicFullName"]));
    }
    if (m.find("MessageContent") != m.end() && !m["MessageContent"].empty()) {
      messageContent = make_shared<string>(boost::any_cast<string>(m["MessageContent"]));
    }
  }


  virtual ~PubBroadcastRequest() = default;
};
class PubBroadcastResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> messageId{};

  PubBroadcastResponse() {}

  explicit PubBroadcastResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!messageId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("messageId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<long>(boost::any_cast<long>(m["MessageId"]));
    }
  }


  virtual ~PubBroadcastResponse() = default;
};
class DeleteTopicRouteTableRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<string>> dstTopic{};
  shared_ptr<string> srcTopic{};

  DeleteTopicRouteTableRequest() {}

  explicit DeleteTopicRouteTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!dstTopic) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dstTopic is required.")));
    }
    if (!srcTopic) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("srcTopic is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (dstTopic) {
      res["DstTopic"] = boost::any(*dstTopic);
    }
    if (srcTopic) {
      res["SrcTopic"] = boost::any(*srcTopic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("DstTopic") != m.end() && !m["DstTopic"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DstTopic"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DstTopic"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dstTopic = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SrcTopic") != m.end() && !m["SrcTopic"].empty()) {
      srcTopic = make_shared<string>(boost::any_cast<string>(m["SrcTopic"]));
    }
  }


  virtual ~DeleteTopicRouteTableRequest() = default;
};
class DeleteTopicRouteTableResponseFailureTopics : public Darabonba::Model {
public:
  shared_ptr<vector<map<string, boost::any>>> topic{};

  DeleteTopicRouteTableResponseFailureTopics() {}

  explicit DeleteTopicRouteTableResponseFailureTopics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!topic) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topic is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Topic"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Topic"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      topic = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
  }


  virtual ~DeleteTopicRouteTableResponseFailureTopics() = default;
};
class DeleteTopicRouteTableResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<bool> isAllSucceed{};
  shared_ptr<string> errorMessage{};
  shared_ptr<DeleteTopicRouteTableResponseFailureTopics> failureTopics{};

  DeleteTopicRouteTableResponse() {}

  explicit DeleteTopicRouteTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!isAllSucceed) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isAllSucceed is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!failureTopics) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("failureTopics is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (isAllSucceed) {
      res["IsAllSucceed"] = boost::any(*isAllSucceed);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (failureTopics) {
      res["FailureTopics"] = failureTopics ? boost::any(failureTopics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("IsAllSucceed") != m.end() && !m["IsAllSucceed"].empty()) {
      isAllSucceed = make_shared<bool>(boost::any_cast<bool>(m["IsAllSucceed"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("FailureTopics") != m.end() && !m["FailureTopics"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailureTopics"].type()) {
        DeleteTopicRouteTableResponseFailureTopics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailureTopics"]));
        failureTopics = make_shared<DeleteTopicRouteTableResponseFailureTopics>(model1);
      }
    }
  }


  virtual ~DeleteTopicRouteTableResponse() = default;
};
class DeleteDevicePropRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> propKey{};
  shared_ptr<string> iotId{};

  DeleteDevicePropRequest() {}

  explicit DeleteDevicePropRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!propKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("propKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (propKey) {
      res["PropKey"] = boost::any(*propKey);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("PropKey") != m.end() && !m["PropKey"].empty()) {
      propKey = make_shared<string>(boost::any_cast<string>(m["PropKey"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~DeleteDevicePropRequest() = default;
};
class DeleteDevicePropResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteDevicePropResponse() {}

  explicit DeleteDevicePropResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteDevicePropResponse() = default;
};
class CreateTopicRouteTableRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<vector<string>> dstTopic{};
  shared_ptr<string> srcTopic{};

  CreateTopicRouteTableRequest() {}

  explicit CreateTopicRouteTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!dstTopic) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dstTopic is required.")));
    }
    if (!srcTopic) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("srcTopic is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (dstTopic) {
      res["DstTopic"] = boost::any(*dstTopic);
    }
    if (srcTopic) {
      res["SrcTopic"] = boost::any(*srcTopic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("DstTopic") != m.end() && !m["DstTopic"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DstTopic"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DstTopic"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dstTopic = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SrcTopic") != m.end() && !m["SrcTopic"].empty()) {
      srcTopic = make_shared<string>(boost::any_cast<string>(m["SrcTopic"]));
    }
  }


  virtual ~CreateTopicRouteTableRequest() = default;
};
class CreateTopicRouteTableResponseFailureTopics : public Darabonba::Model {
public:
  shared_ptr<vector<map<string, boost::any>>> topic{};

  CreateTopicRouteTableResponseFailureTopics() {}

  explicit CreateTopicRouteTableResponseFailureTopics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!topic) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topic is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Topic"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Topic"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      topic = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
  }


  virtual ~CreateTopicRouteTableResponseFailureTopics() = default;
};
class CreateTopicRouteTableResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<bool> isAllSucceed{};
  shared_ptr<string> errorMessage{};
  shared_ptr<CreateTopicRouteTableResponseFailureTopics> failureTopics{};

  CreateTopicRouteTableResponse() {}

  explicit CreateTopicRouteTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!isAllSucceed) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("isAllSucceed is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!failureTopics) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("failureTopics is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (isAllSucceed) {
      res["IsAllSucceed"] = boost::any(*isAllSucceed);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (failureTopics) {
      res["FailureTopics"] = failureTopics ? boost::any(failureTopics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("IsAllSucceed") != m.end() && !m["IsAllSucceed"].empty()) {
      isAllSucceed = make_shared<bool>(boost::any_cast<bool>(m["IsAllSucceed"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("FailureTopics") != m.end() && !m["FailureTopics"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailureTopics"].type()) {
        CreateTopicRouteTableResponseFailureTopics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailureTopics"]));
        failureTopics = make_shared<CreateTopicRouteTableResponseFailureTopics>(model1);
      }
    }
  }


  virtual ~CreateTopicRouteTableResponse() = default;
};
class BatchGetDeviceStateRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> deviceName{};
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<vector<string>> iotId{};

  BatchGetDeviceStateRequest() {}

  explicit BatchGetDeviceStateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IotId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IotId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      iotId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchGetDeviceStateRequest() = default;
};
class BatchGetDeviceStateResponseDeviceStatusListDeviceStatus : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> status{};
  shared_ptr<string> asAddress{};
  shared_ptr<string> lastOnlineTime{};
  shared_ptr<string> iotId{};

  BatchGetDeviceStateResponseDeviceStatusListDeviceStatus() {}

  explicit BatchGetDeviceStateResponseDeviceStatusListDeviceStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!deviceId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceId is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!asAddress) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("asAddress is required.")));
    }
    if (!lastOnlineTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("lastOnlineTime is required.")));
    }
    if (!iotId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (asAddress) {
      res["AsAddress"] = boost::any(*asAddress);
    }
    if (lastOnlineTime) {
      res["LastOnlineTime"] = boost::any(*lastOnlineTime);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("AsAddress") != m.end() && !m["AsAddress"].empty()) {
      asAddress = make_shared<string>(boost::any_cast<string>(m["AsAddress"]));
    }
    if (m.find("LastOnlineTime") != m.end() && !m["LastOnlineTime"].empty()) {
      lastOnlineTime = make_shared<string>(boost::any_cast<string>(m["LastOnlineTime"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~BatchGetDeviceStateResponseDeviceStatusListDeviceStatus() = default;
};
class BatchGetDeviceStateResponseDeviceStatusList : public Darabonba::Model {
public:
  shared_ptr<vector<BatchGetDeviceStateResponseDeviceStatusListDeviceStatus>> deviceStatus{};

  BatchGetDeviceStateResponseDeviceStatusList() {}

  explicit BatchGetDeviceStateResponseDeviceStatusList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!deviceStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceStatus is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceStatus) {
      vector<boost::any> temp1;
      for(auto item1:*deviceStatus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceStatus"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceStatus") != m.end() && !m["DeviceStatus"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceStatus"].type()) {
        vector<BatchGetDeviceStateResponseDeviceStatusListDeviceStatus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceStatus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetDeviceStateResponseDeviceStatusListDeviceStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceStatus = make_shared<vector<BatchGetDeviceStateResponseDeviceStatusListDeviceStatus>>(expect1);
      }
    }
  }


  virtual ~BatchGetDeviceStateResponseDeviceStatusList() = default;
};
class BatchGetDeviceStateResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<BatchGetDeviceStateResponseDeviceStatusList> deviceStatusList{};

  BatchGetDeviceStateResponse() {}

  explicit BatchGetDeviceStateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!deviceStatusList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceStatusList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (deviceStatusList) {
      res["DeviceStatusList"] = deviceStatusList ? boost::any(deviceStatusList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("DeviceStatusList") != m.end() && !m["DeviceStatusList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeviceStatusList"].type()) {
        BatchGetDeviceStateResponseDeviceStatusList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeviceStatusList"]));
        deviceStatusList = make_shared<BatchGetDeviceStateResponseDeviceStatusList>(model1);
      }
    }
  }


  virtual ~BatchGetDeviceStateResponse() = default;
};
class UpdateRuleActionRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> actionId{};
  shared_ptr<string> type{};
  shared_ptr<string> configuration{};

  UpdateRuleActionRequest() {}

  explicit UpdateRuleActionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!actionId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("actionId is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
    if (!configuration) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("configuration is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (actionId) {
      res["ActionId"] = boost::any(*actionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (configuration) {
      res["Configuration"] = boost::any(*configuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ActionId") != m.end() && !m["ActionId"].empty()) {
      actionId = make_shared<long>(boost::any_cast<long>(m["ActionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configuration = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
  }


  virtual ~UpdateRuleActionRequest() = default;
};
class UpdateRuleActionResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};

  UpdateRuleActionResponse() {}

  explicit UpdateRuleActionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateRuleActionResponse() = default;
};
class UpdateRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> select{};
  shared_ptr<string> shortTopic{};
  shared_ptr<string> where{};
  shared_ptr<string> productKey{};
  shared_ptr<string> name{};
  shared_ptr<string> ruleDesc{};
  shared_ptr<int> topicType{};
  shared_ptr<string> topic{};

  UpdateRuleRequest() {}

  explicit UpdateRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!ruleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (select) {
      res["Select"] = boost::any(*select);
    }
    if (shortTopic) {
      res["ShortTopic"] = boost::any(*shortTopic);
    }
    if (where) {
      res["Where"] = boost::any(*where);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ruleDesc) {
      res["RuleDesc"] = boost::any(*ruleDesc);
    }
    if (topicType) {
      res["TopicType"] = boost::any(*topicType);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("Select") != m.end() && !m["Select"].empty()) {
      select = make_shared<string>(boost::any_cast<string>(m["Select"]));
    }
    if (m.find("ShortTopic") != m.end() && !m["ShortTopic"].empty()) {
      shortTopic = make_shared<string>(boost::any_cast<string>(m["ShortTopic"]));
    }
    if (m.find("Where") != m.end() && !m["Where"].empty()) {
      where = make_shared<string>(boost::any_cast<string>(m["Where"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RuleDesc") != m.end() && !m["RuleDesc"].empty()) {
      ruleDesc = make_shared<string>(boost::any_cast<string>(m["RuleDesc"]));
    }
    if (m.find("TopicType") != m.end() && !m["TopicType"].empty()) {
      topicType = make_shared<int>(boost::any_cast<int>(m["TopicType"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~UpdateRuleRequest() = default;
};
class UpdateRuleResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateRuleResponse() {}

  explicit UpdateRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateRuleResponse() = default;
};
class UpdateProductTopicRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> desc{};
  shared_ptr<string> operation{};
  shared_ptr<string> topicShortName{};
  shared_ptr<string> topicId{};

  UpdateProductTopicRequest() {}

  explicit UpdateProductTopicRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!operation) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("operation is required.")));
    }
    if (!topicShortName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topicShortName is required.")));
    }
    if (!topicId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topicId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (topicShortName) {
      res["TopicShortName"] = boost::any(*topicShortName);
    }
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("TopicShortName") != m.end() && !m["TopicShortName"].empty()) {
      topicShortName = make_shared<string>(boost::any_cast<string>(m["TopicShortName"]));
    }
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<string>(boost::any_cast<string>(m["TopicId"]));
    }
  }


  virtual ~UpdateProductTopicRequest() = default;
};
class UpdateProductTopicResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateProductTopicResponse() {}

  explicit UpdateProductTopicResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateProductTopicResponse() = default;
};
class UpdateDeviceShadowRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> shadowMessage{};
  shared_ptr<bool> deltaUpdate{};

  UpdateDeviceShadowRequest() {}

  explicit UpdateDeviceShadowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!shadowMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("shadowMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (shadowMessage) {
      res["ShadowMessage"] = boost::any(*shadowMessage);
    }
    if (deltaUpdate) {
      res["DeltaUpdate"] = boost::any(*deltaUpdate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("ShadowMessage") != m.end() && !m["ShadowMessage"].empty()) {
      shadowMessage = make_shared<string>(boost::any_cast<string>(m["ShadowMessage"]));
    }
    if (m.find("DeltaUpdate") != m.end() && !m["DeltaUpdate"].empty()) {
      deltaUpdate = make_shared<bool>(boost::any_cast<bool>(m["DeltaUpdate"]));
    }
  }


  virtual ~UpdateDeviceShadowRequest() = default;
};
class UpdateDeviceShadowResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateDeviceShadowResponse() {}

  explicit UpdateDeviceShadowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateDeviceShadowResponse() = default;
};
class StopRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> ruleId{};

  StopRuleRequest() {}

  explicit StopRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!ruleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~StopRuleRequest() = default;
};
class StopRuleResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  StopRuleResponse() {}

  explicit StopRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~StopRuleResponse() = default;
};
class StartRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> ruleId{};

  StartRuleRequest() {}

  explicit StartRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!ruleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~StartRuleRequest() = default;
};
class StartRuleResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  StartRuleResponse() {}

  explicit StartRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~StartRuleResponse() = default;
};
class QueryProductTopicRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  QueryProductTopicRequest() {}

  explicit QueryProductTopicRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryProductTopicRequest() = default;
};
class QueryProductTopicResponseDataProductTopicInfo : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> topicShortName{};
  shared_ptr<string> operation{};
  shared_ptr<string> desc{};
  shared_ptr<string> id{};

  QueryProductTopicResponseDataProductTopicInfo() {}

  explicit QueryProductTopicResponseDataProductTopicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!topicShortName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topicShortName is required.")));
    }
    if (!operation) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("operation is required.")));
    }
    if (!desc) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("desc is required.")));
    }
    if (!id) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("id is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (topicShortName) {
      res["TopicShortName"] = boost::any(*topicShortName);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("TopicShortName") != m.end() && !m["TopicShortName"].empty()) {
      topicShortName = make_shared<string>(boost::any_cast<string>(m["TopicShortName"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~QueryProductTopicResponseDataProductTopicInfo() = default;
};
class QueryProductTopicResponseData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryProductTopicResponseDataProductTopicInfo>> productTopicInfo{};

  QueryProductTopicResponseData() {}

  explicit QueryProductTopicResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productTopicInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productTopicInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productTopicInfo) {
      vector<boost::any> temp1;
      for(auto item1:*productTopicInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProductTopicInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductTopicInfo") != m.end() && !m["ProductTopicInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ProductTopicInfo"].type()) {
        vector<QueryProductTopicResponseDataProductTopicInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProductTopicInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryProductTopicResponseDataProductTopicInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        productTopicInfo = make_shared<vector<QueryProductTopicResponseDataProductTopicInfo>>(expect1);
      }
    }
  }


  virtual ~QueryProductTopicResponseData() = default;
};
class QueryProductTopicResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryProductTopicResponseData> data{};

  QueryProductTopicResponse() {}

  explicit QueryProductTopicResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryProductTopicResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryProductTopicResponseData>(model1);
      }
    }
  }


  virtual ~QueryProductTopicResponse() = default;
};
class QueryDevicePropRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};

  QueryDevicePropRequest() {}

  explicit QueryDevicePropRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~QueryDevicePropRequest() = default;
};
class QueryDevicePropResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> props{};

  QueryDevicePropResponse() {}

  explicit QueryDevicePropResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!props) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("props is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (props) {
      res["Props"] = boost::any(*props);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Props") != m.end() && !m["Props"].empty()) {
      props = make_shared<string>(boost::any_cast<string>(m["Props"]));
    }
  }


  virtual ~QueryDevicePropResponse() = default;
};
class PubRequestUserProp : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  PubRequestUserProp() {}

  explicit PubRequestUserProp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~PubRequestUserProp() = default;
};
class PubRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<int> qos{};
  shared_ptr<string> topicFullName{};
  shared_ptr<string> messageContent{};
  shared_ptr<string> responseTopic{};
  shared_ptr<string> correlationData{};
  shared_ptr<vector<PubRequestUserProp>> userProp{};

  PubRequest() {}

  explicit PubRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!topicFullName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topicFullName is required.")));
    }
    if (!messageContent) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("messageContent is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (qos) {
      res["Qos"] = boost::any(*qos);
    }
    if (topicFullName) {
      res["TopicFullName"] = boost::any(*topicFullName);
    }
    if (messageContent) {
      res["MessageContent"] = boost::any(*messageContent);
    }
    if (responseTopic) {
      res["ResponseTopic"] = boost::any(*responseTopic);
    }
    if (correlationData) {
      res["CorrelationData"] = boost::any(*correlationData);
    }
    if (userProp) {
      vector<boost::any> temp1;
      for(auto item1:*userProp){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserProp"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Qos") != m.end() && !m["Qos"].empty()) {
      qos = make_shared<int>(boost::any_cast<int>(m["Qos"]));
    }
    if (m.find("TopicFullName") != m.end() && !m["TopicFullName"].empty()) {
      topicFullName = make_shared<string>(boost::any_cast<string>(m["TopicFullName"]));
    }
    if (m.find("MessageContent") != m.end() && !m["MessageContent"].empty()) {
      messageContent = make_shared<string>(boost::any_cast<string>(m["MessageContent"]));
    }
    if (m.find("ResponseTopic") != m.end() && !m["ResponseTopic"].empty()) {
      responseTopic = make_shared<string>(boost::any_cast<string>(m["ResponseTopic"]));
    }
    if (m.find("CorrelationData") != m.end() && !m["CorrelationData"].empty()) {
      correlationData = make_shared<string>(boost::any_cast<string>(m["CorrelationData"]));
    }
    if (m.find("UserProp") != m.end() && !m["UserProp"].empty()) {
      if (typeid(vector<boost::any>) == m["UserProp"].type()) {
        vector<PubRequestUserProp> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserProp"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PubRequestUserProp model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userProp = make_shared<vector<PubRequestUserProp>>(expect1);
      }
    }
  }


  virtual ~PubRequest() = default;
};
class PubResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> messageId{};

  PubResponse() {}

  explicit PubResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!messageId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("messageId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~PubResponse() = default;
};
class ListRuleActionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> ruleId{};

  ListRuleActionsRequest() {}

  explicit ListRuleActionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!ruleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~ListRuleActionsRequest() = default;
};
class ListRuleActionsResponseRuleActionListRuleActionInfo : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> type{};
  shared_ptr<string> configuration{};
  shared_ptr<bool> errorActionFlag{};

  ListRuleActionsResponseRuleActionListRuleActionInfo() {}

  explicit ListRuleActionsResponseRuleActionListRuleActionInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!id) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("id is required.")));
    }
    if (!ruleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleId is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
    if (!configuration) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("configuration is required.")));
    }
    if (!errorActionFlag) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorActionFlag is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (configuration) {
      res["Configuration"] = boost::any(*configuration);
    }
    if (errorActionFlag) {
      res["ErrorActionFlag"] = boost::any(*errorActionFlag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configuration = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
    if (m.find("ErrorActionFlag") != m.end() && !m["ErrorActionFlag"].empty()) {
      errorActionFlag = make_shared<bool>(boost::any_cast<bool>(m["ErrorActionFlag"]));
    }
  }


  virtual ~ListRuleActionsResponseRuleActionListRuleActionInfo() = default;
};
class ListRuleActionsResponseRuleActionList : public Darabonba::Model {
public:
  shared_ptr<vector<ListRuleActionsResponseRuleActionListRuleActionInfo>> ruleActionInfo{};

  ListRuleActionsResponseRuleActionList() {}

  explicit ListRuleActionsResponseRuleActionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!ruleActionInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleActionInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleActionInfo) {
      vector<boost::any> temp1;
      for(auto item1:*ruleActionInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleActionInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleActionInfo") != m.end() && !m["RuleActionInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleActionInfo"].type()) {
        vector<ListRuleActionsResponseRuleActionListRuleActionInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleActionInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRuleActionsResponseRuleActionListRuleActionInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleActionInfo = make_shared<vector<ListRuleActionsResponseRuleActionListRuleActionInfo>>(expect1);
      }
    }
  }


  virtual ~ListRuleActionsResponseRuleActionList() = default;
};
class ListRuleActionsResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<ListRuleActionsResponseRuleActionList> ruleActionList{};

  ListRuleActionsResponse() {}

  explicit ListRuleActionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!ruleActionList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleActionList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (ruleActionList) {
      res["RuleActionList"] = ruleActionList ? boost::any(ruleActionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RuleActionList") != m.end() && !m["RuleActionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuleActionList"].type()) {
        ListRuleActionsResponseRuleActionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuleActionList"]));
        ruleActionList = make_shared<ListRuleActionsResponseRuleActionList>(model1);
      }
    }
  }


  virtual ~ListRuleActionsResponse() = default;
};
class ListRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<int> currentPage{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> resourceGroupId{};

  ListRuleRequest() {}

  explicit ListRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListRuleRequest() = default;
};
class ListRuleResponseDataRuleInfo : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> select{};
  shared_ptr<string> topic{};
  shared_ptr<string> shortTopic{};
  shared_ptr<string> where{};
  shared_ptr<string> status{};
  shared_ptr<long> createUserId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> name{};
  shared_ptr<string> dataType{};
  shared_ptr<string> ruleDesc{};
  shared_ptr<string> created{};
  shared_ptr<string> utcCreated{};
  shared_ptr<string> modified{};
  shared_ptr<string> utcModified{};

  ListRuleResponseDataRuleInfo() {}

  explicit ListRuleResponseDataRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!id) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("id is required.")));
    }
    if (!select) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("select is required.")));
    }
    if (!topic) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topic is required.")));
    }
    if (!shortTopic) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("shortTopic is required.")));
    }
    if (!where) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("where is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!createUserId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createUserId is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!dataType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataType is required.")));
    }
    if (!ruleDesc) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleDesc is required.")));
    }
    if (!created) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("created is required.")));
    }
    if (!utcCreated) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcCreated is required.")));
    }
    if (!modified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("modified is required.")));
    }
    if (!utcModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcModified is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (select) {
      res["Select"] = boost::any(*select);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (shortTopic) {
      res["ShortTopic"] = boost::any(*shortTopic);
    }
    if (where) {
      res["Where"] = boost::any(*where);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (createUserId) {
      res["CreateUserId"] = boost::any(*createUserId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (ruleDesc) {
      res["RuleDesc"] = boost::any(*ruleDesc);
    }
    if (created) {
      res["Created"] = boost::any(*created);
    }
    if (utcCreated) {
      res["UtcCreated"] = boost::any(*utcCreated);
    }
    if (modified) {
      res["Modified"] = boost::any(*modified);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Select") != m.end() && !m["Select"].empty()) {
      select = make_shared<string>(boost::any_cast<string>(m["Select"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("ShortTopic") != m.end() && !m["ShortTopic"].empty()) {
      shortTopic = make_shared<string>(boost::any_cast<string>(m["ShortTopic"]));
    }
    if (m.find("Where") != m.end() && !m["Where"].empty()) {
      where = make_shared<string>(boost::any_cast<string>(m["Where"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CreateUserId") != m.end() && !m["CreateUserId"].empty()) {
      createUserId = make_shared<long>(boost::any_cast<long>(m["CreateUserId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("RuleDesc") != m.end() && !m["RuleDesc"].empty()) {
      ruleDesc = make_shared<string>(boost::any_cast<string>(m["RuleDesc"]));
    }
    if (m.find("Created") != m.end() && !m["Created"].empty()) {
      created = make_shared<string>(boost::any_cast<string>(m["Created"]));
    }
    if (m.find("UtcCreated") != m.end() && !m["UtcCreated"].empty()) {
      utcCreated = make_shared<string>(boost::any_cast<string>(m["UtcCreated"]));
    }
    if (m.find("Modified") != m.end() && !m["Modified"].empty()) {
      modified = make_shared<string>(boost::any_cast<string>(m["Modified"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
  }


  virtual ~ListRuleResponseDataRuleInfo() = default;
};
class ListRuleResponseData : public Darabonba::Model {
public:
  shared_ptr<vector<ListRuleResponseDataRuleInfo>> ruleInfo{};

  ListRuleResponseData() {}

  explicit ListRuleResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!ruleInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleInfo) {
      vector<boost::any> temp1;
      for(auto item1:*ruleInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleInfo") != m.end() && !m["RuleInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleInfo"].type()) {
        vector<ListRuleResponseDataRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRuleResponseDataRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleInfo = make_shared<vector<ListRuleResponseDataRuleInfo>>(expect1);
      }
    }
  }


  virtual ~ListRuleResponseData() = default;
};
class ListRuleResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<int> page{};
  shared_ptr<int> total{};
  shared_ptr<int> pageSize{};
  shared_ptr<ListRuleResponseData> data{};

  ListRuleResponse() {}

  explicit ListRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!page) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("page is required.")));
    }
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<int>(boost::any_cast<int>(m["Page"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListRuleResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListRuleResponseData>(model1);
      }
    }
  }


  virtual ~ListRuleResponse() = default;
};
class GetRuleActionRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> actionId{};

  GetRuleActionRequest() {}

  explicit GetRuleActionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!actionId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("actionId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (actionId) {
      res["ActionId"] = boost::any(*actionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ActionId") != m.end() && !m["ActionId"].empty()) {
      actionId = make_shared<long>(boost::any_cast<long>(m["ActionId"]));
    }
  }


  virtual ~GetRuleActionRequest() = default;
};
class GetRuleActionResponseRuleActionInfo : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> type{};
  shared_ptr<string> configuration{};
  shared_ptr<bool> errorActionFlag{};

  GetRuleActionResponseRuleActionInfo() {}

  explicit GetRuleActionResponseRuleActionInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!id) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("id is required.")));
    }
    if (!ruleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleId is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
    if (!configuration) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("configuration is required.")));
    }
    if (!errorActionFlag) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorActionFlag is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (configuration) {
      res["Configuration"] = boost::any(*configuration);
    }
    if (errorActionFlag) {
      res["ErrorActionFlag"] = boost::any(*errorActionFlag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configuration = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
    if (m.find("ErrorActionFlag") != m.end() && !m["ErrorActionFlag"].empty()) {
      errorActionFlag = make_shared<bool>(boost::any_cast<bool>(m["ErrorActionFlag"]));
    }
  }


  virtual ~GetRuleActionResponseRuleActionInfo() = default;
};
class GetRuleActionResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetRuleActionResponseRuleActionInfo> ruleActionInfo{};

  GetRuleActionResponse() {}

  explicit GetRuleActionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!ruleActionInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleActionInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (ruleActionInfo) {
      res["RuleActionInfo"] = ruleActionInfo ? boost::any(ruleActionInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RuleActionInfo") != m.end() && !m["RuleActionInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuleActionInfo"].type()) {
        GetRuleActionResponseRuleActionInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuleActionInfo"]));
        ruleActionInfo = make_shared<GetRuleActionResponseRuleActionInfo>(model1);
      }
    }
  }


  virtual ~GetRuleActionResponse() = default;
};
class GetRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> ruleId{};

  GetRuleRequest() {}

  explicit GetRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!ruleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~GetRuleRequest() = default;
};
class GetRuleResponseRuleInfo : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> select{};
  shared_ptr<string> topic{};
  shared_ptr<string> shortTopic{};
  shared_ptr<string> where{};
  shared_ptr<string> status{};
  shared_ptr<long> createUserId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> name{};
  shared_ptr<string> ruleDesc{};
  shared_ptr<string> dataType{};
  shared_ptr<string> created{};
  shared_ptr<string> utcCreated{};
  shared_ptr<string> modified{};
  shared_ptr<string> utcModified{};
  shared_ptr<int> topicType{};

  GetRuleResponseRuleInfo() {}

  explicit GetRuleResponseRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!id) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("id is required.")));
    }
    if (!select) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("select is required.")));
    }
    if (!topic) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topic is required.")));
    }
    if (!shortTopic) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("shortTopic is required.")));
    }
    if (!where) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("where is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!createUserId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("createUserId is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!ruleDesc) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleDesc is required.")));
    }
    if (!dataType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataType is required.")));
    }
    if (!created) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("created is required.")));
    }
    if (!utcCreated) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcCreated is required.")));
    }
    if (!modified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("modified is required.")));
    }
    if (!utcModified) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcModified is required.")));
    }
    if (!topicType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topicType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (select) {
      res["Select"] = boost::any(*select);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (shortTopic) {
      res["ShortTopic"] = boost::any(*shortTopic);
    }
    if (where) {
      res["Where"] = boost::any(*where);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (createUserId) {
      res["CreateUserId"] = boost::any(*createUserId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ruleDesc) {
      res["RuleDesc"] = boost::any(*ruleDesc);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (created) {
      res["Created"] = boost::any(*created);
    }
    if (utcCreated) {
      res["UtcCreated"] = boost::any(*utcCreated);
    }
    if (modified) {
      res["Modified"] = boost::any(*modified);
    }
    if (utcModified) {
      res["UtcModified"] = boost::any(*utcModified);
    }
    if (topicType) {
      res["TopicType"] = boost::any(*topicType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Select") != m.end() && !m["Select"].empty()) {
      select = make_shared<string>(boost::any_cast<string>(m["Select"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("ShortTopic") != m.end() && !m["ShortTopic"].empty()) {
      shortTopic = make_shared<string>(boost::any_cast<string>(m["ShortTopic"]));
    }
    if (m.find("Where") != m.end() && !m["Where"].empty()) {
      where = make_shared<string>(boost::any_cast<string>(m["Where"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CreateUserId") != m.end() && !m["CreateUserId"].empty()) {
      createUserId = make_shared<long>(boost::any_cast<long>(m["CreateUserId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RuleDesc") != m.end() && !m["RuleDesc"].empty()) {
      ruleDesc = make_shared<string>(boost::any_cast<string>(m["RuleDesc"]));
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("Created") != m.end() && !m["Created"].empty()) {
      created = make_shared<string>(boost::any_cast<string>(m["Created"]));
    }
    if (m.find("UtcCreated") != m.end() && !m["UtcCreated"].empty()) {
      utcCreated = make_shared<string>(boost::any_cast<string>(m["UtcCreated"]));
    }
    if (m.find("Modified") != m.end() && !m["Modified"].empty()) {
      modified = make_shared<string>(boost::any_cast<string>(m["Modified"]));
    }
    if (m.find("UtcModified") != m.end() && !m["UtcModified"].empty()) {
      utcModified = make_shared<string>(boost::any_cast<string>(m["UtcModified"]));
    }
    if (m.find("TopicType") != m.end() && !m["TopicType"].empty()) {
      topicType = make_shared<int>(boost::any_cast<int>(m["TopicType"]));
    }
  }


  virtual ~GetRuleResponseRuleInfo() = default;
};
class GetRuleResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetRuleResponseRuleInfo> ruleInfo{};

  GetRuleResponse() {}

  explicit GetRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!ruleInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (ruleInfo) {
      res["RuleInfo"] = ruleInfo ? boost::any(ruleInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RuleInfo") != m.end() && !m["RuleInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuleInfo"].type()) {
        GetRuleResponseRuleInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuleInfo"]));
        ruleInfo = make_shared<GetRuleResponseRuleInfo>(model1);
      }
    }
  }


  virtual ~GetRuleResponse() = default;
};
class GetDeviceShadowRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};

  GetDeviceShadowRequest() {}

  explicit GetDeviceShadowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
  }


  virtual ~GetDeviceShadowRequest() = default;
};
class GetDeviceShadowResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> shadowMessage{};

  GetDeviceShadowResponse() {}

  explicit GetDeviceShadowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!shadowMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("shadowMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (shadowMessage) {
      res["ShadowMessage"] = boost::any(*shadowMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ShadowMessage") != m.end() && !m["ShadowMessage"].empty()) {
      shadowMessage = make_shared<string>(boost::any_cast<string>(m["ShadowMessage"]));
    }
  }


  virtual ~GetDeviceShadowResponse() = default;
};
class DeleteRuleActionRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> actionId{};

  DeleteRuleActionRequest() {}

  explicit DeleteRuleActionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!actionId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("actionId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (actionId) {
      res["ActionId"] = boost::any(*actionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ActionId") != m.end() && !m["ActionId"].empty()) {
      actionId = make_shared<long>(boost::any_cast<long>(m["ActionId"]));
    }
  }


  virtual ~DeleteRuleActionRequest() = default;
};
class DeleteRuleActionResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteRuleActionResponse() {}

  explicit DeleteRuleActionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteRuleActionResponse() = default;
};
class DeleteRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> ruleId{};

  DeleteRuleRequest() {}

  explicit DeleteRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!ruleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~DeleteRuleRequest() = default;
};
class DeleteRuleResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteRuleResponse() {}

  explicit DeleteRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteRuleResponse() = default;
};
class DeleteProductTopicRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> topicId{};

  DeleteProductTopicRequest() {}

  explicit DeleteProductTopicRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!topicId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topicId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<string>(boost::any_cast<string>(m["TopicId"]));
    }
  }


  virtual ~DeleteProductTopicRequest() = default;
};
class DeleteProductTopicResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteProductTopicResponse() {}

  explicit DeleteProductTopicResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteProductTopicResponse() = default;
};
class CreateRuleActionRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> type{};
  shared_ptr<string> configuration{};
  shared_ptr<bool> errorActionFlag{};

  CreateRuleActionRequest() {}

  explicit CreateRuleActionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!ruleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleId is required.")));
    }
    if (!type) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("type is required.")));
    }
    if (!configuration) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("configuration is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (configuration) {
      res["Configuration"] = boost::any(*configuration);
    }
    if (errorActionFlag) {
      res["ErrorActionFlag"] = boost::any(*errorActionFlag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configuration = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
    if (m.find("ErrorActionFlag") != m.end() && !m["ErrorActionFlag"].empty()) {
      errorActionFlag = make_shared<bool>(boost::any_cast<bool>(m["ErrorActionFlag"]));
    }
  }


  virtual ~CreateRuleActionRequest() = default;
};
class CreateRuleActionResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> actionId{};

  CreateRuleActionResponse() {}

  explicit CreateRuleActionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!actionId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("actionId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (actionId) {
      res["ActionId"] = boost::any(*actionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ActionId") != m.end() && !m["ActionId"].empty()) {
      actionId = make_shared<long>(boost::any_cast<long>(m["ActionId"]));
    }
  }


  virtual ~CreateRuleActionResponse() = default;
};
class CreateRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> select{};
  shared_ptr<string> shortTopic{};
  shared_ptr<string> where{};
  shared_ptr<string> productKey{};
  shared_ptr<string> name{};
  shared_ptr<string> ruleDesc{};
  shared_ptr<string> dataType{};
  shared_ptr<int> topicType{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> topic{};

  CreateRuleRequest() {}

  explicit CreateRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (select) {
      res["Select"] = boost::any(*select);
    }
    if (shortTopic) {
      res["ShortTopic"] = boost::any(*shortTopic);
    }
    if (where) {
      res["Where"] = boost::any(*where);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ruleDesc) {
      res["RuleDesc"] = boost::any(*ruleDesc);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (topicType) {
      res["TopicType"] = boost::any(*topicType);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Select") != m.end() && !m["Select"].empty()) {
      select = make_shared<string>(boost::any_cast<string>(m["Select"]));
    }
    if (m.find("ShortTopic") != m.end() && !m["ShortTopic"].empty()) {
      shortTopic = make_shared<string>(boost::any_cast<string>(m["ShortTopic"]));
    }
    if (m.find("Where") != m.end() && !m["Where"].empty()) {
      where = make_shared<string>(boost::any_cast<string>(m["Where"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RuleDesc") != m.end() && !m["RuleDesc"].empty()) {
      ruleDesc = make_shared<string>(boost::any_cast<string>(m["RuleDesc"]));
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("TopicType") != m.end() && !m["TopicType"].empty()) {
      topicType = make_shared<int>(boost::any_cast<int>(m["TopicType"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~CreateRuleRequest() = default;
};
class CreateRuleResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> ruleId{};

  CreateRuleResponse() {}

  explicit CreateRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!ruleId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ruleId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~CreateRuleResponse() = default;
};
class CreateProductTopicRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> topicShortName{};
  shared_ptr<string> operation{};
  shared_ptr<string> desc{};

  CreateProductTopicRequest() {}

  explicit CreateProductTopicRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!topicShortName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topicShortName is required.")));
    }
    if (!operation) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("operation is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (topicShortName) {
      res["TopicShortName"] = boost::any(*topicShortName);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("TopicShortName") != m.end() && !m["TopicShortName"].empty()) {
      topicShortName = make_shared<string>(boost::any_cast<string>(m["TopicShortName"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
  }


  virtual ~CreateProductTopicRequest() = default;
};
class CreateProductTopicResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> topicId{};

  CreateProductTopicResponse() {}

  explicit CreateProductTopicResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!topicId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("topicId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<long>(boost::any_cast<long>(m["TopicId"]));
    }
  }


  virtual ~CreateProductTopicResponse() = default;
};
class QueryBatchRegisterDeviceStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<long> applyId{};

  QueryBatchRegisterDeviceStatusRequest() {}

  explicit QueryBatchRegisterDeviceStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!applyId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applyId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (applyId) {
      res["ApplyId"] = boost::any(*applyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ApplyId") != m.end() && !m["ApplyId"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["ApplyId"]));
    }
  }


  virtual ~QueryBatchRegisterDeviceStatusRequest() = default;
};
class QueryBatchRegisterDeviceStatusResponseDataValidList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> name{};

  QueryBatchRegisterDeviceStatusResponseDataValidList() {}

  explicit QueryBatchRegisterDeviceStatusResponseDataValidList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Name"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Name"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      name = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryBatchRegisterDeviceStatusResponseDataValidList() = default;
};
class QueryBatchRegisterDeviceStatusResponseDataInvalidList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> name{};

  QueryBatchRegisterDeviceStatusResponseDataInvalidList() {}

  explicit QueryBatchRegisterDeviceStatusResponseDataInvalidList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Name"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Name"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      name = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryBatchRegisterDeviceStatusResponseDataInvalidList() = default;
};
class QueryBatchRegisterDeviceStatusResponseData : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<QueryBatchRegisterDeviceStatusResponseDataValidList> validList{};
  shared_ptr<QueryBatchRegisterDeviceStatusResponseDataInvalidList> invalidList{};

  QueryBatchRegisterDeviceStatusResponseData() {}

  explicit QueryBatchRegisterDeviceStatusResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!validList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("validList is required.")));
    }
    if (!invalidList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("invalidList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (validList) {
      res["ValidList"] = validList ? boost::any(validList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (invalidList) {
      res["InvalidList"] = invalidList ? boost::any(invalidList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ValidList") != m.end() && !m["ValidList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ValidList"].type()) {
        QueryBatchRegisterDeviceStatusResponseDataValidList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ValidList"]));
        validList = make_shared<QueryBatchRegisterDeviceStatusResponseDataValidList>(model1);
      }
    }
    if (m.find("InvalidList") != m.end() && !m["InvalidList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvalidList"].type()) {
        QueryBatchRegisterDeviceStatusResponseDataInvalidList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvalidList"]));
        invalidList = make_shared<QueryBatchRegisterDeviceStatusResponseDataInvalidList>(model1);
      }
    }
  }


  virtual ~QueryBatchRegisterDeviceStatusResponseData() = default;
};
class QueryBatchRegisterDeviceStatusResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryBatchRegisterDeviceStatusResponseData> data{};

  QueryBatchRegisterDeviceStatusResponse() {}

  explicit QueryBatchRegisterDeviceStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryBatchRegisterDeviceStatusResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryBatchRegisterDeviceStatusResponseData>(model1);
      }
    }
  }


  virtual ~QueryBatchRegisterDeviceStatusResponse() = default;
};
class GetGatewayBySubDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};

  GetGatewayBySubDeviceRequest() {}

  explicit GetGatewayBySubDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~GetGatewayBySubDeviceRequest() = default;
};
class GetGatewayBySubDeviceResponseData : public Darabonba::Model {
public:
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};
  shared_ptr<string> deviceSecret{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> firmwareVersion{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> gmtActive{};
  shared_ptr<string> utcActive{};
  shared_ptr<string> gmtOnline{};
  shared_ptr<string> utcOnline{};
  shared_ptr<string> status{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> nodeType{};
  shared_ptr<string> region{};
  shared_ptr<string> iotId{};

  GetGatewayBySubDeviceResponseData() {}

  explicit GetGatewayBySubDeviceResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!productName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productName is required.")));
    }
    if (!deviceSecret) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceSecret is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!firmwareVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareVersion is required.")));
    }
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!utcCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcCreate is required.")));
    }
    if (!gmtActive) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtActive is required.")));
    }
    if (!utcActive) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcActive is required.")));
    }
    if (!gmtOnline) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtOnline is required.")));
    }
    if (!utcOnline) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcOnline is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!ipAddress) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ipAddress is required.")));
    }
    if (!nodeType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeType is required.")));
    }
    if (!region) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("region is required.")));
    }
    if (!iotId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (deviceSecret) {
      res["DeviceSecret"] = boost::any(*deviceSecret);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (firmwareVersion) {
      res["FirmwareVersion"] = boost::any(*firmwareVersion);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (gmtActive) {
      res["GmtActive"] = boost::any(*gmtActive);
    }
    if (utcActive) {
      res["UtcActive"] = boost::any(*utcActive);
    }
    if (gmtOnline) {
      res["GmtOnline"] = boost::any(*gmtOnline);
    }
    if (utcOnline) {
      res["UtcOnline"] = boost::any(*utcOnline);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (region) {
      res["region"] = boost::any(*region);
    }
    if (iotId) {
      res["iotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("DeviceSecret") != m.end() && !m["DeviceSecret"].empty()) {
      deviceSecret = make_shared<string>(boost::any_cast<string>(m["DeviceSecret"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("FirmwareVersion") != m.end() && !m["FirmwareVersion"].empty()) {
      firmwareVersion = make_shared<string>(boost::any_cast<string>(m["FirmwareVersion"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("GmtActive") != m.end() && !m["GmtActive"].empty()) {
      gmtActive = make_shared<string>(boost::any_cast<string>(m["GmtActive"]));
    }
    if (m.find("UtcActive") != m.end() && !m["UtcActive"].empty()) {
      utcActive = make_shared<string>(boost::any_cast<string>(m["UtcActive"]));
    }
    if (m.find("GmtOnline") != m.end() && !m["GmtOnline"].empty()) {
      gmtOnline = make_shared<string>(boost::any_cast<string>(m["GmtOnline"]));
    }
    if (m.find("UtcOnline") != m.end() && !m["UtcOnline"].empty()) {
      utcOnline = make_shared<string>(boost::any_cast<string>(m["UtcOnline"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
    if (m.find("region") != m.end() && !m["region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["region"]));
    }
    if (m.find("iotId") != m.end() && !m["iotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["iotId"]));
    }
  }


  virtual ~GetGatewayBySubDeviceResponseData() = default;
};
class GetGatewayBySubDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetGatewayBySubDeviceResponseData> data{};

  GetGatewayBySubDeviceResponse() {}

  explicit GetGatewayBySubDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetGatewayBySubDeviceResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetGatewayBySubDeviceResponseData>(model1);
      }
    }
  }


  virtual ~GetGatewayBySubDeviceResponse() = default;
};
class ResetThingRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};

  ResetThingRequest() {}

  explicit ResetThingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~ResetThingRequest() = default;
};
class ResetThingResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  ResetThingResponse() {}

  explicit ResetThingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~ResetThingResponse() = default;
};
class RemoveThingTopoRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};

  RemoveThingTopoRequest() {}

  explicit RemoveThingTopoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~RemoveThingTopoRequest() = default;
};
class RemoveThingTopoResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> data{};

  RemoveThingTopoResponse() {}

  explicit RemoveThingTopoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
  }


  virtual ~RemoveThingTopoResponse() = default;
};
class NotifyAddThingTopoRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> deviceListStr{};
  shared_ptr<string> gwIotId{};
  shared_ptr<string> gwProductKey{};
  shared_ptr<string> gwDeviceName{};

  NotifyAddThingTopoRequest() {}

  explicit NotifyAddThingTopoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (deviceListStr) {
      res["DeviceListStr"] = boost::any(*deviceListStr);
    }
    if (gwIotId) {
      res["GwIotId"] = boost::any(*gwIotId);
    }
    if (gwProductKey) {
      res["GwProductKey"] = boost::any(*gwProductKey);
    }
    if (gwDeviceName) {
      res["GwDeviceName"] = boost::any(*gwDeviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("DeviceListStr") != m.end() && !m["DeviceListStr"].empty()) {
      deviceListStr = make_shared<string>(boost::any_cast<string>(m["DeviceListStr"]));
    }
    if (m.find("GwIotId") != m.end() && !m["GwIotId"].empty()) {
      gwIotId = make_shared<string>(boost::any_cast<string>(m["GwIotId"]));
    }
    if (m.find("GwProductKey") != m.end() && !m["GwProductKey"].empty()) {
      gwProductKey = make_shared<string>(boost::any_cast<string>(m["GwProductKey"]));
    }
    if (m.find("GwDeviceName") != m.end() && !m["GwDeviceName"].empty()) {
      gwDeviceName = make_shared<string>(boost::any_cast<string>(m["GwDeviceName"]));
    }
  }


  virtual ~NotifyAddThingTopoRequest() = default;
};
class NotifyAddThingTopoResponseData : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};

  NotifyAddThingTopoResponseData() {}

  explicit NotifyAddThingTopoResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!messageId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("messageId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~NotifyAddThingTopoResponseData() = default;
};
class NotifyAddThingTopoResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<NotifyAddThingTopoResponseData> data{};

  NotifyAddThingTopoResponse() {}

  explicit NotifyAddThingTopoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        NotifyAddThingTopoResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<NotifyAddThingTopoResponseData>(model1);
      }
    }
  }


  virtual ~NotifyAddThingTopoResponse() = default;
};
class GetThingTopoRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<int> pageNo{};
  shared_ptr<string> iotId{};

  GetThingTopoRequest() {}

  explicit GetThingTopoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!pageNo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageNo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<int>(boost::any_cast<int>(m["PageNo"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~GetThingTopoRequest() = default;
};
class GetThingTopoResponseDataListDeviceInfo : public Darabonba::Model {
public:
  shared_ptr<string> iotId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};

  GetThingTopoResponseDataListDeviceInfo() {}

  explicit GetThingTopoResponseDataListDeviceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!iotId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotId is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
  }


  virtual ~GetThingTopoResponseDataListDeviceInfo() = default;
};
class GetThingTopoResponseDataList : public Darabonba::Model {
public:
  shared_ptr<vector<GetThingTopoResponseDataListDeviceInfo>> deviceInfo{};

  GetThingTopoResponseDataList() {}

  explicit GetThingTopoResponseDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!deviceInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*deviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["deviceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("deviceInfo") != m.end() && !m["deviceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["deviceInfo"].type()) {
        vector<GetThingTopoResponseDataListDeviceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["deviceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetThingTopoResponseDataListDeviceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceInfo = make_shared<vector<GetThingTopoResponseDataListDeviceInfo>>(expect1);
      }
    }
  }


  virtual ~GetThingTopoResponseDataList() = default;
};
class GetThingTopoResponseData : public Darabonba::Model {
public:
  shared_ptr<long> total{};
  shared_ptr<int> currentPage{};
  shared_ptr<int> pageSize{};
  shared_ptr<long> pageCount{};
  shared_ptr<GetThingTopoResponseDataList> list{};

  GetThingTopoResponseData() {}

  explicit GetThingTopoResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!pageCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageCount is required.")));
    }
    if (!list) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("list is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        GetThingTopoResponseDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<GetThingTopoResponseDataList>(model1);
      }
    }
  }


  virtual ~GetThingTopoResponseData() = default;
};
class GetThingTopoResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetThingTopoResponseData> data{};

  GetThingTopoResponse() {}

  explicit GetThingTopoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetThingTopoResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetThingTopoResponseData>(model1);
      }
    }
  }


  virtual ~GetThingTopoResponse() = default;
};
class QueryDevicePropertyStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> functionBlockId{};

  QueryDevicePropertyStatusRequest() {}

  explicit QueryDevicePropertyStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (functionBlockId) {
      res["FunctionBlockId"] = boost::any(*functionBlockId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("FunctionBlockId") != m.end() && !m["FunctionBlockId"].empty()) {
      functionBlockId = make_shared<string>(boost::any_cast<string>(m["FunctionBlockId"]));
    }
  }


  virtual ~QueryDevicePropertyStatusRequest() = default;
};
class QueryDevicePropertyStatusResponseDataListPropertyStatusInfo : public Darabonba::Model {
public:
  shared_ptr<string> unit{};
  shared_ptr<string> identifier{};
  shared_ptr<string> dataType{};
  shared_ptr<string> time{};
  shared_ptr<string> value{};
  shared_ptr<string> name{};

  QueryDevicePropertyStatusResponseDataListPropertyStatusInfo() {}

  explicit QueryDevicePropertyStatusResponseDataListPropertyStatusInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!unit) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("unit is required.")));
    }
    if (!identifier) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("identifier is required.")));
    }
    if (!dataType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataType is required.")));
    }
    if (!time) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("time is required.")));
    }
    if (!value) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("value is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~QueryDevicePropertyStatusResponseDataListPropertyStatusInfo() = default;
};
class QueryDevicePropertyStatusResponseDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDevicePropertyStatusResponseDataListPropertyStatusInfo>> propertyStatusInfo{};

  QueryDevicePropertyStatusResponseDataList() {}

  explicit QueryDevicePropertyStatusResponseDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!propertyStatusInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("propertyStatusInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertyStatusInfo) {
      vector<boost::any> temp1;
      for(auto item1:*propertyStatusInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyStatusInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertyStatusInfo") != m.end() && !m["PropertyStatusInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyStatusInfo"].type()) {
        vector<QueryDevicePropertyStatusResponseDataListPropertyStatusInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyStatusInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDevicePropertyStatusResponseDataListPropertyStatusInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyStatusInfo = make_shared<vector<QueryDevicePropertyStatusResponseDataListPropertyStatusInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDevicePropertyStatusResponseDataList() = default;
};
class QueryDevicePropertyStatusResponseData : public Darabonba::Model {
public:
  shared_ptr<QueryDevicePropertyStatusResponseDataList> list{};

  QueryDevicePropertyStatusResponseData() {}

  explicit QueryDevicePropertyStatusResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!list) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("list is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDevicePropertyStatusResponseDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDevicePropertyStatusResponseDataList>(model1);
      }
    }
  }


  virtual ~QueryDevicePropertyStatusResponseData() = default;
};
class QueryDevicePropertyStatusResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDevicePropertyStatusResponseData> data{};

  QueryDevicePropertyStatusResponse() {}

  explicit QueryDevicePropertyStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDevicePropertyStatusResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDevicePropertyStatusResponseData>(model1);
      }
    }
  }


  virtual ~QueryDevicePropertyStatusResponse() = default;
};
class QueryDevicePropertyDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<long> startTime{};
  shared_ptr<string> identifier{};
  shared_ptr<int> asc{};
  shared_ptr<string> iotId{};
  shared_ptr<long> endTime{};

  QueryDevicePropertyDataRequest() {}

  explicit QueryDevicePropertyDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!startTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("startTime is required.")));
    }
    if (!identifier) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("identifier is required.")));
    }
    if (!asc) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("asc is required.")));
    }
    if (!endTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endTime is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<int>(boost::any_cast<int>(m["Asc"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
  }


  virtual ~QueryDevicePropertyDataRequest() = default;
};
class QueryDevicePropertyDataResponseDataListPropertyInfo : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> value{};

  QueryDevicePropertyDataResponseDataListPropertyInfo() {}

  explicit QueryDevicePropertyDataResponseDataListPropertyInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!time) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("time is required.")));
    }
    if (!value) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("value is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryDevicePropertyDataResponseDataListPropertyInfo() = default;
};
class QueryDevicePropertyDataResponseDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDevicePropertyDataResponseDataListPropertyInfo>> propertyInfo{};

  QueryDevicePropertyDataResponseDataList() {}

  explicit QueryDevicePropertyDataResponseDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!propertyInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("propertyInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertyInfo) {
      vector<boost::any> temp1;
      for(auto item1:*propertyInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertyInfo") != m.end() && !m["PropertyInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyInfo"].type()) {
        vector<QueryDevicePropertyDataResponseDataListPropertyInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDevicePropertyDataResponseDataListPropertyInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyInfo = make_shared<vector<QueryDevicePropertyDataResponseDataListPropertyInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDevicePropertyDataResponseDataList() = default;
};
class QueryDevicePropertyDataResponseData : public Darabonba::Model {
public:
  shared_ptr<bool> nextValid{};
  shared_ptr<long> nextTime{};
  shared_ptr<QueryDevicePropertyDataResponseDataList> list{};

  QueryDevicePropertyDataResponseData() {}

  explicit QueryDevicePropertyDataResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nextValid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nextValid is required.")));
    }
    if (!nextTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nextTime is required.")));
    }
    if (!list) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("list is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextValid) {
      res["NextValid"] = boost::any(*nextValid);
    }
    if (nextTime) {
      res["NextTime"] = boost::any(*nextTime);
    }
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextValid") != m.end() && !m["NextValid"].empty()) {
      nextValid = make_shared<bool>(boost::any_cast<bool>(m["NextValid"]));
    }
    if (m.find("NextTime") != m.end() && !m["NextTime"].empty()) {
      nextTime = make_shared<long>(boost::any_cast<long>(m["NextTime"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDevicePropertyDataResponseDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDevicePropertyDataResponseDataList>(model1);
      }
    }
  }


  virtual ~QueryDevicePropertyDataResponseData() = default;
};
class QueryDevicePropertyDataResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDevicePropertyDataResponseData> data{};

  QueryDevicePropertyDataResponse() {}

  explicit QueryDevicePropertyDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDevicePropertyDataResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDevicePropertyDataResponseData>(model1);
      }
    }
  }


  virtual ~QueryDevicePropertyDataResponse() = default;
};
class BatchRegisterDeviceWithApplyIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<long> applyId{};

  BatchRegisterDeviceWithApplyIdRequest() {}

  explicit BatchRegisterDeviceWithApplyIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!applyId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applyId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (applyId) {
      res["ApplyId"] = boost::any(*applyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ApplyId") != m.end() && !m["ApplyId"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["ApplyId"]));
    }
  }


  virtual ~BatchRegisterDeviceWithApplyIdRequest() = default;
};
class BatchRegisterDeviceWithApplyIdResponseData : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};

  BatchRegisterDeviceWithApplyIdResponseData() {}

  explicit BatchRegisterDeviceWithApplyIdResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!applyId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applyId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["ApplyId"] = boost::any(*applyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyId") != m.end() && !m["ApplyId"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["ApplyId"]));
    }
  }


  virtual ~BatchRegisterDeviceWithApplyIdResponseData() = default;
};
class BatchRegisterDeviceWithApplyIdResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<BatchRegisterDeviceWithApplyIdResponseData> data{};

  BatchRegisterDeviceWithApplyIdResponse() {}

  explicit BatchRegisterDeviceWithApplyIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BatchRegisterDeviceWithApplyIdResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BatchRegisterDeviceWithApplyIdResponseData>(model1);
      }
    }
  }


  virtual ~BatchRegisterDeviceWithApplyIdResponse() = default;
};
class BatchRegisterDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<int> count{};

  BatchRegisterDeviceRequest() {}

  explicit BatchRegisterDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!count) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("count is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<int>(boost::any_cast<int>(m["Count"]));
    }
  }


  virtual ~BatchRegisterDeviceRequest() = default;
};
class BatchRegisterDeviceResponseData : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};

  BatchRegisterDeviceResponseData() {}

  explicit BatchRegisterDeviceResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!applyId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applyId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["ApplyId"] = boost::any(*applyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyId") != m.end() && !m["ApplyId"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["ApplyId"]));
    }
  }


  virtual ~BatchRegisterDeviceResponseData() = default;
};
class BatchRegisterDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<BatchRegisterDeviceResponseData> data{};

  BatchRegisterDeviceResponse() {}

  explicit BatchRegisterDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BatchRegisterDeviceResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BatchRegisterDeviceResponseData>(model1);
      }
    }
  }


  virtual ~BatchRegisterDeviceResponse() = default;
};
class BatchCheckDeviceNamesRequestDeviceNameList : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceNickname{};

  BatchCheckDeviceNamesRequestDeviceNameList() {}

  explicit BatchCheckDeviceNamesRequestDeviceNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceNickname) {
      res["DeviceNickname"] = boost::any(*deviceNickname);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceNickname") != m.end() && !m["DeviceNickname"].empty()) {
      deviceNickname = make_shared<string>(boost::any_cast<string>(m["DeviceNickname"]));
    }
  }


  virtual ~BatchCheckDeviceNamesRequestDeviceNameList() = default;
};
class BatchCheckDeviceNamesRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<vector<string>> deviceName{};
  shared_ptr<vector<BatchCheckDeviceNamesRequestDeviceNameList>> deviceNameList{};

  BatchCheckDeviceNamesRequest() {}

  explicit BatchCheckDeviceNamesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceNameList) {
      vector<boost::any> temp1;
      for(auto item1:*deviceNameList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceNameList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DeviceNameList") != m.end() && !m["DeviceNameList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceNameList"].type()) {
        vector<BatchCheckDeviceNamesRequestDeviceNameList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceNameList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchCheckDeviceNamesRequestDeviceNameList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceNameList = make_shared<vector<BatchCheckDeviceNamesRequestDeviceNameList>>(expect1);
      }
    }
  }


  virtual ~BatchCheckDeviceNamesRequest() = default;
};
class BatchCheckDeviceNamesResponseDataInvalidDeviceNameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> invalidDeviceName{};

  BatchCheckDeviceNamesResponseDataInvalidDeviceNameList() {}

  explicit BatchCheckDeviceNamesResponseDataInvalidDeviceNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!invalidDeviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("invalidDeviceName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invalidDeviceName) {
      res["InvalidDeviceName"] = boost::any(*invalidDeviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InvalidDeviceName") != m.end() && !m["InvalidDeviceName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InvalidDeviceName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InvalidDeviceName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      invalidDeviceName = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchCheckDeviceNamesResponseDataInvalidDeviceNameList() = default;
};
class BatchCheckDeviceNamesResponseDataInvalidDeviceNicknameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> invalidDeviceNickname{};

  BatchCheckDeviceNamesResponseDataInvalidDeviceNicknameList() {}

  explicit BatchCheckDeviceNamesResponseDataInvalidDeviceNicknameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!invalidDeviceNickname) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("invalidDeviceNickname is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invalidDeviceNickname) {
      res["InvalidDeviceNickname"] = boost::any(*invalidDeviceNickname);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InvalidDeviceNickname") != m.end() && !m["InvalidDeviceNickname"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InvalidDeviceNickname"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InvalidDeviceNickname"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      invalidDeviceNickname = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchCheckDeviceNamesResponseDataInvalidDeviceNicknameList() = default;
};
class BatchCheckDeviceNamesResponseData : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<BatchCheckDeviceNamesResponseDataInvalidDeviceNameList> invalidDeviceNameList{};
  shared_ptr<BatchCheckDeviceNamesResponseDataInvalidDeviceNicknameList> invalidDeviceNicknameList{};

  BatchCheckDeviceNamesResponseData() {}

  explicit BatchCheckDeviceNamesResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!applyId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("applyId is required.")));
    }
    if (!invalidDeviceNameList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("invalidDeviceNameList is required.")));
    }
    if (!invalidDeviceNicknameList) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("invalidDeviceNicknameList is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["ApplyId"] = boost::any(*applyId);
    }
    if (invalidDeviceNameList) {
      res["InvalidDeviceNameList"] = invalidDeviceNameList ? boost::any(invalidDeviceNameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (invalidDeviceNicknameList) {
      res["InvalidDeviceNicknameList"] = invalidDeviceNicknameList ? boost::any(invalidDeviceNicknameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyId") != m.end() && !m["ApplyId"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["ApplyId"]));
    }
    if (m.find("InvalidDeviceNameList") != m.end() && !m["InvalidDeviceNameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvalidDeviceNameList"].type()) {
        BatchCheckDeviceNamesResponseDataInvalidDeviceNameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvalidDeviceNameList"]));
        invalidDeviceNameList = make_shared<BatchCheckDeviceNamesResponseDataInvalidDeviceNameList>(model1);
      }
    }
    if (m.find("InvalidDeviceNicknameList") != m.end() && !m["InvalidDeviceNicknameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvalidDeviceNicknameList"].type()) {
        BatchCheckDeviceNamesResponseDataInvalidDeviceNicknameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvalidDeviceNicknameList"]));
        invalidDeviceNicknameList = make_shared<BatchCheckDeviceNamesResponseDataInvalidDeviceNicknameList>(model1);
      }
    }
  }


  virtual ~BatchCheckDeviceNamesResponseData() = default;
};
class BatchCheckDeviceNamesResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<BatchCheckDeviceNamesResponseData> data{};

  BatchCheckDeviceNamesResponse() {}

  explicit BatchCheckDeviceNamesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BatchCheckDeviceNamesResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BatchCheckDeviceNamesResponseData>(model1);
      }
    }
  }


  virtual ~BatchCheckDeviceNamesResponse() = default;
};
class UpdateProductRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> description{};
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};

  UpdateProductRequest() {}

  explicit UpdateProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!productName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productName is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
  }


  virtual ~UpdateProductRequest() = default;
};
class UpdateProductResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  UpdateProductResponse() {}

  explicit UpdateProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UpdateProductResponse() = default;
};
class SetDevicePropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};
  shared_ptr<string> items{};

  SetDevicePropertyRequest() {}

  explicit SetDevicePropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!items) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("items is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (items) {
      res["Items"] = boost::any(*items);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      items = make_shared<string>(boost::any_cast<string>(m["Items"]));
    }
  }


  virtual ~SetDevicePropertyRequest() = default;
};
class SetDevicePropertyResponseData : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};

  SetDevicePropertyResponseData() {}

  explicit SetDevicePropertyResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!messageId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("messageId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~SetDevicePropertyResponseData() = default;
};
class SetDevicePropertyResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<SetDevicePropertyResponseData> data{};

  SetDevicePropertyResponse() {}

  explicit SetDevicePropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SetDevicePropertyResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SetDevicePropertyResponseData>(model1);
      }
    }
  }


  virtual ~SetDevicePropertyResponse() = default;
};
class RegisterDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> devEui{};
  shared_ptr<string> nickname{};
  shared_ptr<string> pinCode{};
  shared_ptr<string> joinEui{};
  shared_ptr<string> appKey{};
  shared_ptr<string> loraNodeType{};

  RegisterDeviceRequest() {}

  explicit RegisterDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (devEui) {
      res["DevEui"] = boost::any(*devEui);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    if (pinCode) {
      res["PinCode"] = boost::any(*pinCode);
    }
    if (joinEui) {
      res["JoinEui"] = boost::any(*joinEui);
    }
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (loraNodeType) {
      res["LoraNodeType"] = boost::any(*loraNodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DevEui") != m.end() && !m["DevEui"].empty()) {
      devEui = make_shared<string>(boost::any_cast<string>(m["DevEui"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
    if (m.find("PinCode") != m.end() && !m["PinCode"].empty()) {
      pinCode = make_shared<string>(boost::any_cast<string>(m["PinCode"]));
    }
    if (m.find("JoinEui") != m.end() && !m["JoinEui"].empty()) {
      joinEui = make_shared<string>(boost::any_cast<string>(m["JoinEui"]));
    }
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("LoraNodeType") != m.end() && !m["LoraNodeType"].empty()) {
      loraNodeType = make_shared<string>(boost::any_cast<string>(m["LoraNodeType"]));
    }
  }


  virtual ~RegisterDeviceRequest() = default;
};
class RegisterDeviceResponseData : public Darabonba::Model {
public:
  shared_ptr<string> iotId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceSecret{};
  shared_ptr<string> devEui{};
  shared_ptr<string> joinEui{};
  shared_ptr<string> nickname{};

  RegisterDeviceResponseData() {}

  explicit RegisterDeviceResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!iotId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotId is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!deviceSecret) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceSecret is required.")));
    }
    if (!devEui) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("devEui is required.")));
    }
    if (!joinEui) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("joinEui is required.")));
    }
    if (!nickname) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nickname is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceSecret) {
      res["DeviceSecret"] = boost::any(*deviceSecret);
    }
    if (devEui) {
      res["DevEui"] = boost::any(*devEui);
    }
    if (joinEui) {
      res["JoinEui"] = boost::any(*joinEui);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceSecret") != m.end() && !m["DeviceSecret"].empty()) {
      deviceSecret = make_shared<string>(boost::any_cast<string>(m["DeviceSecret"]));
    }
    if (m.find("DevEui") != m.end() && !m["DevEui"].empty()) {
      devEui = make_shared<string>(boost::any_cast<string>(m["DevEui"]));
    }
    if (m.find("JoinEui") != m.end() && !m["JoinEui"].empty()) {
      joinEui = make_shared<string>(boost::any_cast<string>(m["JoinEui"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
  }


  virtual ~RegisterDeviceResponseData() = default;
};
class RegisterDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<RegisterDeviceResponseData> data{};

  RegisterDeviceResponse() {}

  explicit RegisterDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        RegisterDeviceResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<RegisterDeviceResponseData>(model1);
      }
    }
  }


  virtual ~RegisterDeviceResponse() = default;
};
class QueryProductListRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> aliyunCommodityCode{};
  shared_ptr<int> currentPage{};

  QueryProductListRequest() {}

  explicit QueryProductListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (aliyunCommodityCode) {
      res["AliyunCommodityCode"] = boost::any(*aliyunCommodityCode);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("AliyunCommodityCode") != m.end() && !m["AliyunCommodityCode"].empty()) {
      aliyunCommodityCode = make_shared<string>(boost::any_cast<string>(m["AliyunCommodityCode"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
  }


  virtual ~QueryProductListRequest() = default;
};
class QueryProductListResponseDataListProductInfo : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<int> dataFormat{};
  shared_ptr<string> description{};
  shared_ptr<int> deviceCount{};
  shared_ptr<int> nodeType{};
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};
  shared_ptr<string> authType{};

  QueryProductListResponseDataListProductInfo() {}

  explicit QueryProductListResponseDataListProductInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!dataFormat) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataFormat is required.")));
    }
    if (!description) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("description is required.")));
    }
    if (!deviceCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceCount is required.")));
    }
    if (!nodeType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeType is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!productName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productName is required.")));
    }
    if (!authType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("authType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (dataFormat) {
      res["DataFormat"] = boost::any(*dataFormat);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (deviceCount) {
      res["DeviceCount"] = boost::any(*deviceCount);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("DataFormat") != m.end() && !m["DataFormat"].empty()) {
      dataFormat = make_shared<int>(boost::any_cast<int>(m["DataFormat"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DeviceCount") != m.end() && !m["DeviceCount"].empty()) {
      deviceCount = make_shared<int>(boost::any_cast<int>(m["DeviceCount"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<int>(boost::any_cast<int>(m["NodeType"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
  }


  virtual ~QueryProductListResponseDataListProductInfo() = default;
};
class QueryProductListResponseDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryProductListResponseDataListProductInfo>> productInfo{};

  QueryProductListResponseDataList() {}

  explicit QueryProductListResponseDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productInfo) {
      vector<boost::any> temp1;
      for(auto item1:*productInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProductInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductInfo") != m.end() && !m["ProductInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ProductInfo"].type()) {
        vector<QueryProductListResponseDataListProductInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProductInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryProductListResponseDataListProductInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        productInfo = make_shared<vector<QueryProductListResponseDataListProductInfo>>(expect1);
      }
    }
  }


  virtual ~QueryProductListResponseDataList() = default;
};
class QueryProductListResponseData : public Darabonba::Model {
public:
  shared_ptr<int> currentPage{};
  shared_ptr<int> pageCount{};
  shared_ptr<int> pageSize{};
  shared_ptr<int> total{};
  shared_ptr<QueryProductListResponseDataList> list{};

  QueryProductListResponseData() {}

  explicit QueryProductListResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!currentPage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("currentPage is required.")));
    }
    if (!pageCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageCount is required.")));
    }
    if (!pageSize) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("pageSize is required.")));
    }
    if (!total) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("total is required.")));
    }
    if (!list) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("list is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<int>(boost::any_cast<int>(m["CurrentPage"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<int>(boost::any_cast<int>(m["PageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<int>(boost::any_cast<int>(m["Total"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryProductListResponseDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryProductListResponseDataList>(model1);
      }
    }
  }


  virtual ~QueryProductListResponseData() = default;
};
class QueryProductListResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryProductListResponseData> data{};

  QueryProductListResponse() {}

  explicit QueryProductListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryProductListResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryProductListResponseData>(model1);
      }
    }
  }


  virtual ~QueryProductListResponse() = default;
};
class QueryProductRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  QueryProductRequest() {}

  explicit QueryProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~QueryProductRequest() = default;
};
class QueryProductResponseData : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<int> dataFormat{};
  shared_ptr<string> description{};
  shared_ptr<int> deviceCount{};
  shared_ptr<int> nodeType{};
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};
  shared_ptr<string> productSecret{};
  shared_ptr<string> categoryName{};
  shared_ptr<string> categoryKey{};
  shared_ptr<string> aliyunCommodityCode{};
  shared_ptr<bool> id2{};
  shared_ptr<string> protocolType{};
  shared_ptr<string> productStatus{};
  shared_ptr<bool> owner{};
  shared_ptr<int> netType{};
  shared_ptr<string> authType{};
  shared_ptr<int> validateType{};

  QueryProductResponseData() {}

  explicit QueryProductResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!dataFormat) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataFormat is required.")));
    }
    if (!description) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("description is required.")));
    }
    if (!deviceCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceCount is required.")));
    }
    if (!nodeType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeType is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!productName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productName is required.")));
    }
    if (!productSecret) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productSecret is required.")));
    }
    if (!categoryName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("categoryName is required.")));
    }
    if (!categoryKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("categoryKey is required.")));
    }
    if (!aliyunCommodityCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("aliyunCommodityCode is required.")));
    }
    if (!id2) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("id2 is required.")));
    }
    if (!protocolType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("protocolType is required.")));
    }
    if (!productStatus) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productStatus is required.")));
    }
    if (!owner) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("owner is required.")));
    }
    if (!netType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("netType is required.")));
    }
    if (!authType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("authType is required.")));
    }
    if (!validateType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("validateType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (dataFormat) {
      res["DataFormat"] = boost::any(*dataFormat);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (deviceCount) {
      res["DeviceCount"] = boost::any(*deviceCount);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (productSecret) {
      res["ProductSecret"] = boost::any(*productSecret);
    }
    if (categoryName) {
      res["CategoryName"] = boost::any(*categoryName);
    }
    if (categoryKey) {
      res["CategoryKey"] = boost::any(*categoryKey);
    }
    if (aliyunCommodityCode) {
      res["AliyunCommodityCode"] = boost::any(*aliyunCommodityCode);
    }
    if (id2) {
      res["Id2"] = boost::any(*id2);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (productStatus) {
      res["ProductStatus"] = boost::any(*productStatus);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (validateType) {
      res["ValidateType"] = boost::any(*validateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("DataFormat") != m.end() && !m["DataFormat"].empty()) {
      dataFormat = make_shared<int>(boost::any_cast<int>(m["DataFormat"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DeviceCount") != m.end() && !m["DeviceCount"].empty()) {
      deviceCount = make_shared<int>(boost::any_cast<int>(m["DeviceCount"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<int>(boost::any_cast<int>(m["NodeType"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("ProductSecret") != m.end() && !m["ProductSecret"].empty()) {
      productSecret = make_shared<string>(boost::any_cast<string>(m["ProductSecret"]));
    }
    if (m.find("CategoryName") != m.end() && !m["CategoryName"].empty()) {
      categoryName = make_shared<string>(boost::any_cast<string>(m["CategoryName"]));
    }
    if (m.find("CategoryKey") != m.end() && !m["CategoryKey"].empty()) {
      categoryKey = make_shared<string>(boost::any_cast<string>(m["CategoryKey"]));
    }
    if (m.find("AliyunCommodityCode") != m.end() && !m["AliyunCommodityCode"].empty()) {
      aliyunCommodityCode = make_shared<string>(boost::any_cast<string>(m["AliyunCommodityCode"]));
    }
    if (m.find("Id2") != m.end() && !m["Id2"].empty()) {
      id2 = make_shared<bool>(boost::any_cast<bool>(m["Id2"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("ProductStatus") != m.end() && !m["ProductStatus"].empty()) {
      productStatus = make_shared<string>(boost::any_cast<string>(m["ProductStatus"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<bool>(boost::any_cast<bool>(m["Owner"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<int>(boost::any_cast<int>(m["NetType"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("ValidateType") != m.end() && !m["ValidateType"].empty()) {
      validateType = make_shared<int>(boost::any_cast<int>(m["ValidateType"]));
    }
  }


  virtual ~QueryProductResponseData() = default;
};
class QueryProductResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryProductResponseData> data{};

  QueryProductResponse() {}

  explicit QueryProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryProductResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryProductResponseData>(model1);
      }
    }
  }


  virtual ~QueryProductResponse() = default;
};
class QueryDeviceStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> groupId{};

  QueryDeviceStatisticsRequest() {}

  explicit QueryDeviceStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~QueryDeviceStatisticsRequest() = default;
};
class QueryDeviceStatisticsResponseData : public Darabonba::Model {
public:
  shared_ptr<long> deviceCount{};
  shared_ptr<long> onlineCount{};
  shared_ptr<long> activeCount{};

  QueryDeviceStatisticsResponseData() {}

  explicit QueryDeviceStatisticsResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!deviceCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceCount is required.")));
    }
    if (!onlineCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("onlineCount is required.")));
    }
    if (!activeCount) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("activeCount is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceCount) {
      res["deviceCount"] = boost::any(*deviceCount);
    }
    if (onlineCount) {
      res["onlineCount"] = boost::any(*onlineCount);
    }
    if (activeCount) {
      res["activeCount"] = boost::any(*activeCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("deviceCount") != m.end() && !m["deviceCount"].empty()) {
      deviceCount = make_shared<long>(boost::any_cast<long>(m["deviceCount"]));
    }
    if (m.find("onlineCount") != m.end() && !m["onlineCount"].empty()) {
      onlineCount = make_shared<long>(boost::any_cast<long>(m["onlineCount"]));
    }
    if (m.find("activeCount") != m.end() && !m["activeCount"].empty()) {
      activeCount = make_shared<long>(boost::any_cast<long>(m["activeCount"]));
    }
  }


  virtual ~QueryDeviceStatisticsResponseData() = default;
};
class QueryDeviceStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceStatisticsResponseData> data{};

  QueryDeviceStatisticsResponse() {}

  explicit QueryDeviceStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceStatisticsResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceStatisticsResponseData>(model1);
      }
    }
  }


  virtual ~QueryDeviceStatisticsResponse() = default;
};
class QueryDeviceServiceDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<long> startTime{};
  shared_ptr<string> identifier{};
  shared_ptr<int> asc{};
  shared_ptr<string> iotId{};
  shared_ptr<long> endTime{};

  QueryDeviceServiceDataRequest() {}

  explicit QueryDeviceServiceDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!startTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("startTime is required.")));
    }
    if (!endTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endTime is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<int>(boost::any_cast<int>(m["Asc"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
  }


  virtual ~QueryDeviceServiceDataRequest() = default;
};
class QueryDeviceServiceDataResponseDataListServiceInfo : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> identifier{};
  shared_ptr<string> name{};
  shared_ptr<string> inputData{};
  shared_ptr<string> outputData{};

  QueryDeviceServiceDataResponseDataListServiceInfo() {}

  explicit QueryDeviceServiceDataResponseDataListServiceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!time) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("time is required.")));
    }
    if (!identifier) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("identifier is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!inputData) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("inputData is required.")));
    }
    if (!outputData) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("outputData is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (inputData) {
      res["InputData"] = boost::any(*inputData);
    }
    if (outputData) {
      res["OutputData"] = boost::any(*outputData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("InputData") != m.end() && !m["InputData"].empty()) {
      inputData = make_shared<string>(boost::any_cast<string>(m["InputData"]));
    }
    if (m.find("OutputData") != m.end() && !m["OutputData"].empty()) {
      outputData = make_shared<string>(boost::any_cast<string>(m["OutputData"]));
    }
  }


  virtual ~QueryDeviceServiceDataResponseDataListServiceInfo() = default;
};
class QueryDeviceServiceDataResponseDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceServiceDataResponseDataListServiceInfo>> serviceInfo{};

  QueryDeviceServiceDataResponseDataList() {}

  explicit QueryDeviceServiceDataResponseDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!serviceInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("serviceInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*serviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceInfo") != m.end() && !m["ServiceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceInfo"].type()) {
        vector<QueryDeviceServiceDataResponseDataListServiceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceServiceDataResponseDataListServiceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceInfo = make_shared<vector<QueryDeviceServiceDataResponseDataListServiceInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceServiceDataResponseDataList() = default;
};
class QueryDeviceServiceDataResponseData : public Darabonba::Model {
public:
  shared_ptr<long> nextTime{};
  shared_ptr<bool> nextValid{};
  shared_ptr<QueryDeviceServiceDataResponseDataList> list{};

  QueryDeviceServiceDataResponseData() {}

  explicit QueryDeviceServiceDataResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nextTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nextTime is required.")));
    }
    if (!nextValid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nextValid is required.")));
    }
    if (!list) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("list is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextTime) {
      res["NextTime"] = boost::any(*nextTime);
    }
    if (nextValid) {
      res["NextValid"] = boost::any(*nextValid);
    }
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextTime") != m.end() && !m["NextTime"].empty()) {
      nextTime = make_shared<long>(boost::any_cast<long>(m["NextTime"]));
    }
    if (m.find("NextValid") != m.end() && !m["NextValid"].empty()) {
      nextValid = make_shared<bool>(boost::any_cast<bool>(m["NextValid"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDeviceServiceDataResponseDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDeviceServiceDataResponseDataList>(model1);
      }
    }
  }


  virtual ~QueryDeviceServiceDataResponseData() = default;
};
class QueryDeviceServiceDataResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceServiceDataResponseData> data{};

  QueryDeviceServiceDataResponse() {}

  explicit QueryDeviceServiceDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceServiceDataResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceServiceDataResponseData>(model1);
      }
    }
  }


  virtual ~QueryDeviceServiceDataResponse() = default;
};
class QueryDeviceEventDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<int> pageSize{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<long> startTime{};
  shared_ptr<string> identifier{};
  shared_ptr<string> eventType{};
  shared_ptr<int> asc{};
  shared_ptr<string> iotId{};
  shared_ptr<long> endTime{};

  QueryDeviceEventDataRequest() {}

  explicit QueryDeviceEventDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!startTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("startTime is required.")));
    }
    if (!endTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("endTime is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<int>(boost::any_cast<int>(m["PageSize"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<int>(boost::any_cast<int>(m["Asc"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
  }


  virtual ~QueryDeviceEventDataRequest() = default;
};
class QueryDeviceEventDataResponseDataListEventInfo : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> identifier{};
  shared_ptr<string> name{};
  shared_ptr<string> eventType{};
  shared_ptr<string> outputData{};

  QueryDeviceEventDataResponseDataListEventInfo() {}

  explicit QueryDeviceEventDataResponseDataListEventInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!time) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("time is required.")));
    }
    if (!identifier) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("identifier is required.")));
    }
    if (!name) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("name is required.")));
    }
    if (!eventType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("eventType is required.")));
    }
    if (!outputData) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("outputData is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (outputData) {
      res["OutputData"] = boost::any(*outputData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("OutputData") != m.end() && !m["OutputData"].empty()) {
      outputData = make_shared<string>(boost::any_cast<string>(m["OutputData"]));
    }
  }


  virtual ~QueryDeviceEventDataResponseDataListEventInfo() = default;
};
class QueryDeviceEventDataResponseDataList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDeviceEventDataResponseDataListEventInfo>> eventInfo{};

  QueryDeviceEventDataResponseDataList() {}

  explicit QueryDeviceEventDataResponseDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!eventInfo) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("eventInfo is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventInfo) {
      vector<boost::any> temp1;
      for(auto item1:*eventInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventInfo") != m.end() && !m["EventInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["EventInfo"].type()) {
        vector<QueryDeviceEventDataResponseDataListEventInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDeviceEventDataResponseDataListEventInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventInfo = make_shared<vector<QueryDeviceEventDataResponseDataListEventInfo>>(expect1);
      }
    }
  }


  virtual ~QueryDeviceEventDataResponseDataList() = default;
};
class QueryDeviceEventDataResponseData : public Darabonba::Model {
public:
  shared_ptr<long> nextTime{};
  shared_ptr<bool> nextValid{};
  shared_ptr<QueryDeviceEventDataResponseDataList> list{};

  QueryDeviceEventDataResponseData() {}

  explicit QueryDeviceEventDataResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!nextTime) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nextTime is required.")));
    }
    if (!nextValid) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nextValid is required.")));
    }
    if (!list) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("list is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextTime) {
      res["NextTime"] = boost::any(*nextTime);
    }
    if (nextValid) {
      res["NextValid"] = boost::any(*nextValid);
    }
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextTime") != m.end() && !m["NextTime"].empty()) {
      nextTime = make_shared<long>(boost::any_cast<long>(m["NextTime"]));
    }
    if (m.find("NextValid") != m.end() && !m["NextValid"].empty()) {
      nextValid = make_shared<bool>(boost::any_cast<bool>(m["NextValid"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        QueryDeviceEventDataResponseDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<QueryDeviceEventDataResponseDataList>(model1);
      }
    }
  }


  virtual ~QueryDeviceEventDataResponseData() = default;
};
class QueryDeviceEventDataResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceEventDataResponseData> data{};

  QueryDeviceEventDataResponse() {}

  explicit QueryDeviceEventDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceEventDataResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceEventDataResponseData>(model1);
      }
    }
  }


  virtual ~QueryDeviceEventDataResponse() = default;
};
class QueryDeviceDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};

  QueryDeviceDetailRequest() {}

  explicit QueryDeviceDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~QueryDeviceDetailRequest() = default;
};
class QueryDeviceDetailResponseData : public Darabonba::Model {
public:
  shared_ptr<string> iotId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceSecret{};
  shared_ptr<string> firmwareVersion{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> utcCreate{};
  shared_ptr<string> gmtActive{};
  shared_ptr<string> utcActive{};
  shared_ptr<string> gmtOnline{};
  shared_ptr<string> utcOnline{};
  shared_ptr<string> status{};
  shared_ptr<string> ipAddress{};
  shared_ptr<int> nodeType{};
  shared_ptr<string> region{};
  shared_ptr<bool> owner{};
  shared_ptr<string> nickname{};

  QueryDeviceDetailResponseData() {}

  explicit QueryDeviceDetailResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!iotId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("iotId is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!productName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productName is required.")));
    }
    if (!deviceName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceName is required.")));
    }
    if (!deviceSecret) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("deviceSecret is required.")));
    }
    if (!firmwareVersion) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("firmwareVersion is required.")));
    }
    if (!gmtCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtCreate is required.")));
    }
    if (!utcCreate) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcCreate is required.")));
    }
    if (!gmtActive) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtActive is required.")));
    }
    if (!utcActive) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcActive is required.")));
    }
    if (!gmtOnline) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("gmtOnline is required.")));
    }
    if (!utcOnline) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("utcOnline is required.")));
    }
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
    if (!ipAddress) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("ipAddress is required.")));
    }
    if (!nodeType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeType is required.")));
    }
    if (!region) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("region is required.")));
    }
    if (!owner) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("owner is required.")));
    }
    if (!nickname) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nickname is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceSecret) {
      res["DeviceSecret"] = boost::any(*deviceSecret);
    }
    if (firmwareVersion) {
      res["FirmwareVersion"] = boost::any(*firmwareVersion);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (utcCreate) {
      res["UtcCreate"] = boost::any(*utcCreate);
    }
    if (gmtActive) {
      res["GmtActive"] = boost::any(*gmtActive);
    }
    if (utcActive) {
      res["UtcActive"] = boost::any(*utcActive);
    }
    if (gmtOnline) {
      res["GmtOnline"] = boost::any(*gmtOnline);
    }
    if (utcOnline) {
      res["UtcOnline"] = boost::any(*utcOnline);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (nickname) {
      res["Nickname"] = boost::any(*nickname);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceSecret") != m.end() && !m["DeviceSecret"].empty()) {
      deviceSecret = make_shared<string>(boost::any_cast<string>(m["DeviceSecret"]));
    }
    if (m.find("FirmwareVersion") != m.end() && !m["FirmwareVersion"].empty()) {
      firmwareVersion = make_shared<string>(boost::any_cast<string>(m["FirmwareVersion"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("UtcCreate") != m.end() && !m["UtcCreate"].empty()) {
      utcCreate = make_shared<string>(boost::any_cast<string>(m["UtcCreate"]));
    }
    if (m.find("GmtActive") != m.end() && !m["GmtActive"].empty()) {
      gmtActive = make_shared<string>(boost::any_cast<string>(m["GmtActive"]));
    }
    if (m.find("UtcActive") != m.end() && !m["UtcActive"].empty()) {
      utcActive = make_shared<string>(boost::any_cast<string>(m["UtcActive"]));
    }
    if (m.find("GmtOnline") != m.end() && !m["GmtOnline"].empty()) {
      gmtOnline = make_shared<string>(boost::any_cast<string>(m["GmtOnline"]));
    }
    if (m.find("UtcOnline") != m.end() && !m["UtcOnline"].empty()) {
      utcOnline = make_shared<string>(boost::any_cast<string>(m["UtcOnline"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<int>(boost::any_cast<int>(m["NodeType"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<bool>(boost::any_cast<bool>(m["Owner"]));
    }
    if (m.find("Nickname") != m.end() && !m["Nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["Nickname"]));
    }
  }


  virtual ~QueryDeviceDetailResponseData() = default;
};
class QueryDeviceDetailResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<QueryDeviceDetailResponseData> data{};

  QueryDeviceDetailResponse() {}

  explicit QueryDeviceDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryDeviceDetailResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryDeviceDetailResponseData>(model1);
      }
    }
  }


  virtual ~QueryDeviceDetailResponse() = default;
};
class InvokeThingServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> identifier{};
  shared_ptr<string> args{};
  shared_ptr<string> iotId{};

  InvokeThingServiceRequest() {}

  explicit InvokeThingServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!identifier) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("identifier is required.")));
    }
    if (!args) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("args is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (args) {
      res["Args"] = boost::any(*args);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Args") != m.end() && !m["Args"].empty()) {
      args = make_shared<string>(boost::any_cast<string>(m["Args"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~InvokeThingServiceRequest() = default;
};
class InvokeThingServiceResponseData : public Darabonba::Model {
public:
  shared_ptr<string> result{};
  shared_ptr<string> messageId{};

  InvokeThingServiceResponseData() {}

  explicit InvokeThingServiceResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!result) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("result is required.")));
    }
    if (!messageId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("messageId is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~InvokeThingServiceResponseData() = default;
};
class InvokeThingServiceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> code{};
  shared_ptr<InvokeThingServiceResponseData> data{};

  InvokeThingServiceResponse() {}

  explicit InvokeThingServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        InvokeThingServiceResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<InvokeThingServiceResponseData>(model1);
      }
    }
  }


  virtual ~InvokeThingServiceResponse() = default;
};
class GetDeviceStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};

  GetDeviceStatusRequest() {}

  explicit GetDeviceStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~GetDeviceStatusRequest() = default;
};
class GetDeviceStatusResponseData : public Darabonba::Model {
public:
  shared_ptr<string> status{};

  GetDeviceStatusResponseData() {}

  explicit GetDeviceStatusResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!status) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("status is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetDeviceStatusResponseData() = default;
};
class GetDeviceStatusResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetDeviceStatusResponseData> data{};

  GetDeviceStatusResponse() {}

  explicit GetDeviceStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDeviceStatusResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDeviceStatusResponseData>(model1);
      }
    }
  }


  virtual ~GetDeviceStatusResponse() = default;
};
class EnableThingRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};

  EnableThingRequest() {}

  explicit EnableThingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~EnableThingRequest() = default;
};
class EnableThingResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  EnableThingResponse() {}

  explicit EnableThingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~EnableThingResponse() = default;
};
class DisableThingRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};

  DisableThingRequest() {}

  explicit DisableThingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~DisableThingRequest() = default;
};
class DisableThingResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DisableThingResponse() {}

  explicit DisableThingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DisableThingResponse() = default;
};
class DeleteProductRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};

  DeleteProductRequest() {}

  explicit DeleteProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
  }


  virtual ~DeleteProductRequest() = default;
};
class DeleteProductResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteProductResponse() {}

  explicit DeleteProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteProductResponse() = default;
};
class DeleteDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productKey{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> iotId{};

  DeleteDeviceRequest() {}

  explicit DeleteDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (iotId) {
      res["IotId"] = boost::any(*iotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("IotId") != m.end() && !m["IotId"].empty()) {
      iotId = make_shared<string>(boost::any_cast<string>(m["IotId"]));
    }
  }


  virtual ~DeleteDeviceRequest() = default;
};
class DeleteDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};

  DeleteDeviceResponse() {}

  explicit DeleteDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~DeleteDeviceResponse() = default;
};
class CreateProductRequest : public Darabonba::Model {
public:
  shared_ptr<string> iotInstanceId{};
  shared_ptr<string> productName{};
  shared_ptr<int> nodeType{};
  shared_ptr<int> dataFormat{};
  shared_ptr<string> description{};
  shared_ptr<string> aliyunCommodityCode{};
  shared_ptr<bool> id2{};
  shared_ptr<long> categoryId{};
  shared_ptr<string> protocolType{};
  shared_ptr<string> netType{};
  shared_ptr<string> joinPermissionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> authType{};
  shared_ptr<string> categoryKey{};
  shared_ptr<bool> publishAuto{};
  shared_ptr<int> validateType{};

  CreateProductRequest() {}

  explicit CreateProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!productName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productName is required.")));
    }
    if (!nodeType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeType is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iotInstanceId) {
      res["IotInstanceId"] = boost::any(*iotInstanceId);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (dataFormat) {
      res["DataFormat"] = boost::any(*dataFormat);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (aliyunCommodityCode) {
      res["AliyunCommodityCode"] = boost::any(*aliyunCommodityCode);
    }
    if (id2) {
      res["Id2"] = boost::any(*id2);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (joinPermissionId) {
      res["JoinPermissionId"] = boost::any(*joinPermissionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (categoryKey) {
      res["CategoryKey"] = boost::any(*categoryKey);
    }
    if (publishAuto) {
      res["PublishAuto"] = boost::any(*publishAuto);
    }
    if (validateType) {
      res["ValidateType"] = boost::any(*validateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IotInstanceId") != m.end() && !m["IotInstanceId"].empty()) {
      iotInstanceId = make_shared<string>(boost::any_cast<string>(m["IotInstanceId"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<int>(boost::any_cast<int>(m["NodeType"]));
    }
    if (m.find("DataFormat") != m.end() && !m["DataFormat"].empty()) {
      dataFormat = make_shared<int>(boost::any_cast<int>(m["DataFormat"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("AliyunCommodityCode") != m.end() && !m["AliyunCommodityCode"].empty()) {
      aliyunCommodityCode = make_shared<string>(boost::any_cast<string>(m["AliyunCommodityCode"]));
    }
    if (m.find("Id2") != m.end() && !m["Id2"].empty()) {
      id2 = make_shared<bool>(boost::any_cast<bool>(m["Id2"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<string>(boost::any_cast<string>(m["NetType"]));
    }
    if (m.find("JoinPermissionId") != m.end() && !m["JoinPermissionId"].empty()) {
      joinPermissionId = make_shared<string>(boost::any_cast<string>(m["JoinPermissionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("CategoryKey") != m.end() && !m["CategoryKey"].empty()) {
      categoryKey = make_shared<string>(boost::any_cast<string>(m["CategoryKey"]));
    }
    if (m.find("PublishAuto") != m.end() && !m["PublishAuto"].empty()) {
      publishAuto = make_shared<bool>(boost::any_cast<bool>(m["PublishAuto"]));
    }
    if (m.find("ValidateType") != m.end() && !m["ValidateType"].empty()) {
      validateType = make_shared<int>(boost::any_cast<int>(m["ValidateType"]));
    }
  }


  virtual ~CreateProductRequest() = default;
};
class CreateProductResponseData : public Darabonba::Model {
public:
  shared_ptr<int> dataFormat{};
  shared_ptr<string> description{};
  shared_ptr<int> nodeType{};
  shared_ptr<string> productKey{};
  shared_ptr<string> productName{};
  shared_ptr<string> aliyunCommodityCode{};
  shared_ptr<bool> id2{};
  shared_ptr<string> protocolType{};
  shared_ptr<string> authType{};
  shared_ptr<string> productSecret{};

  CreateProductResponseData() {}

  explicit CreateProductResponseData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!dataFormat) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("dataFormat is required.")));
    }
    if (!description) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("description is required.")));
    }
    if (!nodeType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("nodeType is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!productName) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productName is required.")));
    }
    if (!aliyunCommodityCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("aliyunCommodityCode is required.")));
    }
    if (!id2) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("id2 is required.")));
    }
    if (!protocolType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("protocolType is required.")));
    }
    if (!authType) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("authType is required.")));
    }
    if (!productSecret) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productSecret is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataFormat) {
      res["DataFormat"] = boost::any(*dataFormat);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (productName) {
      res["ProductName"] = boost::any(*productName);
    }
    if (aliyunCommodityCode) {
      res["AliyunCommodityCode"] = boost::any(*aliyunCommodityCode);
    }
    if (id2) {
      res["Id2"] = boost::any(*id2);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (productSecret) {
      res["ProductSecret"] = boost::any(*productSecret);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataFormat") != m.end() && !m["DataFormat"].empty()) {
      dataFormat = make_shared<int>(boost::any_cast<int>(m["DataFormat"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<int>(boost::any_cast<int>(m["NodeType"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("ProductName") != m.end() && !m["ProductName"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["ProductName"]));
    }
    if (m.find("AliyunCommodityCode") != m.end() && !m["AliyunCommodityCode"].empty()) {
      aliyunCommodityCode = make_shared<string>(boost::any_cast<string>(m["AliyunCommodityCode"]));
    }
    if (m.find("Id2") != m.end() && !m["Id2"].empty()) {
      id2 = make_shared<bool>(boost::any_cast<bool>(m["Id2"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("ProductSecret") != m.end() && !m["ProductSecret"].empty()) {
      productSecret = make_shared<string>(boost::any_cast<string>(m["ProductSecret"]));
    }
  }


  virtual ~CreateProductResponseData() = default;
};
class CreateProductResponse : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> productKey{};
  shared_ptr<CreateProductResponseData> data{};

  CreateProductResponse() {}

  explicit CreateProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!requestId) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("requestId is required.")));
    }
    if (!success) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("success is required.")));
    }
    if (!code) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("code is required.")));
    }
    if (!errorMessage) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("errorMessage is required.")));
    }
    if (!productKey) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("productKey is required.")));
    }
    if (!data) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("data is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (productKey) {
      res["ProductKey"] = boost::any(*productKey);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ProductKey") != m.end() && !m["ProductKey"].empty()) {
      productKey = make_shared<string>(boost::any_cast<string>(m["ProductKey"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateProductResponseData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateProductResponseData>(model1);
      }
    }
  }


  virtual ~CreateProductResponse() = default;
};
class Client : Alibabacloud_RPC::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_RPC::Config>& config);
  ListAnalyticsDataResponse listAnalyticsDataWithOptions(shared_ptr<ListAnalyticsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAnalyticsDataResponse listAnalyticsData(shared_ptr<ListAnalyticsDataRequest> request);
  BatchBindDevicesIntoProjectResponse batchBindDevicesIntoProjectWithOptions(shared_ptr<BatchBindDevicesIntoProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchBindDevicesIntoProjectResponse batchBindDevicesIntoProject(shared_ptr<BatchBindDevicesIntoProjectRequest> request);
  BatchBindProductsIntoProjectResponse batchBindProductsIntoProjectWithOptions(shared_ptr<BatchBindProductsIntoProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchBindProductsIntoProjectResponse batchBindProductsIntoProject(shared_ptr<BatchBindProductsIntoProjectRequest> request);
  BatchUnbindProjectDevicesResponse batchUnbindProjectDevicesWithOptions(shared_ptr<BatchUnbindProjectDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchUnbindProjectDevicesResponse batchUnbindProjectDevices(shared_ptr<BatchUnbindProjectDevicesRequest> request);
  BatchUnbindProjectProductsResponse batchUnbindProjectProductsWithOptions(shared_ptr<BatchUnbindProjectProductsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchUnbindProjectProductsResponse batchUnbindProjectProducts(shared_ptr<BatchUnbindProjectProductsRequest> request);
  SyncSpeechByCombinationResponse syncSpeechByCombinationWithOptions(shared_ptr<SyncSpeechByCombinationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SyncSpeechByCombinationResponse syncSpeechByCombination(shared_ptr<SyncSpeechByCombinationRequest> request);
  OpenIotServiceResponse openIotServiceWithOptions(shared_ptr<OpenIotServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenIotServiceResponse openIotService(shared_ptr<OpenIotServiceRequest> request);
  CreateRulengDistributeJobResponse createRulengDistributeJobWithOptions(shared_ptr<CreateRulengDistributeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRulengDistributeJobResponse createRulengDistributeJob(shared_ptr<CreateRulengDistributeJobRequest> request);
  ListTaskByPageResponse listTaskByPageWithOptions(shared_ptr<ListTaskByPageRequest> tmp, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTaskByPageResponse listTaskByPage(shared_ptr<ListTaskByPageRequest> request);
  ListTaskResponse listTaskWithOptions(shared_ptr<ListTaskRequest> tmp, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTaskResponse listTask(shared_ptr<ListTaskRequest> request);
  QueryJobStatisticsResponse queryJobStatisticsWithOptions(shared_ptr<QueryJobStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryJobStatisticsResponse queryJobStatistics(shared_ptr<QueryJobStatisticsRequest> request);
  DeleteJobResponse deleteJobWithOptions(shared_ptr<DeleteJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteJobResponse deleteJob(shared_ptr<DeleteJobRequest> request);
  CancelJobResponse cancelJobWithOptions(shared_ptr<CancelJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelJobResponse cancelJob(shared_ptr<CancelJobRequest> request);
  ListJobResponse listJobWithOptions(shared_ptr<ListJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListJobResponse listJob(shared_ptr<ListJobRequest> request);
  QueryJobResponse queryJobWithOptions(shared_ptr<QueryJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryJobResponse queryJob(shared_ptr<QueryJobRequest> request);
  UpdateJobResponse updateJobWithOptions(shared_ptr<UpdateJobRequest> tmp, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateJobResponse updateJob(shared_ptr<UpdateJobRequest> request);
  CreateJobResponse createJobWithOptions(shared_ptr<CreateJobRequest> tmp, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateJobResponse createJob(shared_ptr<CreateJobRequest> request);
  GenerateFileUploadURLResponse generateFileUploadURLWithOptions(shared_ptr<GenerateFileUploadURLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateFileUploadURLResponse generateFileUploadURL(shared_ptr<GenerateFileUploadURLRequest> request);
  CreateProductDistributeJobResponse createProductDistributeJobWithOptions(shared_ptr<CreateProductDistributeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProductDistributeJobResponse createProductDistributeJob(shared_ptr<CreateProductDistributeJobRequest> request);
  QueryDeviceOriginalPropertyDataResponse queryDeviceOriginalPropertyDataWithOptions(shared_ptr<QueryDeviceOriginalPropertyDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceOriginalPropertyDataResponse queryDeviceOriginalPropertyData(shared_ptr<QueryDeviceOriginalPropertyDataRequest> request);
  QueryDeviceOriginalEventDataResponse queryDeviceOriginalEventDataWithOptions(shared_ptr<QueryDeviceOriginalEventDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceOriginalEventDataResponse queryDeviceOriginalEventData(shared_ptr<QueryDeviceOriginalEventDataRequest> request);
  QueryDeviceOriginalPropertyStatusResponse queryDeviceOriginalPropertyStatusWithOptions(shared_ptr<QueryDeviceOriginalPropertyStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceOriginalPropertyStatusResponse queryDeviceOriginalPropertyStatus(shared_ptr<QueryDeviceOriginalPropertyStatusRequest> request);
  QueryDeviceOriginalServiceDataResponse queryDeviceOriginalServiceDataWithOptions(shared_ptr<QueryDeviceOriginalServiceDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceOriginalServiceDataResponse queryDeviceOriginalServiceData(shared_ptr<QueryDeviceOriginalServiceDataRequest> request);
  CreateThingScriptResponse createThingScriptWithOptions(shared_ptr<CreateThingScriptRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateThingScriptResponse createThingScript(shared_ptr<CreateThingScriptRequest> request);
  UpdateThingScriptResponse updateThingScriptWithOptions(shared_ptr<UpdateThingScriptRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateThingScriptResponse updateThingScript(shared_ptr<UpdateThingScriptRequest> request);
  GetThingScriptResponse getThingScriptWithOptions(shared_ptr<GetThingScriptRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetThingScriptResponse getThingScript(shared_ptr<GetThingScriptRequest> request);
  ListOTAModuleVersionsByDeviceResponse listOTAModuleVersionsByDeviceWithOptions(shared_ptr<ListOTAModuleVersionsByDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOTAModuleVersionsByDeviceResponse listOTAModuleVersionsByDevice(shared_ptr<ListOTAModuleVersionsByDeviceRequest> request);
  BatchPubResponse batchPubWithOptions(shared_ptr<BatchPubRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchPubResponse batchPub(shared_ptr<BatchPubRequest> request);
  SpeechByCombinationResponse speechByCombinationWithOptions(shared_ptr<SpeechByCombinationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SpeechByCombinationResponse speechByCombination(shared_ptr<SpeechByCombinationRequest> request);
  UpdateThingModelValidationConfigResponse updateThingModelValidationConfigWithOptions(shared_ptr<UpdateThingModelValidationConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateThingModelValidationConfigResponse updateThingModelValidationConfig(shared_ptr<UpdateThingModelValidationConfigRequest> request);
  QueryDeviceBySQLResponse queryDeviceBySQLWithOptions(shared_ptr<QueryDeviceBySQLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceBySQLResponse queryDeviceBySQL(shared_ptr<QueryDeviceBySQLRequest> request);
  ListOTAModuleByProductResponse listOTAModuleByProductWithOptions(shared_ptr<ListOTAModuleByProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOTAModuleByProductResponse listOTAModuleByProduct(shared_ptr<ListOTAModuleByProductRequest> request);
  DeleteOTAModuleResponse deleteOTAModuleWithOptions(shared_ptr<DeleteOTAModuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteOTAModuleResponse deleteOTAModule(shared_ptr<DeleteOTAModuleRequest> request);
  GenerateDeviceNameListURLResponse generateDeviceNameListURLWithOptions(shared_ptr<GenerateDeviceNameListURLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateDeviceNameListURLResponse generateDeviceNameListURL(shared_ptr<GenerateDeviceNameListURLRequest> request);
  UpdateOTAModuleResponse updateOTAModuleWithOptions(shared_ptr<UpdateOTAModuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateOTAModuleResponse updateOTAModule(shared_ptr<UpdateOTAModuleRequest> request);
  CreateOTAModuleResponse createOTAModuleWithOptions(shared_ptr<CreateOTAModuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOTAModuleResponse createOTAModule(shared_ptr<CreateOTAModuleRequest> request);
  QueryThingModelExtendConfigPublishedResponse queryThingModelExtendConfigPublishedWithOptions(shared_ptr<QueryThingModelExtendConfigPublishedRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryThingModelExtendConfigPublishedResponse queryThingModelExtendConfigPublished(shared_ptr<QueryThingModelExtendConfigPublishedRequest> request);
  GetThingModelTslPublishedResponse getThingModelTslPublishedWithOptions(shared_ptr<GetThingModelTslPublishedRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetThingModelTslPublishedResponse getThingModelTslPublished(shared_ptr<GetThingModelTslPublishedRequest> request);
  QueryThingModelPublishedResponse queryThingModelPublishedWithOptions(shared_ptr<QueryThingModelPublishedRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryThingModelPublishedResponse queryThingModelPublished(shared_ptr<QueryThingModelPublishedRequest> request);
  QueryThingModelExtendConfigResponse queryThingModelExtendConfigWithOptions(shared_ptr<QueryThingModelExtendConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryThingModelExtendConfigResponse queryThingModelExtendConfig(shared_ptr<QueryThingModelExtendConfigRequest> request);
  ListDistributedDeviceResponse listDistributedDeviceWithOptions(shared_ptr<ListDistributedDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDistributedDeviceResponse listDistributedDevice(shared_ptr<ListDistributedDeviceRequest> request);
  ListDistributedProductResponse listDistributedProductWithOptions(shared_ptr<ListDistributedProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDistributedProductResponse listDistributedProduct(shared_ptr<ListDistributedProductRequest> request);
  QuerySubscribeRelationResponse querySubscribeRelationWithOptions(shared_ptr<QuerySubscribeRelationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySubscribeRelationResponse querySubscribeRelation(shared_ptr<QuerySubscribeRelationRequest> request);
  CreateConsumerGroupSubscribeRelationResponse createConsumerGroupSubscribeRelationWithOptions(shared_ptr<CreateConsumerGroupSubscribeRelationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateConsumerGroupSubscribeRelationResponse createConsumerGroupSubscribeRelation(shared_ptr<CreateConsumerGroupSubscribeRelationRequest> request);
  UpdateSubscribeRelationResponse updateSubscribeRelationWithOptions(shared_ptr<UpdateSubscribeRelationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSubscribeRelationResponse updateSubscribeRelation(shared_ptr<UpdateSubscribeRelationRequest> request);
  DeleteConsumerGroupSubscribeRelationResponse deleteConsumerGroupSubscribeRelationWithOptions(shared_ptr<DeleteConsumerGroupSubscribeRelationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteConsumerGroupSubscribeRelationResponse deleteConsumerGroupSubscribeRelation(shared_ptr<DeleteConsumerGroupSubscribeRelationRequest> request);
  ResetConsumerGroupPositionResponse resetConsumerGroupPositionWithOptions(shared_ptr<ResetConsumerGroupPositionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetConsumerGroupPositionResponse resetConsumerGroupPosition(shared_ptr<ResetConsumerGroupPositionRequest> request);
  UpdateConsumerGroupResponse updateConsumerGroupWithOptions(shared_ptr<UpdateConsumerGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateConsumerGroupResponse updateConsumerGroup(shared_ptr<UpdateConsumerGroupRequest> request);
  BatchDeleteEdgeInstanceChannelResponse batchDeleteEdgeInstanceChannelWithOptions(shared_ptr<BatchDeleteEdgeInstanceChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchDeleteEdgeInstanceChannelResponse batchDeleteEdgeInstanceChannel(shared_ptr<BatchDeleteEdgeInstanceChannelRequest> request);
  BatchSetEdgeInstanceDeviceChannelResponse batchSetEdgeInstanceDeviceChannelWithOptions(shared_ptr<BatchSetEdgeInstanceDeviceChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchSetEdgeInstanceDeviceChannelResponse batchSetEdgeInstanceDeviceChannel(shared_ptr<BatchSetEdgeInstanceDeviceChannelRequest> request);
  BatchGetEdgeInstanceDeviceDriverResponse batchGetEdgeInstanceDeviceDriverWithOptions(shared_ptr<BatchGetEdgeInstanceDeviceDriverRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetEdgeInstanceDeviceDriverResponse batchGetEdgeInstanceDeviceDriver(shared_ptr<BatchGetEdgeInstanceDeviceDriverRequest> request);
  BatchGetEdgeInstanceDeviceChannelResponse batchGetEdgeInstanceDeviceChannelWithOptions(shared_ptr<BatchGetEdgeInstanceDeviceChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetEdgeInstanceDeviceChannelResponse batchGetEdgeInstanceDeviceChannel(shared_ptr<BatchGetEdgeInstanceDeviceChannelRequest> request);
  ReleaseEdgeDriverVersionResponse releaseEdgeDriverVersionWithOptions(shared_ptr<ReleaseEdgeDriverVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseEdgeDriverVersionResponse releaseEdgeDriverVersion(shared_ptr<ReleaseEdgeDriverVersionRequest> request);
  QueryEdgeInstanceDeviceByDriverResponse queryEdgeInstanceDeviceByDriverWithOptions(shared_ptr<QueryEdgeInstanceDeviceByDriverRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeInstanceDeviceByDriverResponse queryEdgeInstanceDeviceByDriver(shared_ptr<QueryEdgeInstanceDeviceByDriverRequest> request);
  DisableSceneRuleResponse disableSceneRuleWithOptions(shared_ptr<DisableSceneRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableSceneRuleResponse disableSceneRule(shared_ptr<DisableSceneRuleRequest> request);
  TriggerSceneRuleResponse triggerSceneRuleWithOptions(shared_ptr<TriggerSceneRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TriggerSceneRuleResponse triggerSceneRule(shared_ptr<TriggerSceneRuleRequest> request);
  UnbindSceneRuleFromEdgeInstanceResponse unbindSceneRuleFromEdgeInstanceWithOptions(shared_ptr<UnbindSceneRuleFromEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindSceneRuleFromEdgeInstanceResponse unbindSceneRuleFromEdgeInstance(shared_ptr<UnbindSceneRuleFromEdgeInstanceRequest> request);
  QueryEdgeInstanceSceneRuleResponse queryEdgeInstanceSceneRuleWithOptions(shared_ptr<QueryEdgeInstanceSceneRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeInstanceSceneRuleResponse queryEdgeInstanceSceneRule(shared_ptr<QueryEdgeInstanceSceneRuleRequest> request);
  CreateSceneRuleResponse createSceneRuleWithOptions(shared_ptr<CreateSceneRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSceneRuleResponse createSceneRule(shared_ptr<CreateSceneRuleRequest> request);
  QueryDetailSceneRuleLogResponse queryDetailSceneRuleLogWithOptions(shared_ptr<QueryDetailSceneRuleLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDetailSceneRuleLogResponse queryDetailSceneRuleLog(shared_ptr<QueryDetailSceneRuleLogRequest> request);
  EnableSceneRuleResponse enableSceneRuleWithOptions(shared_ptr<EnableSceneRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableSceneRuleResponse enableSceneRule(shared_ptr<EnableSceneRuleRequest> request);
  UpdateSceneRuleResponse updateSceneRuleWithOptions(shared_ptr<UpdateSceneRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSceneRuleResponse updateSceneRule(shared_ptr<UpdateSceneRuleRequest> request);
  QuerySceneRuleResponse querySceneRuleWithOptions(shared_ptr<QuerySceneRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySceneRuleResponse querySceneRule(shared_ptr<QuerySceneRuleRequest> request);
  QuerySummarySceneRuleLogResponse querySummarySceneRuleLogWithOptions(shared_ptr<QuerySummarySceneRuleLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySummarySceneRuleLogResponse querySummarySceneRuleLog(shared_ptr<QuerySummarySceneRuleLogRequest> request);
  GetSceneRuleResponse getSceneRuleWithOptions(shared_ptr<GetSceneRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSceneRuleResponse getSceneRule(shared_ptr<GetSceneRuleRequest> request);
  DeleteSceneRuleResponse deleteSceneRuleWithOptions(shared_ptr<DeleteSceneRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSceneRuleResponse deleteSceneRule(shared_ptr<DeleteSceneRuleRequest> request);
  BindSceneRuleToEdgeInstanceResponse bindSceneRuleToEdgeInstanceWithOptions(shared_ptr<BindSceneRuleToEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindSceneRuleToEdgeInstanceResponse bindSceneRuleToEdgeInstance(shared_ptr<BindSceneRuleToEdgeInstanceRequest> request);
  CreateEdgeOssPreSignedAddressResponse createEdgeOssPreSignedAddressWithOptions(shared_ptr<CreateEdgeOssPreSignedAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEdgeOssPreSignedAddressResponse createEdgeOssPreSignedAddress(shared_ptr<CreateEdgeOssPreSignedAddressRequest> request);
  UpdateEdgeDriverVersionResponse updateEdgeDriverVersionWithOptions(shared_ptr<UpdateEdgeDriverVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEdgeDriverVersionResponse updateEdgeDriverVersion(shared_ptr<UpdateEdgeDriverVersionRequest> request);
  DeleteEdgeDriverVersionResponse deleteEdgeDriverVersionWithOptions(shared_ptr<DeleteEdgeDriverVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEdgeDriverVersionResponse deleteEdgeDriverVersion(shared_ptr<DeleteEdgeDriverVersionRequest> request);
  CreateEdgeDriverVersionResponse createEdgeDriverVersionWithOptions(shared_ptr<CreateEdgeDriverVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEdgeDriverVersionResponse createEdgeDriverVersion(shared_ptr<CreateEdgeDriverVersionRequest> request);
  DeleteEdgeDriverResponse deleteEdgeDriverWithOptions(shared_ptr<DeleteEdgeDriverRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEdgeDriverResponse deleteEdgeDriver(shared_ptr<DeleteEdgeDriverRequest> request);
  QueryEdgeDriverResponse queryEdgeDriverWithOptions(shared_ptr<QueryEdgeDriverRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeDriverResponse queryEdgeDriver(shared_ptr<QueryEdgeDriverRequest> request);
  BatchGetEdgeDriverResponse batchGetEdgeDriverWithOptions(shared_ptr<BatchGetEdgeDriverRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetEdgeDriverResponse batchGetEdgeDriver(shared_ptr<BatchGetEdgeDriverRequest> request);
  CreateEdgeDriverResponse createEdgeDriverWithOptions(shared_ptr<CreateEdgeDriverRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEdgeDriverResponse createEdgeDriver(shared_ptr<CreateEdgeDriverRequest> request);
  GetEdgeDriverVersionResponse getEdgeDriverVersionWithOptions(shared_ptr<GetEdgeDriverVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEdgeDriverVersionResponse getEdgeDriverVersion(shared_ptr<GetEdgeDriverVersionRequest> request);
  QueryEdgeDriverVersionResponse queryEdgeDriverVersionWithOptions(shared_ptr<QueryEdgeDriverVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeDriverVersionResponse queryEdgeDriverVersion(shared_ptr<QueryEdgeDriverVersionRequest> request);
  BatchGetDeviceBindStatusResponse batchGetDeviceBindStatusWithOptions(shared_ptr<BatchGetDeviceBindStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetDeviceBindStatusResponse batchGetDeviceBindStatus(shared_ptr<BatchGetDeviceBindStatusRequest> request);
  ListOTAJobByDeviceResponse listOTAJobByDeviceWithOptions(shared_ptr<ListOTAJobByDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOTAJobByDeviceResponse listOTAJobByDevice(shared_ptr<ListOTAJobByDeviceRequest> request);
  UpdateThingModelResponse updateThingModelWithOptions(shared_ptr<UpdateThingModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateThingModelResponse updateThingModel(shared_ptr<UpdateThingModelRequest> request);
  CreateThingModelResponse createThingModelWithOptions(shared_ptr<CreateThingModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateThingModelResponse createThingModel(shared_ptr<CreateThingModelRequest> request);
  ListOTATaskByJobResponse listOTATaskByJobWithOptions(shared_ptr<ListOTATaskByJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOTATaskByJobResponse listOTATaskByJob(shared_ptr<ListOTATaskByJobRequest> request);
  ListThingTemplatesResponse listThingTemplatesWithOptions(shared_ptr<ListThingTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListThingTemplatesResponse listThingTemplates(shared_ptr<ListThingTemplatesRequest> request);
  GetThingTemplateResponse getThingTemplateWithOptions(shared_ptr<GetThingTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetThingTemplateResponse getThingTemplate(shared_ptr<GetThingTemplateRequest> request);
  ListThingModelVersionResponse listThingModelVersionWithOptions(shared_ptr<ListThingModelVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListThingModelVersionResponse listThingModelVersion(shared_ptr<ListThingModelVersionRequest> request);
  ImportThingModelTslResponse importThingModelTslWithOptions(shared_ptr<ImportThingModelTslRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportThingModelTslResponse importThingModelTsl(shared_ptr<ImportThingModelTslRequest> request);
  PublishThingModelResponse publishThingModelWithOptions(shared_ptr<PublishThingModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublishThingModelResponse publishThingModel(shared_ptr<PublishThingModelRequest> request);
  CopyThingModelResponse copyThingModelWithOptions(shared_ptr<CopyThingModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CopyThingModelResponse copyThingModel(shared_ptr<CopyThingModelRequest> request);
  GetThingModelTslResponse getThingModelTslWithOptions(shared_ptr<GetThingModelTslRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetThingModelTslResponse getThingModelTsl(shared_ptr<GetThingModelTslRequest> request);
  QueryThingModelResponse queryThingModelWithOptions(shared_ptr<QueryThingModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryThingModelResponse queryThingModel(shared_ptr<QueryThingModelRequest> request);
  DeleteThingModelResponse deleteThingModelWithOptions(shared_ptr<DeleteThingModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteThingModelResponse deleteThingModel(shared_ptr<DeleteThingModelRequest> request);
  UpdateProductFilterConfigResponse updateProductFilterConfigWithOptions(shared_ptr<UpdateProductFilterConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProductFilterConfigResponse updateProductFilterConfig(shared_ptr<UpdateProductFilterConfigRequest> request);
  CancelOTAStrategyByJobResponse cancelOTAStrategyByJobWithOptions(shared_ptr<CancelOTAStrategyByJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelOTAStrategyByJobResponse cancelOTAStrategyByJob(shared_ptr<CancelOTAStrategyByJobRequest> request);
  ListOTAJobByFirmwareResponse listOTAJobByFirmwareWithOptions(shared_ptr<ListOTAJobByFirmwareRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOTAJobByFirmwareResponse listOTAJobByFirmware(shared_ptr<ListOTAJobByFirmwareRequest> request);
  ListOTAFirmwareResponse listOTAFirmwareWithOptions(shared_ptr<ListOTAFirmwareRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOTAFirmwareResponse listOTAFirmware(shared_ptr<ListOTAFirmwareRequest> request);
  CancelOTATaskByJobResponse cancelOTATaskByJobWithOptions(shared_ptr<CancelOTATaskByJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelOTATaskByJobResponse cancelOTATaskByJob(shared_ptr<CancelOTATaskByJobRequest> request);
  CreateDeviceDistributeJobResponse createDeviceDistributeJobWithOptions(shared_ptr<CreateDeviceDistributeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDeviceDistributeJobResponse createDeviceDistributeJob(shared_ptr<CreateDeviceDistributeJobRequest> request);
  QueryDeviceDistributeDetailResponse queryDeviceDistributeDetailWithOptions(shared_ptr<QueryDeviceDistributeDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceDistributeDetailResponse queryDeviceDistributeDetail(shared_ptr<QueryDeviceDistributeDetailRequest> request);
  ListDeviceDistributeJobResponse listDeviceDistributeJobWithOptions(shared_ptr<ListDeviceDistributeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDeviceDistributeJobResponse listDeviceDistributeJob(shared_ptr<ListDeviceDistributeJobRequest> request);
  QueryDeviceDistributeJobResponse queryDeviceDistributeJobWithOptions(shared_ptr<QueryDeviceDistributeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceDistributeJobResponse queryDeviceDistributeJob(shared_ptr<QueryDeviceDistributeJobRequest> request);
  DeleteDeviceDistributeJobResponse deleteDeviceDistributeJobWithOptions(shared_ptr<DeleteDeviceDistributeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDeviceDistributeJobResponse deleteDeviceDistributeJob(shared_ptr<DeleteDeviceDistributeJobRequest> request);
  QueryDeviceByStatusResponse queryDeviceByStatusWithOptions(shared_ptr<QueryDeviceByStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceByStatusResponse queryDeviceByStatus(shared_ptr<QueryDeviceByStatusRequest> request);
  GenerateOTAUploadURLResponse generateOTAUploadURLWithOptions(shared_ptr<GenerateOTAUploadURLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateOTAUploadURLResponse generateOTAUploadURL(shared_ptr<GenerateOTAUploadURLRequest> request);
  QueryProductCertInfoResponse queryProductCertInfoWithOptions(shared_ptr<QueryProductCertInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryProductCertInfoResponse queryProductCertInfo(shared_ptr<QueryProductCertInfoRequest> request);
  SetProductCertInfoResponse setProductCertInfoWithOptions(shared_ptr<SetProductCertInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetProductCertInfoResponse setProductCertInfo(shared_ptr<SetProductCertInfoRequest> request);
  CreateSubscribeRelationResponse createSubscribeRelationWithOptions(shared_ptr<CreateSubscribeRelationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSubscribeRelationResponse createSubscribeRelation(shared_ptr<CreateSubscribeRelationRequest> request);
  DeleteSubscribeRelationResponse deleteSubscribeRelationWithOptions(shared_ptr<DeleteSubscribeRelationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSubscribeRelationResponse deleteSubscribeRelation(shared_ptr<DeleteSubscribeRelationRequest> request);
  QueryConsumerGroupStatusResponse queryConsumerGroupStatusWithOptions(shared_ptr<QueryConsumerGroupStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryConsumerGroupStatusResponse queryConsumerGroupStatus(shared_ptr<QueryConsumerGroupStatusRequest> request);
  DeleteConsumerGroupResponse deleteConsumerGroupWithOptions(shared_ptr<DeleteConsumerGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteConsumerGroupResponse deleteConsumerGroup(shared_ptr<DeleteConsumerGroupRequest> request);
  QueryConsumerGroupListResponse queryConsumerGroupListWithOptions(shared_ptr<QueryConsumerGroupListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryConsumerGroupListResponse queryConsumerGroupList(shared_ptr<QueryConsumerGroupListRequest> request);
  QueryConsumerGroupByGroupIdResponse queryConsumerGroupByGroupIdWithOptions(shared_ptr<QueryConsumerGroupByGroupIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryConsumerGroupByGroupIdResponse queryConsumerGroupByGroupId(shared_ptr<QueryConsumerGroupByGroupIdRequest> request);
  CreateConsumerGroupResponse createConsumerGroupWithOptions(shared_ptr<CreateConsumerGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateConsumerGroupResponse createConsumerGroup(shared_ptr<CreateConsumerGroupRequest> request);
  CreateOTADynamicUpgradeJobResponse createOTADynamicUpgradeJobWithOptions(shared_ptr<CreateOTADynamicUpgradeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOTADynamicUpgradeJobResponse createOTADynamicUpgradeJob(shared_ptr<CreateOTADynamicUpgradeJobRequest> request);
  CreateOTAStaticUpgradeJobResponse createOTAStaticUpgradeJobWithOptions(shared_ptr<CreateOTAStaticUpgradeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOTAStaticUpgradeJobResponse createOTAStaticUpgradeJob(shared_ptr<CreateOTAStaticUpgradeJobRequest> request);
  CreateOTAFirmwareResponse createOTAFirmwareWithOptions(shared_ptr<CreateOTAFirmwareRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOTAFirmwareResponse createOTAFirmware(shared_ptr<CreateOTAFirmwareRequest> request);
  CreateOTAVerifyJobResponse createOTAVerifyJobWithOptions(shared_ptr<CreateOTAVerifyJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOTAVerifyJobResponse createOTAVerifyJob(shared_ptr<CreateOTAVerifyJobRequest> request);
  QueryOTAJobResponse queryOTAJobWithOptions(shared_ptr<QueryOTAJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryOTAJobResponse queryOTAJob(shared_ptr<QueryOTAJobRequest> request);
  CancelOTATaskByDeviceResponse cancelOTATaskByDeviceWithOptions(shared_ptr<CancelOTATaskByDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelOTATaskByDeviceResponse cancelOTATaskByDevice(shared_ptr<CancelOTATaskByDeviceRequest> request);
  DeleteOTAFirmwareResponse deleteOTAFirmwareWithOptions(shared_ptr<DeleteOTAFirmwareRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteOTAFirmwareResponse deleteOTAFirmware(shared_ptr<DeleteOTAFirmwareRequest> request);
  QueryOTAFirmwareResponse queryOTAFirmwareWithOptions(shared_ptr<QueryOTAFirmwareRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryOTAFirmwareResponse queryOTAFirmware(shared_ptr<QueryOTAFirmwareRequest> request);
  UnbindApplicationFromEdgeInstanceResponse unbindApplicationFromEdgeInstanceWithOptions(shared_ptr<UnbindApplicationFromEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindApplicationFromEdgeInstanceResponse unbindApplicationFromEdgeInstance(shared_ptr<UnbindApplicationFromEdgeInstanceRequest> request);
  BindApplicationToEdgeInstanceResponse bindApplicationToEdgeInstanceWithOptions(shared_ptr<BindApplicationToEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindApplicationToEdgeInstanceResponse bindApplicationToEdgeInstance(shared_ptr<BindApplicationToEdgeInstanceRequest> request);
  QueryCertUrlByApplyIdResponse queryCertUrlByApplyIdWithOptions(shared_ptr<QueryCertUrlByApplyIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryCertUrlByApplyIdResponse queryCertUrlByApplyId(shared_ptr<QueryCertUrlByApplyIdRequest> request);
  QueryDeviceCertResponse queryDeviceCertWithOptions(shared_ptr<QueryDeviceCertRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceCertResponse queryDeviceCert(shared_ptr<QueryDeviceCertRequest> request);
  CloseEdgeInstanceDeploymentResponse closeEdgeInstanceDeploymentWithOptions(shared_ptr<CloseEdgeInstanceDeploymentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CloseEdgeInstanceDeploymentResponse closeEdgeInstanceDeployment(shared_ptr<CloseEdgeInstanceDeploymentRequest> request);
  UnbindDriverFromEdgeInstanceResponse unbindDriverFromEdgeInstanceWithOptions(shared_ptr<UnbindDriverFromEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindDriverFromEdgeInstanceResponse unbindDriverFromEdgeInstance(shared_ptr<UnbindDriverFromEdgeInstanceRequest> request);
  ReplaceEdgeInstanceGatewayResponse replaceEdgeInstanceGatewayWithOptions(shared_ptr<ReplaceEdgeInstanceGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReplaceEdgeInstanceGatewayResponse replaceEdgeInstanceGateway(shared_ptr<ReplaceEdgeInstanceGatewayRequest> request);
  BindDriverToEdgeInstanceResponse bindDriverToEdgeInstanceWithOptions(shared_ptr<BindDriverToEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindDriverToEdgeInstanceResponse bindDriverToEdgeInstance(shared_ptr<BindDriverToEdgeInstanceRequest> request);
  BatchQueryDeviceDetailResponse batchQueryDeviceDetailWithOptions(shared_ptr<BatchQueryDeviceDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchQueryDeviceDetailResponse batchQueryDeviceDetail(shared_ptr<BatchQueryDeviceDetailRequest> request);
  GetEdgeInstanceDeploymentResponse getEdgeInstanceDeploymentWithOptions(shared_ptr<GetEdgeInstanceDeploymentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEdgeInstanceDeploymentResponse getEdgeInstanceDeployment(shared_ptr<GetEdgeInstanceDeploymentRequest> request);
  QueryTaskResponse queryTaskWithOptions(shared_ptr<QueryTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTaskResponse queryTask(shared_ptr<QueryTaskRequest> request);
  CreateDataAPIServiceResponse createDataAPIServiceWithOptions(shared_ptr<CreateDataAPIServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataAPIServiceResponse createDataAPIService(shared_ptr<CreateDataAPIServiceRequest> request);
  GetDataAPIServiceDetailResponse getDataAPIServiceDetailWithOptions(shared_ptr<GetDataAPIServiceDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataAPIServiceDetailResponse getDataAPIServiceDetail(shared_ptr<GetDataAPIServiceDetailRequest> request);
  InvokeDataAPIServiceResponse invokeDataAPIServiceWithOptions(shared_ptr<InvokeDataAPIServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InvokeDataAPIServiceResponse invokeDataAPIService(shared_ptr<InvokeDataAPIServiceRequest> request);
  UpdateEdgeInstanceChannelResponse updateEdgeInstanceChannelWithOptions(shared_ptr<UpdateEdgeInstanceChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEdgeInstanceChannelResponse updateEdgeInstanceChannel(shared_ptr<UpdateEdgeInstanceChannelRequest> request);
  QueryEdgeInstanceChannelResponse queryEdgeInstanceChannelWithOptions(shared_ptr<QueryEdgeInstanceChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeInstanceChannelResponse queryEdgeInstanceChannel(shared_ptr<QueryEdgeInstanceChannelRequest> request);
  BatchUnbindDeviceFromEdgeInstanceResponse batchUnbindDeviceFromEdgeInstanceWithOptions(shared_ptr<BatchUnbindDeviceFromEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchUnbindDeviceFromEdgeInstanceResponse batchUnbindDeviceFromEdgeInstance(shared_ptr<BatchUnbindDeviceFromEdgeInstanceRequest> request);
  SetEdgeInstanceDriverConfigsResponse setEdgeInstanceDriverConfigsWithOptions(shared_ptr<SetEdgeInstanceDriverConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetEdgeInstanceDriverConfigsResponse setEdgeInstanceDriverConfigs(shared_ptr<SetEdgeInstanceDriverConfigsRequest> request);
  CreateEdgeInstanceChannelResponse createEdgeInstanceChannelWithOptions(shared_ptr<CreateEdgeInstanceChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEdgeInstanceChannelResponse createEdgeInstanceChannel(shared_ptr<CreateEdgeInstanceChannelRequest> request);
  BatchBindDeviceToEdgeInstanceWithDriverResponse batchBindDeviceToEdgeInstanceWithDriverWithOptions(shared_ptr<BatchBindDeviceToEdgeInstanceWithDriverRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchBindDeviceToEdgeInstanceWithDriverResponse batchBindDeviceToEdgeInstanceWithDriver(shared_ptr<BatchBindDeviceToEdgeInstanceWithDriverRequest> request);
  BatchGetEdgeInstanceChannelResponse batchGetEdgeInstanceChannelWithOptions(shared_ptr<BatchGetEdgeInstanceChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetEdgeInstanceChannelResponse batchGetEdgeInstanceChannel(shared_ptr<BatchGetEdgeInstanceChannelRequest> request);
  BatchSetEdgeInstanceDeviceConfigResponse batchSetEdgeInstanceDeviceConfigWithOptions(shared_ptr<BatchSetEdgeInstanceDeviceConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchSetEdgeInstanceDeviceConfigResponse batchSetEdgeInstanceDeviceConfig(shared_ptr<BatchSetEdgeInstanceDeviceConfigRequest> request);
  BatchClearEdgeInstanceDeviceConfigResponse batchClearEdgeInstanceDeviceConfigWithOptions(shared_ptr<BatchClearEdgeInstanceDeviceConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchClearEdgeInstanceDeviceConfigResponse batchClearEdgeInstanceDeviceConfig(shared_ptr<BatchClearEdgeInstanceDeviceConfigRequest> request);
  BatchGetEdgeInstanceDeviceConfigResponse batchGetEdgeInstanceDeviceConfigWithOptions(shared_ptr<BatchGetEdgeInstanceDeviceConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetEdgeInstanceDeviceConfigResponse batchGetEdgeInstanceDeviceConfig(shared_ptr<BatchGetEdgeInstanceDeviceConfigRequest> request);
  BatchGetEdgeInstanceDriverConfigsResponse batchGetEdgeInstanceDriverConfigsWithOptions(shared_ptr<BatchGetEdgeInstanceDriverConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetEdgeInstanceDriverConfigsResponse batchGetEdgeInstanceDriverConfigs(shared_ptr<BatchGetEdgeInstanceDriverConfigsRequest> request);
  ClearEdgeInstanceDriverConfigsResponse clearEdgeInstanceDriverConfigsWithOptions(shared_ptr<ClearEdgeInstanceDriverConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ClearEdgeInstanceDriverConfigsResponse clearEdgeInstanceDriverConfigs(shared_ptr<ClearEdgeInstanceDriverConfigsRequest> request);
  CreateLoRaNodesTaskResponse createLoRaNodesTaskWithOptions(shared_ptr<CreateLoRaNodesTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLoRaNodesTaskResponse createLoRaNodesTask(shared_ptr<CreateLoRaNodesTaskRequest> request);
  GetLoraNodesTaskResponse getLoraNodesTaskWithOptions(shared_ptr<GetLoraNodesTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLoraNodesTaskResponse getLoraNodesTask(shared_ptr<GetLoraNodesTaskRequest> request);
  QueryLoRaJoinPermissionsResponse queryLoRaJoinPermissionsWithOptions(shared_ptr<QueryLoRaJoinPermissionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryLoRaJoinPermissionsResponse queryLoRaJoinPermissions(shared_ptr<QueryLoRaJoinPermissionsRequest> request);
  QueryEdgeInstanceDriverResponse queryEdgeInstanceDriverWithOptions(shared_ptr<QueryEdgeInstanceDriverRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeInstanceDriverResponse queryEdgeInstanceDriver(shared_ptr<QueryEdgeInstanceDriverRequest> request);
  BatchUpdateDeviceNicknameResponse batchUpdateDeviceNicknameWithOptions(shared_ptr<BatchUpdateDeviceNicknameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchUpdateDeviceNicknameResponse batchUpdateDeviceNickname(shared_ptr<BatchUpdateDeviceNicknameRequest> request);
  QueryDeviceFileResponse queryDeviceFileWithOptions(shared_ptr<QueryDeviceFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceFileResponse queryDeviceFile(shared_ptr<QueryDeviceFileRequest> request);
  QueryDeviceFileListResponse queryDeviceFileListWithOptions(shared_ptr<QueryDeviceFileListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceFileListResponse queryDeviceFileList(shared_ptr<QueryDeviceFileListRequest> request);
  DeleteDeviceFileResponse deleteDeviceFileWithOptions(shared_ptr<DeleteDeviceFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDeviceFileResponse deleteDeviceFile(shared_ptr<DeleteDeviceFileRequest> request);
  GetNodesAddingTaskResponse getNodesAddingTaskWithOptions(shared_ptr<GetNodesAddingTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNodesAddingTaskResponse getNodesAddingTask(shared_ptr<GetNodesAddingTaskRequest> request);
  SetDeviceDesiredPropertyResponse setDeviceDesiredPropertyWithOptions(shared_ptr<SetDeviceDesiredPropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDeviceDesiredPropertyResponse setDeviceDesiredProperty(shared_ptr<SetDeviceDesiredPropertyRequest> request);
  QueryDeviceDesiredPropertyResponse queryDeviceDesiredPropertyWithOptions(shared_ptr<QueryDeviceDesiredPropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceDesiredPropertyResponse queryDeviceDesiredProperty(shared_ptr<QueryDeviceDesiredPropertyRequest> request);
  QueryEdgeInstanceHistoricDeploymentResponse queryEdgeInstanceHistoricDeploymentWithOptions(shared_ptr<QueryEdgeInstanceHistoricDeploymentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeInstanceHistoricDeploymentResponse queryEdgeInstanceHistoricDeployment(shared_ptr<QueryEdgeInstanceHistoricDeploymentRequest> request);
  CreateProductTagsResponse createProductTagsWithOptions(shared_ptr<CreateProductTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProductTagsResponse createProductTags(shared_ptr<CreateProductTagsRequest> request);
  UpdateProductTagsResponse updateProductTagsWithOptions(shared_ptr<UpdateProductTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProductTagsResponse updateProductTags(shared_ptr<UpdateProductTagsRequest> request);
  DeleteProductTagsResponse deleteProductTagsWithOptions(shared_ptr<DeleteProductTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteProductTagsResponse deleteProductTags(shared_ptr<DeleteProductTagsRequest> request);
  ListProductTagsResponse listProductTagsWithOptions(shared_ptr<ListProductTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProductTagsResponse listProductTags(shared_ptr<ListProductTagsRequest> request);
  ListProductByTagsResponse listProductByTagsWithOptions(shared_ptr<ListProductByTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProductByTagsResponse listProductByTags(shared_ptr<ListProductByTagsRequest> request);
  QueryDeviceGroupByTagsResponse queryDeviceGroupByTagsWithOptions(shared_ptr<QueryDeviceGroupByTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceGroupByTagsResponse queryDeviceGroupByTags(shared_ptr<QueryDeviceGroupByTagsRequest> request);
  BatchAddThingTopoResponse batchAddThingTopoWithOptions(shared_ptr<BatchAddThingTopoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchAddThingTopoResponse batchAddThingTopo(shared_ptr<BatchAddThingTopoRequest> request);
  QueryDeviceListByDeviceGroupResponse queryDeviceListByDeviceGroupWithOptions(shared_ptr<QueryDeviceListByDeviceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceListByDeviceGroupResponse queryDeviceListByDeviceGroup(shared_ptr<QueryDeviceListByDeviceGroupRequest> request);
  QueryDevicePropertiesDataResponse queryDevicePropertiesDataWithOptions(shared_ptr<QueryDevicePropertiesDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDevicePropertiesDataResponse queryDevicePropertiesData(shared_ptr<QueryDevicePropertiesDataRequest> request);
  UnbindRoleFromEdgeInstanceResponse unbindRoleFromEdgeInstanceWithOptions(shared_ptr<UnbindRoleFromEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindRoleFromEdgeInstanceResponse unbindRoleFromEdgeInstance(shared_ptr<UnbindRoleFromEdgeInstanceRequest> request);
  UpdateEdgeInstanceResponse updateEdgeInstanceWithOptions(shared_ptr<UpdateEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEdgeInstanceResponse updateEdgeInstance(shared_ptr<UpdateEdgeInstanceRequest> request);
  GetEdgeInstanceResponse getEdgeInstanceWithOptions(shared_ptr<GetEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEdgeInstanceResponse getEdgeInstance(shared_ptr<GetEdgeInstanceRequest> request);
  DeleteEdgeInstanceResponse deleteEdgeInstanceWithOptions(shared_ptr<DeleteEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEdgeInstanceResponse deleteEdgeInstance(shared_ptr<DeleteEdgeInstanceRequest> request);
  CreateEdgeInstanceResponse createEdgeInstanceWithOptions(shared_ptr<CreateEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEdgeInstanceResponse createEdgeInstance(shared_ptr<CreateEdgeInstanceRequest> request);
  QueryEdgeInstanceGatewayResponse queryEdgeInstanceGatewayWithOptions(shared_ptr<QueryEdgeInstanceGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeInstanceGatewayResponse queryEdgeInstanceGateway(shared_ptr<QueryEdgeInstanceGatewayRequest> request);
  QueryEdgeInstanceDeviceResponse queryEdgeInstanceDeviceWithOptions(shared_ptr<QueryEdgeInstanceDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeInstanceDeviceResponse queryEdgeInstanceDevice(shared_ptr<QueryEdgeInstanceDeviceRequest> request);
  BindGatewayToEdgeInstanceResponse bindGatewayToEdgeInstanceWithOptions(shared_ptr<BindGatewayToEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindGatewayToEdgeInstanceResponse bindGatewayToEdgeInstance(shared_ptr<BindGatewayToEdgeInstanceRequest> request);
  QueryEdgeInstanceResponse queryEdgeInstanceWithOptions(shared_ptr<QueryEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEdgeInstanceResponse queryEdgeInstance(shared_ptr<QueryEdgeInstanceRequest> request);
  CreateEdgeInstanceDeploymentResponse createEdgeInstanceDeploymentWithOptions(shared_ptr<CreateEdgeInstanceDeploymentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEdgeInstanceDeploymentResponse createEdgeInstanceDeployment(shared_ptr<CreateEdgeInstanceDeploymentRequest> request);
  BindRoleToEdgeInstanceResponse bindRoleToEdgeInstanceWithOptions(shared_ptr<BindRoleToEdgeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindRoleToEdgeInstanceResponse bindRoleToEdgeInstance(shared_ptr<BindRoleToEdgeInstanceRequest> request);
  QuerySuperDeviceGroupResponse querySuperDeviceGroupWithOptions(shared_ptr<QuerySuperDeviceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySuperDeviceGroupResponse querySuperDeviceGroup(shared_ptr<QuerySuperDeviceGroupRequest> request);
  QueryDeviceByTagsResponse queryDeviceByTagsWithOptions(shared_ptr<QueryDeviceByTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceByTagsResponse queryDeviceByTags(shared_ptr<QueryDeviceByTagsRequest> request);
  SetDevicesPropertyResponse setDevicesPropertyWithOptions(shared_ptr<SetDevicesPropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDevicesPropertyResponse setDevicesProperty(shared_ptr<SetDevicesPropertyRequest> request);
  InvokeThingsServiceResponse invokeThingsServiceWithOptions(shared_ptr<InvokeThingsServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InvokeThingsServiceResponse invokeThingsService(shared_ptr<InvokeThingsServiceRequest> request);
  SetDeviceGroupTagsResponse setDeviceGroupTagsWithOptions(shared_ptr<SetDeviceGroupTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDeviceGroupTagsResponse setDeviceGroupTags(shared_ptr<SetDeviceGroupTagsRequest> request);
  QueryAppDeviceListResponse queryAppDeviceListWithOptions(shared_ptr<QueryAppDeviceListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryAppDeviceListResponse queryAppDeviceList(shared_ptr<QueryAppDeviceListRequest> request);
  UpdateDeviceGroupResponse updateDeviceGroupWithOptions(shared_ptr<UpdateDeviceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDeviceGroupResponse updateDeviceGroup(shared_ptr<UpdateDeviceGroupRequest> request);
  QueryDeviceGroupTagListResponse queryDeviceGroupTagListWithOptions(shared_ptr<QueryDeviceGroupTagListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceGroupTagListResponse queryDeviceGroupTagList(shared_ptr<QueryDeviceGroupTagListRequest> request);
  QueryDeviceGroupListResponse queryDeviceGroupListWithOptions(shared_ptr<QueryDeviceGroupListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceGroupListResponse queryDeviceGroupList(shared_ptr<QueryDeviceGroupListRequest> request);
  QueryDeviceGroupInfoResponse queryDeviceGroupInfoWithOptions(shared_ptr<QueryDeviceGroupInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceGroupInfoResponse queryDeviceGroupInfo(shared_ptr<QueryDeviceGroupInfoRequest> request);
  QueryDeviceGroupByDeviceResponse queryDeviceGroupByDeviceWithOptions(shared_ptr<QueryDeviceGroupByDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceGroupByDeviceResponse queryDeviceGroupByDevice(shared_ptr<QueryDeviceGroupByDeviceRequest> request);
  DeleteDeviceGroupResponse deleteDeviceGroupWithOptions(shared_ptr<DeleteDeviceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDeviceGroupResponse deleteDeviceGroup(shared_ptr<DeleteDeviceGroupRequest> request);
  CreateDeviceGroupResponse createDeviceGroupWithOptions(shared_ptr<CreateDeviceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDeviceGroupResponse createDeviceGroup(shared_ptr<CreateDeviceGroupRequest> request);
  BatchDeleteDeviceGroupRelationsResponse batchDeleteDeviceGroupRelationsWithOptions(shared_ptr<BatchDeleteDeviceGroupRelationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchDeleteDeviceGroupRelationsResponse batchDeleteDeviceGroupRelations(shared_ptr<BatchDeleteDeviceGroupRelationsRequest> request);
  BatchAddDeviceGroupRelationsResponse batchAddDeviceGroupRelationsWithOptions(shared_ptr<BatchAddDeviceGroupRelationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchAddDeviceGroupRelationsResponse batchAddDeviceGroupRelations(shared_ptr<BatchAddDeviceGroupRelationsRequest> request);
  RRpcResponse RRpcWithOptions(shared_ptr<RRpcRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RRpcResponse RRpc(shared_ptr<RRpcRequest> request);
  QueryPageByApplyIdResponse queryPageByApplyIdWithOptions(shared_ptr<QueryPageByApplyIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryPageByApplyIdResponse queryPageByApplyId(shared_ptr<QueryPageByApplyIdRequest> request);
  QueryDeviceResponse queryDeviceWithOptions(shared_ptr<QueryDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceResponse queryDevice(shared_ptr<QueryDeviceRequest> request);
  SaveDevicePropResponse saveDevicePropWithOptions(shared_ptr<SaveDevicePropRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveDevicePropResponse saveDeviceProp(shared_ptr<SaveDevicePropRequest> request);
  QueryTopicRouteTableResponse queryTopicRouteTableWithOptions(shared_ptr<QueryTopicRouteTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTopicRouteTableResponse queryTopicRouteTable(shared_ptr<QueryTopicRouteTableRequest> request);
  QueryTopicReverseRouteTableResponse queryTopicReverseRouteTableWithOptions(shared_ptr<QueryTopicReverseRouteTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTopicReverseRouteTableResponse queryTopicReverseRouteTable(shared_ptr<QueryTopicReverseRouteTableRequest> request);
  PubBroadcastResponse pubBroadcastWithOptions(shared_ptr<PubBroadcastRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PubBroadcastResponse pubBroadcast(shared_ptr<PubBroadcastRequest> request);
  DeleteTopicRouteTableResponse deleteTopicRouteTableWithOptions(shared_ptr<DeleteTopicRouteTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTopicRouteTableResponse deleteTopicRouteTable(shared_ptr<DeleteTopicRouteTableRequest> request);
  DeleteDevicePropResponse deleteDevicePropWithOptions(shared_ptr<DeleteDevicePropRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDevicePropResponse deleteDeviceProp(shared_ptr<DeleteDevicePropRequest> request);
  CreateTopicRouteTableResponse createTopicRouteTableWithOptions(shared_ptr<CreateTopicRouteTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTopicRouteTableResponse createTopicRouteTable(shared_ptr<CreateTopicRouteTableRequest> request);
  BatchGetDeviceStateResponse batchGetDeviceStateWithOptions(shared_ptr<BatchGetDeviceStateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetDeviceStateResponse batchGetDeviceState(shared_ptr<BatchGetDeviceStateRequest> request);
  UpdateRuleActionResponse updateRuleActionWithOptions(shared_ptr<UpdateRuleActionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRuleActionResponse updateRuleAction(shared_ptr<UpdateRuleActionRequest> request);
  UpdateRuleResponse updateRuleWithOptions(shared_ptr<UpdateRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRuleResponse updateRule(shared_ptr<UpdateRuleRequest> request);
  UpdateProductTopicResponse updateProductTopicWithOptions(shared_ptr<UpdateProductTopicRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProductTopicResponse updateProductTopic(shared_ptr<UpdateProductTopicRequest> request);
  UpdateDeviceShadowResponse updateDeviceShadowWithOptions(shared_ptr<UpdateDeviceShadowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDeviceShadowResponse updateDeviceShadow(shared_ptr<UpdateDeviceShadowRequest> request);
  StopRuleResponse stopRuleWithOptions(shared_ptr<StopRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopRuleResponse stopRule(shared_ptr<StopRuleRequest> request);
  StartRuleResponse startRuleWithOptions(shared_ptr<StartRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartRuleResponse startRule(shared_ptr<StartRuleRequest> request);
  QueryProductTopicResponse queryProductTopicWithOptions(shared_ptr<QueryProductTopicRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryProductTopicResponse queryProductTopic(shared_ptr<QueryProductTopicRequest> request);
  QueryDevicePropResponse queryDevicePropWithOptions(shared_ptr<QueryDevicePropRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDevicePropResponse queryDeviceProp(shared_ptr<QueryDevicePropRequest> request);
  PubResponse pubWithOptions(shared_ptr<PubRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PubResponse pub(shared_ptr<PubRequest> request);
  ListRuleActionsResponse listRuleActionsWithOptions(shared_ptr<ListRuleActionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRuleActionsResponse listRuleActions(shared_ptr<ListRuleActionsRequest> request);
  ListRuleResponse listRuleWithOptions(shared_ptr<ListRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRuleResponse listRule(shared_ptr<ListRuleRequest> request);
  GetRuleActionResponse getRuleActionWithOptions(shared_ptr<GetRuleActionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRuleActionResponse getRuleAction(shared_ptr<GetRuleActionRequest> request);
  GetRuleResponse getRuleWithOptions(shared_ptr<GetRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRuleResponse getRule(shared_ptr<GetRuleRequest> request);
  GetDeviceShadowResponse getDeviceShadowWithOptions(shared_ptr<GetDeviceShadowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDeviceShadowResponse getDeviceShadow(shared_ptr<GetDeviceShadowRequest> request);
  DeleteRuleActionResponse deleteRuleActionWithOptions(shared_ptr<DeleteRuleActionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRuleActionResponse deleteRuleAction(shared_ptr<DeleteRuleActionRequest> request);
  DeleteRuleResponse deleteRuleWithOptions(shared_ptr<DeleteRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRuleResponse deleteRule(shared_ptr<DeleteRuleRequest> request);
  DeleteProductTopicResponse deleteProductTopicWithOptions(shared_ptr<DeleteProductTopicRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteProductTopicResponse deleteProductTopic(shared_ptr<DeleteProductTopicRequest> request);
  CreateRuleActionResponse createRuleActionWithOptions(shared_ptr<CreateRuleActionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRuleActionResponse createRuleAction(shared_ptr<CreateRuleActionRequest> request);
  CreateRuleResponse createRuleWithOptions(shared_ptr<CreateRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRuleResponse createRule(shared_ptr<CreateRuleRequest> request);
  CreateProductTopicResponse createProductTopicWithOptions(shared_ptr<CreateProductTopicRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProductTopicResponse createProductTopic(shared_ptr<CreateProductTopicRequest> request);
  QueryBatchRegisterDeviceStatusResponse queryBatchRegisterDeviceStatusWithOptions(shared_ptr<QueryBatchRegisterDeviceStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryBatchRegisterDeviceStatusResponse queryBatchRegisterDeviceStatus(shared_ptr<QueryBatchRegisterDeviceStatusRequest> request);
  GetGatewayBySubDeviceResponse getGatewayBySubDeviceWithOptions(shared_ptr<GetGatewayBySubDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetGatewayBySubDeviceResponse getGatewayBySubDevice(shared_ptr<GetGatewayBySubDeviceRequest> request);
  ResetThingResponse resetThingWithOptions(shared_ptr<ResetThingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetThingResponse resetThing(shared_ptr<ResetThingRequest> request);
  RemoveThingTopoResponse removeThingTopoWithOptions(shared_ptr<RemoveThingTopoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveThingTopoResponse removeThingTopo(shared_ptr<RemoveThingTopoRequest> request);
  NotifyAddThingTopoResponse notifyAddThingTopoWithOptions(shared_ptr<NotifyAddThingTopoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  NotifyAddThingTopoResponse notifyAddThingTopo(shared_ptr<NotifyAddThingTopoRequest> request);
  GetThingTopoResponse getThingTopoWithOptions(shared_ptr<GetThingTopoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetThingTopoResponse getThingTopo(shared_ptr<GetThingTopoRequest> request);
  QueryDevicePropertyStatusResponse queryDevicePropertyStatusWithOptions(shared_ptr<QueryDevicePropertyStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDevicePropertyStatusResponse queryDevicePropertyStatus(shared_ptr<QueryDevicePropertyStatusRequest> request);
  QueryDevicePropertyDataResponse queryDevicePropertyDataWithOptions(shared_ptr<QueryDevicePropertyDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDevicePropertyDataResponse queryDevicePropertyData(shared_ptr<QueryDevicePropertyDataRequest> request);
  BatchRegisterDeviceWithApplyIdResponse batchRegisterDeviceWithApplyIdWithOptions(shared_ptr<BatchRegisterDeviceWithApplyIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchRegisterDeviceWithApplyIdResponse batchRegisterDeviceWithApplyId(shared_ptr<BatchRegisterDeviceWithApplyIdRequest> request);
  BatchRegisterDeviceResponse batchRegisterDeviceWithOptions(shared_ptr<BatchRegisterDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchRegisterDeviceResponse batchRegisterDevice(shared_ptr<BatchRegisterDeviceRequest> request);
  BatchCheckDeviceNamesResponse batchCheckDeviceNamesWithOptions(shared_ptr<BatchCheckDeviceNamesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchCheckDeviceNamesResponse batchCheckDeviceNames(shared_ptr<BatchCheckDeviceNamesRequest> request);
  UpdateProductResponse updateProductWithOptions(shared_ptr<UpdateProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProductResponse updateProduct(shared_ptr<UpdateProductRequest> request);
  SetDevicePropertyResponse setDevicePropertyWithOptions(shared_ptr<SetDevicePropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDevicePropertyResponse setDeviceProperty(shared_ptr<SetDevicePropertyRequest> request);
  RegisterDeviceResponse registerDeviceWithOptions(shared_ptr<RegisterDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RegisterDeviceResponse registerDevice(shared_ptr<RegisterDeviceRequest> request);
  QueryProductListResponse queryProductListWithOptions(shared_ptr<QueryProductListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryProductListResponse queryProductList(shared_ptr<QueryProductListRequest> request);
  QueryProductResponse queryProductWithOptions(shared_ptr<QueryProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryProductResponse queryProduct(shared_ptr<QueryProductRequest> request);
  QueryDeviceStatisticsResponse queryDeviceStatisticsWithOptions(shared_ptr<QueryDeviceStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceStatisticsResponse queryDeviceStatistics(shared_ptr<QueryDeviceStatisticsRequest> request);
  QueryDeviceServiceDataResponse queryDeviceServiceDataWithOptions(shared_ptr<QueryDeviceServiceDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceServiceDataResponse queryDeviceServiceData(shared_ptr<QueryDeviceServiceDataRequest> request);
  QueryDeviceEventDataResponse queryDeviceEventDataWithOptions(shared_ptr<QueryDeviceEventDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceEventDataResponse queryDeviceEventData(shared_ptr<QueryDeviceEventDataRequest> request);
  QueryDeviceDetailResponse queryDeviceDetailWithOptions(shared_ptr<QueryDeviceDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDeviceDetailResponse queryDeviceDetail(shared_ptr<QueryDeviceDetailRequest> request);
  InvokeThingServiceResponse invokeThingServiceWithOptions(shared_ptr<InvokeThingServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InvokeThingServiceResponse invokeThingService(shared_ptr<InvokeThingServiceRequest> request);
  GetDeviceStatusResponse getDeviceStatusWithOptions(shared_ptr<GetDeviceStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDeviceStatusResponse getDeviceStatus(shared_ptr<GetDeviceStatusRequest> request);
  EnableThingResponse enableThingWithOptions(shared_ptr<EnableThingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableThingResponse enableThing(shared_ptr<EnableThingRequest> request);
  DisableThingResponse disableThingWithOptions(shared_ptr<DisableThingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableThingResponse disableThing(shared_ptr<DisableThingRequest> request);
  DeleteProductResponse deleteProductWithOptions(shared_ptr<DeleteProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteProductResponse deleteProduct(shared_ptr<DeleteProductRequest> request);
  DeleteDeviceResponse deleteDeviceWithOptions(shared_ptr<DeleteDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDeviceResponse deleteDevice(shared_ptr<DeleteDeviceRequest> request);
  CreateProductResponse createProductWithOptions(shared_ptr<CreateProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProductResponse createProduct(shared_ptr<CreateProductRequest> request);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Iot20180120

#endif
